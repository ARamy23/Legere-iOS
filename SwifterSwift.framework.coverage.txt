/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/CGColorExtensions.swift:
    1|       |//
    2|       |//  CGColorExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 03/02/2017.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |#endif
   15|       |
   16|       |#if canImport(Cocoa)
   17|       |import Cocoa
   18|       |#endif
   19|       |
   20|       |// MARK: - Properties
   21|       |public extension CGColor {
   22|       |
   23|       |    #if canImport(UIKit)
   24|       |    /// SwifterSwift: UIColor.
   25|      0|    public var uiColor: UIColor? {
   26|      0|        return UIColor(cgColor: self)
   27|      0|    }
   28|       |    #endif
   29|       |
   30|       |    #if canImport(Cocoa)
   31|       |    /// SwifterSwift: NSColor.
   32|       |    public var nsColor: NSColor? {
   33|       |        return NSColor(cgColor: self)
   34|       |    }
   35|       |    #endif
   36|       |
   37|       |}
   38|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/CGFloatExtensions.swift:
    1|       |//
    2|       |//  CGFloatExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/23/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |#endif
   15|       |
   16|       |#if canImport(Cocoa)
   17|       |import Cocoa
   18|       |#endif
   19|       |
   20|       |// MARK: - Properties
   21|       |public extension CGFloat {
   22|       |
   23|       |    /// SwifterSwift: Absolute of CGFloat value.
   24|      0|    public var abs: CGFloat {
   25|      0|        return Swift.abs(self)
   26|      0|    }
   27|       |
   28|       |    /// SwifterSwift: Ceil of CGFloat value.
   29|      0|    public var ceil: CGFloat {
   30|      0|        return Foundation.ceil(self)
   31|      0|    }
   32|       |
   33|       |    /// SwifterSwift: Radian value of degree input.
   34|      0|    public var degreesToRadians: CGFloat {
   35|      0|        return .pi * self / 180.0
   36|      0|    }
   37|       |
   38|       |    /// SwifterSwift: Floor of CGFloat value.
   39|      0|    public var floor: CGFloat {
   40|      0|        return Foundation.floor(self)
   41|      0|    }
   42|       |
   43|       |    /// SwifterSwift: Check if CGFloat is positive.
   44|      0|    public var isPositive: Bool {
   45|      0|        return self > 0
   46|      0|    }
   47|       |
   48|       |    /// SwifterSwift: Check if CGFloat is negative.
   49|      0|    public var isNegative: Bool {
   50|      0|        return self < 0
   51|      0|    }
   52|       |
   53|       |    /// SwifterSwift: Int.
   54|      0|    public var int: Int {
   55|      0|        return Int(self)
   56|      0|    }
   57|       |
   58|       |    /// SwifterSwift: Float.
   59|      0|    public var float: Float {
   60|      0|        return Float(self)
   61|      0|    }
   62|       |
   63|       |    /// SwifterSwift: Double.
   64|      0|    public var double: Double {
   65|      0|        return Double(self)
   66|      0|    }
   67|       |
   68|       |    /// SwifterSwift: Degree value of radian input.
   69|      0|    public var radiansToDegrees: CGFloat {
   70|      0|        return self * 180 / CGFloat.pi
   71|      0|    }
   72|       |
   73|       |}
   74|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/CGPointExtensions.swift:
    1|       |//
    2|       |//  CGPointExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 07/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |#endif
   15|       |
   16|       |#if canImport(Cocoa)
   17|       |import Cocoa
   18|       |#endif
   19|       |
   20|       |// MARK: - Methods
   21|       |public extension CGPoint {
   22|       |
   23|       |    /// SwifterSwift: Distance from another CGPoint.
   24|       |    ///
   25|       |    ///     let point1 = CGPoint(x: 10, y: 10)
   26|       |    ///     let point2 = CGPoint(x: 30, y: 30)
   27|       |    ///     let distance = point1.distance(from: point2)
   28|       |    ///     //distance = 28.28
   29|       |    ///
   30|       |    /// - Parameter point: CGPoint to get distance from.
   31|       |    /// - Returns: Distance between self and given CGPoint.
   32|      0|    public func distance(from point: CGPoint) -> CGFloat {
   33|      0|        return CGPoint.distance(from: self, to: point)
   34|      0|    }
   35|       |
   36|       |    /// SwifterSwift: Distance between two CGPoints.
   37|       |    ///
   38|       |    ///     let point1 = CGPoint(x: 10, y: 10)
   39|       |    ///     let point2 = CGPoint(x: 30, y: 30)
   40|       |    ///     let distance = CGPoint.distance(from: point2, to: point1)
   41|       |    ///     //Distance = 28.28
   42|       |    ///
   43|       |    /// - Parameters:
   44|       |    ///   - point1: first CGPoint.
   45|       |    ///   - point2: second CGPoint.
   46|       |    /// - Returns: distance between the two given CGPoints.
   47|       |    public static func distance(from point1: CGPoint, to point2: CGPoint) -> CGFloat {
   48|       |        // http://stackoverflow.com/questions/6416101/calculate-the-distance-between-two-cgpoints
   49|       |        return sqrt(pow(point2.x - point1.x, 2) + pow(point2.y - point1.y, 2))
   50|       |    }
   51|       |
   52|       |}
   53|       |
   54|       |// MARK: - Operators
   55|       |public extension CGPoint {
   56|       |
   57|       |    /// SwifterSwift: Add two CGPoints.
   58|       |    ///
   59|       |    ///     let point1 = CGPoint(x: 10, y: 10)
   60|       |    ///     let point2 = CGPoint(x: 30, y: 30)
   61|       |    ///     let point = point1 + point2
   62|       |    ///     //point = CGPoint(x: 40, y: 40)
   63|       |    ///
   64|       |    /// - Parameters:
   65|       |    ///   - lhs: CGPoint to add to.
   66|       |    ///   - rhs: CGPoint to add.
   67|       |    /// - Returns: result of addition of the two given CGPoints.
   68|      0|    public static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
   69|      0|        return CGPoint(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
   70|      0|    }
   71|       |
   72|       |    /// SwifterSwift: Add a CGPoints to self.
   73|       |    ///
   74|       |    ///     let point1 = CGPoint(x: 10, y: 10)
   75|       |    ///     let point2 = CGPoint(x: 30, y: 30)
   76|       |    ///     point1 += point2
   77|       |    ///     //point1 = CGPoint(x: 40, y: 40)
   78|       |    ///
   79|       |    /// - Parameters:
   80|       |    ///   - lhs: self
   81|       |    ///   - rhs: CGPoint to add.
   82|      0|    public static func += (lhs: inout CGPoint, rhs: CGPoint) {
   83|      0|        // swiftlint:disable next shorthand_operator
   84|      0|        lhs = lhs + rhs
   85|      0|    }
   86|       |
   87|       |    /// SwifterSwift: Subtract two CGPoints.
   88|       |    ///
   89|       |    ///     let point1 = CGPoint(x: 10, y: 10)
   90|       |    ///     let point2 = CGPoint(x: 30, y: 30)
   91|       |    ///     let point = point1 - point2
   92|       |    ///     //point = CGPoint(x: -20, y: -20)
   93|       |    ///
   94|       |    /// - Parameters:
   95|       |    ///   - lhs: CGPoint to subtract from.
   96|       |    ///   - rhs: CGPoint to subtract.
   97|       |    /// - Returns: result of subtract of the two given CGPoints.
   98|      0|    public static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
   99|      0|        return CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
  100|      0|    }
  101|       |
  102|       |    /// SwifterSwift: Subtract a CGPoints from self.
  103|       |    ///
  104|       |    ///     let point1 = CGPoint(x: 10, y: 10)
  105|       |    ///     let point2 = CGPoint(x: 30, y: 30)
  106|       |    ///     point1 -= point2
  107|       |    ///     //point1 = CGPoint(x: -20, y: -20)
  108|       |    ///
  109|       |    /// - Parameters:
  110|       |    ///   - lhs: self
  111|       |    ///   - rhs: CGPoint to subtract.
  112|      0|    public static func -= (lhs: inout CGPoint, rhs: CGPoint) {
  113|      0|        // swiftlint:disable next shorthand_operator
  114|      0|        lhs = lhs - rhs
  115|      0|    }
  116|       |
  117|       |    /// SwifterSwift: Multiply a CGPoint with a scalar
  118|       |    ///
  119|       |    ///     let point1 = CGPoint(x: 10, y: 10)
  120|       |    ///     let scalar = point1 * 5
  121|       |    ///     //scalar = CGPoint(x: 50, y: 50)
  122|       |    ///
  123|       |    /// - Parameters:
  124|       |    ///   - point: CGPoint to multiply.
  125|       |    ///   - scalar: scalar value.
  126|       |    /// - Returns: result of multiplication of the given CGPoint with the scalar.
  127|      0|    public static func * (point: CGPoint, scalar: CGFloat) -> CGPoint {
  128|      0|        return CGPoint(x: point.x * scalar, y: point.y * scalar)
  129|      0|    }
  130|       |
  131|       |    /// SwifterSwift: Multiply self with a scalar
  132|       |    ///
  133|       |    ///     let point1 = CGPoint(x: 10, y: 10)
  134|       |    ///     point *= 5
  135|       |    ///     //point1 = CGPoint(x: 50, y: 50)
  136|       |    ///
  137|       |    /// - Parameters:
  138|       |    ///   - point: self.
  139|       |    ///   - scalar: scalar value.
  140|       |    /// - Returns: result of multiplication of the given CGPoint with the scalar.
  141|      0|    public static func *= (point: inout CGPoint, scalar: CGFloat) {
  142|      0|        // swiftlint:disable next shorthand_operator
  143|      0|        point = point * scalar
  144|      0|    }
  145|       |
  146|       |    /// SwifterSwift: Multiply a CGPoint with a scalar
  147|       |    ///
  148|       |    ///     let point1 = CGPoint(x: 10, y: 10)
  149|       |    ///     let scalar = 5 * point1
  150|       |    ///     //scalar = CGPoint(x: 50, y: 50)
  151|       |    ///
  152|       |    /// - Parameters:
  153|       |    ///   - scalar: scalar value.
  154|       |    ///   - point: CGPoint to multiply.
  155|       |    /// - Returns: result of multiplication of the given CGPoint with the scalar.
  156|      0|    public static func * (scalar: CGFloat, point: CGPoint) -> CGPoint {
  157|      0|        return CGPoint(x: point.x * scalar, y: point.y * scalar)
  158|      0|    }
  159|       |
  160|       |}
  161|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/CGSizeExtensions.swift:
    1|       |//
    2|       |//  CGSizeExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/22/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |#endif
   15|       |
   16|       |#if canImport(Cocoa)
   17|       |import Cocoa
   18|       |#endif
   19|       |
   20|       |// MARK: - Methods
   21|       |public extension CGSize {
   22|       |
   23|       |    /// SwifterSwift: Aspect fit CGSize.
   24|       |    ///
   25|       |    ///     let rect = CGSize(width: 120, height: 80)
   26|       |    ///     let parentRect  = CGSize(width: 100, height: 50)
   27|       |    ///     let newRect = rect.aspectFit(to: parentRect)
   28|       |    ///     //newRect.width = 75 , newRect = 50
   29|       |    ///
   30|       |    /// - Parameter boundingSize: bounding size to fit self to.
   31|       |    /// - Returns: self fitted into given bounding size
   32|      0|    public func aspectFit(to boundingSize: CGSize) -> CGSize {
   33|      0|        let minRatio = min(boundingSize.width / width, boundingSize.height / height)
   34|      0|        return CGSize(width: width * minRatio, height: height * minRatio)
   35|      0|    }
   36|       |
   37|       |    /// SwifterSwift: Aspect fill CGSize.
   38|       |    ///
   39|       |    ///     let rect = CGSize(width: 20, height: 120)
   40|       |    ///     let parentRect  = CGSize(width: 100, height: 60)
   41|       |    ///     let newRect = rect.aspectFit(to: parentRect)
   42|       |    ///     //newRect.width = 100 , newRect = 60
   43|       |    ///
   44|       |    /// - Parameter boundingSize: bounding size to fill self to.
   45|       |    /// - Returns: self filled into given bounding size
   46|      0|    public func aspectFill(to boundingSize: CGSize) -> CGSize {
   47|      0|        let minRatio = max(boundingSize.width / width, boundingSize.height / height)
   48|      0|        let aWidth = min(width * minRatio, boundingSize.width)
   49|      0|        let aHeight = min(height * minRatio, boundingSize.height)
   50|      0|        return CGSize(width: aWidth, height: aHeight)
   51|      0|    }
   52|       |
   53|       |}
   54|       |
   55|       |// MARK: - Operators
   56|       |public extension CGSize {
   57|       |
   58|       |    /// SwifterSwift: Add two CGSize
   59|       |    ///
   60|       |    ///     let sizeA = CGSize(width: 5, height: 10)
   61|       |    ///     let sizeB = CGSize(width: 3, height: 4)
   62|       |    ///     let result = sizeA + sizeB
   63|       |    ///     //result = CGSize(width: 8, height: 14)
   64|       |    ///
   65|       |    /// - Parameters:
   66|       |    ///   - lhs: CGSize to add to.
   67|       |    ///   - rhs: CGSize to add.
   68|       |    /// - Returns: The result comes from the addition of the two given CGSize struct.
   69|      0|    public static func + (lhs: CGSize, rhs: CGSize) -> CGSize {
   70|      0|        return CGSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
   71|      0|    }
   72|       |
   73|       |    /// SwifterSwift: Add a CGSize to self.
   74|       |    ///
   75|       |    ///     let sizeA = CGSize(width: 5, height: 10)
   76|       |    ///     let sizeB = CGSize(width: 3, height: 4)
   77|       |    ///     sizeA += sizeB
   78|       |    ///     //sizeA = CGPoint(width: 8, height: 14)
   79|       |    ///
   80|       |    /// - Parameters:
   81|       |    ///   - lhs: self
   82|       |    ///   - rhs: CGSize to add.
   83|      0|    public static func += (lhs: inout CGSize, rhs: CGSize) {
   84|      0|        lhs.width += rhs.width
   85|      0|        lhs.height += rhs.height
   86|      0|    }
   87|       |
   88|       |    /// SwifterSwift: Subtract two CGSize
   89|       |    ///
   90|       |    ///     let sizeA = CGSize(width: 5, height: 10)
   91|       |    ///     let sizeB = CGSize(width: 3, height: 4)
   92|       |    ///     let result = sizeA - sizeB
   93|       |    ///     //result = CGSize(width: 2, height: 6)
   94|       |    ///
   95|       |    /// - Parameters:
   96|       |    ///   - lhs: CGSize to subtract from.
   97|       |    ///   - rhs: CGSize to subtract.
   98|       |    /// - Returns: The result comes from the subtract of the two given CGSize struct.
   99|      0|    public static func - (lhs: CGSize, rhs: CGSize) -> CGSize {
  100|      0|        return CGSize(width: lhs.width - rhs.width, height: lhs.height - rhs.height)
  101|      0|    }
  102|       |
  103|       |    /// SwifterSwift: Subtract a CGSize from self.
  104|       |    ///
  105|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  106|       |    ///     let sizeB = CGSize(width: 3, height: 4)
  107|       |    ///     sizeA -= sizeB
  108|       |    ///     //sizeA = CGPoint(width: 2, height: 6)
  109|       |    ///
  110|       |    /// - Parameters:
  111|       |    ///   - lhs: self
  112|       |    ///   - rhs: CGSize to subtract.
  113|      0|    public static func -= (lhs: inout CGSize, rhs: CGSize) {
  114|      0|        lhs.width -= rhs.width
  115|      0|        lhs.height -= rhs.height
  116|      0|    }
  117|       |
  118|       |    /// SwifterSwift: Multiply two CGSize
  119|       |    ///
  120|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  121|       |    ///     let sizeB = CGSize(width: 3, height: 4)
  122|       |    ///     let result = sizeA * sizeB
  123|       |    ///     //result = CGSize(width: 15, height: 40)
  124|       |    ///
  125|       |    /// - Parameters:
  126|       |    ///   - lhs: CGSize to multiply.
  127|       |    ///   - rhs: CGSize to multiply with.
  128|       |    /// - Returns: The result comes from the multiplication of the two given CGSize structs.
  129|      0|    public static func * (lhs: CGSize, rhs: CGSize) -> CGSize {
  130|      0|        return CGSize(width: lhs.width * rhs.width, height: lhs.height * rhs.height)
  131|      0|    }
  132|       |
  133|       |    /// SwifterSwift: Multiply a CGSize with a scalar.
  134|       |    ///
  135|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  136|       |    ///     let result = sizeA * 5
  137|       |    ///     //result = CGSize(width: 25, height: 50)
  138|       |    ///
  139|       |    /// - Parameters:
  140|       |    ///   - lhs: CGSize to multiply.
  141|       |    ///   - scalar: scalar value.
  142|       |    /// - Returns: The result comes from the multiplication of the given CGSize and scalar.
  143|      0|    public static func * (lhs: CGSize, scalar: CGFloat) -> CGSize {
  144|      0|        return CGSize(width: lhs.width * scalar, height: lhs.height * scalar)
  145|      0|    }
  146|       |
  147|       |    /// SwifterSwift: Multiply a CGSize with a scalar.
  148|       |    ///
  149|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  150|       |    ///     let result = 5 * sizeA
  151|       |    ///     //result = CGSize(width: 25, height: 50)
  152|       |    ///
  153|       |    /// - Parameters:
  154|       |    ///   - scalar: scalar value.
  155|       |    ///   - rhs: CGSize to multiply.
  156|       |    /// - Returns: The result comes from the multiplication of the given scalar and CGSize.
  157|      0|    public static func * (scalar: CGFloat, rhs: CGSize) -> CGSize {
  158|      0|        return CGSize(width: scalar * rhs.width, height: scalar * rhs.height)
  159|      0|    }
  160|       |
  161|       |    /// SwifterSwift: Multiply self with a CGSize.
  162|       |    ///
  163|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  164|       |    ///     let sizeB = CGSize(width: 3, height: 4)
  165|       |    ///     sizeA *= sizeB
  166|       |    ///     //result = CGSize(width: 15, height: 40)
  167|       |    ///
  168|       |    /// - Parameters:
  169|       |    ///   - lhs: self.
  170|       |    ///   - rhs: CGSize to multiply.
  171|      0|    public static func *= (lhs: inout CGSize, rhs: CGSize) {
  172|      0|        lhs.width *= rhs.width
  173|      0|        lhs.height *= rhs.height
  174|      0|    }
  175|       |
  176|       |    /// SwifterSwift: Multiply self with a scalar.
  177|       |    ///
  178|       |    ///     let sizeA = CGSize(width: 5, height: 10)
  179|       |    ///     sizeA *= 3
  180|       |    ///     //result = CGSize(width: 15, height: 30)
  181|       |    ///
  182|       |    /// - Parameters:
  183|       |    ///   - lhs: self.
  184|       |    ///   - scalar: scalar value.
  185|      0|    public static func *= (lhs: inout CGSize, scalar: CGFloat) {
  186|      0|        lhs.width *= scalar
  187|      0|        lhs.height *= scalar
  188|      0|    }
  189|       |
  190|       |}
  191|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/CGVectorExtensions.swift:
    1|       |//
    2|       |//  CGVectorExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Robbie Moyer on 7/25/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension CGVector {
   14|       |
   15|       |    /// SwifterSwift: The angle of rotation (in radians) of the vector.
   16|       |    /// The range of the angle is -π to π; an angle of 0 points to the right.
   17|       |    ///
   18|       |    /// https://en.wikipedia.org/wiki/Atan2
   19|      0|    public var angle: CGFloat {
   20|      0|        return atan2(dy, dx)
   21|      0|    }
   22|       |
   23|       |    /// SwifterSwift: The magnitude (or length) of the vector.
   24|       |    ///
   25|       |    /// https://en.wikipedia.org/wiki/Euclidean_vector#Length
   26|      0|    public var magnitude: CGFloat {
   27|      0|        return sqrt((dx * dx) + (dy * dy))
   28|      0|    }
   29|       |
   30|       |}
   31|       |
   32|       |// MARK: - Initializers
   33|       |public extension CGVector {
   34|       |
   35|       |    /// SwifterSwift: Creates a vector with the given magnitude and angle.
   36|       |    ///
   37|       |    /// https://www.grc.nasa.gov/WWW/K-12/airplane/vectpart.html
   38|       |    ///
   39|       |    ///     let vector = CGVector(angle: .pi, magnitude: 1)
   40|       |    ///
   41|       |    /// - Parameters:
   42|       |    ///     - angle: The angle of rotation (in radians) counterclockwise from the positive x-axis.
   43|       |    ///     - magnitude: The lenth of the vector.
   44|       |    ///
   45|      0|    public init(angle: CGFloat, magnitude: CGFloat) {
   46|      0|        self.init(dx: magnitude * cos(angle), dy: magnitude * sin(angle))
   47|      0|    }
   48|       |
   49|       |}
   50|       |
   51|       |// MARK: - Operators
   52|       |public extension CGVector {
   53|       |
   54|       |    /// SwifterSwift: Multiplies a scalar and a vector (commutative).
   55|       |    ///
   56|       |    ///     let vector = CGVector(dx: 1, dy: 1)
   57|       |    ///     let largerVector = vector * 2
   58|       |    ///
   59|       |    /// - Parameters:
   60|       |    ///   - vector: The vector to be multiplied
   61|       |    ///   - scalar: The scale by which the vector will be multiplied
   62|       |    /// - Returns: The vector with its magnitude scaled
   63|      0|    public static func * (vector: CGVector, scalar: CGFloat) -> CGVector {
   64|      0|        return CGVector(dx: vector.dx * scalar, dy: vector.dy * scalar)
   65|      0|    }
   66|       |
   67|       |    /// SwifterSwift: Multiplies a scalar and a vector (commutative).
   68|       |    ///
   69|       |    ///     let vector = CGVector(dx: 1, dy: 1)
   70|       |    ///     let largerVector = 2 * vector
   71|       |    ///
   72|       |    /// - Parameters:
   73|       |    ///   - scalar: The scalar by which the vector will be multiplied
   74|       |    ///   - vector: The vector to be multiplied
   75|       |    /// - Returns: The vector with its magnitude scaled
   76|      0|    public static func * (scalar: CGFloat, vector: CGVector) -> CGVector {
   77|      0|        return CGVector(dx: scalar * vector.dx, dy: scalar * vector.dy)
   78|      0|    }
   79|       |
   80|       |    /// SwifterSwift: Compound assignment operator for vector-scalr multiplication
   81|       |    ///
   82|       |    ///     var vector = CGVector(dx: 1, dy: 1)
   83|       |    ///     vector *= 2
   84|       |    ///
   85|       |    /// - Parameters:
   86|       |    ///   - vector: The vector to be multiplied
   87|       |    ///   - scalar: The scale by which the vector will be multiplied
   88|      0|    public static func *= (vector: inout CGVector, scalar: CGFloat) {
   89|      0|        // swiftlint:disable next shorthand_operator
   90|      0|        vector = vector * scalar
   91|      0|    }
   92|       |
   93|       |    /// SwifterSwift: Negates the vector. The direction is reversed, but magnitude
   94|       |    /// remains the same.
   95|       |    ///
   96|       |    ///     let vector = CGVector(dx: 1, dy: 1)
   97|       |    ///     let reversedVector = -vector
   98|       |    ///
   99|       |    /// - Parameter vector: The vector to be negated
  100|       |    /// - Returns: The negated vector
  101|      0|    public static prefix func - (vector: CGVector) -> CGVector {
  102|      0|        return CGVector(dx: -vector.dx, dy: -vector.dy)
  103|      0|    }
  104|       |
  105|       |}
  106|       |
  107|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreGraphics/Deprecated/CoreGraphicsDeprecated.swift:
    1|       |//
    2|       |//  CoreGraphicsDeprecated.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Luciano Almeida on 9/18/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |#if canImport(CoreGraphics)
    9|       |import CoreGraphics
   10|       |
   11|       |// MARK: - Methods
   12|       |public extension CGFloat {
   13|       |
   14|       |    /// SwifterSwift: Random CGFloat between two CGFloat values.
   15|       |    ///
   16|       |    /// - Parameters:
   17|       |    ///   - min: minimum number to start random from.
   18|       |    ///   - max: maximum number random number end before.
   19|       |    /// - Returns: random CGFloat between two CGFloat values.
   20|       |    @available(*, deprecated: 4.5.0, message: "User CGFloat.random(in: min...max)")
   21|      0|    public static func randomBetween(min: CGFloat, max: CGFloat) -> CGFloat {
   22|      0|        return CGFloat.random(in: min...max)
   23|      0|    }
   24|       |
   25|       |}
   26|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/CoreLocation/CLLocationExtensions.swift:
    1|       |//
    2|       |//  CLLocationExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Luciano Almeida on 21/04/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreLocation)
   10|       |import CoreLocation
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension CLLocation {
   14|       |
   15|       |    /// SwifterSwift: Calculate the half-way point along a great circle path between the two points.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - start: Start location.
   19|       |    ///   - end: End location.
   20|       |    /// - Returns: Location that represents the half-way point.
   21|      0|    public static func midLocation(start: CLLocation, end: CLLocation) -> CLLocation {
   22|      0|        let lat1 = Double.pi * start.coordinate.latitude / 180.0
   23|      0|        let long1 = Double.pi * start.coordinate.longitude / 180.0
   24|      0|        let lat2 = Double.pi * end.coordinate.latitude / 180.0
   25|      0|        let long2 = Double.pi * end.coordinate.longitude / 180.0
   26|      0|
   27|      0|        // Formula
   28|      0|        //    Bx = cos φ2 ⋅ cos Δλ
   29|      0|        //    By = cos φ2 ⋅ sin Δλ
   30|      0|        //    φm = atan2( sin φ1 + sin φ2, √(cos φ1 + Bx)² + By² )
   31|      0|        //    λm = λ1 + atan2(By, cos(φ1)+Bx)
   32|      0|        // Source: http://www.movable-type.co.uk/scripts/latlong.html
   33|      0|
   34|      0|        let bxLoc = cos(lat2) * cos(long2 - long1)
   35|      0|        let byLoc = cos(lat2) * sin(long2 - long1)
   36|      0|        let mlat = atan2(sin(lat1) + sin(lat2), sqrt((cos(lat1) + bxLoc) * (cos(lat1) + bxLoc) + (byLoc * byLoc)))
   37|      0|        let mlong = (long1) + atan2(byLoc, cos(lat1) + bxLoc)
   38|      0|
   39|      0|        return CLLocation(latitude: (mlat * 180 / Double.pi), longitude: (mlong * 180 / Double.pi))
   40|      0|    }
   41|       |
   42|       |    /// SwifterSwift: Calculate the half-way point along a great circle path between self and another points.
   43|       |    ///
   44|       |    /// - Parameter point: End location.
   45|       |    /// - Returns: Location that represents the half-way point.
   46|      0|    public func midLocation(to point: CLLocation) -> CLLocation {
   47|      0|        return CLLocation.midLocation(start: self, end: point)
   48|      0|    }
   49|       |
   50|       |    /// SwifterSwift: Calculates the bearing to another CLLocation.
   51|       |    ///
   52|       |    /// - Parameters:
   53|       |    ///   - destination: Location to calculate bearing.
   54|       |    /// - Returns: Calculated bearing degrees in the range 0° ... 360°
   55|      0|    public func bearing(to destination: CLLocation) -> Double {
   56|      0|        // http://stackoverflow.com/questions/3925942/cllocation-category-for-calculating-bearing-w-haversine-function
   57|      0|        let lat1 = Double.pi * coordinate.latitude / 180.0
   58|      0|        let long1 = Double.pi * coordinate.longitude / 180.0
   59|      0|        let lat2 = Double.pi * destination.coordinate.latitude / 180.0
   60|      0|        let long2 = Double.pi * destination.coordinate.longitude / 180.0
   61|      0|
   62|      0|        // Formula: θ = atan2( sin Δλ ⋅ cos φ2 , cos φ1 ⋅ sin φ2 − sin φ1 ⋅ cos φ2 ⋅ cos Δλ )
   63|      0|        // Source: http://www.movable-type.co.uk/scripts/latlong.html
   64|      0|
   65|      0|        let rads = atan2(
   66|      0|            sin(long2 - long1) * cos(lat2),
   67|      0|            cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(long2 - long1))
   68|      0|        let degrees = rads * 180 / Double.pi
   69|      0|
   70|      0|        return (degrees+360).truncatingRemainder(dividingBy: 360)
   71|      0|    }
   72|       |
   73|       |}
   74|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/CalendarExtensions.swift:
    1|       |//
    2|       |//  CalendarExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Chaithanya Prathyush on 09/11/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension Calendar {
   14|       |
   15|       |    /// SwifterSwift: Return the number of days in the month for a specified 'Date'.
   16|       |    ///
   17|       |    ///		let date = Date() // "Jan 12, 2017, 7:07 PM"
   18|       |    ///		Calendar.current.numberOfDaysInMonth(for: date) -> 31
   19|       |    ///
   20|       |    /// - Parameter date: the date form which the number of days in month is calculated.
   21|       |    /// - Returns: The number of days in the month of 'Date'.
   22|      0|    public func numberOfDaysInMonth(for date: Date) -> Int {
   23|      0|        return range(of: .day, in: .month, for: date)!.count
   24|      0|    }
   25|       |
   26|       |}
   27|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/DataExtensions.swift:
    1|       |//
    2|       |//  DataExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 07/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension Data {
   14|       |
   15|       |    /// SwifterSwift: Return data as an array of bytes.
   16|      0|    public var bytes: [UInt8] {
   17|      0|        // http://stackoverflow.com/questions/38097710/swift-3-changes-for-getbytes-method
   18|      0|        return [UInt8](self)
   19|      0|    }
   20|       |
   21|       |}
   22|       |
   23|       |// MARK: - Methods
   24|       |public extension Data {
   25|       |
   26|       |    /// SwifterSwift: String by encoding Data using the given encoding (if applicable).
   27|       |    ///
   28|       |    /// - Parameter encoding: encoding.
   29|       |    /// - Returns: String by encoding Data using the given encoding (if applicable).
   30|      0|    public func string(encoding: String.Encoding) -> String? {
   31|      0|        return String(data: self, encoding: encoding)
   32|      0|    }
   33|       |
   34|       |    /// SwifterSwift: Returns a Foundation object from given JSON data.
   35|       |    ///
   36|       |    /// - Parameter options: Options for reading the JSON data and creating the Foundation object.
   37|       |    ///
   38|       |    ///   For possible values, see `JSONSerialization.ReadingOptions`.
   39|       |    /// - Returns: A Foundation object from the JSON data in the receiver, or `nil` if an error occurs.
   40|       |    /// - Throws: An `NSError` if the receiver does not represent a valid JSON object.
   41|      0|    public func jsonObject(options: JSONSerialization.ReadingOptions = []) throws -> Any {
   42|      0|        return try JSONSerialization.jsonObject(with: self, options: options)
   43|      0|    }
   44|       |
   45|       |}
   46|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/DateExtensions.swift:
    1|       |//
    2|       |//  DateExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/5/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Enums
   13|       |public extension Date {
   14|       |
   15|       |    /// SwifterSwift: Day name format.
   16|       |    ///
   17|       |    /// - threeLetters: 3 letter day abbreviation of day name.
   18|       |    /// - oneLetter: 1 letter day abbreviation of day name.
   19|       |    /// - full: Full day name.
   20|       |    public enum DayNameStyle {
   21|       |        /// 3 letter day abbreviation of day name.
   22|       |        case threeLetters
   23|       |
   24|       |        /// 1 letter day abbreviation of day name.
   25|       |        case oneLetter
   26|       |
   27|       |        /// Full day name.
   28|       |        case full
   29|       |    }
   30|       |
   31|       |    /// SwifterSwift: Month name format.
   32|       |    ///
   33|       |    /// - threeLetters: 3 letter month abbreviation of month name.
   34|       |    /// - oneLetter: 1 letter month abbreviation of month name.
   35|       |    /// - full: Full month name.
   36|       |    public enum MonthNameStyle {
   37|       |        /// 3 letter month abbreviation of month name.
   38|       |        case threeLetters
   39|       |
   40|       |        /// 1 letter month abbreviation of month name.
   41|       |        case oneLetter
   42|       |
   43|       |        /// Full month name.
   44|       |        case full
   45|       |    }
   46|       |
   47|       |}
   48|       |
   49|       |// MARK: - Properties
   50|       |public extension Date {
   51|       |
   52|       |    /// SwifterSwift: User’s current calendar.
   53|      0|    public var calendar: Calendar {
   54|      0|        return Calendar.current
   55|      0|    }
   56|       |
   57|       |    /// SwifterSwift: Era.
   58|       |    ///
   59|       |    ///		Date().era -> 1
   60|       |    ///
   61|      0|    public var era: Int {
   62|      0|        return Calendar.current.component(.era, from: self)
   63|      0|    }
   64|       |
   65|       |    /// SwifterSwift: Quarter.
   66|       |    ///
   67|       |    ///		Date().quarter -> 3 // date in third quarter of the year.
   68|       |    ///
   69|      0|    public var quarter: Int {
   70|      0|        let month = Double(Calendar.current.component(.month, from: self))
   71|      0|        let numberOfMonths = Double(Calendar.current.monthSymbols.count)
   72|      0|        let numberOfMonthsInQuarter = numberOfMonths / 4
   73|      0|        return Int(ceil(month/numberOfMonthsInQuarter))
   74|      0|    }
   75|       |
   76|       |    /// SwifterSwift: Week of year.
   77|       |    ///
   78|       |    ///		Date().weekOfYear -> 2 // second week in the year.
   79|       |    ///
   80|      0|    public var weekOfYear: Int {
   81|      0|        return Calendar.current.component(.weekOfYear, from: self)
   82|      0|    }
   83|       |
   84|       |    /// SwifterSwift: Week of month.
   85|       |    ///
   86|       |    ///		Date().weekOfMonth -> 3 // date is in third week of the month.
   87|       |    ///
   88|      0|    public var weekOfMonth: Int {
   89|      0|        return Calendar.current.component(.weekOfMonth, from: self)
   90|      0|    }
   91|       |
   92|       |    /// SwifterSwift: Year.
   93|       |    ///
   94|       |    ///		Date().year -> 2017
   95|       |    ///
   96|       |    ///		var someDate = Date()
   97|       |    ///		someDate.year = 2000 // sets someDate's year to 2000
   98|       |    ///
   99|       |    public var year: Int {
  100|      0|        get {
  101|      0|            return Calendar.current.component(.year, from: self)
  102|      0|        }
  103|      0|        set {
  104|      0|            guard newValue > 0 else { return }
  105|      0|            let currentYear = Calendar.current.component(.year, from: self)
  106|      0|            let yearsToAdd = newValue - currentYear
  107|      0|            if let date = Calendar.current.date(byAdding: .year, value: yearsToAdd, to: self) {
  108|      0|                self = date
  109|      0|            }
  110|      0|        }
  111|       |    }
  112|       |
  113|       |    /// SwifterSwift: Month.
  114|       |    ///
  115|       |    /// 	Date().month -> 1
  116|       |    ///
  117|       |    /// 	var someDate = Date()
  118|       |    /// 	someDate.month = 10 // sets someDate's month to 10.
  119|       |    ///
  120|       |    public var month: Int {
  121|      0|        get {
  122|      0|            return Calendar.current.component(.month, from: self)
  123|      0|        }
  124|      0|        set {
  125|      0|            let allowedRange = Calendar.current.range(of: .month, in: .year, for: self)!
  126|      0|            guard allowedRange.contains(newValue) else { return }
  127|      0|
  128|      0|            let currentMonth = Calendar.current.component(.month, from: self)
  129|      0|            let monthsToAdd = newValue - currentMonth
  130|      0|            if let date = Calendar.current.date(byAdding: .month, value: monthsToAdd, to: self) {
  131|      0|                self = date
  132|      0|            }
  133|      0|        }
  134|       |    }
  135|       |
  136|       |    /// SwifterSwift: Day.
  137|       |    ///
  138|       |    /// 	Date().day -> 12
  139|       |    ///
  140|       |    /// 	var someDate = Date()
  141|       |    /// 	someDate.day = 1 // sets someDate's day of month to 1.
  142|       |    ///
  143|       |    public var day: Int {
  144|      0|        get {
  145|      0|            return Calendar.current.component(.day, from: self)
  146|      0|        }
  147|      0|        set {
  148|      0|            let allowedRange = Calendar.current.range(of: .day, in: .month, for: self)!
  149|      0|            guard allowedRange.contains(newValue) else { return }
  150|      0|
  151|      0|            let currentDay = Calendar.current.component(.day, from: self)
  152|      0|            let daysToAdd = newValue - currentDay
  153|      0|            if let date = Calendar.current.date(byAdding: .day, value: daysToAdd, to: self) {
  154|      0|                self = date
  155|      0|            }
  156|      0|        }
  157|       |    }
  158|       |
  159|       |    /// SwifterSwift: Weekday.
  160|       |    ///
  161|       |    /// 	Date().weekday -> 5 // fifth day in the current week.
  162|       |    ///
  163|      0|    public var weekday: Int {
  164|      0|        return Calendar.current.component(.weekday, from: self)
  165|      0|    }
  166|       |
  167|       |    /// SwifterSwift: Hour.
  168|       |    ///
  169|       |    /// 	Date().hour -> 17 // 5 pm
  170|       |    ///
  171|       |    /// 	var someDate = Date()
  172|       |    /// 	someDate.hour = 13 // sets someDate's hour to 1 pm.
  173|       |    ///
  174|       |    public var hour: Int {
  175|      0|        get {
  176|      0|            return Calendar.current.component(.hour, from: self)
  177|      0|        }
  178|      0|        set {
  179|      0|            let allowedRange = Calendar.current.range(of: .hour, in: .day, for: self)!
  180|      0|            guard allowedRange.contains(newValue) else { return }
  181|      0|
  182|      0|            let currentHour = Calendar.current.component(.hour, from: self)
  183|      0|            let hoursToAdd = newValue - currentHour
  184|      0|            if let date = Calendar.current.date(byAdding: .hour, value: hoursToAdd, to: self) {
  185|      0|                self = date
  186|      0|            }
  187|      0|        }
  188|       |    }
  189|       |
  190|       |    /// SwifterSwift: Minutes.
  191|       |    ///
  192|       |    /// 	Date().minute -> 39
  193|       |    ///
  194|       |    /// 	var someDate = Date()
  195|       |    /// 	someDate.minute = 10 // sets someDate's minutes to 10.
  196|       |    ///
  197|       |    public var minute: Int {
  198|      0|        get {
  199|      0|            return Calendar.current.component(.minute, from: self)
  200|      0|        }
  201|      0|        set {
  202|      0|            let allowedRange = Calendar.current.range(of: .minute, in: .hour, for: self)!
  203|      0|            guard allowedRange.contains(newValue) else { return }
  204|      0|
  205|      0|            let currentMinutes = Calendar.current.component(.minute, from: self)
  206|      0|            let minutesToAdd = newValue - currentMinutes
  207|      0|            if let date = Calendar.current.date(byAdding: .minute, value: minutesToAdd, to: self) {
  208|      0|                self = date
  209|      0|            }
  210|      0|        }
  211|       |    }
  212|       |
  213|       |    /// SwifterSwift: Seconds.
  214|       |    ///
  215|       |    /// 	Date().second -> 55
  216|       |    ///
  217|       |    /// 	var someDate = Date()
  218|       |    /// 	someDate.second = 15 // sets someDate's seconds to 15.
  219|       |    ///
  220|       |    public var second: Int {
  221|      0|        get {
  222|      0|            return Calendar.current.component(.second, from: self)
  223|      0|        }
  224|      0|        set {
  225|      0|            let allowedRange = Calendar.current.range(of: .second, in: .minute, for: self)!
  226|      0|            guard allowedRange.contains(newValue) else { return }
  227|      0|
  228|      0|            let currentSeconds = Calendar.current.component(.second, from: self)
  229|      0|            let secondsToAdd = newValue - currentSeconds
  230|      0|            if let date = Calendar.current.date(byAdding: .second, value: secondsToAdd, to: self) {
  231|      0|                self = date
  232|      0|            }
  233|      0|        }
  234|       |    }
  235|       |
  236|       |    /// SwifterSwift: Nanoseconds.
  237|       |    ///
  238|       |    /// 	Date().nanosecond -> 981379985
  239|       |    ///
  240|       |    /// 	var someDate = Date()
  241|       |    /// 	someDate.nanosecond = 981379985 // sets someDate's seconds to 981379985.
  242|       |    ///
  243|       |    public var nanosecond: Int {
  244|      0|        get {
  245|      0|            return Calendar.current.component(.nanosecond, from: self)
  246|      0|        }
  247|      0|        set {
  248|      0|            let allowedRange = Calendar.current.range(of: .nanosecond, in: .second, for: self)!
  249|      0|            guard allowedRange.contains(newValue) else { return }
  250|      0|
  251|      0|            let currentNanoseconds = Calendar.current.component(.nanosecond, from: self)
  252|      0|            let nanosecondsToAdd = newValue - currentNanoseconds
  253|      0|
  254|      0|            if let date = Calendar.current.date(byAdding: .nanosecond, value: nanosecondsToAdd, to: self) {
  255|      0|                self = date
  256|      0|            }
  257|      0|        }
  258|       |    }
  259|       |
  260|       |    /// SwifterSwift: Milliseconds.
  261|       |    ///
  262|       |    /// 	Date().millisecond -> 68
  263|       |    ///
  264|       |    /// 	var someDate = Date()
  265|       |    /// 	someDate.millisecond = 68 // sets someDate's nanosecond to 68000000.
  266|       |    ///
  267|       |    public var millisecond: Int {
  268|      0|        get {
  269|      0|            return Calendar.current.component(.nanosecond, from: self) / 1000000
  270|      0|        }
  271|      0|        set {
  272|      0|            let nanoSeconds = newValue * 1000000
  273|      0|            let allowedRange = Calendar.current.range(of: .nanosecond, in: .second, for: self)!
  274|      0|            guard allowedRange.contains(nanoSeconds) else { return }
  275|      0|
  276|      0|            if let date = Calendar.current.date(bySetting: .nanosecond, value: nanoSeconds, of: self) {
  277|      0|                self = date
  278|      0|            }
  279|      0|        }
  280|       |    }
  281|       |
  282|       |    /// SwifterSwift: Check if date is in future.
  283|       |    ///
  284|       |    /// 	Date(timeInterval: 100, since: Date()).isInFuture -> true
  285|       |    ///
  286|      0|    public var isInFuture: Bool {
  287|      0|        return self > Date()
  288|      0|    }
  289|       |
  290|       |    /// SwifterSwift: Check if date is in past.
  291|       |    ///
  292|       |    /// 	Date(timeInterval: -100, since: Date()).isInPast -> true
  293|       |    ///
  294|      0|    public var isInPast: Bool {
  295|      0|        return self < Date()
  296|      0|    }
  297|       |
  298|       |    /// SwifterSwift: Check if date is within today.
  299|       |    ///
  300|       |    /// 	Date().isInToday -> true
  301|       |    ///
  302|      0|    public var isInToday: Bool {
  303|      0|        return Calendar.current.isDateInToday(self)
  304|      0|    }
  305|       |
  306|       |    /// SwifterSwift: Check if date is within yesterday.
  307|       |    ///
  308|       |    /// 	Date().isInYesterday -> false
  309|       |    ///
  310|      0|    public var isInYesterday: Bool {
  311|      0|        return Calendar.current.isDateInYesterday(self)
  312|      0|    }
  313|       |
  314|       |    /// SwifterSwift: Check if date is within tomorrow.
  315|       |    ///
  316|       |    /// 	Date().isInTomorrow -> false
  317|       |    ///
  318|      0|    public var isInTomorrow: Bool {
  319|      0|        return Calendar.current.isDateInTomorrow(self)
  320|      0|    }
  321|       |
  322|       |    /// SwifterSwift: Check if date is within a weekend period.
  323|      0|    public var isInWeekend: Bool {
  324|      0|        return Calendar.current.isDateInWeekend(self)
  325|      0|    }
  326|       |
  327|       |    /// SwifterSwift: Check if date is within a weekday period.
  328|      0|    public var isWorkday: Bool {
  329|      0|        return !Calendar.current.isDateInWeekend(self)
  330|      0|    }
  331|       |
  332|       |    /// SwifterSwift: Check if date is within the current week.
  333|      0|    public var isInCurrentWeek: Bool {
  334|      0|        return Calendar.current.isDate(self, equalTo: Date(), toGranularity: .weekOfYear)
  335|      0|    }
  336|       |
  337|       |    /// SwifterSwift: Check if date is within the current month.
  338|      0|    public var isInCurrentMonth: Bool {
  339|      0|        return Calendar.current.isDate(self, equalTo: Date(), toGranularity: .month)
  340|      0|    }
  341|       |
  342|       |    /// SwifterSwift: Check if date is within the current year.
  343|      0|    public var isInCurrentYear: Bool {
  344|      0|        return Calendar.current.isDate(self, equalTo: Date(), toGranularity: .year)
  345|      0|    }
  346|       |
  347|       |    /// SwifterSwift: ISO8601 string of format (yyyy-MM-dd'T'HH:mm:ss.SSS) from date.
  348|       |    ///
  349|       |    /// 	Date().iso8601String -> "2017-01-12T14:51:29.574Z"
  350|       |    ///
  351|      0|    public var iso8601String: String {
  352|      0|        // https://github.com/justinmakaila/NSDate-ISO-8601/blob/master/NSDateISO8601.swift
  353|      0|        let dateFormatter = DateFormatter()
  354|      0|        dateFormatter.locale = Locale(identifier: "en_US_POSIX")
  355|      0|        dateFormatter.timeZone = TimeZone(abbreviation: "GMT")
  356|      0|        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS"
  357|      0|
  358|      0|        return dateFormatter.string(from: self).appending("Z")
  359|      0|    }
  360|       |
  361|       |    /// SwifterSwift: Nearest five minutes to date.
  362|       |    ///
  363|       |    /// 	var date = Date() // "5:54 PM"
  364|       |    /// 	date.minute = 32 // "5:32 PM"
  365|       |    /// 	date.nearestFiveMinutes // "5:30 PM"
  366|       |    ///
  367|       |    /// 	date.minute = 44 // "5:44 PM"
  368|       |    /// 	date.nearestFiveMinutes // "5:45 PM"
  369|       |    ///
  370|      0|    public var nearestFiveMinutes: Date {
  371|      0|        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second, .nanosecond], from: self)
  372|      0|        let min = components.minute!
  373|      0|        components.minute! = min % 5 < 3 ? min - min % 5 : min + 5 - (min % 5)
  374|      0|        components.second = 0
  375|      0|        components.nanosecond = 0
  376|      0|        return Calendar.current.date(from: components)!
  377|      0|    }
  378|       |
  379|       |    /// SwifterSwift: Nearest ten minutes to date.
  380|       |    ///
  381|       |    /// 	var date = Date() // "5:57 PM"
  382|       |    /// 	date.minute = 34 // "5:34 PM"
  383|       |    /// 	date.nearestTenMinutes // "5:30 PM"
  384|       |    ///
  385|       |    /// 	date.minute = 48 // "5:48 PM"
  386|       |    /// 	date.nearestTenMinutes // "5:50 PM"
  387|       |    ///
  388|      0|    public var nearestTenMinutes: Date {
  389|      0|        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second, .nanosecond], from: self)
  390|      0|        let min = components.minute!
  391|      0|        components.minute? = min % 10 < 6 ? min - min % 10 : min + 10 - (min % 10)
  392|      0|        components.second = 0
  393|      0|        components.nanosecond = 0
  394|      0|        return Calendar.current.date(from: components)!
  395|      0|    }
  396|       |
  397|       |    /// SwifterSwift: Nearest quarter hour to date.
  398|       |    ///
  399|       |    /// 	var date = Date() // "5:57 PM"
  400|       |    /// 	date.minute = 34 // "5:34 PM"
  401|       |    /// 	date.nearestQuarterHour // "5:30 PM"
  402|       |    ///
  403|       |    /// 	date.minute = 40 // "5:40 PM"
  404|       |    /// 	date.nearestQuarterHour // "5:45 PM"
  405|       |    ///
  406|      0|    public var nearestQuarterHour: Date {
  407|      0|        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second, .nanosecond], from: self)
  408|      0|        let min = components.minute!
  409|      0|        components.minute! = min % 15 < 8 ? min - min % 15 : min + 15 - (min % 15)
  410|      0|        components.second = 0
  411|      0|        components.nanosecond = 0
  412|      0|        return Calendar.current.date(from: components)!
  413|      0|    }
  414|       |
  415|       |    /// SwifterSwift: Nearest half hour to date.
  416|       |    ///
  417|       |    /// 	var date = Date() // "6:07 PM"
  418|       |    /// 	date.minute = 41 // "6:41 PM"
  419|       |    /// 	date.nearestHalfHour // "6:30 PM"
  420|       |    ///
  421|       |    /// 	date.minute = 51 // "6:51 PM"
  422|       |    /// 	date.nearestHalfHour // "7:00 PM"
  423|       |    ///
  424|      0|    public var nearestHalfHour: Date {
  425|      0|        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second, .nanosecond], from: self)
  426|      0|        let min = components.minute!
  427|      0|        components.minute! = min % 30 < 15 ? min - min % 30 : min + 30 - (min % 30)
  428|      0|        components.second = 0
  429|      0|        components.nanosecond = 0
  430|      0|        return Calendar.current.date(from: components)!
  431|      0|    }
  432|       |
  433|       |    /// SwifterSwift: Nearest hour to date.
  434|       |    ///
  435|       |    /// 	var date = Date() // "6:17 PM"
  436|       |    /// 	date.nearestHour // "6:00 PM"
  437|       |    ///
  438|       |    /// 	date.minute = 36 // "6:36 PM"
  439|       |    /// 	date.nearestHour // "7:00 PM"
  440|       |    ///
  441|      0|    public var nearestHour: Date {
  442|      0|        let min = Calendar.current.component(.minute, from: self)
  443|      0|        let components: Set<Calendar.Component> = [.year, .month, .day, .hour]
  444|      0|        let date = Calendar.current.date(from: Calendar.current.dateComponents(components, from: self))!
  445|      0|
  446|      0|        if min < 30 {
  447|      0|            return date
  448|      0|        }
  449|      0|        return Calendar.current.date(byAdding: .hour, value: 1, to: date)!
  450|      0|    }
  451|       |
  452|       |    /// SwifterSwift: Time zone used currently by system.
  453|       |    ///
  454|       |    ///		Date().timeZone -> Europe/Istanbul (current)
  455|       |    ///
  456|      0|    public var timeZone: TimeZone {
  457|      0|        return Calendar.current.timeZone
  458|      0|    }
  459|       |
  460|       |    /// SwifterSwift: UNIX timestamp from date.
  461|       |    ///
  462|       |    ///		Date().unixTimestamp -> 1484233862.826291
  463|       |    ///
  464|      0|    public var unixTimestamp: Double {
  465|      0|        return timeIntervalSince1970
  466|      0|    }
  467|       |
  468|       |}
  469|       |
  470|       |// MARK: - Methods
  471|       |public extension Date {
  472|       |
  473|       |    /// SwifterSwift: Date by adding multiples of calendar component.
  474|       |    ///
  475|       |    /// 	let date = Date() // "Jan 12, 2017, 7:07 PM"
  476|       |    /// 	let date2 = date.adding(.minute, value: -10) // "Jan 12, 2017, 6:57 PM"
  477|       |    /// 	let date3 = date.adding(.day, value: 4) // "Jan 16, 2017, 7:07 PM"
  478|       |    /// 	let date4 = date.adding(.month, value: 2) // "Mar 12, 2017, 7:07 PM"
  479|       |    /// 	let date5 = date.adding(.year, value: 13) // "Jan 12, 2030, 7:07 PM"
  480|       |    ///
  481|       |    /// - Parameters:
  482|       |    ///   - component: component type.
  483|       |    ///   - value: multiples of components to add.
  484|       |    /// - Returns: original date + multiples of component added.
  485|      0|    public func adding(_ component: Calendar.Component, value: Int) -> Date {
  486|      0|        return Calendar.current.date(byAdding: component, value: value, to: self)!
  487|      0|    }
  488|       |
  489|       |    /// SwifterSwift: Add calendar component to date.
  490|       |    ///
  491|       |    /// 	var date = Date() // "Jan 12, 2017, 7:07 PM"
  492|       |    /// 	date.add(.minute, value: -10) // "Jan 12, 2017, 6:57 PM"
  493|       |    /// 	date.add(.day, value: 4) // "Jan 16, 2017, 7:07 PM"
  494|       |    /// 	date.add(.month, value: 2) // "Mar 12, 2017, 7:07 PM"
  495|       |    /// 	date.add(.year, value: 13) // "Jan 12, 2030, 7:07 PM"
  496|       |    ///
  497|       |    /// - Parameters:
  498|       |    ///   - component: component type.
  499|       |    ///   - value: multiples of compnenet to add.
  500|      0|    public mutating func add(_ component: Calendar.Component, value: Int) {
  501|      0|        if let date = Calendar.current.date(byAdding: component, value: value, to: self) {
  502|      0|            self = date
  503|      0|        }
  504|      0|    }
  505|       |
  506|       |    // swiftlint:disable function_body_length, function_body_length
  507|       |    // swiftlint:disable cyclomatic_complexity
  508|       |    /// SwifterSwift: Date by changing value of calendar component.
  509|       |    ///
  510|       |    /// 	let date = Date() // "Jan 12, 2017, 7:07 PM"
  511|       |    /// 	let date2 = date.changing(.minute, value: 10) // "Jan 12, 2017, 6:10 PM"
  512|       |    /// 	let date3 = date.changing(.day, value: 4) // "Jan 4, 2017, 7:07 PM"
  513|       |    /// 	let date4 = date.changing(.month, value: 2) // "Feb 12, 2017, 7:07 PM"
  514|       |    /// 	let date5 = date.changing(.year, value: 2000) // "Jan 12, 2000, 7:07 PM"
  515|       |    ///
  516|       |    /// - Parameters:
  517|       |    ///   - component: component type.
  518|       |    ///   - value: new value of compnenet to change.
  519|       |    /// - Returns: original date after changing given component to given value.
  520|      0|    public func changing(_ component: Calendar.Component, value: Int) -> Date? {
  521|      0|        switch component {
  522|      0|        case .nanosecond:
  523|      0|            let allowedRange = Calendar.current.range(of: .nanosecond, in: .second, for: self)!
  524|      0|            guard allowedRange.contains(value) else { return nil }
  525|      0|            let currentNanoseconds = Calendar.current.component(.nanosecond, from: self)
  526|      0|            let nanosecondsToAdd = value - currentNanoseconds
  527|      0|            return Calendar.current.date(byAdding: .nanosecond, value: nanosecondsToAdd, to: self)
  528|      0|
  529|      0|        case .second:
  530|      0|            let allowedRange = Calendar.current.range(of: .second, in: .minute, for: self)!
  531|      0|            guard allowedRange.contains(value) else { return nil }
  532|      0|            let currentSeconds = Calendar.current.component(.second, from: self)
  533|      0|            let secondsToAdd = value - currentSeconds
  534|      0|            return Calendar.current.date(byAdding: .second, value: secondsToAdd, to: self)
  535|      0|
  536|      0|        case .minute:
  537|      0|            let allowedRange = Calendar.current.range(of: .minute, in: .hour, for: self)!
  538|      0|            guard allowedRange.contains(value) else { return nil }
  539|      0|            let currentMinutes = Calendar.current.component(.minute, from: self)
  540|      0|            let minutesToAdd = value - currentMinutes
  541|      0|            return Calendar.current.date(byAdding: .minute, value: minutesToAdd, to: self)
  542|      0|
  543|      0|        case .hour:
  544|      0|            let allowedRange = Calendar.current.range(of: .hour, in: .day, for: self)!
  545|      0|            guard allowedRange.contains(value) else { return nil }
  546|      0|            let currentHour = Calendar.current.component(.hour, from: self)
  547|      0|            let hoursToAdd = value - currentHour
  548|      0|            return Calendar.current.date(byAdding: .hour, value: hoursToAdd, to: self)
  549|      0|
  550|      0|        case .day:
  551|      0|            let allowedRange = Calendar.current.range(of: .day, in: .month, for: self)!
  552|      0|            guard allowedRange.contains(value) else { return nil }
  553|      0|            let currentDay = Calendar.current.component(.day, from: self)
  554|      0|            let daysToAdd = value - currentDay
  555|      0|            return Calendar.current.date(byAdding: .day, value: daysToAdd, to: self)
  556|      0|
  557|      0|        case .month:
  558|      0|            let allowedRange = Calendar.current.range(of: .month, in: .year, for: self)!
  559|      0|            guard allowedRange.contains(value) else { return nil }
  560|      0|            let currentMonth = Calendar.current.component(.month, from: self)
  561|      0|            let monthsToAdd = value - currentMonth
  562|      0|            return Calendar.current.date(byAdding: .month, value: monthsToAdd, to: self)
  563|      0|
  564|      0|        case .year:
  565|      0|            guard value > 0 else { return nil }
  566|      0|            let currentYear = Calendar.current.component(.year, from: self)
  567|      0|            let yearsToAdd = value - currentYear
  568|      0|            return Calendar.current.date(byAdding: .year, value: yearsToAdd, to: self)
  569|      0|
  570|      0|        default:
  571|      0|            return Calendar.current.date(bySetting: component, value: value, of: self)
  572|      0|        }
  573|      0|    }
  574|       |    // swiftlint:enable cyclomatic_complexity, function_body_length
  575|       |
  576|       |    /// SwifterSwift: Data at the beginning of calendar component.
  577|       |    ///
  578|       |    /// 	let date = Date() // "Jan 12, 2017, 7:14 PM"
  579|       |    /// 	let date2 = date.beginning(of: .hour) // "Jan 12, 2017, 7:00 PM"
  580|       |    /// 	let date3 = date.beginning(of: .month) // "Jan 1, 2017, 12:00 AM"
  581|       |    /// 	let date4 = date.beginning(of: .year) // "Jan 1, 2017, 12:00 AM"
  582|       |    ///
  583|       |    /// - Parameter component: calendar component to get date at the beginning of.
  584|       |    /// - Returns: date at the beginning of calendar component (if applicable).
  585|      0|    public func beginning(of component: Calendar.Component) -> Date? {
  586|      0|        if component == .day {
  587|      0|            return Calendar.current.startOfDay(for: self)
  588|      0|        }
  589|      0|
  590|      0|        var components: Set<Calendar.Component> {
  591|      0|            switch component {
  592|      0|            case .second:
  593|      0|                return [.year, .month, .day, .hour, .minute, .second]
  594|      0|
  595|      0|            case .minute:
  596|      0|                return [.year, .month, .day, .hour, .minute]
  597|      0|
  598|      0|            case .hour:
  599|      0|                return [.year, .month, .day, .hour]
  600|      0|
  601|      0|            case .weekOfYear, .weekOfMonth:
  602|      0|                return [.yearForWeekOfYear, .weekOfYear]
  603|      0|
  604|      0|            case .month:
  605|      0|                return [.year, .month]
  606|      0|
  607|      0|            case .year:
  608|      0|                return [.year]
  609|      0|
  610|      0|            default:
  611|      0|                return []
  612|      0|            }
  613|      0|        }
  614|      0|
  615|      0|        guard !components.isEmpty else { return nil }
  616|      0|        return Calendar.current.date(from: Calendar.current.dateComponents(components, from: self))
  617|      0|    }
  618|       |
  619|       |    // swiftlint:disable function_body_length
  620|       |    /// SwifterSwift: Date at the end of calendar component.
  621|       |    ///
  622|       |    /// 	let date = Date() // "Jan 12, 2017, 7:27 PM"
  623|       |    /// 	let date2 = date.end(of: .day) // "Jan 12, 2017, 11:59 PM"
  624|       |    /// 	let date3 = date.end(of: .month) // "Jan 31, 2017, 11:59 PM"
  625|       |    /// 	let date4 = date.end(of: .year) // "Dec 31, 2017, 11:59 PM"
  626|       |    ///
  627|       |    /// - Parameter component: calendar component to get date at the end of.
  628|       |    /// - Returns: date at the end of calendar component (if applicable).
  629|      0|    public func end(of component: Calendar.Component) -> Date? {
  630|      0|        switch component {
  631|      0|        case .second:
  632|      0|            var date = adding(.second, value: 1)
  633|      0|            date = Calendar.current.date(from:
  634|      0|                Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: date))!
  635|      0|            date.add(.second, value: -1)
  636|      0|            return date
  637|      0|
  638|      0|        case .minute:
  639|      0|            var date = adding(.minute, value: 1)
  640|      0|            let after = Calendar.current.date(from:
  641|      0|                Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: date))!
  642|      0|            date = after.adding(.second, value: -1)
  643|      0|            return date
  644|      0|
  645|      0|        case .hour:
  646|      0|            var date = adding(.hour, value: 1)
  647|      0|            let after = Calendar.current.date(from:
  648|      0|                Calendar.current.dateComponents([.year, .month, .day, .hour], from: date))!
  649|      0|            date = after.adding(.second, value: -1)
  650|      0|            return date
  651|      0|
  652|      0|        case .day:
  653|      0|            var date = adding(.day, value: 1)
  654|      0|            date = Calendar.current.startOfDay(for: date)
  655|      0|            date.add(.second, value: -1)
  656|      0|            return date
  657|      0|
  658|      0|        case .weekOfYear, .weekOfMonth:
  659|      0|            var date = self
  660|      0|            let beginningOfWeek = Calendar.current.date(from:
  661|      0|                Calendar.current.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date))!
  662|      0|            date = beginningOfWeek.adding(.day, value: 7).adding(.second, value: -1)
  663|      0|            return date
  664|      0|
  665|      0|        case .month:
  666|      0|            var date = adding(.month, value: 1)
  667|      0|            let after = Calendar.current.date(from:
  668|      0|                Calendar.current.dateComponents([.year, .month], from: date))!
  669|      0|            date = after.adding(.second, value: -1)
  670|      0|            return date
  671|      0|
  672|      0|        case .year:
  673|      0|            var date = adding(.year, value: 1)
  674|      0|            let after = Calendar.current.date(from:
  675|      0|                Calendar.current.dateComponents([.year], from: date))!
  676|      0|            date = after.adding(.second, value: -1)
  677|      0|            return date
  678|      0|
  679|      0|        default:
  680|      0|            return nil
  681|      0|        }
  682|      0|    }
  683|       |    // swiftlint:enable function_body_length
  684|       |
  685|       |    /// SwifterSwift: Check if date is in current given calendar component.
  686|       |    ///
  687|       |    /// 	Date().isInCurrent(.day) -> true
  688|       |    /// 	Date().isInCurrent(.year) -> true
  689|       |    ///
  690|       |    /// - Parameter component: calendar component to check.
  691|       |    /// - Returns: true if date is in current given calendar component.
  692|      0|    public func isInCurrent(_ component: Calendar.Component) -> Bool {
  693|      0|        return Calendar.current.isDate(self, equalTo: Date(), toGranularity: component)
  694|      0|    }
  695|       |
  696|       |    /// SwifterSwift: Date string from date.
  697|       |    ///
  698|       |    ///     Date().string(withFormat: "dd/MM/yyyy") -> "1/12/17"
  699|       |    ///     Date().string(withFormat: "HH:mm") -> "23:50"
  700|       |    ///     Date().string(withFormat: "dd/MM/yyyy HH:mm") -> "1/12/17 23:50"
  701|       |    ///
  702|       |    /// - Parameter format: Date format (default is "dd/MM/yyyy").
  703|       |    /// - Returns: date string.
  704|      0|    public func string(withFormat format: String = "dd/MM/yyyy HH:mm") -> String {
  705|      0|        let dateFormatter = DateFormatter()
  706|      0|        dateFormatter.dateFormat = format
  707|      0|        return dateFormatter.string(from: self)
  708|      0|    }
  709|       |
  710|       |    /// SwifterSwift: Date string from date.
  711|       |    ///
  712|       |    /// 	Date().dateString(ofStyle: .short) -> "1/12/17"
  713|       |    /// 	Date().dateString(ofStyle: .medium) -> "Jan 12, 2017"
  714|       |    /// 	Date().dateString(ofStyle: .long) -> "January 12, 2017"
  715|       |    /// 	Date().dateString(ofStyle: .full) -> "Thursday, January 12, 2017"
  716|       |    ///
  717|       |    /// - Parameter style: DateFormatter style (default is .medium).
  718|       |    /// - Returns: date string.
  719|      0|    public func dateString(ofStyle style: DateFormatter.Style = .medium) -> String {
  720|      0|        let dateFormatter = DateFormatter()
  721|      0|        dateFormatter.timeStyle = .none
  722|      0|        dateFormatter.dateStyle = style
  723|      0|        return dateFormatter.string(from: self)
  724|      0|    }
  725|       |
  726|       |    /// SwifterSwift: Date and time string from date.
  727|       |    ///
  728|       |    /// 	Date().dateTimeString(ofStyle: .short) -> "1/12/17, 7:32 PM"
  729|       |    /// 	Date().dateTimeString(ofStyle: .medium) -> "Jan 12, 2017, 7:32:00 PM"
  730|       |    /// 	Date().dateTimeString(ofStyle: .long) -> "January 12, 2017 at 7:32:00 PM GMT+3"
  731|       |    /// 	Date().dateTimeString(ofStyle: .full) -> "Thursday, January 12, 2017 at 7:32:00 PM GMT+03:00"
  732|       |    ///
  733|       |    /// - Parameter style: DateFormatter style (default is .medium).
  734|       |    /// - Returns: date and time string.
  735|      0|    public func dateTimeString(ofStyle style: DateFormatter.Style = .medium) -> String {
  736|      0|        let dateFormatter = DateFormatter()
  737|      0|        dateFormatter.timeStyle = style
  738|      0|        dateFormatter.dateStyle = style
  739|      0|        return dateFormatter.string(from: self)
  740|      0|    }
  741|       |
  742|       |    /// SwifterSwift: Time string from date
  743|       |    ///
  744|       |    /// 	Date().timeString(ofStyle: .short) -> "7:37 PM"
  745|       |    /// 	Date().timeString(ofStyle: .medium) -> "7:37:02 PM"
  746|       |    /// 	Date().timeString(ofStyle: .long) -> "7:37:02 PM GMT+3"
  747|       |    /// 	Date().timeString(ofStyle: .full) -> "7:37:02 PM GMT+03:00"
  748|       |    ///
  749|       |    /// - Parameter style: DateFormatter style (default is .medium).
  750|       |    /// - Returns: time string.
  751|      0|    public func timeString(ofStyle style: DateFormatter.Style = .medium) -> String {
  752|      0|        let dateFormatter = DateFormatter()
  753|      0|        dateFormatter.timeStyle = style
  754|      0|        dateFormatter.dateStyle = .none
  755|      0|        return dateFormatter.string(from: self)
  756|      0|    }
  757|       |
  758|       |    /// SwifterSwift: Day name from date.
  759|       |    ///
  760|       |    /// 	Date().dayName(ofStyle: .oneLetter) -> "T"
  761|       |    /// 	Date().dayName(ofStyle: .threeLetters) -> "Thu"
  762|       |    /// 	Date().dayName(ofStyle: .full) -> "Thursday"
  763|       |    ///
  764|       |    /// - Parameter Style: style of day name (default is DayNameStyle.full).
  765|       |    /// - Returns: day name string (example: W, Wed, Wednesday).
  766|      0|    public func dayName(ofStyle style: DayNameStyle = .full) -> String {
  767|      0|        // http://www.codingexplorer.com/swiftly-getting-human-readable-date-nsdateformatter/
  768|      0|        let dateFormatter = DateFormatter()
  769|      0|        var format: String {
  770|      0|            switch style {
  771|      0|            case .oneLetter:
  772|      0|                return "EEEEE"
  773|      0|            case .threeLetters:
  774|      0|                return "EEE"
  775|      0|            case .full:
  776|      0|                return "EEEE"
  777|      0|            }
  778|      0|        }
  779|      0|        dateFormatter.setLocalizedDateFormatFromTemplate(format)
  780|      0|        return dateFormatter.string(from: self)
  781|      0|    }
  782|       |
  783|       |    /// SwifterSwift: Month name from date.
  784|       |    ///
  785|       |    /// 	Date().monthName(ofStyle: .oneLetter) -> "J"
  786|       |    /// 	Date().monthName(ofStyle: .threeLetters) -> "Jan"
  787|       |    /// 	Date().monthName(ofStyle: .full) -> "January"
  788|       |    ///
  789|       |    /// - Parameter Style: style of month name (default is MonthNameStyle.full).
  790|       |    /// - Returns: month name string (example: D, Dec, December).
  791|      0|    public func monthName(ofStyle style: MonthNameStyle = .full) -> String {
  792|      0|        // http://www.codingexplorer.com/swiftly-getting-human-readable-date-nsdateformatter/
  793|      0|        let dateFormatter = DateFormatter()
  794|      0|        var format: String {
  795|      0|            switch style {
  796|      0|            case .oneLetter:
  797|      0|                return "MMMMM"
  798|      0|            case .threeLetters:
  799|      0|                return "MMM"
  800|      0|            case .full:
  801|      0|                return "MMMM"
  802|      0|            }
  803|      0|        }
  804|      0|        dateFormatter.setLocalizedDateFormatFromTemplate(format)
  805|      0|        return dateFormatter.string(from: self)
  806|      0|    }
  807|       |
  808|       |    /// SwifterSwift: get number of seconds between two date
  809|       |    ///
  810|       |    /// - Parameter date: date to compate self to.
  811|       |    /// - Returns: number of seconds between self and given date.
  812|      0|    public func secondsSince(_ date: Date) -> Double {
  813|      0|        return timeIntervalSince(date)
  814|      0|    }
  815|       |
  816|       |    /// SwifterSwift: get number of minutes between two date
  817|       |    ///
  818|       |    /// - Parameter date: date to compate self to.
  819|       |    /// - Returns: number of minutes between self and given date.
  820|      0|    public func minutesSince(_ date: Date) -> Double {
  821|      0|        return timeIntervalSince(date)/60
  822|      0|    }
  823|       |
  824|       |    /// SwifterSwift: get number of hours between two date
  825|       |    ///
  826|       |    /// - Parameter date: date to compate self to.
  827|       |    /// - Returns: number of hours between self and given date.
  828|      0|    public func hoursSince(_ date: Date) -> Double {
  829|      0|        return timeIntervalSince(date)/3600
  830|      0|    }
  831|       |
  832|       |    /// SwifterSwift: get number of days between two date
  833|       |    ///
  834|       |    /// - Parameter date: date to compate self to.
  835|       |    /// - Returns: number of days between self and given date.
  836|      0|    public func daysSince(_ date: Date) -> Double {
  837|      0|        return timeIntervalSince(date)/(3600*24)
  838|      0|    }
  839|       |
  840|       |    /// SwifterSwift: check if a date is between two other dates
  841|       |    ///
  842|       |    /// - Parameters:
  843|       |    ///   - startDate: start date to compare self to.
  844|       |    ///   - endDate: endDate date to compare self to.
  845|       |    ///   - includeBounds: true if the start and end date should be included (default is false)
  846|       |    /// - Returns: true if the date is between the two given dates.
  847|      0|    public func isBetween(_ startDate: Date, _ endDate: Date, includeBounds: Bool = false) -> Bool {
  848|      0|        if includeBounds {
  849|      0|            return startDate.compare(self).rawValue * compare(endDate).rawValue >= 0
  850|      0|        }
  851|      0|        return startDate.compare(self).rawValue * compare(endDate).rawValue > 0
  852|      0|    }
  853|       |
  854|       |    /// SwifterSwift: check if a date is a number of date components of another date
  855|       |    ///
  856|       |    /// - Parameters:
  857|       |    ///   - value: number of times component is used in creating range
  858|       |    ///   - component: Calendar.Component to use.
  859|       |    ///   - date: Date to compare self to.
  860|       |    /// - Returns: true if the date is within a number of components of another date
  861|      0|    public func isWithin(_ value: UInt, _ component: Calendar.Component, of date: Date) -> Bool {
  862|      0|        let components = Calendar.current.dateComponents([component], from: self, to: date)
  863|      0|        let componentValue = components.value(for: component)!
  864|      0|        return abs(componentValue) <= value
  865|      0|    }
  866|       |
  867|       |    /// SwifterSwift: Random date between two dates.
  868|       |    ///
  869|       |    ///     Date.random()
  870|       |    ///     Date.random(from: Date())
  871|       |    ///     Date.random(upTo: Date())
  872|       |    ///     Date.random(from: Date(), upTo: Date())
  873|       |    ///
  874|       |    /// - Parameters:
  875|       |    ///   - fromDate: minimum date (default is Date.distantPast)
  876|       |    ///   - toDate: maximum date (default is Date.distantFuture)
  877|       |    /// - Returns: random date between two dates.
  878|      0|    public static func random(from fromDate: Date = Date.distantPast, upTo toDate: Date = Date.distantFuture) -> Date {
  879|      0|        guard fromDate != toDate else {
  880|      0|            return fromDate
  881|      0|        }
  882|      0|
  883|      0|        let diff = llabs(Int64(toDate.timeIntervalSinceReferenceDate - fromDate.timeIntervalSinceReferenceDate))
  884|      0|        var randomValue: Int64 = Int64.random(in: Int64.min...Int64.max)
  885|      0|        randomValue = llabs(randomValue%diff)
  886|      0|
  887|      0|        let startReferenceDate = toDate > fromDate ? fromDate : toDate
  888|      0|        return startReferenceDate.addingTimeInterval(TimeInterval(randomValue))
  889|      0|    }
  890|       |
  891|       |}
  892|       |
  893|       |// MARK: - Initializers
  894|       |public extension Date {
  895|       |
  896|       |    /// SwifterSwift: Create a new date form calendar components.
  897|       |    ///
  898|       |    /// 	let date = Date(year: 2010, month: 1, day: 12) // "Jan 12, 2010, 7:45 PM"
  899|       |    ///
  900|       |    /// - Parameters:
  901|       |    ///   - calendar: Calendar (default is current).
  902|       |    ///   - timeZone: TimeZone (default is current).
  903|       |    ///   - era: Era (default is current era).
  904|       |    ///   - year: Year (default is current year).
  905|       |    ///   - month: Month (default is current month).
  906|       |    ///   - day: Day (default is today).
  907|       |    ///   - hour: Hour (default is current hour).
  908|       |    ///   - minute: Minute (default is current minute).
  909|       |    ///   - second: Second (default is current second).
  910|       |    ///   - nanosecond: Nanosecond (default is current nanosecond).
  911|       |    public init?(
  912|       |        calendar: Calendar? = Calendar.current,
  913|       |        timeZone: TimeZone? = TimeZone.current,
  914|       |        era: Int? = Date().era,
  915|       |        year: Int? = Date().year,
  916|       |        month: Int? = Date().month,
  917|       |        day: Int? = Date().day,
  918|       |        hour: Int? = Date().hour,
  919|       |        minute: Int? = Date().minute,
  920|       |        second: Int? = Date().second,
  921|      0|        nanosecond: Int? = Date().nanosecond) {
  922|      0|
  923|      0|        var components = DateComponents()
  924|      0|        components.calendar = calendar
  925|      0|        components.timeZone = timeZone
  926|      0|        components.era = era
  927|      0|        components.year = year
  928|      0|        components.month = month
  929|      0|        components.day = day
  930|      0|        components.hour = hour
  931|      0|        components.minute = minute
  932|      0|        components.second = second
  933|      0|        components.nanosecond = nanosecond
  934|      0|
  935|      0|        if let date = calendar?.date(from: components) {
  936|      0|            self = date
  937|      0|        } else {
  938|      0|            return nil
  939|      0|        }
  940|      0|    }
  941|       |
  942|       |    /// SwifterSwift: Create date object from ISO8601 string.
  943|       |    ///
  944|       |    /// 	let date = Date(iso8601String: "2017-01-12T16:48:00.959Z") // "Jan 12, 2017, 7:48 PM"
  945|       |    ///
  946|       |    /// - Parameter iso8601String: ISO8601 string of format (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
  947|      0|    public init?(iso8601String: String) {
  948|      0|        // https://github.com/justinmakaila/NSDate-ISO-8601/blob/master/NSDateISO8601.swift
  949|      0|        let dateFormatter = DateFormatter()
  950|      0|        dateFormatter.locale = Locale(identifier: "en_US_POSIX")
  951|      0|        dateFormatter.timeZone = TimeZone.current
  952|      0|        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
  953|      0|        if let date = dateFormatter.date(from: iso8601String) {
  954|      0|            self = date
  955|      0|        } else {
  956|      0|            return nil
  957|      0|        }
  958|      0|    }
  959|       |
  960|       |    /// SwifterSwift: Create new date object from UNIX timestamp.
  961|       |    ///
  962|       |    /// 	let date = Date(unixTimestamp: 1484239783.922743) // "Jan 12, 2017, 7:49 PM"
  963|       |    ///
  964|       |    /// - Parameter unixTimestamp: UNIX timestamp.
  965|      0|    public init(unixTimestamp: Double) {
  966|      0|        self.init(timeIntervalSince1970: unixTimestamp)
  967|      0|    }
  968|       |
  969|       |    /// SwifterSwift: Create date object from Int literal
  970|       |    ///
  971|       |    ///     let date = Date(integerLiteral: 2017_12_25) // "2017-12-25 00:00:00 +0000"
  972|       |    /// - Parameter value: Int value, e.g. 20171225, or 2017_12_25 etc.
  973|      0|    public init?(integerLiteral value: Int) {
  974|      0|        let formatter = DateFormatter()
  975|      0|        formatter.dateFormat = "yyyyMMdd"
  976|      0|        guard let date = formatter.date(from: String(value)) else { return nil }
  977|      0|        self = date
  978|      0|    }
  979|       |
  980|       |}
  981|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/FileManagerExtensions.swift:
    1|       |//
    2|       |//  FileManagerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Jason Jon E. Carreos on 05/02/2018.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |public extension FileManager {
   13|       |
   14|       |    /// SwifterSwift: Read from a JSON file at a given path.
   15|       |    ///
   16|       |    /// - Parameters:
   17|       |    ///   - path: JSON file path.
   18|       |    ///   - options: JSONSerialization reading options.
   19|       |    /// - Returns: Optional dictionary.
   20|       |    /// - Throws: Throws any errors thrown by Data creation or JSON serialization.
   21|       |    public func jsonFromFile(
   22|       |        atPath path: String,
   23|      0|        readingOptions: JSONSerialization.ReadingOptions = .allowFragments) throws -> [String: Any]? {
   24|      0|
   25|      0|        let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)
   26|      0|        let json = try JSONSerialization.jsonObject(with: data, options: readingOptions)
   27|      0|
   28|      0|        return json as? [String: Any]
   29|      0|    }
   30|       |
   31|       |    /// SwifterSwift: Read from a JSON file with a given filename.
   32|       |    ///
   33|       |    /// - Parameters:
   34|       |    ///   - filename: File to read.
   35|       |    ///   - bundleClass: Bundle where the file is associated.
   36|       |    ///   - readingOptions: JSONSerialization reading options.
   37|       |    /// - Returns: Optional dictionary.
   38|       |    /// - Throws: Throws any errors thrown by Data creation or JSON serialization.
   39|       |    public func jsonFromFile(
   40|       |        withFilename filename: String,
   41|       |        at bundleClass: AnyClass? = nil,
   42|      0|        readingOptions: JSONSerialization.ReadingOptions = .allowFragments) throws -> [String: Any]? {
   43|      0|        // https://stackoverflow.com/questions/24410881/reading-in-a-json-file-using-swift
   44|      0|
   45|      0|        // To handle cases that provided filename has an extension
   46|      0|        let name = filename.components(separatedBy: ".")[0]
   47|      0|        let bundle = bundleClass != nil ? Bundle(for: bundleClass!) : Bundle.main
   48|      0|
   49|      0|        if let path = bundle.path(forResource: name, ofType: "json") {
   50|      0|            let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)
   51|      0|            let json = try JSONSerialization.jsonObject(with: data, options: readingOptions)
   52|      0|
   53|      0|            return json as? [String: Any]
   54|      0|        }
   55|      0|
   56|      0|        return nil
   57|      0|    }
   58|       |
   59|       |}
   60|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/LocaleExtensions.swift:
    1|       |//
    2|       |//  LocalExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Basem Emara on 4/19/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension Locale {
   14|       |
   15|       |    /// SwifterSwift: UNIX representation of locale usually used for normalizing.
   16|      0|    public static var posix: Locale {
   17|      0|        return Locale(identifier: "en_US_POSIX")
   18|      0|    }
   19|       |
   20|       |}
   21|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/NSAttributedStringExtensions.swift:
    1|       |//
    2|       |//  NSAttributedStringExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 26/11/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |#if canImport(UIKit)
   13|       |import UIKit
   14|       |#endif
   15|       |
   16|       |#if canImport(Cocoa)
   17|       |import Cocoa
   18|       |#endif
   19|       |
   20|       |// MARK: - Properties
   21|       |public extension NSAttributedString {
   22|       |
   23|       |    #if os(iOS)
   24|       |    /// SwifterSwift: Bolded string.
   25|      0|    public var bolded: NSAttributedString {
   26|      0|        return applying(attributes: [.font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize)])
   27|      0|    }
   28|       |    #endif
   29|       |
   30|       |    /// SwifterSwift: Underlined string.
   31|      0|    public var underlined: NSAttributedString {
   32|      0|        return applying(attributes: [.underlineStyle: NSUnderlineStyle.single.rawValue])
   33|      0|    }
   34|       |
   35|       |    #if os(iOS)
   36|       |    /// SwifterSwift: Italicized string.
   37|      0|    public var italicized: NSAttributedString {
   38|      0|        return applying(attributes: [.font: UIFont.italicSystemFont(ofSize: UIFont.systemFontSize)])
   39|      0|    }
   40|       |    #endif
   41|       |
   42|       |    /// SwifterSwift: Struckthrough string.
   43|      0|    public var struckthrough: NSAttributedString {
   44|      0|        return applying(attributes: [.strikethroughStyle: NSNumber(value: NSUnderlineStyle.single.rawValue as Int)])
   45|      0|    }
   46|       |
   47|       |    /// SwifterSwift: Dictionary of the attributes applied across the whole string
   48|      0|    public var attributes: [NSAttributedString.Key: Any] {
   49|      0|        return attributes(at: 0, effectiveRange: nil)
   50|      0|    }
   51|       |
   52|       |}
   53|       |
   54|       |// MARK: - Methods
   55|       |public extension NSAttributedString {
   56|       |
   57|       |    /// SwifterSwift: Applies given attributes to the new instance of NSAttributedString initialized with self object
   58|       |    ///
   59|       |    /// - Parameter attributes: Dictionary of attributes
   60|       |    /// - Returns: NSAttributedString with applied attributes
   61|       |    fileprivate func applying(attributes: [NSAttributedString.Key: Any]) -> NSAttributedString {
   62|       |        let copy = NSMutableAttributedString(attributedString: self)
   63|       |        let range = (string as NSString).range(of: string)
   64|       |        copy.addAttributes(attributes, range: range)
   65|       |
   66|       |        return copy
   67|       |    }
   68|       |
   69|       |    #if os(macOS)
   70|       |    /// SwifterSwift: Add color to NSAttributedString.
   71|       |    ///
   72|       |    /// - Parameter color: text color.
   73|       |    /// - Returns: a NSAttributedString colored with given color.
   74|       |    public func colored(with color: NSColor) -> NSAttributedString {
   75|       |        return applying(attributes: [.foregroundColor: color])
   76|       |    }
   77|       |    #else
   78|       |    /// SwifterSwift: Add color to NSAttributedString.
   79|       |    ///
   80|       |    /// - Parameter color: text color.
   81|       |    /// - Returns: a NSAttributedString colored with given color.
   82|      0|    public func colored(with color: UIColor) -> NSAttributedString {
   83|      0|        return applying(attributes: [.foregroundColor: color])
   84|      0|    }
   85|       |    #endif
   86|       |
   87|       |    /// SwifterSwift: Apply attributes to substrings matching a regular expression
   88|       |    ///
   89|       |    /// - Parameters:
   90|       |    ///   - attributes: Dictionary of attributes
   91|       |    ///   - pattern: a regular expression to target
   92|       |    /// - Returns: An NSAttributedString with attributes applied to substrings matching the pattern
   93|      0|    public func applying(attributes: [NSAttributedString.Key: Any], toRangesMatching pattern: String) -> NSAttributedString {
   94|      0|        guard let pattern = try? NSRegularExpression(pattern: pattern, options: []) else { return self }
   95|      0|
   96|      0|        let matches = pattern.matches(in: string, options: [], range: NSRange(0..<length))
   97|      0|        let result = NSMutableAttributedString(attributedString: self)
   98|      0|
   99|      0|        for match in matches {
  100|      0|            result.addAttributes(attributes, range: match.range)
  101|      0|        }
  102|      0|
  103|      0|        return result
  104|      0|    }
  105|       |
  106|       |    /// SwifterSwift: Apply attributes to occurrences of a given string
  107|       |    ///
  108|       |    /// - Parameters:
  109|       |    ///   - attributes: Dictionary of attributes
  110|       |    ///   - target: a subsequence string for the attributes to be applied to
  111|       |    /// - Returns: An NSAttributedString with attributes applied on the target string
  112|      0|    public func applying<T: StringProtocol>(attributes: [NSAttributedString.Key: Any], toOccurrencesOf target: T) -> NSAttributedString {
  113|      0|        let pattern = "\\Q\(target)\\E"
  114|      0|
  115|      0|        return applying(attributes: attributes, toRangesMatching: pattern)
  116|      0|    }
  117|       |
  118|       |}
  119|       |
  120|       |// MARK: - Operators
  121|       |public extension NSAttributedString {
  122|       |
  123|       |    /// SwifterSwift: Add a NSAttributedString to another NSAttributedString.
  124|       |    ///
  125|       |    /// - Parameters:
  126|       |    ///   - lhs: NSAttributedString to add to.
  127|       |    ///   - rhs: NSAttributedString to add.
  128|      0|    public static func += (lhs: inout NSAttributedString, rhs: NSAttributedString) {
  129|      0|        let string = NSMutableAttributedString(attributedString: lhs)
  130|      0|        string.append(rhs)
  131|      0|        lhs = string
  132|      0|    }
  133|       |
  134|       |    /// SwifterSwift: Add a NSAttributedString to another NSAttributedString and return a new NSAttributedString instance.
  135|       |    ///
  136|       |    /// - Parameters:
  137|       |    ///   - lhs: NSAttributedString to add.
  138|       |    ///   - rhs: NSAttributedString to add.
  139|       |    /// - Returns: New instance with added NSAttributedString.
  140|      0|    public static func + (lhs: NSAttributedString, rhs: NSAttributedString) -> NSAttributedString {
  141|      0|        let string = NSMutableAttributedString(attributedString: lhs)
  142|      0|        string.append(rhs)
  143|      0|        return NSAttributedString(attributedString: string)
  144|      0|    }
  145|       |
  146|       |    /// SwifterSwift: Add a NSAttributedString to another NSAttributedString.
  147|       |    ///
  148|       |    /// - Parameters:
  149|       |    ///   - lhs: NSAttributedString to add to.
  150|       |    ///   - rhs: String to add.
  151|      0|    public static func += (lhs: inout NSAttributedString, rhs: String) {
  152|      0|        lhs += NSAttributedString(string: rhs)
  153|      0|    }
  154|       |
  155|       |    /// SwifterSwift: Add a NSAttributedString to another NSAttributedString and return a new NSAttributedString instance.
  156|       |    ///
  157|       |    /// - Parameters:
  158|       |    ///   - lhs: NSAttributedString to add.
  159|       |    ///   - rhs: String to add.
  160|       |    /// - Returns: New instance with added NSAttributedString.
  161|      0|    public static func + (lhs: NSAttributedString, rhs: String) -> NSAttributedString {
  162|      0|        return lhs + NSAttributedString(string: rhs)
  163|      0|    }
  164|       |
  165|       |}
  166|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/NSPredicateExtensions.swift:
    1|       |//
    2|       |//  NSPredicateExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Max Härtwig on 04.10.17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension NSPredicate {
   14|       |
   15|       |    /// SwifterSwift: Returns a new predicate formed by NOT-ing the predicate.
   16|      0|    public var not: NSCompoundPredicate {
   17|      0|        return NSCompoundPredicate(notPredicateWithSubpredicate: self)
   18|      0|    }
   19|       |
   20|       |}
   21|       |
   22|       |// MARK: - Methods
   23|       |public extension NSPredicate {
   24|       |
   25|       |    /// SwifterSwift: Returns a new predicate formed by AND-ing the argument to the predicate.
   26|       |    ///
   27|       |    /// - Parameter predicate: NSPredicate
   28|       |    /// - Returns: NSCompoundPredicate
   29|      0|    public func and(_ predicate: NSPredicate) -> NSCompoundPredicate {
   30|      0|        return NSCompoundPredicate(andPredicateWithSubpredicates: [self, predicate])
   31|      0|    }
   32|       |
   33|       |    /// SwifterSwift: Returns a new predicate formed by OR-ing the argument to the predicate.
   34|       |    ///
   35|       |    /// - Parameter predicate: NSPredicate
   36|       |    /// - Returns: NSCompoundPredicate
   37|      0|    public func or(_ predicate: NSPredicate) -> NSCompoundPredicate {
   38|      0|        return NSCompoundPredicate(orPredicateWithSubpredicates: [self, predicate])
   39|      0|    }
   40|       |
   41|       |}
   42|       |
   43|       |// MARK: - Operators
   44|       |public extension NSPredicate {
   45|       |
   46|       |    /// SwifterSwift: Returns a new predicate formed by NOT-ing the predicate.
   47|       |    /// - Parameters: rhs: NSPredicate to convert.
   48|       |    /// - Returns: NSCompoundPredicate
   49|      0|    static public prefix func ! (rhs: NSPredicate) -> NSCompoundPredicate {
   50|      0|        return rhs.not
   51|      0|    }
   52|       |
   53|       |    /// SwifterSwift: Returns a new predicate formed by AND-ing the argument to the predicate.
   54|       |    ///
   55|       |    /// - Parameters:
   56|       |    ///   - lhs: NSPredicate.
   57|       |    ///   - rhs: NSPredicate.
   58|       |    /// - Returns: NSCompoundPredicate
   59|      0|    static public func + (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate {
   60|      0|        return lhs.and(rhs)
   61|      0|    }
   62|       |
   63|       |    /// SwifterSwift: Returns a new predicate formed by OR-ing the argument to the predicate.
   64|       |    ///
   65|       |    /// - Parameters:
   66|       |    ///   - lhs: NSPredicate.
   67|       |    ///   - rhs: NSPredicate.
   68|       |    /// - Returns: NSCompoundPredicate
   69|      0|    static public func | (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate {
   70|      0|        return lhs.or(rhs)
   71|      0|    }
   72|       |
   73|       |    /// SwifterSwift: Returns a new predicate formed by remove the argument to the predicate.
   74|       |    ///
   75|       |    /// - Parameters:
   76|       |    ///   - lhs: NSPredicate.
   77|       |    ///   - rhs: NSPredicate.
   78|       |    /// - Returns: NSCompoundPredicate
   79|      0|    static public func - (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate {
   80|      0|        return lhs + !rhs
   81|      0|    }
   82|       |
   83|       |}
   84|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/URLExtensions.swift:
    1|       |//
    2|       |//  URLExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 03/02/2017.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |#if canImport(UIKit) && canImport(AVFoundation)
   13|       |import UIKit
   14|       |import AVFoundation
   15|       |#endif
   16|       |
   17|       |// MARK: - Properties
   18|       |public extension URL {
   19|       |
   20|       |    /// SwifterSwift: Dictionary of the URL's query parameters
   21|      0|    public var queryParameters: [String: String]? {
   22|      0|        guard let components = URLComponents(url: self, resolvingAgainstBaseURL: false), let queryItems = components.queryItems else { return nil }
   23|      0|
   24|      0|        var items: [String: String] = [:]
   25|      0|
   26|      0|        for queryItem in queryItems {
   27|      0|            items[queryItem.name] = queryItem.value
   28|      0|        }
   29|      0|
   30|      0|        return items
   31|      0|    }
   32|       |
   33|       |}
   34|       |
   35|       |// MARK: - Methods
   36|       |public extension URL {
   37|       |
   38|       |    /// SwifterSwift: URL with appending query parameters.
   39|       |    ///
   40|       |    ///		let url = URL(string: "https://google.com")!
   41|       |    ///		let param = ["q": "Swifter Swift"]
   42|       |    ///		url.appendingQueryParameters(params) -> "https://google.com?q=Swifter%20Swift"
   43|       |    ///
   44|       |    /// - Parameter parameters: parameters dictionary.
   45|       |    /// - Returns: URL with appending given query parameters.
   46|      0|    public func appendingQueryParameters(_ parameters: [String: String]) -> URL {
   47|      0|        var urlComponents = URLComponents(url: self, resolvingAgainstBaseURL: true)!
   48|      0|        var items = urlComponents.queryItems ?? []
   49|      0|        items += parameters.map({ URLQueryItem(name: $0, value: $1) })
   50|      0|        urlComponents.queryItems = items
   51|      0|        return urlComponents.url!
   52|      0|    }
   53|       |
   54|       |    /// SwifterSwift: Append query parameters to URL.
   55|       |    ///
   56|       |    ///		var url = URL(string: "https://google.com")!
   57|       |    ///		let param = ["q": "Swifter Swift"]
   58|       |    ///		url.appendQueryParameters(params)
   59|       |    ///		print(url) // prints "https://google.com?q=Swifter%20Swift"
   60|       |    ///
   61|       |    /// - Parameter parameters: parameters dictionary.
   62|      0|    public mutating func appendQueryParameters(_ parameters: [String: String]) {
   63|      0|        self = appendingQueryParameters(parameters)
   64|      0|    }
   65|       |
   66|       |    /// SwifterSwift: Get value of a query key.
   67|       |    ///
   68|       |    ///    var url = URL(string: "https://google.com?code=12345")!
   69|       |    ///    queryValue(for: "code") -> "12345"
   70|       |    ///
   71|       |    /// - Parameter key: The key of a query value.
   72|      0|    public func queryValue(for key: String) -> String? {
   73|      0|        let stringURL = self.absoluteString
   74|      0|        guard let items = URLComponents(string: stringURL)?.queryItems else { return nil }
   75|      0|        for item in items where item.name == key {
   76|      0|            return item.value
   77|      0|        }
   78|      0|        return nil
   79|      0|    }
   80|       |
   81|       |    /// SwifterSwift: Returns a new URL by removing all the path components.
   82|       |    ///
   83|       |    ///     let url = URL(string: "https://domain.com/path/other")!
   84|       |    ///     print(url.deletingAllPathComponents()) // prints "https://domain.com/"
   85|       |    ///
   86|       |    /// - Returns: URL with all path components removed.
   87|      0|    public func deletingAllPathComponents() -> URL {
   88|      0|        var url: URL = self
   89|      0|        for _ in 0..<pathComponents.count - 1 {
   90|      0|            url.deleteLastPathComponent()
   91|      0|        }
   92|      0|        return url
   93|      0|    }
   94|       |
   95|       |    /// SwifterSwift: Remove all the path components from the URL.
   96|       |    ///
   97|       |    ///        var url = URL(string: "https://domain.com/path/other")!
   98|       |    ///        url.deleteAllPathComponents()
   99|       |    ///        print(url) // prints "https://domain.com/"
  100|      0|    public mutating func deleteAllPathComponents() {
  101|      0|        for _ in 0..<pathComponents.count - 1 {
  102|      0|            deleteLastPathComponent()
  103|      0|        }
  104|      0|    }
  105|       |
  106|       |    /// SwifterSwift: Generates new URL that does not have scheme.
  107|       |    ///
  108|       |    ///        let url = URL(string: "https://domain.com")!
  109|       |    ///        print(url.droppedScheme()) // prints "domain.com"
  110|      0|    public func droppedScheme() -> URL? {
  111|      0|        if let scheme = self.scheme {
  112|      0|            let droppedScheme = String(self.absoluteString.dropFirst(scheme.count + 3))
  113|      0|            return URL(string: droppedScheme)
  114|      0|        }
  115|      0|
  116|      0|        guard host != nil else { return self }
  117|      0|
  118|      0|        let droppedScheme = String(absoluteString.dropFirst(2))
  119|      0|        return URL(string: droppedScheme)
  120|      0|    }
  121|       |
  122|       |}
  123|       |
  124|       |// MARK: - Methods
  125|       |public extension URL {
  126|       |
  127|       |    #if os(iOS) || os(tvOS)
  128|       |    /// Generate a thumbnail image from given url. Returns nil if no thumbnail could be created. This function may take some time to complete. It's recommended to dispatch the call if the thumbnail is not generated from a local resource.
  129|       |    ///
  130|       |    ///     var url = URL(string: "https://video.golem.de/files/1/1/20637/wrkw0718-sd.mp4")!
  131|       |    ///     var thumbnail = url.thumbnail()
  132|       |    ///     thumbnail = url.thumbnail(fromTime: 5)
  133|       |    ///
  134|       |    ///     DisptachQueue.main.async {
  135|       |    ///         someImageView.image = url.thumbnail()
  136|       |    ///     }
  137|       |    ///
  138|       |    /// - Parameter time: Seconds into the video where the image should be generated.
  139|       |    /// - Returns: The UIImage result of the AVAssetImageGenerator
  140|      0|    public func thumbnail(fromTime time: Float64 = 0) -> UIImage? {
  141|      0|        let imageGenerator = AVAssetImageGenerator(asset: AVAsset(url: self))
  142|      0|        let time = CMTimeMakeWithSeconds(time, preferredTimescale: 1)
  143|      0|        var actualTime = CMTimeMake(value: 0, timescale: 0)
  144|      0|
  145|      0|        guard let cgImage = try? imageGenerator.copyCGImage(at: time, actualTime: &actualTime) else {
  146|      0|            return nil
  147|      0|        }
  148|      0|        return UIImage(cgImage: cgImage)
  149|      0|    }
  150|       |    #endif
  151|       |
  152|       |}
  153|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/URLRequestExtensions.swift:
    1|       |//
    2|       |//  URLRequestExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/5/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Initializers
   13|       |public extension URLRequest {
   14|       |
   15|       |    /// SwifterSwift: Create URLRequest from URL string.
   16|       |    ///
   17|       |    /// - Parameter urlString: URL string to initialize URL request from
   18|      0|    public init?(urlString: String) {
   19|      0|        guard let url = URL(string: urlString) else { return nil }
   20|      0|        self.init(url: url)
   21|      0|    }
   22|       |
   23|       |}
   24|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Foundation/UserDefaultsExtensions.swift:
    1|       |//
    2|       |//  UserDefaultsExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/5/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UserDefaults {
   14|       |
   15|       |    /// SwifterSwift: get object from UserDefaults by using subscript
   16|       |    ///
   17|       |    /// - Parameter key: key in the current user's defaults database.
   18|       |    public subscript(key: String) -> Any? {
   19|      0|        get {
   20|      0|            return object(forKey: key)
   21|      0|        }
   22|      0|        set {
   23|      0|            set(newValue, forKey: key)
   24|      0|        }
   25|       |    }
   26|       |
   27|       |    /// SwifterSwift: Float from UserDefaults.
   28|       |    ///
   29|       |    /// - Parameter forKey: key to find float for.
   30|       |    /// - Returns: Float object for key (if exists).
   31|      0|    public func float(forKey key: String) -> Float? {
   32|      0|        return object(forKey: key) as? Float
   33|      0|    }
   34|       |
   35|       |    /// SwifterSwift: Date from UserDefaults.
   36|       |    ///
   37|       |    /// - Parameter forKey: key to find date for.
   38|       |    /// - Returns: Date object for key (if exists).
   39|      0|    public func date(forKey key: String) -> Date? {
   40|      0|        return object(forKey: key) as? Date
   41|      0|    }
   42|       |
   43|       |    /// SwifterSwift: Retrieves a Codable object from UserDefaults.
   44|       |    ///
   45|       |    /// - Parameters:
   46|       |    ///   - type: Class that conforms to the Codable protocol.
   47|       |    ///   - key: Identifier of the object.
   48|       |    ///   - decoder: Custom JSONDecoder instance. Defaults to `JSONDecoder()`.
   49|       |    /// - Returns: Codable object for key (if exists).
   50|      0|    public func object<T: Codable>(_ type: T.Type, with key: String, usingDecoder decoder: JSONDecoder = JSONDecoder()) -> T? {
   51|      0|        guard let data = self.value(forKey: key) as? Data else { return nil }
   52|      0|        return try? decoder.decode(type.self, from: data)
   53|      0|    }
   54|       |
   55|       |    /// SwifterSwift: Allows storing of Codable objects to UserDefaults.
   56|       |    ///
   57|       |    /// - Parameters:
   58|       |    ///   - object: Codable object to store.
   59|       |    ///   - key: Identifier of the object.
   60|       |    ///   - encoder: Custom JSONEncoder instance. Defaults to `JSONEncoder()`.
   61|      0|    public func set<T: Codable>(object: T, forKey key: String, usingEncoder encoder: JSONEncoder = JSONEncoder()) {
   62|      0|        let data = try? encoder.encode(object)
   63|      0|        self.set(data, forKey: key)
   64|      0|    }
   65|       |
   66|       |}
   67|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/MapKit/MKPolylineExtensions.swift:
    1|       |//
    2|       |//  MKPolylineExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Shai Mishali on 3/8/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(MapKit)
   10|       |import MapKit
   11|       |
   12|       |// MARK: - Initializers
   13|       |#if !os(watchOS)
   14|       |@available(tvOS 9.2, *)
   15|       |public extension MKPolyline {
   16|       |
   17|       |    /// SwifterSwift: Create a new MKPolyline from a provided Array of coordinates.
   18|       |    ///
   19|       |    /// - Parameter coordinates: Array of CLLocationCoordinate2D(s).
   20|      0|    public convenience init(coordinates: [CLLocationCoordinate2D]) {
   21|      0|        var refCoordinates = coordinates
   22|      0|        self.init(coordinates: &refCoordinates, count: refCoordinates.count)
   23|      0|    }
   24|       |
   25|       |}
   26|       |#endif
   27|       |
   28|       |#if !os(watchOS)
   29|       |// MARK: - Properties
   30|       |@available(tvOS 9.2, *)
   31|       |public extension MKPolyline {
   32|       |
   33|       |    /// SwifterSwift: Return an Array of coordinates representing the provided polyline.
   34|      0|    public var coordinates: [CLLocationCoordinate2D] {
   35|      0|        var coords = [CLLocationCoordinate2D](repeating: kCLLocationCoordinate2DInvalid, count: pointCount)
   36|      0|        getCoordinates(&coords, range: NSRange(location: 0, length: pointCount))
   37|      0|        return coords
   38|      0|    }
   39|       |
   40|       |}
   41|       |#endif
   42|       |
   43|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/Shared/ColorExtensions.swift:
    1|       |//
    2|       |//  ColorExtensions.swift
    3|       |//  SwifterSwift-iOS
    4|       |//
    5|       |//  Created by Omar Albeik on 9/27/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)
   10|       |import UIKit
   11|       |/// Color
   12|       |public typealias Color = UIColor
   13|       |#endif
   14|       |
   15|       |#if canImport(Cocoa)
   16|       |import Cocoa
   17|       |/// Color
   18|       |public typealias Color = NSColor
   19|       |#endif
   20|       |
   21|       |#if !os(watchOS)
   22|       |import CoreImage
   23|       |#endif
   24|       |
   25|       |#if !os(Linux)
   26|       |// MARK: - Properties
   27|       |public extension Color {
   28|       |
   29|       |    /// SwifterSwift: Random color.
   30|      0|    public static var random: Color {
   31|      0|        let red = Int.random(in: 0...255)
   32|      0|        let green = Int.random(in: 0...255)
   33|      0|        let blue = Int.random(in: 0...255)
   34|      0|        return Color(red: red, green: green, blue: blue)!
   35|      0|    }
   36|       |
   37|       |    // swiftlint:disable next large_tuple
   38|       |    /// SwifterSwift: RGB components for a Color (between 0 and 255).
   39|       |    ///
   40|       |    ///		UIColor.red.rgbComponents.red -> 255
   41|       |    ///		NSColor.green.rgbComponents.green -> 255
   42|       |    ///		UIColor.blue.rgbComponents.blue -> 255
   43|       |    ///
   44|      0|    public var rgbComponents: (red: Int, green: Int, blue: Int) {
   45|      0|        var components: [CGFloat] {
   46|      0|            let comps = cgColor.components!
   47|      0|            if comps.count == 4 { return comps }
   48|      0|            return [comps[0], comps[0], comps[0], comps[1]]
   49|      0|        }
   50|      0|        let red = components[0]
   51|      0|        let green = components[1]
   52|      0|        let blue = components[2]
   53|      0|        return (red: Int(red * 255.0), green: Int(green * 255.0), blue: Int(blue * 255.0))
   54|      0|    }
   55|       |
   56|       |    // swiftlint:disable next large_tuple
   57|       |    /// SwifterSwift: RGB components for a Color represented as CGFloat numbers (between 0 and 1)
   58|       |    ///
   59|       |    ///		UIColor.red.rgbComponents.red -> 1.0
   60|       |    ///		NSColor.green.rgbComponents.green -> 1.0
   61|       |    ///		UIColor.blue.rgbComponents.blue -> 1.0
   62|       |    ///
   63|      0|    public var cgFloatComponents: (red: CGFloat, green: CGFloat, blue: CGFloat) {
   64|      0|        var components: [CGFloat] {
   65|      0|            let comps = cgColor.components!
   66|      0|            if comps.count == 4 { return comps }
   67|      0|            return [comps[0], comps[0], comps[0], comps[1]]
   68|      0|        }
   69|      0|        let red = components[0]
   70|      0|        let green = components[1]
   71|      0|        let blue = components[2]
   72|      0|        return (red: red, green: green, blue: blue)
   73|      0|    }
   74|       |
   75|       |    // swiftlint:disable next large_tuple
   76|       |    /// SwifterSwift: Get components of hue, saturation, and brightness, and alpha (read-only).
   77|      0|    public var hsbaComponents: (hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat) {
   78|      0|        var hue: CGFloat = 0.0
   79|      0|        var saturation: CGFloat = 0.0
   80|      0|        var brightness: CGFloat = 0.0
   81|      0|        var alpha: CGFloat = 0.0
   82|      0|
   83|      0|        getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: &alpha)
   84|      0|        return (hue: hue, saturation: saturation, brightness: brightness, alpha: alpha)
   85|      0|    }
   86|       |
   87|       |    /// SwifterSwift: Hexadecimal value string (read-only).
   88|      0|    public var hexString: String {
   89|      0|        let components: [Int] = {
   90|      0|            let comps = cgColor.components!
   91|      0|            let components = comps.count == 4 ? comps : [comps[0], comps[0], comps[0], comps[1]]
   92|      0|            return components.map { Int($0 * 255.0) }
   93|      0|        }()
   94|      0|        return String(format: "#%02X%02X%02X", components[0], components[1], components[2])
   95|      0|    }
   96|       |
   97|       |    /// SwifterSwift: Short hexadecimal value string (read-only, if applicable).
   98|      0|    public var shortHexString: String? {
   99|      0|        let string = hexString.replacingOccurrences(of: "#", with: "")
  100|      0|        let chrs = Array(string)
  101|      0|        guard chrs[0] == chrs[1], chrs[2] == chrs[3], chrs[4] == chrs[5] else { return nil }
  102|      0|        return "#\(chrs[0])\(chrs[2])\(chrs[4])"
  103|      0|    }
  104|       |
  105|       |    /// SwifterSwift: Short hexadecimal value string, or full hexadecimal string if not possible (read-only).
  106|      0|    public var shortHexOrHexString: String {
  107|      0|        let components: [Int] = {
  108|      0|            let comps = cgColor.components!
  109|      0|            let components = comps.count == 4 ? comps : [comps[0], comps[0], comps[0], comps[1]]
  110|      0|            return components.map { Int($0 * 255.0) }
  111|      0|        }()
  112|      0|        let hexString = String(format: "#%02X%02X%02X", components[0], components[1], components[2])
  113|      0|        let string = hexString.replacingOccurrences(of: "#", with: "")
  114|      0|        let chrs = Array(string)
  115|      0|        guard chrs[0] == chrs[1], chrs[2] == chrs[3], chrs[4] == chrs[5] else { return hexString }
  116|      0|        return "#\(chrs[0])\(chrs[2])\(chrs[4])"
  117|      0|    }
  118|       |
  119|       |    /// SwifterSwift: Alpha of Color (read-only).
  120|      0|    public var alpha: CGFloat {
  121|      0|        return cgColor.alpha
  122|      0|    }
  123|       |
  124|       |    #if !os(watchOS)
  125|       |    /// SwifterSwift: CoreImage.CIColor (read-only)
  126|      0|    public var coreImageColor: CoreImage.CIColor? {
  127|      0|        return CoreImage.CIColor(color: self)
  128|      0|    }
  129|       |    #endif
  130|       |
  131|       |    /// SwifterSwift: Get UInt representation of a Color (read-only).
  132|      0|    public var uInt: UInt {
  133|      0|        let comps: [CGFloat] = {
  134|      0|            let comps = cgColor.components!
  135|      0|            return comps.count == 4 ? comps : [comps[0], comps[0], comps[0], comps[1]]
  136|      0|        }()
  137|      0|
  138|      0|        var colorAsUInt32: UInt32 = 0
  139|      0|        colorAsUInt32 += UInt32(comps[0] * 255.0) << 16
  140|      0|        colorAsUInt32 += UInt32(comps[1] * 255.0) << 8
  141|      0|        colorAsUInt32 += UInt32(comps[2] * 255.0)
  142|      0|
  143|      0|        return UInt(colorAsUInt32)
  144|      0|    }
  145|       |
  146|       |    /// SwifterSwift: Get color complementary (read-only, if applicable).
  147|      0|    public var complementary: Color? {
  148|      0|        let colorSpaceRGB = CGColorSpaceCreateDeviceRGB()
  149|      0|        let convertColorToRGBSpace: ((_ color: Color) -> Color?) = { color -> Color? in
  150|      0|            if self.cgColor.colorSpace!.model == CGColorSpaceModel.monochrome {
  151|      0|                let oldComponents = self.cgColor.components
  152|      0|                let components: [CGFloat] = [ oldComponents![0], oldComponents![0], oldComponents![0], oldComponents![1]]
  153|      0|                let colorRef = CGColor(colorSpace: colorSpaceRGB, components: components)
  154|      0|                let colorOut = Color(cgColor: colorRef!)
  155|      0|                return colorOut
  156|      0|            } else {
  157|      0|                return self
  158|      0|            }
  159|      0|        }
  160|      0|
  161|      0|        let color = convertColorToRGBSpace(self)
  162|      0|        guard let componentColors = color?.cgColor.components else { return nil }
  163|      0|
  164|      0|        let red: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[0]*255), 2.0))/255
  165|      0|        let green: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[1]*255), 2.0))/255
  166|      0|        let blue: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[2]*255), 2.0))/255
  167|      0|
  168|      0|        return Color(red: red, green: green, blue: blue, alpha: 1.0)
  169|      0|    }
  170|       |
  171|       |}
  172|       |
  173|       |// MARK: - Methods
  174|       |public extension Color {
  175|       |
  176|       |    /// SwifterSwift: Blend two Colors
  177|       |    ///
  178|       |    /// - Parameters:
  179|       |    ///   - color1: first color to blend
  180|       |    ///   - intensity1: intensity of first color (default is 0.5)
  181|       |    ///   - color2: second color to blend
  182|       |    ///   - intensity2: intensity of second color (default is 0.5)
  183|       |    /// - Returns: Color created by blending first and seond colors.
  184|      0|    public static func blend(_ color1: Color, intensity1: CGFloat = 0.5, with color2: Color, intensity2: CGFloat = 0.5) -> Color {
  185|      0|        // http://stackoverflow.com/questions/27342715/blend-uicolors-in-swift
  186|      0|
  187|      0|        let total = intensity1 + intensity2
  188|      0|        let level1 = intensity1/total
  189|      0|        let level2 = intensity2/total
  190|      0|
  191|      0|        guard level1 > 0 else { return color2 }
  192|      0|        guard level2 > 0 else { return color1 }
  193|      0|
  194|      0|        let components1: [CGFloat] = {
  195|      0|            let comps = color1.cgColor.components!
  196|      0|            return comps.count == 4 ? comps : [comps[0], comps[0], comps[0], comps[1]]
  197|      0|        }()
  198|      0|
  199|      0|        let components2: [CGFloat] = {
  200|      0|            let comps = color2.cgColor.components!
  201|      0|            return comps.count == 4 ? comps : [comps[0], comps[0], comps[0], comps[1]]
  202|      0|        }()
  203|      0|
  204|      0|        let red1 = components1[0]
  205|      0|        let red2 = components2[0]
  206|      0|
  207|      0|        let green1 = components1[1]
  208|      0|        let green2 = components2[1]
  209|      0|
  210|      0|        let blue1 = components1[2]
  211|      0|        let blue2 = components2[2]
  212|      0|
  213|      0|        let alpha1 = color1.cgColor.alpha
  214|      0|        let alpha2 = color2.cgColor.alpha
  215|      0|
  216|      0|        let red = level1*red1 + level2*red2
  217|      0|        let green = level1*green1 + level2*green2
  218|      0|        let blue = level1*blue1 + level2*blue2
  219|      0|        let alpha = level1*alpha1 + level2*alpha2
  220|      0|
  221|      0|        return Color(red: red, green: green, blue: blue, alpha: alpha)
  222|      0|    }
  223|       |
  224|       |    /// SwifterSwift: Lighten a color
  225|       |    ///
  226|       |    ///     let color = Color(red: r, green: g, blue: b, alpha: a)
  227|       |    ///     let lighterColor: Color = color.lighten(by: 0.2)
  228|       |    ///
  229|       |    /// - Parameter percentage: Percentage by which to lighten the color
  230|       |    /// - Returns: A lightened color
  231|      0|    public func lighten(by percentage: CGFloat = 0.2) -> Color {
  232|      0|        // https://stackoverflow.com/questions/38435308/swift-get-lighter-and-darker-color-variations-for-a-given-uicolor
  233|      0|        var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
  234|      0|        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
  235|      0|        return Color(red: min(red + percentage, 1.0),
  236|      0|                     green: min(green + percentage, 1.0),
  237|      0|                     blue: min(blue + percentage, 1.0),
  238|      0|                     alpha: alpha)
  239|      0|    }
  240|       |
  241|       |    /// SwifterSwift: Darken a color
  242|       |    ///
  243|       |    ///     let color = Color(red: r, green: g, blue: b, alpha: a)
  244|       |    ///     let darkerColor: Color = color.darken(by: 0.2)
  245|       |    ///
  246|       |    /// - Parameter percentage: Percentage by which to darken the color
  247|       |    /// - Returns: A darkened color
  248|      0|    public func darken(by percentage: CGFloat = 0.2) -> Color {
  249|      0|        // https://stackoverflow.com/questions/38435308/swift-get-lighter-and-darker-color-variations-for-a-given-uicolor
  250|      0|        var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
  251|      0|        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
  252|      0|        return Color(red: max(red - percentage, 0),
  253|      0|                     green: max(green - percentage, 0),
  254|      0|                     blue: max(blue - percentage, 0),
  255|      0|                     alpha: alpha)
  256|      0|    }
  257|       |
  258|       |}
  259|       |
  260|       |// MARK: - Initializers
  261|       |public extension Color {
  262|       |
  263|       |    /// SwifterSwift: Create Color from RGB values with optional transparency.
  264|       |    ///
  265|       |    /// - Parameters:
  266|       |    ///   - red: red component.
  267|       |    ///   - green: green component.
  268|       |    ///   - blue: blue component.
  269|       |    ///   - transparency: optional transparency value (default is 1).
  270|      0|    public convenience init?(red: Int, green: Int, blue: Int, transparency: CGFloat = 1) {
  271|      0|        guard red >= 0 && red <= 255 else { return nil }
  272|      0|        guard green >= 0 && green <= 255 else { return nil }
  273|      0|        guard blue >= 0 && blue <= 255 else { return nil }
  274|      0|
  275|      0|        var trans = transparency
  276|      0|        if trans < 0 { trans = 0 }
  277|      0|        if trans > 1 { trans = 1 }
  278|      0|
  279|      0|        self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: trans)
  280|      0|    }
  281|       |
  282|       |    /// SwifterSwift: Create Color from hexadecimal value with optional transparency.
  283|       |    ///
  284|       |    /// - Parameters:
  285|       |    ///   - hex: hex Int (example: 0xDECEB5).
  286|       |    ///   - transparency: optional transparency value (default is 1).
  287|      0|    public convenience init?(hex: Int, transparency: CGFloat = 1) {
  288|      0|        var trans = transparency
  289|      0|        if trans < 0 { trans = 0 }
  290|      0|        if trans > 1 { trans = 1 }
  291|      0|
  292|      0|        let red = (hex >> 16) & 0xff
  293|      0|        let green = (hex >> 8) & 0xff
  294|      0|        let blue = hex & 0xff
  295|      0|        self.init(red: red, green: green, blue: blue, transparency: trans)
  296|      0|    }
  297|       |
  298|       |    /// SwifterSwift: Create Color from hexadecimal string with optional transparency (if applicable).
  299|       |    ///
  300|       |    /// - Parameters:
  301|       |    ///   - hexString: hexadecimal string (examples: EDE7F6, 0xEDE7F6, #EDE7F6, #0ff, 0xF0F, ..).
  302|       |    ///   - transparency: optional transparency value (default is 1).
  303|      0|    public convenience init?(hexString: String, transparency: CGFloat = 1) {
  304|      0|        var string = ""
  305|      0|        if hexString.lowercased().hasPrefix("0x") {
  306|      0|            string =  hexString.replacingOccurrences(of: "0x", with: "")
  307|      0|        } else if hexString.hasPrefix("#") {
  308|      0|            string = hexString.replacingOccurrences(of: "#", with: "")
  309|      0|        } else {
  310|      0|            string = hexString
  311|      0|        }
  312|      0|
  313|      0|        if string.count == 3 { // convert hex to 6 digit format if in short format
  314|      0|            var str = ""
  315|      0|            string.forEach { str.append(String(repeating: String($0), count: 2)) }
  316|      0|            string = str
  317|      0|        }
  318|      0|
  319|      0|        guard let hexValue = Int(string, radix: 16) else { return nil }
  320|      0|
  321|      0|        var trans = transparency
  322|      0|        if trans < 0 { trans = 0 }
  323|      0|        if trans > 1 { trans = 1 }
  324|      0|
  325|      0|        let red = (hexValue >> 16) & 0xff
  326|      0|        let green = (hexValue >> 8) & 0xff
  327|      0|        let blue = hexValue & 0xff
  328|      0|        self.init(red: red, green: green, blue: blue, transparency: trans)
  329|      0|    }
  330|       |
  331|       |    /// SwifterSwift: Create Color from a complementary of a Color (if applicable).
  332|       |    ///
  333|       |    /// - Parameter color: color of which opposite color is desired.
  334|      0|    public convenience init?(complementaryFor color: Color) {
  335|      0|        let colorSpaceRGB = CGColorSpaceCreateDeviceRGB()
  336|      0|        let convertColorToRGBSpace: ((_ color: Color) -> Color?) = { color -> Color? in
  337|      0|            if color.cgColor.colorSpace!.model == CGColorSpaceModel.monochrome {
  338|      0|                let oldComponents = color.cgColor.components
  339|      0|                let components: [CGFloat] = [ oldComponents![0], oldComponents![0], oldComponents![0], oldComponents![1]]
  340|      0|                let colorRef = CGColor(colorSpace: colorSpaceRGB, components: components)
  341|      0|                let colorOut = Color(cgColor: colorRef!)
  342|      0|                return colorOut
  343|      0|            } else {
  344|      0|                return color
  345|      0|            }
  346|      0|        }
  347|      0|
  348|      0|        let color = convertColorToRGBSpace(color)
  349|      0|        guard let componentColors = color?.cgColor.components else { return nil }
  350|      0|
  351|      0|        let red: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[0]*255), 2.0))/255
  352|      0|        let green: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[1]*255), 2.0))/255
  353|      0|        let blue: CGFloat = sqrt(pow(255.0, 2.0) - pow((componentColors[2]*255), 2.0))/255
  354|      0|        self.init(red: red, green: green, blue: blue, alpha: 1.0)
  355|      0|    }
  356|       |
  357|       |}
  358|       |
  359|       |// swiftlint:disable next type_body_length
  360|       |// MARK: - Social
  361|       |public extension Color {
  362|       |
  363|       |    /// SwifterSwift: Brand identity color of popular social media platform.
  364|       |    public struct Social {
  365|       |        // https://www.lockedowndesign.com/social-media-colors/
  366|       |
  367|       |        /// red: 59, green: 89, blue: 152
  368|       |        public static let facebook = Color(red: 59, green: 89, blue: 152)!
  369|       |
  370|       |        /// red: 0, green: 182, blue: 241
  371|       |        public static let twitter = Color(red: 0, green: 182, blue: 241)!
  372|       |
  373|       |        /// red: 223, green: 74, blue: 50
  374|       |        public static let googlePlus = Color(red: 223, green: 74, blue: 50)!
  375|       |
  376|       |        /// red: 0, green: 123, blue: 182
  377|       |        public static let linkedIn = Color(red: 0, green: 123, blue: 182)!
  378|       |
  379|       |        /// red: 69, green: 187, blue: 255
  380|       |        public static let vimeo = Color(red: 69, green: 187, blue: 255)!
  381|       |
  382|       |        /// red: 179, green: 18, blue: 23
  383|       |        public static let youtube = Color(red: 179, green: 18, blue: 23)!
  384|       |
  385|       |        /// red: 195, green: 42, blue: 163
  386|       |        public static let instagram = Color(red: 195, green: 42, blue: 163)!
  387|       |
  388|       |        /// red: 203, green: 32, blue: 39
  389|       |        public static let pinterest = Color(red: 203, green: 32, blue: 39)!
  390|       |
  391|       |        /// red: 244, green: 0, blue: 131
  392|       |        public static let flickr = Color(red: 244, green: 0, blue: 131)!
  393|       |
  394|       |        /// red: 67, green: 2, blue: 151
  395|       |        public static let yahoo = Color(red: 67, green: 2, blue: 151)!
  396|       |
  397|       |        /// red: 67, green: 2, blue: 151
  398|       |        public static let soundCloud = Color(red: 67, green: 2, blue: 151)!
  399|       |
  400|       |        /// red: 44, green: 71, blue: 98
  401|       |        public static let tumblr = Color(red: 44, green: 71, blue: 98)!
  402|       |
  403|       |        /// red: 252, green: 69, blue: 117
  404|       |        public static let foursquare = Color(red: 252, green: 69, blue: 117)!
  405|       |
  406|       |        /// red: 255, green: 176, blue: 0
  407|       |        public static let swarm = Color(red: 255, green: 176, blue: 0)!
  408|       |
  409|       |        /// red: 234, green: 76, blue: 137
  410|       |        public static let dribbble = Color(red: 234, green: 76, blue: 137)!
  411|       |
  412|       |        /// red: 255, green: 87, blue: 0
  413|       |        public static let reddit = Color(red: 255, green: 87, blue: 0)!
  414|       |
  415|       |        /// red: 74, green: 93, blue: 78
  416|       |        public static let devianArt = Color(red: 74, green: 93, blue: 78)!
  417|       |
  418|       |        /// red: 238, green: 64, blue: 86
  419|       |        public static let pocket = Color(red: 238, green: 64, blue: 86)!
  420|       |
  421|       |        /// red: 170, green: 34, blue: 182
  422|       |        public static let quora = Color(red: 170, green: 34, blue: 182)!
  423|       |
  424|       |        /// red: 247, green: 146, blue: 30
  425|       |        public static let slideShare = Color(red: 247, green: 146, blue: 30)!
  426|       |
  427|       |        /// red: 0, green: 153, blue: 229
  428|       |        public static let px500 = Color(red: 0, green: 153, blue: 229)!
  429|       |
  430|       |        /// red: 223, green: 109, blue: 70
  431|       |        public static let listly = Color(red: 223, green: 109, blue: 70)!
  432|       |
  433|       |        /// red: 0, green: 180, blue: 137
  434|       |        public static let vine = Color(red: 0, green: 180, blue: 137)!
  435|       |
  436|       |        /// red: 0, green: 175, blue: 240
  437|       |        public static let skype = Color(red: 0, green: 175, blue: 240)!
  438|       |
  439|       |        /// red: 235, green: 73, blue: 36
  440|       |        public static let stumbleUpon = Color(red: 235, green: 73, blue: 36)!
  441|       |
  442|       |        /// red: 255, green: 252, blue: 0
  443|       |        public static let snapchat = Color(red: 255, green: 252, blue: 0)!
  444|       |    }
  445|       |
  446|       |}
  447|       |
  448|       |// MARK: - Material colors
  449|       |public extension Color {
  450|       |
  451|       |    /// SwifterSwift: Google Material design colors palette.
  452|       |    public struct Material {
  453|       |        // https://material.google.com/style/color.html
  454|       |
  455|       |        /// SwifterSwift: color red500
  456|       |        public static let red					= red500
  457|       |
  458|       |        /// SwifterSwift: hex #FFEBEE
  459|       |        public static let red50					= Color(hex: 0xFFEBEE)!
  460|       |
  461|       |        /// SwifterSwift: hex #FFCDD2
  462|       |        public static let red100				= Color(hex: 0xFFCDD2)!
  463|       |
  464|       |        /// SwifterSwift: hex #EF9A9A
  465|       |        public static let red200				= Color(hex: 0xEF9A9A)!
  466|       |
  467|       |        /// SwifterSwift: hex #E57373
  468|       |        public static let red300				= Color(hex: 0xE57373)!
  469|       |
  470|       |        /// SwifterSwift: hex #EF5350
  471|       |        public static let red400				= Color(hex: 0xEF5350)!
  472|       |
  473|       |        /// SwifterSwift: hex #F44336
  474|       |        public static let red500				= Color(hex: 0xF44336)!
  475|       |
  476|       |        /// SwifterSwift: hex #E53935
  477|       |        public static let red600				= Color(hex: 0xE53935)!
  478|       |
  479|       |        /// SwifterSwift: hex #D32F2F
  480|       |        public static let red700				= Color(hex: 0xD32F2F)!
  481|       |
  482|       |        /// SwifterSwift: hex #C62828
  483|       |        public static let red800				= Color(hex: 0xC62828)!
  484|       |
  485|       |        /// SwifterSwift: hex #B71C1C
  486|       |        public static let red900				= Color(hex: 0xB71C1C)!
  487|       |
  488|       |        /// SwifterSwift: hex #FF8A80
  489|       |        public static let redA100				= Color(hex: 0xFF8A80)!
  490|       |
  491|       |        /// SwifterSwift: hex #FF5252
  492|       |        public static let redA200				= Color(hex: 0xFF5252)!
  493|       |
  494|       |        /// SwifterSwift: hex #FF1744
  495|       |        public static let redA400				= Color(hex: 0xFF1744)!
  496|       |
  497|       |        /// SwifterSwift: hex #D50000
  498|       |        public static let redA700				= Color(hex: 0xD50000)!
  499|       |
  500|       |        /// SwifterSwift: color pink500
  501|       |        public static let pink					= pink500
  502|       |
  503|       |        /// SwifterSwift: hex #FCE4EC
  504|       |        public static let pink50				= Color(hex: 0xFCE4EC)!
  505|       |
  506|       |        /// SwifterSwift: hex #F8BBD0
  507|       |        public static let pink100				= Color(hex: 0xF8BBD0)!
  508|       |
  509|       |        /// SwifterSwift: hex #F48FB1
  510|       |        public static let pink200				= Color(hex: 0xF48FB1)!
  511|       |
  512|       |        /// SwifterSwift: hex #F06292
  513|       |        public static let pink300				= Color(hex: 0xF06292)!
  514|       |
  515|       |        /// SwifterSwift: hex #EC407A
  516|       |        public static let pink400				= Color(hex: 0xEC407A)!
  517|       |
  518|       |        /// SwifterSwift: hex #E91E63
  519|       |        public static let pink500				= Color(hex: 0xE91E63)!
  520|       |
  521|       |        /// SwifterSwift: hex #D81B60
  522|       |        public static let pink600				= Color(hex: 0xD81B60)!
  523|       |
  524|       |        /// SwifterSwift: hex #C2185B
  525|       |        public static let pink700				= Color(hex: 0xC2185B)!
  526|       |
  527|       |        /// SwifterSwift: hex #AD1457
  528|       |        public static let pink800				= Color(hex: 0xAD1457)!
  529|       |
  530|       |        /// SwifterSwift: hex #880E4F
  531|       |        public static let pink900				= Color(hex: 0x880E4F)!
  532|       |
  533|       |        /// SwifterSwift: hex #FF80AB
  534|       |        public static let pinkA100				= Color(hex: 0xFF80AB)!
  535|       |
  536|       |        /// SwifterSwift: hex #FF4081
  537|       |        public static let pinkA200				= Color(hex: 0xFF4081)!
  538|       |
  539|       |        /// SwifterSwift: hex #F50057
  540|       |        public static let pinkA400				= Color(hex: 0xF50057)!
  541|       |
  542|       |        /// SwifterSwift: hex #C51162
  543|       |        public static let pinkA700				= Color(hex: 0xC51162)!
  544|       |
  545|       |        /// SwifterSwift: color purple500
  546|       |        public static let purple				= purple500
  547|       |
  548|       |        /// SwifterSwift: hex #F3E5F5
  549|       |        public static let purple50				= Color(hex: 0xF3E5F5)!
  550|       |
  551|       |        /// SwifterSwift: hex #E1BEE7
  552|       |        public static let purple100				= Color(hex: 0xE1BEE7)!
  553|       |
  554|       |        /// SwifterSwift: hex #CE93D8
  555|       |        public static let purple200				= Color(hex: 0xCE93D8)!
  556|       |
  557|       |        /// SwifterSwift: hex #BA68C8
  558|       |        public static let purple300				= Color(hex: 0xBA68C8)!
  559|       |
  560|       |        /// SwifterSwift: hex #AB47BC
  561|       |        public static let purple400				= Color(hex: 0xAB47BC)!
  562|       |
  563|       |        /// SwifterSwift: hex #9C27B0
  564|       |        public static let purple500				= Color(hex: 0x9C27B0)!
  565|       |
  566|       |        /// SwifterSwift: hex #8E24AA
  567|       |        public static let purple600				= Color(hex: 0x8E24AA)!
  568|       |
  569|       |        /// SwifterSwift: hex #7B1FA2
  570|       |        public static let purple700				= Color(hex: 0x7B1FA2)!
  571|       |
  572|       |        /// SwifterSwift: hex #6A1B9A
  573|       |        public static let purple800				= Color(hex: 0x6A1B9A)!
  574|       |
  575|       |        /// SwifterSwift: hex #4A148C
  576|       |        public static let purple900				= Color(hex: 0x4A148C)!
  577|       |
  578|       |        /// SwifterSwift: hex #EA80FC
  579|       |        public static let purpleA100			= Color(hex: 0xEA80FC)!
  580|       |
  581|       |        /// SwifterSwift: hex #E040FB
  582|       |        public static let purpleA200			= Color(hex: 0xE040FB)!
  583|       |
  584|       |        /// SwifterSwift: hex #D500F9
  585|       |        public static let purpleA400			= Color(hex: 0xD500F9)!
  586|       |
  587|       |        /// SwifterSwift: hex #AA00FF
  588|       |        public static let purpleA700			= Color(hex: 0xAA00FF)!
  589|       |
  590|       |        /// SwifterSwift: color deepPurple500
  591|       |        public static let deepPurple			= deepPurple500
  592|       |
  593|       |        /// SwifterSwift: hex #EDE7F6
  594|       |        public static let deepPurple50			= Color(hex: 0xEDE7F6)!
  595|       |
  596|       |        /// SwifterSwift: hex #D1C4E9
  597|       |        public static let deepPurple100			= Color(hex: 0xD1C4E9)!
  598|       |
  599|       |        /// SwifterSwift: hex #B39DDB
  600|       |        public static let deepPurple200			= Color(hex: 0xB39DDB)!
  601|       |
  602|       |        /// SwifterSwift: hex #9575CD
  603|       |        public static let deepPurple300			= Color(hex: 0x9575CD)!
  604|       |
  605|       |        /// SwifterSwift: hex #7E57C2
  606|       |        public static let deepPurple400			= Color(hex: 0x7E57C2)!
  607|       |
  608|       |        /// SwifterSwift: hex #673AB7
  609|       |        public static let deepPurple500			= Color(hex: 0x673AB7)!
  610|       |
  611|       |        /// SwifterSwift: hex #5E35B1
  612|       |        public static let deepPurple600			= Color(hex: 0x5E35B1)!
  613|       |
  614|       |        /// SwifterSwift: hex #512DA8
  615|       |        public static let deepPurple700			= Color(hex: 0x512DA8)!
  616|       |
  617|       |        /// SwifterSwift: hex #4527A0
  618|       |        public static let deepPurple800			= Color(hex: 0x4527A0)!
  619|       |
  620|       |        /// SwifterSwift: hex #311B92
  621|       |        public static let deepPurple900			= Color(hex: 0x311B92)!
  622|       |
  623|       |        /// SwifterSwift: hex #B388FF
  624|       |        public static let deepPurpleA100		= Color(hex: 0xB388FF)!
  625|       |
  626|       |        /// SwifterSwift: hex #7C4DFF
  627|       |        public static let deepPurpleA200		= Color(hex: 0x7C4DFF)!
  628|       |
  629|       |        /// SwifterSwift: hex #651FFF
  630|       |        public static let deepPurpleA400		= Color(hex: 0x651FFF)!
  631|       |
  632|       |        /// SwifterSwift: hex #6200EA
  633|       |        public static let deepPurpleA700		= Color(hex: 0x6200EA)!
  634|       |
  635|       |        /// SwifterSwift: color indigo500
  636|       |        public static let indigo				= indigo500
  637|       |
  638|       |        /// SwifterSwift: hex #E8EAF6
  639|       |        public static let indigo50				= Color(hex: 0xE8EAF6)!
  640|       |
  641|       |        /// SwifterSwift: hex #C5CAE9
  642|       |        public static let indigo100				= Color(hex: 0xC5CAE9)!
  643|       |
  644|       |        /// SwifterSwift: hex #9FA8DA
  645|       |        public static let indigo200				= Color(hex: 0x9FA8DA)!
  646|       |
  647|       |        /// SwifterSwift: hex #7986CB
  648|       |        public static let indigo300				= Color(hex: 0x7986CB)!
  649|       |
  650|       |        /// SwifterSwift: hex #5C6BC0
  651|       |        public static let indigo400				= Color(hex: 0x5C6BC0)!
  652|       |
  653|       |        /// SwifterSwift: hex #3F51B5
  654|       |        public static let indigo500				= Color(hex: 0x3F51B5)!
  655|       |
  656|       |        /// SwifterSwift: hex #3949AB
  657|       |        public static let indigo600				= Color(hex: 0x3949AB)!
  658|       |
  659|       |        /// SwifterSwift: hex #303F9F
  660|       |        public static let indigo700				= Color(hex: 0x303F9F)!
  661|       |
  662|       |        /// SwifterSwift: hex #283593
  663|       |        public static let indigo800				= Color(hex: 0x283593)!
  664|       |
  665|       |        /// SwifterSwift: hex #1A237E
  666|       |        public static let indigo900				= Color(hex: 0x1A237E)!
  667|       |
  668|       |        /// SwifterSwift: hex #8C9EFF
  669|       |        public static let indigoA100			= Color(hex: 0x8C9EFF)!
  670|       |
  671|       |        /// SwifterSwift: hex #536DFE
  672|       |        public static let indigoA200			= Color(hex: 0x536DFE)!
  673|       |
  674|       |        /// SwifterSwift: hex #3D5AFE
  675|       |        public static let indigoA400			= Color(hex: 0x3D5AFE)!
  676|       |
  677|       |        /// SwifterSwift: hex #304FFE
  678|       |        public static let indigoA700			= Color(hex: 0x304FFE)!
  679|       |
  680|       |        /// SwifterSwift: color blue500
  681|       |        public static let blue					= blue500
  682|       |
  683|       |        /// SwifterSwift: hex #E3F2FD
  684|       |        public static let blue50				= Color(hex: 0xE3F2FD)!
  685|       |
  686|       |        /// SwifterSwift: hex #BBDEFB
  687|       |        public static let blue100				= Color(hex: 0xBBDEFB)!
  688|       |
  689|       |        /// SwifterSwift: hex #90CAF9
  690|       |        public static let blue200				= Color(hex: 0x90CAF9)!
  691|       |
  692|       |        /// SwifterSwift: hex #64B5F6
  693|       |        public static let blue300				= Color(hex: 0x64B5F6)!
  694|       |
  695|       |        /// SwifterSwift: hex #42A5F5
  696|       |        public static let blue400				= Color(hex: 0x42A5F5)!
  697|       |
  698|       |        /// SwifterSwift: hex #2196F3
  699|       |        public static let blue500				= Color(hex: 0x2196F3)!
  700|       |
  701|       |        /// SwifterSwift: hex #1E88E5
  702|       |        public static let blue600				= Color(hex: 0x1E88E5)!
  703|       |
  704|       |        /// SwifterSwift: hex #1976D2
  705|       |        public static let blue700				= Color(hex: 0x1976D2)!
  706|       |
  707|       |        /// SwifterSwift: hex #1565C0
  708|       |        public static let blue800				= Color(hex: 0x1565C0)!
  709|       |
  710|       |        /// SwifterSwift: hex #0D47A1
  711|       |        public static let blue900				= Color(hex: 0x0D47A1)!
  712|       |
  713|       |        /// SwifterSwift: hex #82B1FF
  714|       |        public static let blueA100				= Color(hex: 0x82B1FF)!
  715|       |
  716|       |        /// SwifterSwift: hex #448AFF
  717|       |        public static let blueA200				= Color(hex: 0x448AFF)!
  718|       |
  719|       |        /// SwifterSwift: hex #2979FF
  720|       |        public static let blueA400				= Color(hex: 0x2979FF)!
  721|       |
  722|       |        /// SwifterSwift: hex #2962FF
  723|       |        public static let blueA700				= Color(hex: 0x2962FF)!
  724|       |
  725|       |        /// SwifterSwift: color lightBlue500
  726|       |        public static let lightBlue				= lightBlue500
  727|       |
  728|       |        /// SwifterSwift: hex #E1F5FE
  729|       |        public static let lightBlue50			= Color(hex: 0xE1F5FE)!
  730|       |
  731|       |        /// SwifterSwift: hex #B3E5FC
  732|       |        public static let lightBlue100			= Color(hex: 0xB3E5FC)!
  733|       |
  734|       |        /// SwifterSwift: hex #81D4FA
  735|       |        public static let lightBlue200			= Color(hex: 0x81D4FA)!
  736|       |
  737|       |        /// SwifterSwift: hex #4FC3F7
  738|       |        public static let lightBlue300			= Color(hex: 0x4FC3F7)!
  739|       |
  740|       |        /// SwifterSwift: hex #29B6F6
  741|       |        public static let lightBlue400			= Color(hex: 0x29B6F6)!
  742|       |
  743|       |        /// SwifterSwift: hex #03A9F4
  744|       |        public static let lightBlue500			= Color(hex: 0x03A9F4)!
  745|       |
  746|       |        /// SwifterSwift: hex #039BE5
  747|       |        public static let lightBlue600			= Color(hex: 0x039BE5)!
  748|       |
  749|       |        /// SwifterSwift: hex #0288D1
  750|       |        public static let lightBlue700			= Color(hex: 0x0288D1)!
  751|       |
  752|       |        /// SwifterSwift: hex #0277BD
  753|       |        public static let lightBlue800			= Color(hex: 0x0277BD)!
  754|       |
  755|       |        /// SwifterSwift: hex #01579B
  756|       |        public static let lightBlue900			= Color(hex: 0x01579B)!
  757|       |
  758|       |        /// SwifterSwift: hex #80D8FF
  759|       |        public static let lightBlueA100			= Color(hex: 0x80D8FF)!
  760|       |
  761|       |        /// SwifterSwift: hex #40C4FF
  762|       |        public static let lightBlueA200			= Color(hex: 0x40C4FF)!
  763|       |
  764|       |        /// SwifterSwift: hex #00B0FF
  765|       |        public static let lightBlueA400			= Color(hex: 0x00B0FF)!
  766|       |
  767|       |        /// SwifterSwift: hex #0091EA
  768|       |        public static let lightBlueA700			= Color(hex: 0x0091EA)!
  769|       |
  770|       |        /// SwifterSwift: color cyan500
  771|       |        public static let cyan					= cyan500
  772|       |
  773|       |        /// SwifterSwift: hex #E0F7FA
  774|       |        public static let cyan50				= Color(hex: 0xE0F7FA)!
  775|       |
  776|       |        /// SwifterSwift: hex #B2EBF2
  777|       |        public static let cyan100				= Color(hex: 0xB2EBF2)!
  778|       |
  779|       |        /// SwifterSwift: hex #80DEEA
  780|       |        public static let cyan200				= Color(hex: 0x80DEEA)!
  781|       |
  782|       |        /// SwifterSwift: hex #4DD0E1
  783|       |        public static let cyan300				= Color(hex: 0x4DD0E1)!
  784|       |
  785|       |        /// SwifterSwift: hex #26C6DA
  786|       |        public static let cyan400				= Color(hex: 0x26C6DA)!
  787|       |
  788|       |        /// SwifterSwift: hex #00BCD4
  789|       |        public static let cyan500				= Color(hex: 0x00BCD4)!
  790|       |
  791|       |        /// SwifterSwift: hex #00ACC1
  792|       |        public static let cyan600				= Color(hex: 0x00ACC1)!
  793|       |
  794|       |        /// SwifterSwift: hex #0097A7
  795|       |        public static let cyan700				= Color(hex: 0x0097A7)!
  796|       |
  797|       |        /// SwifterSwift: hex #00838F
  798|       |        public static let cyan800				= Color(hex: 0x00838F)!
  799|       |
  800|       |        /// SwifterSwift: hex #006064
  801|       |        public static let cyan900				= Color(hex: 0x006064)!
  802|       |
  803|       |        /// SwifterSwift: hex #84FFFF
  804|       |        public static let cyanA100				= Color(hex: 0x84FFFF)!
  805|       |
  806|       |        /// SwifterSwift: hex #18FFFF
  807|       |        public static let cyanA200				= Color(hex: 0x18FFFF)!
  808|       |
  809|       |        /// SwifterSwift: hex #00E5FF
  810|       |        public static let cyanA400				= Color(hex: 0x00E5FF)!
  811|       |
  812|       |        /// SwifterSwift: hex #00B8D4
  813|       |        public static let cyanA700				= Color(hex: 0x00B8D4)!
  814|       |
  815|       |        /// SwifterSwift: color teal500
  816|       |        public static let teal					= teal500
  817|       |
  818|       |        /// SwifterSwift: hex #E0F2F1
  819|       |        public static let teal50				= Color(hex: 0xE0F2F1)!
  820|       |
  821|       |        /// SwifterSwift: hex #B2DFDB
  822|       |        public static let teal100				= Color(hex: 0xB2DFDB)!
  823|       |
  824|       |        /// SwifterSwift: hex #80CBC4
  825|       |        public static let teal200				= Color(hex: 0x80CBC4)!
  826|       |
  827|       |        /// SwifterSwift: hex #4DB6AC
  828|       |        public static let teal300				= Color(hex: 0x4DB6AC)!
  829|       |
  830|       |        /// SwifterSwift: hex #26A69A
  831|       |        public static let teal400				= Color(hex: 0x26A69A)!
  832|       |
  833|       |        /// SwifterSwift: hex #009688
  834|       |        public static let teal500				= Color(hex: 0x009688)!
  835|       |
  836|       |        /// SwifterSwift: hex #00897B
  837|       |        public static let teal600				= Color(hex: 0x00897B)!
  838|       |
  839|       |        /// SwifterSwift: hex #00796B
  840|       |        public static let teal700				= Color(hex: 0x00796B)!
  841|       |
  842|       |        /// SwifterSwift: hex #00695C
  843|       |        public static let teal800				= Color(hex: 0x00695C)!
  844|       |
  845|       |        /// SwifterSwift: hex #004D40
  846|       |        public static let teal900				= Color(hex: 0x004D40)!
  847|       |
  848|       |        /// SwifterSwift: hex #A7FFEB
  849|       |        public static let tealA100				= Color(hex: 0xA7FFEB)!
  850|       |
  851|       |        /// SwifterSwift: hex #64FFDA
  852|       |        public static let tealA200				= Color(hex: 0x64FFDA)!
  853|       |
  854|       |        /// SwifterSwift: hex #1DE9B6
  855|       |        public static let tealA400				= Color(hex: 0x1DE9B6)!
  856|       |
  857|       |        /// SwifterSwift: hex #00BFA5
  858|       |        public static let tealA700				= Color(hex: 0x00BFA5)!
  859|       |
  860|       |        /// SwifterSwift: color green500
  861|       |        public static let green					= green500
  862|       |
  863|       |        /// SwifterSwift: hex #E8F5E9
  864|       |        public static let green50				= Color(hex: 0xE8F5E9)!
  865|       |
  866|       |        /// SwifterSwift: hex #C8E6C9
  867|       |        public static let green100				= Color(hex: 0xC8E6C9)!
  868|       |
  869|       |        /// SwifterSwift: hex #A5D6A7
  870|       |        public static let green200				= Color(hex: 0xA5D6A7)!
  871|       |
  872|       |        /// SwifterSwift: hex #81C784
  873|       |        public static let green300				= Color(hex: 0x81C784)!
  874|       |
  875|       |        /// SwifterSwift: hex #66BB6A
  876|       |        public static let green400				= Color(hex: 0x66BB6A)!
  877|       |
  878|       |        /// SwifterSwift: hex #4CAF50
  879|       |        public static let green500				= Color(hex: 0x4CAF50)!
  880|       |
  881|       |        /// SwifterSwift: hex #43A047
  882|       |        public static let green600				= Color(hex: 0x43A047)!
  883|       |
  884|       |        /// SwifterSwift: hex #388E3C
  885|       |        public static let green700				= Color(hex: 0x388E3C)!
  886|       |
  887|       |        /// SwifterSwift: hex #2E7D32
  888|       |        public static let green800				= Color(hex: 0x2E7D32)!
  889|       |
  890|       |        /// SwifterSwift: hex #1B5E20
  891|       |        public static let green900				= Color(hex: 0x1B5E20)!
  892|       |
  893|       |        /// SwifterSwift: hex #B9F6CA
  894|       |        public static let greenA100				= Color(hex: 0xB9F6CA)!
  895|       |
  896|       |        /// SwifterSwift: hex #69F0AE
  897|       |        public static let greenA200				= Color(hex: 0x69F0AE)!
  898|       |
  899|       |        /// SwifterSwift: hex #00E676
  900|       |        public static let greenA400				= Color(hex: 0x00E676)!
  901|       |
  902|       |        /// SwifterSwift: hex #00C853
  903|       |        public static let greenA700				= Color(hex: 0x00C853)!
  904|       |
  905|       |        /// SwifterSwift: color lightGreen500
  906|       |        public static let lightGreen			= lightGreen500
  907|       |
  908|       |        /// SwifterSwift: hex #F1F8E9
  909|       |        public static let lightGreen50			= Color(hex: 0xF1F8E9)!
  910|       |
  911|       |        /// SwifterSwift: hex #DCEDC8
  912|       |        public static let lightGreen100			= Color(hex: 0xDCEDC8)!
  913|       |
  914|       |        /// SwifterSwift: hex #C5E1A5
  915|       |        public static let lightGreen200			= Color(hex: 0xC5E1A5)!
  916|       |
  917|       |        /// SwifterSwift: hex #AED581
  918|       |        public static let lightGreen300			= Color(hex: 0xAED581)!
  919|       |
  920|       |        /// SwifterSwift: hex #9CCC65
  921|       |        public static let lightGreen400			= Color(hex: 0x9CCC65)!
  922|       |
  923|       |        /// SwifterSwift: hex #8BC34A
  924|       |        public static let lightGreen500			= Color(hex: 0x8BC34A)!
  925|       |
  926|       |        /// SwifterSwift: hex #7CB342
  927|       |        public static let lightGreen600			= Color(hex: 0x7CB342)!
  928|       |
  929|       |        /// SwifterSwift: hex #689F38
  930|       |        public static let lightGreen700			= Color(hex: 0x689F38)!
  931|       |
  932|       |        /// SwifterSwift: hex #558B2F
  933|       |        public static let lightGreen800			= Color(hex: 0x558B2F)!
  934|       |
  935|       |        /// SwifterSwift: hex #33691E
  936|       |        public static let lightGreen900			= Color(hex: 0x33691E)!
  937|       |
  938|       |        /// SwifterSwift: hex #CCFF90
  939|       |        public static let lightGreenA100		= Color(hex: 0xCCFF90)!
  940|       |
  941|       |        /// SwifterSwift: hex #B2FF59
  942|       |        public static let lightGreenA200		= Color(hex: 0xB2FF59)!
  943|       |
  944|       |        /// SwifterSwift: hex #76FF03
  945|       |        public static let lightGreenA400		= Color(hex: 0x76FF03)!
  946|       |
  947|       |        /// SwifterSwift: hex #64DD17
  948|       |        public static let lightGreenA700		= Color(hex: 0x64DD17)!
  949|       |
  950|       |        /// SwifterSwift: color lime500
  951|       |        public static let lime					= lime500
  952|       |
  953|       |        /// SwifterSwift: hex #F9FBE7
  954|       |        public static let lime50				= Color(hex: 0xF9FBE7)!
  955|       |
  956|       |        /// SwifterSwift: hex #F0F4C3
  957|       |        public static let lime100				= Color(hex: 0xF0F4C3)!
  958|       |
  959|       |        /// SwifterSwift: hex #E6EE9C
  960|       |        public static let lime200				= Color(hex: 0xE6EE9C)!
  961|       |
  962|       |        /// SwifterSwift: hex #DCE775
  963|       |        public static let lime300				= Color(hex: 0xDCE775)!
  964|       |
  965|       |        /// SwifterSwift: hex #D4E157
  966|       |        public static let lime400				= Color(hex: 0xD4E157)!
  967|       |
  968|       |        /// SwifterSwift: hex #CDDC39
  969|       |        public static let lime500				= Color(hex: 0xCDDC39)!
  970|       |
  971|       |        /// SwifterSwift: hex #C0CA33
  972|       |        public static let lime600				= Color(hex: 0xC0CA33)!
  973|       |
  974|       |        /// SwifterSwift: hex #AFB42B
  975|       |        public static let lime700				= Color(hex: 0xAFB42B)!
  976|       |
  977|       |        /// SwifterSwift: hex #9E9D24
  978|       |        public static let lime800				= Color(hex: 0x9E9D24)!
  979|       |
  980|       |        /// SwifterSwift: hex #827717
  981|       |        public static let lime900				= Color(hex: 0x827717)!
  982|       |
  983|       |        /// SwifterSwift: hex #F4FF81
  984|       |        public static let limeA100				= Color(hex: 0xF4FF81)!
  985|       |
  986|       |        /// SwifterSwift: hex #EEFF41
  987|       |        public static let limeA200				= Color(hex: 0xEEFF41)!
  988|       |
  989|       |        /// SwifterSwift: hex #C6FF00
  990|       |        public static let limeA400				= Color(hex: 0xC6FF00)!
  991|       |
  992|       |        /// SwifterSwift: hex #AEEA00
  993|       |        public static let limeA700				= Color(hex: 0xAEEA00)!
  994|       |
  995|       |        /// SwifterSwift: color yellow500
  996|       |        public static let yellow				= yellow500
  997|       |
  998|       |        /// SwifterSwift: hex #FFFDE7
  999|       |        public static let yellow50				= Color(hex: 0xFFFDE7)!
 1000|       |
 1001|       |        /// SwifterSwift: hex #FFF9C4
 1002|       |        public static let yellow100				= Color(hex: 0xFFF9C4)!
 1003|       |
 1004|       |        /// SwifterSwift: hex #FFF59D
 1005|       |        public static let yellow200				= Color(hex: 0xFFF59D)!
 1006|       |
 1007|       |        /// SwifterSwift: hex #FFF176
 1008|       |        public static let yellow300				= Color(hex: 0xFFF176)!
 1009|       |
 1010|       |        /// SwifterSwift: hex #FFEE58
 1011|       |        public static let yellow400				= Color(hex: 0xFFEE58)!
 1012|       |
 1013|       |        /// SwifterSwift: hex #FFEB3B
 1014|       |        public static let yellow500				= Color(hex: 0xFFEB3B)!
 1015|       |
 1016|       |        /// SwifterSwift: hex #FDD835
 1017|       |        public static let yellow600				= Color(hex: 0xFDD835)!
 1018|       |
 1019|       |        /// SwifterSwift: hex #FBC02D
 1020|       |        public static let yellow700				= Color(hex: 0xFBC02D)!
 1021|       |
 1022|       |        /// SwifterSwift: hex #F9A825
 1023|       |        public static let yellow800				= Color(hex: 0xF9A825)!
 1024|       |
 1025|       |        /// SwifterSwift: hex #F57F17
 1026|       |        public static let yellow900				= Color(hex: 0xF57F17)!
 1027|       |
 1028|       |        /// SwifterSwift: hex #FFFF8D
 1029|       |        public static let yellowA100			= Color(hex: 0xFFFF8D)!
 1030|       |
 1031|       |        /// SwifterSwift: hex #FFFF00
 1032|       |        public static let yellowA200			= Color(hex: 0xFFFF00)!
 1033|       |
 1034|       |        /// SwifterSwift: hex #FFEA00
 1035|       |        public static let yellowA400			= Color(hex: 0xFFEA00)!
 1036|       |
 1037|       |        /// SwifterSwift: hex #FFD600
 1038|       |        public static let yellowA700			= Color(hex: 0xFFD600)!
 1039|       |
 1040|       |        /// SwifterSwift: color amber500
 1041|       |        public static let amber					= amber500
 1042|       |
 1043|       |        /// SwifterSwift: hex #FFF8E1
 1044|       |        public static let amber50				= Color(hex: 0xFFF8E1)!
 1045|       |
 1046|       |        /// SwifterSwift: hex #FFECB3
 1047|       |        public static let amber100				= Color(hex: 0xFFECB3)!
 1048|       |
 1049|       |        /// SwifterSwift: hex #FFE082
 1050|       |        public static let amber200				= Color(hex: 0xFFE082)!
 1051|       |
 1052|       |        /// SwifterSwift: hex #FFD54F
 1053|       |        public static let amber300				= Color(hex: 0xFFD54F)!
 1054|       |
 1055|       |        /// SwifterSwift: hex #FFCA28
 1056|       |        public static let amber400				= Color(hex: 0xFFCA28)!
 1057|       |
 1058|       |        /// SwifterSwift: hex #FFC107
 1059|       |        public static let amber500				= Color(hex: 0xFFC107)!
 1060|       |
 1061|       |        /// SwifterSwift: hex #FFB300
 1062|       |        public static let amber600				= Color(hex: 0xFFB300)!
 1063|       |
 1064|       |        /// SwifterSwift: hex #FFA000
 1065|       |        public static let amber700				= Color(hex: 0xFFA000)!
 1066|       |
 1067|       |        /// SwifterSwift: hex #FF8F00
 1068|       |        public static let amber800				= Color(hex: 0xFF8F00)!
 1069|       |
 1070|       |        /// SwifterSwift: hex #FF6F00
 1071|       |        public static let amber900				= Color(hex: 0xFF6F00)!
 1072|       |
 1073|       |        /// SwifterSwift: hex #FFE57F
 1074|       |        public static let amberA100				= Color(hex: 0xFFE57F)!
 1075|       |
 1076|       |        /// SwifterSwift: hex #FFD740
 1077|       |        public static let amberA200				= Color(hex: 0xFFD740)!
 1078|       |
 1079|       |        /// SwifterSwift: hex #FFC400
 1080|       |        public static let amberA400				= Color(hex: 0xFFC400)!
 1081|       |
 1082|       |        /// SwifterSwift: hex #FFAB00
 1083|       |        public static let amberA700				= Color(hex: 0xFFAB00)!
 1084|       |
 1085|       |        /// SwifterSwift: color orange500
 1086|       |        public static let orange				= orange500
 1087|       |
 1088|       |        /// SwifterSwift: hex #FFF3E0
 1089|       |        public static let orange50				= Color(hex: 0xFFF3E0)!
 1090|       |
 1091|       |        /// SwifterSwift: hex #FFE0B2
 1092|       |        public static let orange100				= Color(hex: 0xFFE0B2)!
 1093|       |
 1094|       |        /// SwifterSwift: hex #FFCC80
 1095|       |        public static let orange200				= Color(hex: 0xFFCC80)!
 1096|       |
 1097|       |        /// SwifterSwift: hex #FFB74D
 1098|       |        public static let orange300				= Color(hex: 0xFFB74D)!
 1099|       |
 1100|       |        /// SwifterSwift: hex #FFA726
 1101|       |        public static let orange400				= Color(hex: 0xFFA726)!
 1102|       |
 1103|       |        /// SwifterSwift: hex #FF9800
 1104|       |        public static let orange500				= Color(hex: 0xFF9800)!
 1105|       |
 1106|       |        /// SwifterSwift: hex #FB8C00
 1107|       |        public static let orange600				= Color(hex: 0xFB8C00)!
 1108|       |
 1109|       |        /// SwifterSwift: hex #F57C00
 1110|       |        public static let orange700				= Color(hex: 0xF57C00)!
 1111|       |
 1112|       |        /// SwifterSwift: hex #EF6C00
 1113|       |        public static let orange800				= Color(hex: 0xEF6C00)!
 1114|       |
 1115|       |        /// SwifterSwift: hex #E65100
 1116|       |        public static let orange900				= Color(hex: 0xE65100)!
 1117|       |
 1118|       |        /// SwifterSwift: hex #FFD180
 1119|       |        public static let orangeA100			= Color(hex: 0xFFD180)!
 1120|       |
 1121|       |        /// SwifterSwift: hex #FFAB40
 1122|       |        public static let orangeA200			= Color(hex: 0xFFAB40)!
 1123|       |
 1124|       |        /// SwifterSwift: hex #FF9100
 1125|       |        public static let orangeA400			= Color(hex: 0xFF9100)!
 1126|       |
 1127|       |        /// SwifterSwift: hex #FF6D00
 1128|       |        public static let orangeA700			= Color(hex: 0xFF6D00)!
 1129|       |
 1130|       |        /// SwifterSwift: color deepOrange500
 1131|       |        public static let deepOrange			= deepOrange500
 1132|       |
 1133|       |        /// SwifterSwift: hex #FBE9E7
 1134|       |        public static let deepOrange50			= Color(hex: 0xFBE9E7)!
 1135|       |
 1136|       |        /// SwifterSwift: hex #FFCCBC
 1137|       |        public static let deepOrange100			= Color(hex: 0xFFCCBC)!
 1138|       |
 1139|       |        /// SwifterSwift: hex #FFAB91
 1140|       |        public static let deepOrange200			= Color(hex: 0xFFAB91)!
 1141|       |
 1142|       |        /// SwifterSwift: hex #FF8A65
 1143|       |        public static let deepOrange300			= Color(hex: 0xFF8A65)!
 1144|       |
 1145|       |        /// SwifterSwift: hex #FF7043
 1146|       |        public static let deepOrange400			= Color(hex: 0xFF7043)!
 1147|       |
 1148|       |        /// SwifterSwift: hex #FF5722
 1149|       |        public static let deepOrange500			= Color(hex: 0xFF5722)!
 1150|       |
 1151|       |        /// SwifterSwift: hex #F4511E
 1152|       |        public static let deepOrange600			= Color(hex: 0xF4511E)!
 1153|       |
 1154|       |        /// SwifterSwift: hex #E64A19
 1155|       |        public static let deepOrange700			= Color(hex: 0xE64A19)!
 1156|       |
 1157|       |        /// SwifterSwift: hex #D84315
 1158|       |        public static let deepOrange800			= Color(hex: 0xD84315)!
 1159|       |
 1160|       |        /// SwifterSwift: hex #BF360C
 1161|       |        public static let deepOrange900			= Color(hex: 0xBF360C)!
 1162|       |
 1163|       |        /// SwifterSwift: hex #FF9E80
 1164|       |        public static let deepOrangeA100		= Color(hex: 0xFF9E80)!
 1165|       |
 1166|       |        /// SwifterSwift: hex #FF6E40
 1167|       |        public static let deepOrangeA200		= Color(hex: 0xFF6E40)!
 1168|       |
 1169|       |        /// SwifterSwift: hex #FF3D00
 1170|       |        public static let deepOrangeA400		= Color(hex: 0xFF3D00)!
 1171|       |
 1172|       |        /// SwifterSwift: hex #DD2C00
 1173|       |        public static let deepOrangeA700		= Color(hex: 0xDD2C00)!
 1174|       |
 1175|       |        /// SwifterSwift: color brown500
 1176|       |        public static let brown					= brown500
 1177|       |
 1178|       |        /// SwifterSwift: hex #EFEBE9
 1179|       |        public static let brown50				= Color(hex: 0xEFEBE9)!
 1180|       |
 1181|       |        /// SwifterSwift: hex #D7CCC8
 1182|       |        public static let brown100				= Color(hex: 0xD7CCC8)!
 1183|       |
 1184|       |        /// SwifterSwift: hex #BCAAA4
 1185|       |        public static let brown200				= Color(hex: 0xBCAAA4)!
 1186|       |
 1187|       |        /// SwifterSwift: hex #A1887F
 1188|       |        public static let brown300				= Color(hex: 0xA1887F)!
 1189|       |
 1190|       |        /// SwifterSwift: hex #8D6E63
 1191|       |        public static let brown400				= Color(hex: 0x8D6E63)!
 1192|       |
 1193|       |        /// SwifterSwift: hex #795548
 1194|       |        public static let brown500				= Color(hex: 0x795548)!
 1195|       |
 1196|       |        /// SwifterSwift: hex #6D4C41
 1197|       |        public static let brown600				= Color(hex: 0x6D4C41)!
 1198|       |
 1199|       |        /// SwifterSwift: hex #5D4037
 1200|       |        public static let brown700				= Color(hex: 0x5D4037)!
 1201|       |
 1202|       |        /// SwifterSwift: hex #4E342E
 1203|       |        public static let brown800				= Color(hex: 0x4E342E)!
 1204|       |
 1205|       |        /// SwifterSwift: hex #3E2723
 1206|       |        public static let brown900				= Color(hex: 0x3E2723)!
 1207|       |
 1208|       |        /// SwifterSwift: color grey500
 1209|       |        public static let grey					= grey500
 1210|       |
 1211|       |        /// SwifterSwift: hex #FAFAFA
 1212|       |        public static let grey50				= Color(hex: 0xFAFAFA)!
 1213|       |
 1214|       |        /// SwifterSwift: hex #F5F5F5
 1215|       |        public static let grey100				= Color(hex: 0xF5F5F5)!
 1216|       |
 1217|       |        /// SwifterSwift: hex #EEEEEE
 1218|       |        public static let grey200				= Color(hex: 0xEEEEEE)!
 1219|       |
 1220|       |        /// SwifterSwift: hex #E0E0E0
 1221|       |        public static let grey300				= Color(hex: 0xE0E0E0)!
 1222|       |
 1223|       |        /// SwifterSwift: hex #BDBDBD
 1224|       |        public static let grey400				= Color(hex: 0xBDBDBD)!
 1225|       |
 1226|       |        /// SwifterSwift: hex #9E9E9E
 1227|       |        public static let grey500				= Color(hex: 0x9E9E9E)!
 1228|       |
 1229|       |        /// SwifterSwift: hex #757575
 1230|       |        public static let grey600				= Color(hex: 0x757575)!
 1231|       |
 1232|       |        /// SwifterSwift: hex #616161
 1233|       |        public static let grey700				= Color(hex: 0x616161)!
 1234|       |
 1235|       |        /// SwifterSwift: hex #424242
 1236|       |        public static let grey800				= Color(hex: 0x424242)!
 1237|       |
 1238|       |        /// SwifterSwift: hex #212121
 1239|       |        public static let grey900				= Color(hex: 0x212121)!
 1240|       |
 1241|       |        /// SwifterSwift: color blueGrey500
 1242|       |        public static let blueGrey				= blueGrey500
 1243|       |
 1244|       |        /// SwifterSwift: hex #ECEFF1
 1245|       |        public static let blueGrey50			= Color(hex: 0xECEFF1)!
 1246|       |
 1247|       |        /// SwifterSwift: hex #CFD8DC
 1248|       |        public static let blueGrey100			= Color(hex: 0xCFD8DC)!
 1249|       |
 1250|       |        /// SwifterSwift: hex #B0BEC5
 1251|       |        public static let blueGrey200			= Color(hex: 0xB0BEC5)!
 1252|       |
 1253|       |        /// SwifterSwift: hex #90A4AE
 1254|       |        public static let blueGrey300			= Color(hex: 0x90A4AE)!
 1255|       |
 1256|       |        /// SwifterSwift: hex #78909C
 1257|       |        public static let blueGrey400			= Color(hex: 0x78909C)!
 1258|       |
 1259|       |        /// SwifterSwift: hex #607D8B
 1260|       |        public static let blueGrey500			= Color(hex: 0x607D8B)!
 1261|       |
 1262|       |        /// SwifterSwift: hex #546E7A
 1263|       |        public static let blueGrey600			= Color(hex: 0x546E7A)!
 1264|       |
 1265|       |        /// SwifterSwift: hex #455A64
 1266|       |        public static let blueGrey700			= Color(hex: 0x455A64)!
 1267|       |
 1268|       |        /// SwifterSwift: hex #37474F
 1269|       |        public static let blueGrey800			= Color(hex: 0x37474F)!
 1270|       |
 1271|       |        /// SwifterSwift: hex #263238
 1272|       |        public static let blueGrey900			= Color(hex: 0x263238)!
 1273|       |
 1274|       |        /// SwifterSwift: hex #000000
 1275|       |        public static let black					= Color(hex: 0x000000)!
 1276|       |
 1277|       |        /// SwifterSwift: hex #FFFFFF
 1278|       |        public static let white					= Color(hex: 0xFFFFFF)!
 1279|       |    }
 1280|       |
 1281|       |}
 1282|       |
 1283|       |// MARK: - CSS colors
 1284|       |public extension Color {
 1285|       |
 1286|       |    /// SwifterSwift: CSS colors.
 1287|       |    public struct CSS {
 1288|       |        // http://www.w3schools.com/colors/colors_names.asp
 1289|       |
 1290|       |        /// SwifterSwift: hex #F0F8FF
 1291|       |        public static let aliceBlue				= Color(hex: 0xF0F8FF)!
 1292|       |
 1293|       |        /// SwifterSwift: hex #FAEBD7
 1294|       |        public static let antiqueWhite			= Color(hex: 0xFAEBD7)!
 1295|       |
 1296|       |        /// SwifterSwift: hex #00FFFF
 1297|       |        public static let aqua					= Color(hex: 0x00FFFF)!
 1298|       |
 1299|       |        /// SwifterSwift: hex #7FFFD4
 1300|       |        public static let aquamarine			= Color(hex: 0x7FFFD4)!
 1301|       |
 1302|       |        /// SwifterSwift: hex #F0FFFF
 1303|       |        public static let azure					= Color(hex: 0xF0FFFF)!
 1304|       |
 1305|       |        /// SwifterSwift: hex #F5F5DC
 1306|       |        public static let beige					= Color(hex: 0xF5F5DC)!
 1307|       |
 1308|       |        /// SwifterSwift: hex #FFE4C4
 1309|       |        public static let bisque				= Color(hex: 0xFFE4C4)!
 1310|       |
 1311|       |        /// SwifterSwift: hex #000000
 1312|       |        public static let black					= Color(hex: 0x000000)!
 1313|       |
 1314|       |        /// SwifterSwift: hex #FFEBCD
 1315|       |        public static let blanchedAlmond		= Color(hex: 0xFFEBCD)!
 1316|       |
 1317|       |        /// SwifterSwift: hex #0000FF
 1318|       |        public static let blue					= Color(hex: 0x0000FF)!
 1319|       |
 1320|       |        /// SwifterSwift: hex #8A2BE2
 1321|       |        public static let blueViolet			= Color(hex: 0x8A2BE2)!
 1322|       |
 1323|       |        /// SwifterSwift: hex #A52A2A
 1324|       |        public static let brown					= Color(hex: 0xA52A2A)!
 1325|       |
 1326|       |        /// SwifterSwift: hex #DEB887
 1327|       |        public static let burlyWood				= Color(hex: 0xDEB887)!
 1328|       |
 1329|       |        /// SwifterSwift: hex #5F9EA0
 1330|       |        public static let cadetBlue				= Color(hex: 0x5F9EA0)!
 1331|       |
 1332|       |        /// SwifterSwift: hex #7FFF00
 1333|       |        public static let chartreuse			= Color(hex: 0x7FFF00)!
 1334|       |
 1335|       |        /// SwifterSwift: hex #D2691E
 1336|       |        public static let chocolate				= Color(hex: 0xD2691E)!
 1337|       |
 1338|       |        /// SwifterSwift: hex #FF7F50
 1339|       |        public static let coral					= Color(hex: 0xFF7F50)!
 1340|       |
 1341|       |        /// SwifterSwift: hex #6495ED
 1342|       |        public static let cornflowerBlue		= Color(hex: 0x6495ED)!
 1343|       |
 1344|       |        /// SwifterSwift: hex #FFF8DC
 1345|       |        public static let cornsilk				= Color(hex: 0xFFF8DC)!
 1346|       |
 1347|       |        /// SwifterSwift: hex #DC143C
 1348|       |        public static let crimson				= Color(hex: 0xDC143C)!
 1349|       |
 1350|       |        /// SwifterSwift: hex #00FFFF
 1351|       |        public static let cyan					= Color(hex: 0x00FFFF)!
 1352|       |
 1353|       |        /// SwifterSwift: hex #00008B
 1354|       |        public static let darkBlue				= Color(hex: 0x00008B)!
 1355|       |
 1356|       |        /// SwifterSwift: hex #008B8B
 1357|       |        public static let darkCyan				= Color(hex: 0x008B8B)!
 1358|       |
 1359|       |        /// SwifterSwift: hex #B8860B
 1360|       |        public static let darkGoldenRod			= Color(hex: 0xB8860B)!
 1361|       |
 1362|       |        /// SwifterSwift: hex #A9A9A9
 1363|       |        public static let darkGray				= Color(hex: 0xA9A9A9)!
 1364|       |
 1365|       |        /// SwifterSwift: hex #A9A9A9
 1366|       |        public static let darkGrey				= Color(hex: 0xA9A9A9)!
 1367|       |
 1368|       |        /// SwifterSwift: hex #006400
 1369|       |        public static let darkGreen				= Color(hex: 0x006400)!
 1370|       |
 1371|       |        /// SwifterSwift: hex #BDB76B
 1372|       |        public static let darkKhaki				= Color(hex: 0xBDB76B)!
 1373|       |
 1374|       |        /// SwifterSwift: hex #8B008B
 1375|       |        public static let darkMagenta			= Color(hex: 0x8B008B)!
 1376|       |
 1377|       |        /// SwifterSwift: hex #556B2F
 1378|       |        public static let darkOliveGreen		= Color(hex: 0x556B2F)!
 1379|       |
 1380|       |        /// SwifterSwift: hex #FF8C00
 1381|       |        public static let darkOrange			= Color(hex: 0xFF8C00)!
 1382|       |
 1383|       |        /// SwifterSwift: hex #9932CC
 1384|       |        public static let darkOrchid			= Color(hex: 0x9932CC)!
 1385|       |
 1386|       |        /// SwifterSwift: hex #8B0000
 1387|       |        public static let darkRed				= Color(hex: 0x8B0000)!
 1388|       |
 1389|       |        /// SwifterSwift: hex #E9967A
 1390|       |        public static let darkSalmon			= Color(hex: 0xE9967A)!
 1391|       |
 1392|       |        /// SwifterSwift: hex #8FBC8F
 1393|       |        public static let darkSeaGreen			= Color(hex: 0x8FBC8F)!
 1394|       |
 1395|       |        /// SwifterSwift: hex #483D8B
 1396|       |        public static let darkSlateBlue			= Color(hex: 0x483D8B)!
 1397|       |
 1398|       |        /// SwifterSwift: hex #2F4F4F
 1399|       |        public static let darkSlateGray			= Color(hex: 0x2F4F4F)!
 1400|       |
 1401|       |        /// SwifterSwift: hex #2F4F4F
 1402|       |        public static let darkSlateGrey			= Color(hex: 0x2F4F4F)!
 1403|       |
 1404|       |        /// SwifterSwift: hex #00CED1
 1405|       |        public static let darkTurquoise			= Color(hex: 0x00CED1)!
 1406|       |
 1407|       |        /// SwifterSwift: hex #9400D3
 1408|       |        public static let darkViolet			= Color(hex: 0x9400D3)!
 1409|       |
 1410|       |        /// SwifterSwift: hex #FF1493
 1411|       |        public static let deepPink				= Color(hex: 0xFF1493)!
 1412|       |
 1413|       |        /// SwifterSwift: hex #00BFFF
 1414|       |        public static let deepSkyBlue			= Color(hex: 0x00BFFF)!
 1415|       |
 1416|       |        /// SwifterSwift: hex #696969
 1417|       |        public static let dimGray				= Color(hex: 0x696969)!
 1418|       |
 1419|       |        /// SwifterSwift: hex #696969
 1420|       |        public static let dimGrey				= Color(hex: 0x696969)!
 1421|       |
 1422|       |        /// SwifterSwift: hex #1E90FF
 1423|       |        public static let dodgerBlue			= Color(hex: 0x1E90FF)!
 1424|       |
 1425|       |        /// SwifterSwift: hex #B22222
 1426|       |        public static let fireBrick				= Color(hex: 0xB22222)!
 1427|       |
 1428|       |        /// SwifterSwift: hex #FFFAF0
 1429|       |        public static let floralWhite			= Color(hex: 0xFFFAF0)!
 1430|       |
 1431|       |        /// SwifterSwift: hex #228B22
 1432|       |        public static let forestGreen			= Color(hex: 0x228B22)!
 1433|       |
 1434|       |        /// SwifterSwift: hex #FF00FF
 1435|       |        public static let fuchsia				= Color(hex: 0xFF00FF)!
 1436|       |
 1437|       |        /// SwifterSwift: hex #DCDCDC
 1438|       |        public static let gainsboro				= Color(hex: 0xDCDCDC)!
 1439|       |
 1440|       |        /// SwifterSwift: hex #F8F8FF
 1441|       |        public static let ghostWhite			= Color(hex: 0xF8F8FF)!
 1442|       |
 1443|       |        /// SwifterSwift: hex #FFD700
 1444|       |        public static let gold					= Color(hex: 0xFFD700)!
 1445|       |
 1446|       |        /// SwifterSwift: hex #DAA520
 1447|       |        public static let goldenRod				= Color(hex: 0xDAA520)!
 1448|       |
 1449|       |        /// SwifterSwift: hex #808080
 1450|       |        public static let gray					= Color(hex: 0x808080)!
 1451|       |
 1452|       |        /// SwifterSwift: hex #808080
 1453|       |        public static let grey					= Color(hex: 0x808080)!
 1454|       |
 1455|       |        /// SwifterSwift: hex #008000
 1456|       |        public static let green					= Color(hex: 0x008000)!
 1457|       |
 1458|       |        /// SwifterSwift: hex #ADFF2F
 1459|       |        public static let greenYellow			= Color(hex: 0xADFF2F)!
 1460|       |
 1461|       |        /// SwifterSwift: hex #F0FFF0
 1462|       |        public static let honeyDew				= Color(hex: 0xF0FFF0)!
 1463|       |
 1464|       |        /// SwifterSwift: hex #FF69B4
 1465|       |        public static let hotPink				= Color(hex: 0xFF69B4)!
 1466|       |
 1467|       |        /// SwifterSwift: hex #CD5C5C
 1468|       |        public static let indianRed				= Color(hex: 0xCD5C5C)!
 1469|       |
 1470|       |        /// SwifterSwift: hex #4B0082
 1471|       |        public static let indigo				= Color(hex: 0x4B0082)!
 1472|       |
 1473|       |        /// SwifterSwift: hex #FFFFF0
 1474|       |        public static let ivory					= Color(hex: 0xFFFFF0)!
 1475|       |
 1476|       |        /// SwifterSwift: hex #F0E68C
 1477|       |        public static let khaki					= Color(hex: 0xF0E68C)!
 1478|       |
 1479|       |        /// SwifterSwift: hex #E6E6FA
 1480|       |        public static let lavender				= Color(hex: 0xE6E6FA)!
 1481|       |
 1482|       |        /// SwifterSwift: hex #FFF0F5
 1483|       |        public static let lavenderBlush			= Color(hex: 0xFFF0F5)!
 1484|       |
 1485|       |        /// SwifterSwift: hex #7CFC00
 1486|       |        public static let lawnGreen				= Color(hex: 0x7CFC00)!
 1487|       |
 1488|       |        /// SwifterSwift: hex #FFFACD
 1489|       |        public static let lemonChiffon			= Color(hex: 0xFFFACD)!
 1490|       |
 1491|       |        /// SwifterSwift: hex #ADD8E6
 1492|       |        public static let lightBlue				= Color(hex: 0xADD8E6)!
 1493|       |
 1494|       |        /// SwifterSwift: hex #F08080
 1495|       |        public static let lightCoral			= Color(hex: 0xF08080)!
 1496|       |
 1497|       |        /// SwifterSwift: hex #E0FFFF
 1498|       |        public static let lightCyan				= Color(hex: 0xE0FFFF)!
 1499|       |
 1500|       |        /// SwifterSwift: hex #FAFAD2
 1501|       |        public static let lightGoldenRodYellow	= Color(hex: 0xFAFAD2)!
 1502|       |
 1503|       |        /// SwifterSwift: hex #D3D3D3
 1504|       |        public static let lightGray				= Color(hex: 0xD3D3D3)!
 1505|       |
 1506|       |        /// SwifterSwift: hex #D3D3D3
 1507|       |        public static let lightGrey				= Color(hex: 0xD3D3D3)!
 1508|       |
 1509|       |        /// SwifterSwift: hex #90EE90
 1510|       |        public static let lightGreen			= Color(hex: 0x90EE90)!
 1511|       |
 1512|       |        /// SwifterSwift: hex #FFB6C1
 1513|       |        public static let lightPink				= Color(hex: 0xFFB6C1)!
 1514|       |
 1515|       |        /// SwifterSwift: hex #FFA07A
 1516|       |        public static let lightSalmon			= Color(hex: 0xFFA07A)!
 1517|       |
 1518|       |        /// SwifterSwift: hex #20B2AA
 1519|       |        public static let lightSeaGreen			= Color(hex: 0x20B2AA)!
 1520|       |
 1521|       |        /// SwifterSwift: hex #87CEFA
 1522|       |        public static let lightSkyBlue			= Color(hex: 0x87CEFA)!
 1523|       |
 1524|       |        /// SwifterSwift: hex #778899
 1525|       |        public static let lightSlateGray		= Color(hex: 0x778899)!
 1526|       |
 1527|       |        /// SwifterSwift: hex #778899
 1528|       |        public static let lightSlateGrey		= Color(hex: 0x778899)!
 1529|       |
 1530|       |        /// SwifterSwift: hex #B0C4DE
 1531|       |        public static let lightSteelBlue		= Color(hex: 0xB0C4DE)!
 1532|       |
 1533|       |        /// SwifterSwift: hex #FFFFE0
 1534|       |        public static let lightYellow			= Color(hex: 0xFFFFE0)!
 1535|       |
 1536|       |        /// SwifterSwift: hex #00FF00
 1537|       |        public static let lime					= Color(hex: 0x00FF00)!
 1538|       |
 1539|       |        /// SwifterSwift: hex #32CD32
 1540|       |        public static let limeGreen				= Color(hex: 0x32CD32)!
 1541|       |
 1542|       |        /// SwifterSwift: hex #FAF0E6
 1543|       |        public static let linen					= Color(hex: 0xFAF0E6)!
 1544|       |
 1545|       |        /// SwifterSwift: hex #FF00FF
 1546|       |        public static let magenta				= Color(hex: 0xFF00FF)!
 1547|       |
 1548|       |        /// SwifterSwift: hex #800000
 1549|       |        public static let maroon				= Color(hex: 0x800000)!
 1550|       |
 1551|       |        /// SwifterSwift: hex #66CDAA
 1552|       |        public static let mediumAquaMarine		= Color(hex: 0x66CDAA)!
 1553|       |
 1554|       |        /// SwifterSwift: hex #0000CD
 1555|       |        public static let mediumBlue			= Color(hex: 0x0000CD)!
 1556|       |
 1557|       |        /// SwifterSwift: hex #BA55D3
 1558|       |        public static let mediumOrchid			= Color(hex: 0xBA55D3)!
 1559|       |
 1560|       |        /// SwifterSwift: hex #9370DB
 1561|       |        public static let mediumPurple			= Color(hex: 0x9370DB)!
 1562|       |
 1563|       |        /// SwifterSwift: hex #3CB371
 1564|       |        public static let mediumSeaGreen		= Color(hex: 0x3CB371)!
 1565|       |
 1566|       |        /// SwifterSwift: hex #7B68EE
 1567|       |        public static let mediumSlateBlue		= Color(hex: 0x7B68EE)!
 1568|       |
 1569|       |        /// SwifterSwift: hex #00FA9A
 1570|       |        public static let mediumSpringGreen		= Color(hex: 0x00FA9A)!
 1571|       |
 1572|       |        /// SwifterSwift: hex #48D1CC
 1573|       |        public static let mediumTurquoise		= Color(hex: 0x48D1CC)!
 1574|       |
 1575|       |        /// SwifterSwift: hex #C71585
 1576|       |        public static let mediumVioletRed		= Color(hex: 0xC71585)!
 1577|       |
 1578|       |        /// SwifterSwift: hex #191970
 1579|       |        public static let midnightBlue			= Color(hex: 0x191970)!
 1580|       |
 1581|       |        /// SwifterSwift: hex #F5FFFA
 1582|       |        public static let mintCream				= Color(hex: 0xF5FFFA)!
 1583|       |
 1584|       |        /// SwifterSwift: hex #FFE4E1
 1585|       |        public static let mistyRose				= Color(hex: 0xFFE4E1)!
 1586|       |
 1587|       |        /// SwifterSwift: hex #FFE4B5
 1588|       |        public static let moccasin				= Color(hex: 0xFFE4B5)!
 1589|       |
 1590|       |        /// SwifterSwift: hex #FFDEAD
 1591|       |        public static let navajoWhite			= Color(hex: 0xFFDEAD)!
 1592|       |
 1593|       |        /// SwifterSwift: hex #000080
 1594|       |        public static let navy					= Color(hex: 0x000080)!
 1595|       |
 1596|       |        /// SwifterSwift: hex #FDF5E6
 1597|       |        public static let oldLace				= Color(hex: 0xFDF5E6)!
 1598|       |
 1599|       |        /// SwifterSwift: hex #808000
 1600|       |        public static let olive					= Color(hex: 0x808000)!
 1601|       |
 1602|       |        /// SwifterSwift: hex #6B8E23
 1603|       |        public static let oliveDrab				= Color(hex: 0x6B8E23)!
 1604|       |
 1605|       |        /// SwifterSwift: hex #FFA500
 1606|       |        public static let orange				= Color(hex: 0xFFA500)!
 1607|       |
 1608|       |        /// SwifterSwift: hex #FF4500
 1609|       |        public static let orangeRed				= Color(hex: 0xFF4500)!
 1610|       |
 1611|       |        /// SwifterSwift: hex #DA70D6
 1612|       |        public static let orchid				= Color(hex: 0xDA70D6)!
 1613|       |
 1614|       |        /// SwifterSwift: hex #EEE8AA
 1615|       |        public static let paleGoldenRod			= Color(hex: 0xEEE8AA)!
 1616|       |
 1617|       |        /// SwifterSwift: hex #98FB98
 1618|       |        public static let paleGreen				= Color(hex: 0x98FB98)!
 1619|       |
 1620|       |        /// SwifterSwift: hex #AFEEEE
 1621|       |        public static let paleTurquoise			= Color(hex: 0xAFEEEE)!
 1622|       |
 1623|       |        /// SwifterSwift: hex #DB7093
 1624|       |        public static let paleVioletRed			= Color(hex: 0xDB7093)!
 1625|       |
 1626|       |        /// SwifterSwift: hex #FFEFD5
 1627|       |        public static let papayaWhip			= Color(hex: 0xFFEFD5)!
 1628|       |
 1629|       |        /// SwifterSwift: hex #FFDAB9
 1630|       |        public static let peachPuff				= Color(hex: 0xFFDAB9)!
 1631|       |
 1632|       |        /// SwifterSwift: hex #CD853F
 1633|       |        public static let peru					= Color(hex: 0xCD853F)!
 1634|       |
 1635|       |        /// SwifterSwift: hex #FFC0CB
 1636|       |        public static let pink					= Color(hex: 0xFFC0CB)!
 1637|       |
 1638|       |        /// SwifterSwift: hex #DDA0DD
 1639|       |        public static let plum					= Color(hex: 0xDDA0DD)!
 1640|       |
 1641|       |        /// SwifterSwift: hex #B0E0E6
 1642|       |        public static let powderBlue			= Color(hex: 0xB0E0E6)!
 1643|       |
 1644|       |        /// SwifterSwift: hex #800080
 1645|       |        public static let purple				= Color(hex: 0x800080)!
 1646|       |
 1647|       |        /// SwifterSwift: hex #663399
 1648|       |        public static let rebeccaPurple			= Color(hex: 0x663399)!
 1649|       |
 1650|       |        /// SwifterSwift: hex #FF0000
 1651|       |        public static let red					= Color(hex: 0xFF0000)!
 1652|       |
 1653|       |        /// SwifterSwift: hex #BC8F8F
 1654|       |        public static let rosyBrown				= Color(hex: 0xBC8F8F)!
 1655|       |
 1656|       |        /// SwifterSwift: hex #4169E1
 1657|       |        public static let royalBlue				= Color(hex: 0x4169E1)!
 1658|       |
 1659|       |        /// SwifterSwift: hex #8B4513
 1660|       |        public static let saddleBrown			= Color(hex: 0x8B4513)!
 1661|       |
 1662|       |        /// SwifterSwift: hex #FA8072
 1663|       |        public static let salmon				= Color(hex: 0xFA8072)!
 1664|       |
 1665|       |        /// SwifterSwift: hex #F4A460
 1666|       |        public static let sandyBrown			= Color(hex: 0xF4A460)!
 1667|       |
 1668|       |        /// SwifterSwift: hex #2E8B57
 1669|       |        public static let seaGreen				= Color(hex: 0x2E8B57)!
 1670|       |
 1671|       |        /// SwifterSwift: hex #FFF5EE
 1672|       |        public static let seaShell				= Color(hex: 0xFFF5EE)!
 1673|       |
 1674|       |        /// SwifterSwift: hex #A0522D
 1675|       |        public static let sienna				= Color(hex: 0xA0522D)!
 1676|       |
 1677|       |        /// SwifterSwift: hex #C0C0C0
 1678|       |        public static let silver				= Color(hex: 0xC0C0C0)!
 1679|       |
 1680|       |        /// SwifterSwift: hex #87CEEB
 1681|       |        public static let skyBlue				= Color(hex: 0x87CEEB)!
 1682|       |
 1683|       |        /// SwifterSwift: hex #6A5ACD
 1684|       |        public static let slateBlue				= Color(hex: 0x6A5ACD)!
 1685|       |
 1686|       |        /// SwifterSwift: hex #708090
 1687|       |        public static let slateGray				= Color(hex: 0x708090)!
 1688|       |
 1689|       |        /// SwifterSwift: hex #708090
 1690|       |        public static let slateGrey				= Color(hex: 0x708090)!
 1691|       |
 1692|       |        /// SwifterSwift: hex #FFFAFA
 1693|       |        public static let snow					= Color(hex: 0xFFFAFA)!
 1694|       |
 1695|       |        /// SwifterSwift: hex #00FF7F
 1696|       |        public static let springGreen			= Color(hex: 0x00FF7F)!
 1697|       |
 1698|       |        /// SwifterSwift: hex #4682B4
 1699|       |        public static let steelBlue				= Color(hex: 0x4682B4)!
 1700|       |
 1701|       |        /// SwifterSwift: hex #D2B48C
 1702|       |        public static let tan					= Color(hex: 0xD2B48C)!
 1703|       |
 1704|       |        /// SwifterSwift: hex #008080
 1705|       |        public static let teal					= Color(hex: 0x008080)!
 1706|       |
 1707|       |        /// SwifterSwift: hex #D8BFD8
 1708|       |        public static let thistle				= Color(hex: 0xD8BFD8)!
 1709|       |
 1710|       |        /// SwifterSwift: hex #FF6347
 1711|       |        public static let tomato				= Color(hex: 0xFF6347)!
 1712|       |
 1713|       |        /// SwifterSwift: hex #40E0D0
 1714|       |        public static let turquoise				= Color(hex: 0x40E0D0)!
 1715|       |
 1716|       |        /// SwifterSwift: hex #EE82EE
 1717|       |        public static let violet				= Color(hex: 0xEE82EE)!
 1718|       |
 1719|       |        /// SwifterSwift: hex #F5DEB3
 1720|       |        public static let wheat					= Color(hex: 0xF5DEB3)!
 1721|       |
 1722|       |        /// SwifterSwift: hex #FFFFFF
 1723|       |        public static let white					= Color(hex: 0xFFFFFF)!
 1724|       |
 1725|       |        /// SwifterSwift: hex #F5F5F5
 1726|       |        public static let whiteSmoke			= Color(hex: 0xF5F5F5)!
 1727|       |
 1728|       |        /// SwifterSwift: hex #FFFF00
 1729|       |        public static let yellow				= Color(hex: 0xFFFF00)!
 1730|       |
 1731|       |        /// SwifterSwift: hex #9ACD32
 1732|       |        public static let yellowGreen			= Color(hex: 0x9ACD32)!
 1733|       |    }
 1734|       |
 1735|       |}
 1736|       |
 1737|       |// MARK: - Flat UI colors
 1738|       |public extension Color {
 1739|       |
 1740|       |    /// SwifterSwift: Flat UI colors
 1741|       |    public struct FlatUI {
 1742|       |        // http://flatuicolors.com.
 1743|       |
 1744|       |        /// SwifterSwift: hex #1ABC9C
 1745|       |        public static let turquoise             = Color(hex: 0x1abc9c)!
 1746|       |
 1747|       |        /// SwifterSwift: hex #16A085
 1748|       |        public static let greenSea              = Color(hex: 0x16a085)!
 1749|       |
 1750|       |        /// SwifterSwift: hex #2ECC71
 1751|       |        public static let emerald               = Color(hex: 0x2ecc71)!
 1752|       |
 1753|       |        /// SwifterSwift: hex #27AE60
 1754|       |        public static let nephritis             = Color(hex: 0x27ae60)!
 1755|       |
 1756|       |        /// SwifterSwift: hex #3498DB
 1757|       |        public static let peterRiver            = Color(hex: 0x3498db)!
 1758|       |
 1759|       |        /// SwifterSwift: hex #2980B9
 1760|       |        public static let belizeHole            = Color(hex: 0x2980b9)!
 1761|       |
 1762|       |        /// SwifterSwift: hex #9B59B6
 1763|       |        public static let amethyst              = Color(hex: 0x9b59b6)!
 1764|       |
 1765|       |        /// SwifterSwift: hex #8E44AD
 1766|       |        public static let wisteria              = Color(hex: 0x8e44ad)!
 1767|       |
 1768|       |        /// SwifterSwift: hex #34495E
 1769|       |        public static let wetAsphalt            = Color(hex: 0x34495e)!
 1770|       |
 1771|       |        /// SwifterSwift: hex #2C3E50
 1772|       |        public static let midnightBlue          = Color(hex: 0x2c3e50)!
 1773|       |
 1774|       |        /// SwifterSwift: hex #F1C40F
 1775|       |        public static let sunFlower             = Color(hex: 0xf1c40f)!
 1776|       |
 1777|       |        /// SwifterSwift: hex #F39C12
 1778|       |        public static let flatOrange            = Color(hex: 0xf39c12)!
 1779|       |
 1780|       |        /// SwifterSwift: hex #E67E22
 1781|       |        public static let carrot                = Color(hex: 0xe67e22)!
 1782|       |
 1783|       |        /// SwifterSwift: hex #D35400
 1784|       |        public static let pumkin                = Color(hex: 0xd35400)!
 1785|       |
 1786|       |        /// SwifterSwift: hex #E74C3C
 1787|       |        public static let alizarin              = Color(hex: 0xe74c3c)!
 1788|       |
 1789|       |        /// SwifterSwift: hex #C0392B
 1790|       |        public static let pomegranate           = Color(hex: 0xc0392b)!
 1791|       |
 1792|       |        /// SwifterSwift: hex #ECF0F1
 1793|       |        public static let clouds                = Color(hex: 0xecf0f1)!
 1794|       |
 1795|       |        /// SwifterSwift: hex #BDC3C7
 1796|       |        public static let silver                = Color(hex: 0xbdc3c7)!
 1797|       |
 1798|       |        /// SwifterSwift: hex #7F8C8D
 1799|       |        public static let asbestos              = Color(hex: 0x7f8c8d)!
 1800|       |
 1801|       |        /// SwifterSwift: hex #95A5A6
 1802|       |        public static let concerte              = Color(hex: 0x95a5a6)!
 1803|       |    }
 1804|       |
 1805|       |}
 1806|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SpriteKit/SKNodeExtensions.swift:
    1|       |//
    2|       |//  SKNodeExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Olivia Brown on 5/28/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(SpriteKit)
   10|       |import SpriteKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension SKNode {
   14|       |
   15|       |    /// SwifterSwift: Return an array of all SKNode descendants
   16|       |    ///
   17|       |    ///         mySKNode.descendants() -> [childNodeOne, childNodeTwo]
   18|       |    ///
   19|      0|    public func descendants() -> [SKNode] {
   20|      0|        return children + children.reduce(into: [SKNode]()) { $0 += $1.descendants() }
   21|      0|    }
   22|       |
   23|       |}
   24|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/ArrayExtensions.swift:
    1|       |//
    2|       |//  ArrayExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/5/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |#if canImport(Foundation)
    9|       |import Foundation
   10|       |#endif
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension Array {
   14|       |
   15|       |    /// SwifterSwift: Insert an element at the beginning of array.
   16|       |    ///
   17|       |    ///        [2, 3, 4, 5].prepend(1) -> [1, 2, 3, 4, 5]
   18|       |    ///        ["e", "l", "l", "o"].prepend("h") -> ["h", "e", "l", "l", "o"]
   19|       |    ///
   20|       |    /// - Parameter newElement: element to insert.
   21|      0|    public mutating func prepend(_ newElement: Element) {
   22|      0|        insert(newElement, at: 0)
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: Safely Swap values at index positions.
   26|       |    ///
   27|       |    ///        [1, 2, 3, 4, 5].safeSwap(from: 3, to: 0) -> [4, 2, 3, 1, 5]
   28|       |    ///        ["h", "e", "l", "l", "o"].safeSwap(from: 1, to: 0) -> ["e", "h", "l", "l", "o"]
   29|       |    ///
   30|       |    /// - Parameters:
   31|       |    ///   - index: index of first element.
   32|       |    ///   - otherIndex: index of other element.
   33|      0|    public mutating func safeSwap(from index: Index, to otherIndex: Index) {
   34|      0|        guard index != otherIndex else { return }
   35|      0|        guard startIndex..<endIndex ~= index else { return }
   36|      0|        guard startIndex..<endIndex ~= otherIndex else { return }
   37|      0|        swapAt(index, otherIndex)
   38|      0|    }
   39|       |
   40|       |    /// SwifterSwift: Keep elements of Array while condition is true.
   41|       |    ///
   42|       |    ///        [0, 2, 4, 7].keep( where: {$0 % 2 == 0}) -> [0, 2, 4]
   43|       |    ///
   44|       |    /// - Parameter condition: condition to evaluate each element against.
   45|       |    /// - Returns: self after applying provided condition.
   46|       |    /// - Throws: provided condition exception.
   47|       |    @discardableResult
   48|      0|    public mutating func keep(while condition: (Element) throws -> Bool) rethrows -> [Element] {
   49|      0|        for (index, element) in lazy.enumerated() where try !condition(element) {
   50|      0|            self = Array(self[startIndex..<index])
   51|      0|            break
   52|      0|        }
   53|      0|        return self
   54|      0|    }
   55|       |
   56|       |    /// SwifterSwift: Take element of Array while condition is true.
   57|       |    ///
   58|       |    ///        [0, 2, 4, 7, 6, 8].take( where: {$0 % 2 == 0}) -> [0, 2, 4]
   59|       |    ///
   60|       |    /// - Parameter condition: condition to evaluate each element against.
   61|       |    /// - Returns: All elements up until condition evaluates to false.
   62|      0|    public func take(while condition: (Element) throws -> Bool) rethrows -> [Element] {
   63|      0|        for (index, element) in lazy.enumerated() where try !condition(element) {
   64|      0|            return Array(self[startIndex..<index])
   65|      0|        }
   66|      0|        return self
   67|      0|    }
   68|       |
   69|       |    /// SwifterSwift: Skip elements of Array while condition is true.
   70|       |    ///
   71|       |    ///        [0, 2, 4, 7, 6, 8].skip( where: {$0 % 2 == 0}) -> [6, 8]
   72|       |    ///
   73|       |    /// - Parameter condition: condition to evaluate each element against.
   74|       |    /// - Returns: All elements after the condition evaluates to false.
   75|      0|    public func skip(while condition: (Element) throws-> Bool) rethrows -> [Element] {
   76|      0|        for (index, element) in lazy.enumerated() where try !condition(element) {
   77|      0|            return Array(self[index..<endIndex])
   78|      0|        }
   79|      0|        return [Element]()
   80|      0|    }
   81|       |
   82|       |    /// SwifterSwift: Separates an array into 2 arrays based on a predicate.
   83|       |    ///
   84|       |    ///     [0, 1, 2, 3, 4, 5].divided { $0 % 2 == 0 } -> ( [0, 2, 4], [1, 3, 5] )
   85|       |    ///
   86|       |    /// - Parameter condition: condition to evaluate each element against.
   87|       |    /// - Returns: Two arrays, the first containing the elements for which the specified condition evaluates to true, the second containing the rest.
   88|      0|    public func divided(by condition: (Element) throws -> Bool) rethrows -> (matching: [Element], nonMatching: [Element]) {
   89|      0|        //Inspired by: http://ruby-doc.org/core-2.5.0/Enumerable.html#method-i-partition
   90|      0|        var matching = [Element]()
   91|      0|        var nonMatching = [Element]()
   92|      0|        for element in self {
   93|      0|            try condition(element) ? matching.append(element) : nonMatching.append(element)
   94|      0|        }
   95|      0|        return (matching, nonMatching)
   96|      0|    }
   97|       |
   98|       |    /// SwifterSwift: Returns a sorted array based on an optional keypath.
   99|       |    ///
  100|       |    /// - Parameter path: Key path to sort. The key path type must be Comparable.
  101|       |    /// - Parameter ascending: If order must be ascending.
  102|       |    /// - Returns: Sorted array based on keyPath.
  103|      0|    public func sorted<T: Comparable>(by path: KeyPath<Element, T?>, ascending: Bool = true) -> [Element] {
  104|      0|        return sorted(by: { (lhs, rhs) -> Bool in
  105|      0|            guard let lhsValue = lhs[keyPath: path], let rhsValue = rhs[keyPath: path] else { return false }
  106|      0|            return ascending ? lhsValue < rhsValue : lhsValue > rhsValue
  107|      0|        })
  108|      0|    }
  109|       |
  110|       |    /// SwifterSwift: Returns a sorted array based on a keypath.
  111|       |    ///
  112|       |    /// - Parameter path: Key path to sort. The key path type must be Comparable.
  113|       |    /// - Parameter ascending: If order must be ascending.
  114|       |    /// - Returns: Sorted array based on keyPath.
  115|      0|    public func sorted<T: Comparable>(by path: KeyPath<Element, T>, ascending: Bool = true) -> [Element] {
  116|      0|        return sorted(by: { (lhs, rhs) -> Bool in
  117|      0|            return ascending ? lhs[keyPath: path] < rhs[keyPath: path] : lhs[keyPath: path] > rhs[keyPath: path]
  118|      0|        })
  119|      0|    }
  120|       |
  121|       |    /// SwifterSwift: Sort the array based on an optional keypath.
  122|       |    ///
  123|       |    /// - Parameters:
  124|       |    ///   - path: Key path to sort, must be Comparable.
  125|       |    ///   - ascending: whether order is ascending or not.
  126|       |    /// - Returns: self after sorting.
  127|       |    @discardableResult
  128|      0|    public mutating func sort<T: Comparable>(by path: KeyPath<Element, T?>, ascending: Bool = true) -> [Element] {
  129|      0|        self = sorted(by: path, ascending: ascending)
  130|      0|        return self
  131|      0|    }
  132|       |
  133|       |    /// SwifterSwift: Sort the array based on a keypath.
  134|       |    ///
  135|       |    /// - Parameters:
  136|       |    ///   - path: Key path to sort, must be Comparable.
  137|       |    ///   - ascending: whether order is ascending or not.
  138|       |    /// - Returns: self after sorting.
  139|       |    @discardableResult
  140|      0|    public mutating func sort<T: Comparable>(by path: KeyPath<Element, T>, ascending: Bool = true) -> [Element] {
  141|      0|        self = sorted(by: path, ascending: ascending)
  142|      0|        return self
  143|      0|    }
  144|       |
  145|       |}
  146|       |
  147|       |// MARK: - Methods (Equatable)
  148|       |public extension Array where Element: Equatable {
  149|       |
  150|       |    /// SwifterSwift: Remove all instances of an item from array.
  151|       |    ///
  152|       |    ///        [1, 2, 2, 3, 4, 5].removeAll(2) -> [1, 3, 4, 5]
  153|       |    ///        ["h", "e", "l", "l", "o"].removeAll("l") -> ["h", "e", "o"]
  154|       |    ///
  155|       |    /// - Parameter item: item to remove.
  156|       |    /// - Returns: self after removing all instances of item.
  157|       |    @discardableResult
  158|      0|    public mutating func removeAll(_ item: Element) -> [Element] {
  159|      0|        removeAll(where: { $0 == item })
  160|      0|        return self
  161|      0|    }
  162|       |
  163|       |    /// SwifterSwift: Remove all instances contained in items parameter from array.
  164|       |    ///
  165|       |    ///        [1, 2, 2, 3, 4, 5].removeAll([2,5]) -> [1, 3, 4]
  166|       |    ///        ["h", "e", "l", "l", "o"].removeAll(["l", "h"]) -> ["e", "o"]
  167|       |    ///
  168|       |    /// - Parameter items: items to remove.
  169|       |    /// - Returns: self after removing all instances of all items in given array.
  170|       |    @discardableResult
  171|      0|    public mutating func removeAll(_ items: [Element]) -> [Element] {
  172|      0|        guard !items.isEmpty else { return self }
  173|      0|        removeAll(where: { items.contains($0) })
  174|      0|        return self
  175|      0|    }
  176|       |
  177|       |    /// SwifterSwift: Remove all duplicate elements from Array.
  178|       |    ///
  179|       |    ///        [1, 2, 2, 3, 4, 5].removeDuplicates() -> [1, 2, 3, 4, 5]
  180|       |    ///        ["h", "e", "l", "l", "o"]. removeDuplicates() -> ["h", "e", "l", "o"]
  181|       |    ///
  182|      0|    public mutating func removeDuplicates() {
  183|      0|        // Thanks to https://github.com/sairamkotha for improving the method
  184|      0|        self = reduce(into: [Element]()) {
  185|      0|            if !$0.contains($1) {
  186|      0|                $0.append($1)
  187|      0|            }
  188|      0|        }
  189|      0|    }
  190|       |
  191|       |    /// SwifterSwift: Return array with all duplicate elements removed.
  192|       |    ///
  193|       |    ///     [1, 1, 2, 2, 3, 3, 3, 4, 5].withoutDuplicates() -> [1, 2, 3, 4, 5])
  194|       |    ///     ["h", "e", "l", "l", "o"].withoutDuplicates() -> ["h", "e", "l", "o"])
  195|       |    ///
  196|       |    /// - Returns: an array of unique elements.
  197|       |    ///
  198|      0|    public func withoutDuplicates() -> [Element] {
  199|      0|        // Thanks to https://github.com/sairamkotha for improving the method
  200|      0|        return reduce(into: [Element]()) {
  201|      0|            if !$0.contains($1) {
  202|      0|                $0.append($1)
  203|      0|            }
  204|      0|        }
  205|      0|    }
  206|       |
  207|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/BoolExtensions.swift:
    1|       |//
    2|       |//  BoolExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 07/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension Bool {
   15|       |
   16|       |    /// SwifterSwift: Return 1 if true, or 0 if false.
   17|       |    ///
   18|       |    ///        false.int -> 0
   19|       |    ///        true.int -> 1
   20|       |    ///
   21|      0|    public var int: Int {
   22|      0|        return self ? 1 : 0
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: Return "true" if true, or "false" if false.
   26|       |    ///
   27|       |    ///        false.string -> "false"
   28|       |    ///        true.string -> "true"
   29|       |    ///
   30|      0|    public var string: String {
   31|      0|        return description
   32|      0|    }
   33|       |
   34|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/CharacterExtensions.swift:
    1|       |//
    2|       |//  CharacterExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/8/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension Character {
   15|       |
   16|       |    /// SwifterSwift: Check if character is emoji.
   17|       |    ///
   18|       |    ///        Character("😀").isEmoji -> true
   19|       |    ///
   20|      0|    public var isEmoji: Bool {
   21|      0|        // http://stackoverflow.com/questions/30757193/find-out-if-character-in-string-is-emoji
   22|      0|        let scalarValue = String(self).unicodeScalars.first!.value
   23|      0|        switch scalarValue {
   24|      0|        case 0x3030, 0x00AE, 0x00A9, // Special Characters
   25|      0|        0x1D000...0x1F77F, // Emoticons
   26|      0|        0x2100...0x27BF, // Misc symbols and Dingbats
   27|      0|        0xFE00...0xFE0F, // Variation Selectors
   28|      0|        0x1F900...0x1F9FF: // Supplemental Symbols and Pictographs
   29|      0|            return true
   30|      0|        default:
   31|      0|            return false
   32|      0|        }
   33|      0|    }
   34|       |
   35|       |    /// SwifterSwift: Check if character is number.
   36|       |    ///
   37|       |    ///        Character("1").isNumber -> true
   38|       |    ///        Character("a").isNumber -> false
   39|       |    ///
   40|      0|    public var isNumber: Bool {
   41|      0|        return Int(String(self)) != nil
   42|      0|    }
   43|       |
   44|       |    /// SwifterSwift: Check if character is a letter.
   45|       |    ///
   46|       |    ///        Character("4").isLetter -> false
   47|       |    ///        Character("a").isLetter -> true
   48|       |    ///
   49|      0|    public var isLetter: Bool {
   50|      0|        return String(self).rangeOfCharacter(from: .letters, options: .numeric, range: nil) != nil
   51|      0|    }
   52|       |
   53|       |    /// SwifterSwift: Check if character is lowercased.
   54|       |    ///
   55|       |    ///        Character("a").isLowercased -> true
   56|       |    ///        Character("A").isLowercased -> false
   57|       |    ///
   58|      0|    public var isLowercased: Bool {
   59|      0|        return String(self) == String(self).lowercased()
   60|      0|    }
   61|       |
   62|       |    /// SwifterSwift: Check if character is uppercased.
   63|       |    ///
   64|       |    ///        Character("a").isUppercased -> false
   65|       |    ///        Character("A").isUppercased -> true
   66|       |    ///
   67|      0|    public var isUppercased: Bool {
   68|      0|        return String(self) == String(self).uppercased()
   69|      0|    }
   70|       |
   71|       |    /// SwifterSwift: Check if character is white space.
   72|       |    ///
   73|       |    ///        Character(" ").isWhiteSpace -> true
   74|       |    ///        Character("A").isWhiteSpace -> false
   75|       |    ///
   76|      0|    public var isWhiteSpace: Bool {
   77|      0|        return String(self) == " "
   78|      0|    }
   79|       |
   80|       |    /// SwifterSwift: Integer from character (if applicable).
   81|       |    ///
   82|       |    ///        Character("1").int -> 1
   83|       |    ///        Character("A").int -> nil
   84|       |    ///
   85|      0|    public var int: Int? {
   86|      0|        return Int(String(self))
   87|      0|    }
   88|       |
   89|       |    /// SwifterSwift: String from character.
   90|       |    ///
   91|       |    ///        Character("a").string -> "a"
   92|       |    ///
   93|      0|    public var string: String {
   94|      0|        return String(self)
   95|      0|    }
   96|       |
   97|       |    /// SwifterSwift: Return the character lowercased.
   98|       |    ///
   99|       |    ///        Character("A").lowercased -> Character("a")
  100|       |    ///
  101|      0|    public var lowercased: Character {
  102|      0|        return String(self).lowercased().first!
  103|      0|    }
  104|       |
  105|       |    /// SwifterSwift: Return the character uppercased.
  106|       |    ///
  107|       |    ///        Character("a").uppercased -> Character("A")
  108|       |    ///
  109|      0|    public var uppercased: Character {
  110|      0|        return String(self).uppercased().first!
  111|      0|    }
  112|       |
  113|       |}
  114|       |
  115|       |// MARK: - Methods
  116|       |public extension Character {
  117|       |
  118|       |    #if canImport(Foundation)
  119|       |    /// SwifterSwift: Random character.
  120|       |    ///
  121|       |    ///    Character.random() -> k
  122|       |    ///
  123|       |    /// - Returns: A random character.
  124|      0|    public static func randomAlphanumeric() -> Character {
  125|      0|        return "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".randomElement()!
  126|      0|    }
  127|       |    #endif
  128|       |
  129|       |}
  130|       |
  131|       |// MARK: - Operators
  132|       |public extension Character {
  133|       |
  134|       |    /// SwifterSwift: Repeat character multiple times.
  135|       |    ///
  136|       |    ///        Character("-") * 10 -> "----------"
  137|       |    ///
  138|       |    /// - Parameters:
  139|       |    ///   - lhs: character to repeat.
  140|       |    ///   - rhs: number of times to repeat character.
  141|       |    /// - Returns: string with character repeated n times.
  142|      0|    public static func * (lhs: Character, rhs: Int) -> String {
  143|      0|        guard rhs > 0 else { return "" }
  144|      0|        return String(repeating: String(lhs), count: rhs)
  145|      0|    }
  146|       |
  147|       |    /// SwifterSwift: Repeat character multiple times.
  148|       |    ///
  149|       |    ///        10 * Character("-") -> "----------"
  150|       |    ///
  151|       |    /// - Parameters:
  152|       |    ///   - lhs: number of times to repeat character.
  153|       |    ///   - rhs: character to repeat.
  154|       |    /// - Returns: string with character repeated n times.
  155|      0|    public static func * (lhs: Int, rhs: Character) -> String {
  156|      0|        guard lhs > 0 else { return "" }
  157|      0|        return String(repeating: String(rhs), count: lhs)
  158|      0|    }
  159|       |
  160|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/CollectionExtensions.swift:
    1|       |//
    2|       |//  CollectionExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Sergey Fedortsov on 19.12.16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Methods
   14|       |public extension Collection {
   15|       |
   16|       |    /// SwifterSwift: Performs `each` closure for each element of collection in parallel.
   17|       |    ///
   18|       |    ///        array.forEachInParallel { item in
   19|       |    ///            print(item)
   20|       |    ///        }
   21|       |    ///
   22|       |    /// - Parameter each: closure to run for each element.
   23|      0|    public func forEachInParallel(_ each: (Self.Element) -> Void) {
   24|      0|        let indicesArray = Array(indices)
   25|      0|
   26|      0|        DispatchQueue.concurrentPerform(iterations: indicesArray.count) { (index) in
   27|      0|            let elementIndex = indicesArray[index]
   28|      0|            each(self[elementIndex])
   29|      0|        }
   30|      0|    }
   31|       |
   32|       |    /// SwifterSwift: Safe protects the array from out of bounds by use of optional.
   33|       |    ///
   34|       |    ///        let arr = [1, 2, 3, 4, 5]
   35|       |    ///        arr[safe: 1] -> 2
   36|       |    ///        arr[safe: 10] -> nil
   37|       |    ///
   38|       |    /// - Parameter index: index of element to access element.
   39|      0|    public subscript(safe index: Index) -> Element? {
   40|      0|        return indices.contains(index) ? self[index] : nil
   41|      0|    }
   42|       |
   43|       |}
   44|       |
   45|       |// MARK: - Methods (Int)
   46|       |public extension Collection where Index == Int {
   47|       |
   48|       |    /// SwifterSwift: Get the first index where condition is met.
   49|       |    ///
   50|       |    ///        [1, 7, 1, 2, 4, 1, 6].firstIndex { $0 % 2 == 0 } -> 3
   51|       |    ///
   52|       |    /// - Parameter condition: condition to evaluate each element against.
   53|       |    /// - Returns: first index where the specified condition evaluates to true. (optional)
   54|      0|    public func firstIndex(where condition: (Element) throws -> Bool) rethrows -> Index? {
   55|      0|        for (index, value) in lazy.enumerated() where try condition(value) {
   56|      0|            return index
   57|      0|        }
   58|      0|        return nil
   59|      0|    }
   60|       |
   61|       |    /// SwifterSwift: Get the last index where condition is met.
   62|       |    ///
   63|       |    ///     [1, 7, 1, 2, 4, 1, 8].lastIndex { $0 % 2 == 0 } -> 6
   64|       |    ///
   65|       |    /// - Parameter condition: condition to evaluate each element against.
   66|       |    /// - Returns: last index where the specified condition evaluates to true. (optional)
   67|      0|    public func lastIndex(where condition: (Element) throws -> Bool) rethrows -> Index? {
   68|      0|        for (index, value) in lazy.enumerated().reversed() where try condition(value) {
   69|      0|            return index
   70|      0|        }
   71|      0|        return nil
   72|      0|    }
   73|       |
   74|       |    /// SwifterSwift: Get all indices where condition is met.
   75|       |    ///
   76|       |    ///     [1, 7, 1, 2, 4, 1, 8].indices(where: { $0 == 1 }) -> [0, 2, 5]
   77|       |    ///
   78|       |    /// - Parameter condition: condition to evaluate each element against.
   79|       |    /// - Returns: all indices where the specified condition evaluates to true. (optional)
   80|      0|    public func indices(where condition: (Element) throws -> Bool) rethrows -> [Index]? {
   81|      0|        var indicies: [Index] = []
   82|      0|        for (index, value) in lazy.enumerated() where try condition(value) {
   83|      0|            indicies.append(index)
   84|      0|        }
   85|      0|        return indicies.isEmpty ? nil : indicies
   86|      0|    }
   87|       |
   88|       |    /// SwifterSwift: Calls the given closure with an array of size of the parameter slice.
   89|       |    ///
   90|       |    ///     [0, 2, 4, 7].forEach(slice: 2) { print($0) } -> //print: [0, 2], [4, 7]
   91|       |    ///     [0, 2, 4, 7, 6].forEach(slice: 2) { print($0) } -> //print: [0, 2], [4, 7], [6]
   92|       |    ///
   93|       |    /// - Parameters:
   94|       |    ///   - slice: size of array in each interation.
   95|       |    ///   - body: a closure that takes an array of slice size as a parameter.
   96|      0|    public func forEach(slice: Int, body: ([Element]) throws -> Void) rethrows {
   97|      0|        guard slice > 0, !isEmpty else { return }
   98|      0|
   99|      0|        var value: Int = 0
  100|      0|        while value < count {
  101|      0|            try body(Array(self[Swift.max(value, startIndex)..<Swift.min(value + slice, endIndex)]))
  102|      0|            value += slice
  103|      0|        }
  104|      0|    }
  105|       |
  106|       |    /// SwifterSwift: Returns an array of slices of length "size" from the array. If array can't be split evenly, the final slice will be the remaining elements.
  107|       |    ///
  108|       |    ///     [0, 2, 4, 7].group(by: 2) -> [[0, 2], [4, 7]]
  109|       |    ///     [0, 2, 4, 7, 6].group(by: 2) -> [[0, 2], [4, 7], [6]]
  110|       |    ///
  111|       |    /// - Parameter size: The size of the slices to be returned.
  112|       |    /// - Returns: grouped self.
  113|      0|    public func group(by size: Int) -> [[Element]]? {
  114|      0|        //Inspired by: https://lodash.com/docs/4.17.4#chunk
  115|      0|        guard size > 0, !isEmpty else { return nil }
  116|      0|        var value: Int = 0
  117|      0|        var slices: [[Element]] = []
  118|      0|        while value < count {
  119|      0|            slices.append(Array(self[Swift.max(value, startIndex)..<Swift.min(value + size, endIndex)]))
  120|      0|            value += size
  121|      0|        }
  122|      0|        return slices
  123|      0|    }
  124|       |
  125|       |}
  126|       |
  127|       |public extension Collection where Element: Equatable, Index == Int {
  128|       |
  129|       |    /// SwifterSwift: First index of a given item in an array.
  130|       |    ///
  131|       |    ///        [1, 2, 2, 3, 4, 2, 5].firstIndex(of: 2) -> 1
  132|       |    ///        [1.2, 2.3, 4.5, 3.4, 4.5].firstIndex(of: 6.5) -> nil
  133|       |    ///        ["h", "e", "l", "l", "o"].firstIndex(of: "l") -> 2
  134|       |    ///
  135|       |    /// - Parameter item: item to check.
  136|       |    /// - Returns: first index of item in array (if exists).
  137|      0|    public func firstIndex(of item: Element) -> Index? {
  138|      0|        for (index, value) in lazy.enumerated() where value == item {
  139|      0|            return index
  140|      0|        }
  141|      0|        return nil
  142|      0|    }
  143|       |
  144|       |    /// SwifterSwift: Last index of element in array.
  145|       |    ///
  146|       |    ///        [1, 2, 2, 3, 4, 2, 5].lastIndex(of: 2) -> 5
  147|       |    ///        [1.2, 2.3, 4.5, 3.4, 4.5].lastIndex(of: 6.5) -> nil
  148|       |    ///        ["h", "e", "l", "l", "o"].lastIndex(of: "l") -> 3
  149|       |    ///
  150|       |    /// - Parameter item: item to check.
  151|       |    /// - Returns: last index of item in array (if exists).
  152|      0|    public func lastIndex(of item: Element) -> Index? {
  153|      0|        for (index, value) in lazy.enumerated().reversed() where value == item {
  154|      0|            return index
  155|      0|        }
  156|      0|        return nil
  157|      0|    }
  158|       |
  159|       |}
  160|       |
  161|       |// MARK: - Methods (Integer)
  162|       |public extension Collection where Element == IntegerLiteralType, Index == Int {
  163|       |
  164|       |    /// SwifterSwift: Average of all elements in array.
  165|       |    ///
  166|       |    /// - Returns: the average of the array's elements.
  167|      0|    public func average() -> Double {
  168|      0|        // http://stackoverflow.com/questions/28288148/making-my-function-calculate-average-of-array-swift
  169|      0|        return isEmpty ? 0 : Double(reduce(0, +)) / Double(count)
  170|      0|    }
  171|       |
  172|       |}
  173|       |
  174|       |// MARK: - Methods (FloatingPoint)
  175|       |public extension Collection where Element: FloatingPoint {
  176|       |
  177|       |    /// SwifterSwift: Average of all elements in array.
  178|       |    ///
  179|       |    ///        [1.2, 2.3, 4.5, 3.4, 4.5].average() = 3.18
  180|       |    ///
  181|       |    /// - Returns: average of the array's elements.
  182|      0|    public func average() -> Element {
  183|      0|        guard !isEmpty else { return 0 }
  184|      0|        return reduce(0, {$0 + $1}) / Element(count)
  185|      0|    }
  186|       |
  187|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/ComparableExtensions.swift:
    1|       |//
    2|       |//  ComparableExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Shai Mishali on 5/4/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |// MARK: - Methods
   10|       |public extension Comparable {
   11|       |
   12|       |    /// SwifterSwift: Returns true if value is in the provided range.
   13|       |    ///
   14|       |    ///    1.isBetween(5...7) // false
   15|       |    ///    7.isBetween(6...12) // true
   16|       |    ///    date.isBetween(date1...date2)
   17|       |    ///    "c".isBetween(a...d) // true
   18|       |    ///    0.32.isBetween(0.31...0.33) // true
   19|       |    ///
   20|       |    /// - parameter min: Minimum comparable value.
   21|       |    /// - parameter max: Maximum comparable value.
   22|       |    ///
   23|       |    /// - returns: `true` if value is between `min` and `max`, `false` otherwise.
   24|      0|    public func isBetween(_ range: ClosedRange<Self>) -> Bool {
   25|      0|        return range ~= self
   26|      0|    }
   27|       |
   28|       |    /// SwifterSwift: Returns value limited within the provided range.
   29|       |    ///
   30|       |    ///     1.clamped(to: 3...8) // 3
   31|       |    ///     4.clamped(to: 3...7) // 4
   32|       |    ///     "c".clamped(to: "e"..."g") // "e"
   33|       |    ///     0.32.clamped(to: 0.1...0.29) // 0.29
   34|       |    ///
   35|       |    /// - parameter min: Lower bound to limit the value to.
   36|       |    /// - parameter max: Upper bound to limit the value to.
   37|       |    ///
   38|       |    /// - returns: A value limited to the range between `min` and `max`.
   39|      0|    public func clamped(to range: ClosedRange<Self>) -> Self {
   40|      0|        return max(range.lowerBound, min(self, range.upperBound))
   41|      0|    }
   42|       |
   43|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/Deprecated/SwiftStdlibDeprecated.swift:
    1|       |//
    2|       |//  SwiftStdlibDeprecated.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Copyright © 2016 SwifterSwift
    6|       |//
    7|       |
    8|       |extension Bool {
    9|       |    #if canImport(Foundation)
   10|       |    /// SwifterSwift: Returns a random boolean value.
   11|       |    ///
   12|       |    ///     Bool.random -> true
   13|       |    ///     Bool.random -> false
   14|       |    ///
   15|       |    @available(*, deprecated: 4.5.0, message: "Use random() instead")
   16|      0|    public static var random: Bool {
   17|      0|        return arc4random_uniform(2) == 1
   18|      0|    }
   19|       |    #endif
   20|       |}
   21|       |
   22|       |extension String {
   23|       |
   24|       |    #if canImport(Foundation)
   25|       |    /// SwifterSwift: Check if string is valid email format.
   26|       |    /// **Note that this property does not validate the email address against an email server. It merely attempts to determine whether its format is suitable for an email address.**.
   27|       |    ///
   28|       |    ///		"john@doe.com".isEmail -> true
   29|       |    ///
   30|       |    @available(*, deprecated: 4.5.0, message: "Use isValidEmail instead", renamed: "isValidEmail")
   31|      0|    public var isEmail: Bool {
   32|      0|        // http://emailregex.com/
   33|      0|        let regex = "^(?:[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[\\p{L}0-9](?:[a-z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$"
   34|      0|        return range(of: regex, options: .regularExpression, range: nil, locale: nil) != nil
   35|      0|    }
   36|       |    #endif
   37|       |
   38|       |}
   39|       |
   40|       |public extension Array {
   41|       |
   42|       |    /// SwifterSwift: Element at the given index if it exists.
   43|       |    ///
   44|       |    ///		[1, 2, 3, 4, 5].item(at: 2) -> 3
   45|       |    ///		[1.2, 2.3, 4.5, 3.4, 4.5].item(at: 3) -> 3.4
   46|       |    ///		["h", "e", "l", "l", "o"].item(at: 10) -> nil
   47|       |    ///
   48|       |    /// - Parameter index: index of element.
   49|       |    /// - Returns: optional element (if exists).
   50|       |    @available(*, deprecated: 4.3, message: "Use subscript(safe:) instead", renamed: "subscript(safe:)")
   51|      0|    public func item(at index: Int) -> Element? {
   52|      0|        guard startIndex..<endIndex ~= index else { return nil }
   53|      0|        return self[index]
   54|      0|    }
   55|       |
   56|       |    /// SwifterSwift: Group the elements of the array in a dictionary.
   57|       |    ///
   58|       |    ///     [0, 2, 5, 4, 7].groupByKey { $0%2 ? "evens" : "odds" } -> [ "evens" : [0, 2, 4], "odds" : [5, 7] ]
   59|       |    ///
   60|       |    /// - Parameter getKey: Clousure to define the key for each element.
   61|       |    /// - Returns: A dictionary with values grouped with keys.
   62|       |    @available(*, deprecated: 4.3, message: "Use 'Dictionary.init(grouping:by:)' instead.")
   63|      0|    public func groupByKey<K: Hashable>(keyForValue: (_ element: Element) throws -> K) rethrows -> [K: [Element]] {
   64|      0|        var group = [K: [Element]]()
   65|      0|        for value in self {
   66|      0|            let key = try keyForValue(value)
   67|      0|            group[key] = (group[key] ?? []) + [value]
   68|      0|        }
   69|      0|        return group
   70|      0|    }
   71|       |}
   72|       |
   73|       |public extension Array where Element: Equatable {
   74|       |
   75|       |    /// SwifterSwift: Return array with all duplicate elements removed.
   76|       |    ///
   77|       |    ///     [1, 1, 2, 2, 3, 3, 3, 4, 5].duplicatesRemoved() -> [1, 2, 3, 4, 5])
   78|       |    ///     ["h", "e", "l", "l", "o"].duplicatesRemoved() -> ["h", "e", "l", "o"])
   79|       |    ///
   80|       |    /// - Returns: an array of unique elements.
   81|       |    ///
   82|       |    @available(*, deprecated: 4.3, message: "Use withoutDuplicates() instead", renamed: "withoutDuplicates")
   83|      0|    public func duplicatesRemoved() -> [Element] {
   84|      0|        // Thanks to https://github.com/sairamkotha for improving the method
   85|      0|        return reduce(into: [Element]()) {
   86|      0|            if !$0.contains($1) {
   87|      0|                $0.append($1)
   88|      0|            }
   89|      0|        }
   90|      0|    }
   91|       |
   92|       |    /// SwifterSwift: Remove last element from array and return it.
   93|       |    ///
   94|       |    ///		[1, 2, 3, 4, 5].pop() // returns 5 and remove it from the array.
   95|       |    ///		[].pop() // returns nil since the array is empty.
   96|       |    ///
   97|       |    /// - Returns: last element in array (if applicable).
   98|       |    @available(*, deprecated: 4.3, message: "Use popLast() instead")
   99|      0|    @discardableResult public mutating func pop() -> Element? {
  100|      0|        return popLast()
  101|      0|    }
  102|       |
  103|       |    /// SwifterSwift: Insert an element to the end of array.
  104|       |    ///
  105|       |    ///		[1, 2, 3, 4].push(5) -> [1, 2, 3, 4, 5]
  106|       |    ///		["h", "e", "l", "l"].push("o") -> ["h", "e", "l", "l", "o"]
  107|       |    ///
  108|       |    /// - Parameter newElement: element to insert.
  109|       |    @available(*, deprecated: 4.3, message: "Use append() instead")
  110|      0|    public mutating func push(_ newElement: Element) {
  111|      0|        append(newElement)
  112|      0|    }
  113|       |
  114|       |    /// SwifterSwift: Swap values at index positions.
  115|       |    ///
  116|       |    ///		[1, 2, 3, 4, 5].swap(from: 3, to: 0) -> [4, 2, 3, 1, 5]
  117|       |    ///		["h", "e", "l", "l", "o"].swap(from: 1, to: 0) -> ["e", "h", "l", "l", "o"]
  118|       |    ///
  119|       |    /// - Parameters:
  120|       |    ///   - index: index of first element.
  121|       |    ///   - otherIndex: index of other element.
  122|       |    @available(*, deprecated: 4.3, message: "Use swapAt() instead")
  123|      0|    public mutating func swap(from index: Int, to otherIndex: Int) {
  124|      0|        swapAt(index, otherIndex)
  125|      0|    }
  126|       |
  127|       |}
  128|       |
  129|       |public extension Collection where Index == Int {
  130|       |
  131|       |    #if canImport(Foundation)
  132|       |    /// SwifterSwift: Random item from array.
  133|       |    @available(*, deprecated: 4.5.0, message: "Use randomElement() instead")
  134|      0|    public var randomItem: Element? {
  135|      0|        guard !isEmpty else { return nil }
  136|      0|        let index = Int(arc4random_uniform(UInt32(count)))
  137|      0|        return self[index]
  138|      0|    }
  139|       |    #endif
  140|       |}
  141|       |
  142|       |// MARK: - Methods
  143|       |public extension FloatingPoint {
  144|       |
  145|       |    #if canImport(Foundation)
  146|       |    /// SwifterSwift: Random number between two number.
  147|       |    ///
  148|       |    /// - Parameters:
  149|       |    ///   - min: minimum number to start random from.
  150|       |    ///   - max: maximum number random number end before.
  151|       |    /// - Returns: random number between two numbers.
  152|       |    @available(*, deprecated: 4.5.0, message: "Double.random(in: ClosedRange<Float>)")
  153|      0|    public static func random(between min: Self, and max: Self) -> Self {
  154|      0|        let aMin = Self.minimum(min, max)
  155|      0|        let aMax = Self.maximum(min, max)
  156|      0|        let delta = aMax - aMin
  157|      0|        return Self(arc4random()) / Self(UInt64(UINT32_MAX)) * delta + aMin
  158|      0|    }
  159|       |    #endif
  160|       |
  161|       |    #if canImport(Foundation)
  162|       |    /// SwifterSwift: Random number in a closed interval range.
  163|       |    ///
  164|       |    /// - Parameter range: closed interval range.
  165|       |    /// - Returns: random number in the given closed range.
  166|       |    @available(*, deprecated: 4.5.0, message: "Double.random(in: ClosedRange<Float>)")
  167|      0|    public static func random(inRange range: ClosedRange<Self>) -> Self {
  168|      0|        let delta = range.upperBound - range.lowerBound
  169|      0|        return Self(arc4random()) / Self(UInt64(UINT32_MAX)) * delta + range.lowerBound
  170|      0|    }
  171|       |    #endif
  172|       |
  173|       |}
  174|       |
  175|       |// MARK: - Initializers
  176|       |public extension FloatingPoint {
  177|       |
  178|       |    /// SwifterSwift: Created a random number between two numbers.
  179|       |    ///
  180|       |    /// - Parameters:
  181|       |    ///   - min: minimum number to start random from.
  182|       |    ///   - max: maximum number random number end before.
  183|       |    @available(*, deprecated: 4.5.0, message: "Double.random(in: ClosedRange<Float>)")
  184|      0|    public init(randomBetween min: Self, and max: Self) {
  185|      0|        let aMin = Self.minimum(min, max)
  186|      0|        let aMax = Self.maximum(min, max)
  187|      0|        let delta = aMax - aMin
  188|      0|        self = Self(arc4random()) / Self(UInt64(UINT32_MAX)) * delta + aMin
  189|      0|    }
  190|       |
  191|       |    /// SwifterSwift: Create a random number in a closed interval range.
  192|       |    ///
  193|       |    /// - Parameter range: closed interval range.
  194|       |    @available(*, deprecated: 4.5.0, message: "Double.random(in: ClosedRange<Float>)")
  195|      0|    public init(randomInRange range: ClosedRange<Self>) {
  196|      0|        let delta = range.upperBound - range.lowerBound
  197|      0|        self = Self(arc4random()) / Self(UInt64(UINT32_MAX)) * delta + range.lowerBound
  198|      0|    }
  199|       |
  200|       |}
  201|       |
  202|       |public extension Int {
  203|       |
  204|       |    /// SwifterSwift: Random integer between two integer values.
  205|       |    ///
  206|       |    /// - Parameters:
  207|       |    ///   - min: minimum number to start random from.
  208|       |    ///   - max: maximum number random number end before.
  209|       |    /// - Returns: random double between two double values.
  210|       |    @available(*, deprecated: 4.5.0, message: "Int.random(in: ClosedRange<Float>)")
  211|      0|    public static func random(between min: Int, and max: Int) -> Int {
  212|      0|        return random(in: min...max)
  213|      0|    }
  214|       |
  215|       |    /// SwifterSwift: Random integer in a closed interval range.
  216|       |    ///
  217|       |    /// - Parameter range: closed interval range.
  218|       |    /// - Returns: random double in the given closed range.
  219|       |    @available(*, deprecated: 4.5.0, message: "Int.random(in: ClosedRange<Float>)")
  220|      0|    public static func random(inRange range: ClosedRange<Int>) -> Int {
  221|      0|        return random(in: range)
  222|      0|    }
  223|       |
  224|       |    /// SwifterSwift: Created a random integer between two integer values.
  225|       |    ///
  226|       |    /// - Parameters:
  227|       |    ///   - min: minimum number to start random from.
  228|       |    ///   - max: maximum number random number end before.
  229|       |    @available(*, deprecated: 4.5.0, message: "Int.random(in: ClosedRange<Float>)")
  230|      0|    public init(randomBetween min: Int, and max: Int) {
  231|      0|        self = Int.random(in: min...max)
  232|      0|    }
  233|       |
  234|       |    /// SwifterSwift: Create a random integer in a closed interval range.
  235|       |    ///
  236|       |    /// - Parameter range: closed interval range.
  237|       |    @available(*, deprecated: 4.5.0, message: "Int.random(in: ClosedRange<Float>)")
  238|      0|    public init(randomInRange range: ClosedRange<Int>) {
  239|      0|        self = Int.random(in: range)
  240|      0|    }
  241|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/DictionaryExtensions.swift:
    1|       |//
    2|       |//  DictionaryExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/24/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Methods
   14|       |public extension Dictionary {
   15|       |
   16|       |    /// SwifterSwift: Check if key exists in dictionary.
   17|       |    ///
   18|       |    ///        let dict: [String : Any] = ["testKey": "testValue", "testArrayKey": [1, 2, 3, 4, 5]]
   19|       |    ///        dict.has(key: "testKey") -> true
   20|       |    ///        dict.has(key: "anotherKey") -> false
   21|       |    ///
   22|       |    /// - Parameter key: key to search for
   23|       |    /// - Returns: true if key exists in dictionary.
   24|      0|    public func has(key: Key) -> Bool {
   25|      0|        return index(forKey: key) != nil
   26|      0|    }
   27|       |
   28|       |    /// SwifterSwift: Remove all keys contained in the keys parameter from the dictionary.
   29|       |    ///
   30|       |    ///        var dict : [String : String] = ["key1" : "value1", "key2" : "value2", "key3" : "value3"]
   31|       |    ///        dict.removeAll(keys: ["key1", "key2"])
   32|       |    ///        dict.keys.contains("key3") -> true
   33|       |    ///        dict.keys.contains("key1") -> false
   34|       |    ///        dict.keys.contains("key2") -> false
   35|       |    ///
   36|       |    /// - Parameter keys: keys to be removed
   37|      0|    public mutating func removeAll<S: Sequence>(keys: S) where S.Element == Key {
   38|      0|        keys.forEach { removeValue(forKey: $0) }
   39|      0|    }
   40|       |
   41|       |    #if canImport(Foundation)
   42|       |    /// SwifterSwift: Remove a value for a random key from the dictionary.
   43|      0|    @discardableResult public mutating func removeValueForRandomKey() -> Value? {
   44|      0|        guard !isEmpty else { return nil }
   45|      0|        let key = Array(keys)[Int.random(in: 0..<keys.count)]
   46|      0|        return removeValue(forKey: key)
   47|      0|    }
   48|       |    #endif
   49|       |
   50|       |    #if canImport(Foundation)
   51|       |    /// SwifterSwift: JSON Data from dictionary.
   52|       |    ///
   53|       |    /// - Parameter prettify: set true to prettify data (default is false).
   54|       |    /// - Returns: optional JSON Data (if applicable).
   55|      0|    public func jsonData(prettify: Bool = false) -> Data? {
   56|      0|        guard JSONSerialization.isValidJSONObject(self) else {
   57|      0|            return nil
   58|      0|        }
   59|      0|        let options = (prettify == true) ? JSONSerialization.WritingOptions.prettyPrinted : JSONSerialization.WritingOptions()
   60|      0|        return try? JSONSerialization.data(withJSONObject: self, options: options)
   61|      0|    }
   62|       |    #endif
   63|       |
   64|       |    #if canImport(Foundation)
   65|       |    /// SwifterSwift: JSON String from dictionary.
   66|       |    ///
   67|       |    ///        dict.jsonString() -> "{"testKey":"testValue","testArrayKey":[1,2,3,4,5]}"
   68|       |    ///
   69|       |    ///        dict.jsonString(prettify: true)
   70|       |    ///        /*
   71|       |    ///        returns the following string:
   72|       |    ///
   73|       |    ///        "{
   74|       |    ///        "testKey" : "testValue",
   75|       |    ///        "testArrayKey" : [
   76|       |    ///            1,
   77|       |    ///            2,
   78|       |    ///            3,
   79|       |    ///            4,
   80|       |    ///            5
   81|       |    ///        ]
   82|       |    ///        }"
   83|       |    ///
   84|       |    ///        */
   85|       |    ///
   86|       |    /// - Parameter prettify: set true to prettify string (default is false).
   87|       |    /// - Returns: optional JSON String (if applicable).
   88|      0|    public func jsonString(prettify: Bool = false) -> String? {
   89|      0|        guard JSONSerialization.isValidJSONObject(self) else { return nil }
   90|      0|        let options = (prettify == true) ? JSONSerialization.WritingOptions.prettyPrinted : JSONSerialization.WritingOptions()
   91|      0|        guard let jsonData = try? JSONSerialization.data(withJSONObject: self, options: options) else { return nil }
   92|      0|        return String(data: jsonData, encoding: .utf8)
   93|      0|    }
   94|       |    #endif
   95|       |
   96|       |    /// SwifterSwift: Returns a dictionary containing the results of mapping the given closure over the sequence’s elements.
   97|       |    /// - Parameter transform: A mapping closure. `transform` accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.
   98|       |    /// - Returns: A dictionary containing the transformed elements of this sequence.
   99|      0|    public func mapKeysAndValues<K, V>(_ transform: ((key: Key, value: Value)) throws -> (K, V)) rethrows -> [K: V] {
  100|      0|        return [K: V](uniqueKeysWithValues: try map(transform))
  101|      0|    }
  102|       |
  103|       |    /// SwifterSwift: Returns a dictionary containing the non-`nil` results of calling the given transformation with each element of this sequence.
  104|       |    /// - Parameter transform: A closure that accepts an element of this sequence as its argument and returns an optional value.
  105|       |    /// - Returns: A dictionary of the non-`nil` results of calling `transform` with each element of the sequence.
  106|       |    /// - Complexity: *O(m + n)*, where _m_ is the length of this sequence and _n_ is the length of the result.
  107|      0|    public func compactMapKeysAndValues<K, V>(_ transform: ((key: Key, value: Value)) throws -> (K, V)?) rethrows -> [K: V] {
  108|      0|        return [K: V](uniqueKeysWithValues: try compactMap(transform))
  109|      0|    }
  110|       |
  111|       |}
  112|       |
  113|       |// MARK: - Methods (Value: Equatable)
  114|       |public extension Dictionary where Value: Equatable {
  115|       |
  116|       |    /// SwifterSwift: Returns an array of all keys that have the given value in dictionary.
  117|       |    ///
  118|       |    ///        let dict = ["key1": "value1", "key2": "value1", "key3": "value2"]
  119|       |    ///        dict.keys(forValue: "value1") -> ["key1", "key2"]
  120|       |    ///        dict.keys(forValue: "value2") -> ["key3"]
  121|       |    ///        dict.keys(forValue: "value3") -> []
  122|       |    ///
  123|       |    /// - Parameter value: Value for which keys are to be fetched.
  124|       |    /// - Returns: An array containing keys that have the given value.
  125|      0|    public func keys(forValue value: Value) -> [Key] {
  126|      0|        return keys.filter { self[$0] == value }
  127|      0|    }
  128|       |
  129|       |}
  130|       |
  131|       |// MARK: - Methods (ExpressibleByStringLiteral)
  132|       |public extension Dictionary where Key: StringProtocol {
  133|       |
  134|       |    /// SwifterSwift: Lowercase all keys in dictionary.
  135|       |    ///
  136|       |    ///        var dict = ["tEstKeY": "value"]
  137|       |    ///        dict.lowercaseAllKeys()
  138|       |    ///        print(dict) // prints "["testkey": "value"]"
  139|       |    ///
  140|      0|    public mutating func lowercaseAllKeys() {
  141|      0|        // http://stackoverflow.com/questions/33180028/extend-dictionary-where-key-is-of-type-string
  142|      0|        for key in keys {
  143|      0|            if let lowercaseKey = String(describing: key).lowercased() as? Key {
  144|      0|                self[lowercaseKey] = removeValue(forKey: key)
  145|      0|            }
  146|      0|        }
  147|      0|    }
  148|       |
  149|       |}
  150|       |
  151|       |// MARK: - Operators
  152|       |public extension Dictionary {
  153|       |
  154|       |    /// SwifterSwift: Merge the keys/values of two dictionaries.
  155|       |    ///
  156|       |    ///        let dict : [String : String] = ["key1" : "value1"]
  157|       |    ///        let dict2 : [String : String] = ["key2" : "value2"]
  158|       |    ///        let result = dict + dict2
  159|       |    ///        result["key1"] -> "value1"
  160|       |    ///        result["key2"] -> "value2"
  161|       |    ///
  162|       |    /// - Parameters:
  163|       |    ///   - lhs: dictionary
  164|       |    ///   - rhs: dictionary
  165|       |    /// - Returns: An dictionary with keys and values from both.
  166|      0|    public static func + (lhs: [Key: Value], rhs: [Key: Value]) -> [Key: Value] {
  167|      0|        var result = lhs
  168|      0|        rhs.forEach { result[$0] = $1 }
  169|      0|        return result
  170|      0|    }
  171|       |
  172|       |    // MARK: - Operators
  173|       |
  174|       |    /// SwifterSwift: Append the keys and values from the second dictionary into the first one.
  175|       |    ///
  176|       |    ///        var dict : [String : String] = ["key1" : "value1"]
  177|       |    ///        let dict2 : [String : String] = ["key2" : "value2"]
  178|       |    ///        dict += dict2
  179|       |    ///        dict["key1"] -> "value1"
  180|       |    ///        dict["key2"] -> "value2"
  181|       |    ///
  182|       |    /// - Parameters:
  183|       |    ///   - lhs: dictionary
  184|       |    ///   - rhs: dictionary
  185|      0|    public static func += (lhs: inout [Key: Value], rhs: [Key: Value]) {
  186|      0|        rhs.forEach { lhs[$0] = $1}
  187|      0|    }
  188|       |
  189|       |    /// SwifterSwift: Remove keys contained in the sequence from the dictionary
  190|       |    ///
  191|       |    ///        let dict : [String : String] = ["key1" : "value1", "key2" : "value2", "key3" : "value3"]
  192|       |    ///        let result = dict-["key1", "key2"]
  193|       |    ///        result.keys.contains("key3") -> true
  194|       |    ///        result.keys.contains("key1") -> false
  195|       |    ///        result.keys.contains("key2") -> false
  196|       |    ///
  197|       |    /// - Parameters:
  198|       |    ///   - lhs: dictionary
  199|       |    ///   - rhs: array with the keys to be removed.
  200|       |    /// - Returns: a new dictionary with keys removed.
  201|      0|    public static func - <S: Sequence>(lhs: [Key: Value], keys: S) -> [Key: Value] where S.Element == Key {
  202|      0|        var result = lhs
  203|      0|        result.removeAll(keys: keys)
  204|      0|        return result
  205|      0|    }
  206|       |
  207|       |    /// SwifterSwift: Remove keys contained in the sequence from the dictionary
  208|       |    ///
  209|       |    ///        var dict : [String : String] = ["key1" : "value1", "key2" : "value2", "key3" : "value3"]
  210|       |    ///        dict-=["key1", "key2"]
  211|       |    ///        dict.keys.contains("key3") -> true
  212|       |    ///        dict.keys.contains("key1") -> false
  213|       |    ///        dict.keys.contains("key2") -> false
  214|       |    ///
  215|       |    /// - Parameters:
  216|       |    ///   - lhs: dictionary
  217|       |    ///   - rhs: array with the keys to be removed.
  218|      0|    public static func -= <S: Sequence>(lhs: inout [Key: Value], keys: S) where S.Element == Key {
  219|      0|        lhs.removeAll(keys: keys)
  220|      0|    }
  221|       |
  222|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/DoubleExtensions.swift:
    1|       |//
    2|       |//  DoubleExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/6/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension Double {
   15|       |
   16|       |    /// SwifterSwift: Int.
   17|      0|    public var int: Int {
   18|      0|        return Int(self)
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Float.
   22|      0|    public var float: Float {
   23|      0|        return Float(self)
   24|      0|    }
   25|       |
   26|       |    #if canImport(CoreGraphics)
   27|       |    /// SwifterSwift: CGFloat.
   28|      0|    public var cgFloat: CGFloat {
   29|      0|        return CGFloat(self)
   30|      0|    }
   31|       |    #endif
   32|       |
   33|       |}
   34|       |
   35|       |// MARK: - Operators
   36|       |
   37|       |precedencegroup PowerPrecedence { higherThan: MultiplicationPrecedence }
   38|       |infix operator ** : PowerPrecedence
   39|       |/// SwifterSwift: Value of exponentiation.
   40|       |///
   41|       |/// - Parameters:
   42|       |///   - lhs: base double.
   43|       |///   - rhs: exponent double.
   44|       |/// - Returns: exponentiation result (example: 4.4 ** 0.5 = 2.0976176963).
   45|      0|public func ** (lhs: Double, rhs: Double) -> Double {
   46|      0|    // http://nshipster.com/swift-operators/
   47|      0|    return pow(lhs, rhs)
   48|      0|}
   49|       |
   50|       |// swiftlint:disable next identifier_name
   51|       |prefix operator √
   52|       |/// SwifterSwift: Square root of double.
   53|       |///
   54|       |/// - Parameter double: double value to find square root for.
   55|       |/// - Returns: square root of given double.
   56|      0|public prefix func √ (double: Double) -> Double {
   57|      0|    // http://nshipster.com/swift-operators/
   58|      0|    return sqrt(double)
   59|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/FloatExtensions.swift:
    1|       |//
    2|       |//  FloatExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/8/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension Float {
   15|       |
   16|       |    /// SwifterSwift: Int.
   17|      0|    public var int: Int {
   18|      0|        return Int(self)
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Double.
   22|      0|    public var double: Double {
   23|      0|        return Double(self)
   24|      0|    }
   25|       |
   26|       |    #if canImport(CoreGraphics)
   27|       |    /// SwifterSwift: CGFloat.
   28|      0|    public var cgFloat: CGFloat {
   29|      0|        return CGFloat(self)
   30|      0|    }
   31|       |    #endif
   32|       |
   33|       |}
   34|       |
   35|       |// MARK: - Operators
   36|       |
   37|       |precedencegroup PowerPrecedence { higherThan: MultiplicationPrecedence }
   38|       |infix operator ** : PowerPrecedence
   39|       |/// SwifterSwift: Value of exponentiation.
   40|       |///
   41|       |/// - Parameters:
   42|       |///   - lhs: base float.
   43|       |///   - rhs: exponent float.
   44|       |/// - Returns: exponentiation result (4.4 ** 0.5 = 2.0976176963).
   45|      0|public func ** (lhs: Float, rhs: Float) -> Float {
   46|      0|    // http://nshipster.com/swift-operators/
   47|      0|    return pow(lhs, rhs)
   48|      0|}
   49|       |
   50|       |// swiftlint:disable next identifier_name
   51|       |prefix operator √
   52|       |/// SwifterSwift: Square root of float.
   53|       |///
   54|       |/// - Parameter float: float value to find square root for
   55|       |/// - Returns: square root of given float.
   56|      0|public prefix func √ (float: Float) -> Float {
   57|      0|    // http://nshipster.com/swift-operators/
   58|      0|    return sqrt(float)
   59|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/FloatingPointExtensions.swift:
    1|       |//
    2|       |//  FloatingPointExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 7/23/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension FloatingPoint {
   15|       |
   16|       |    /// SwifterSwift: Absolute value of number.
   17|      0|    public var abs: Self {
   18|      0|        return Swift.abs(self)
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Check if number is positive.
   22|      0|    public var isPositive: Bool {
   23|      0|        return self > 0
   24|      0|    }
   25|       |
   26|       |    /// SwifterSwift: Check if number is negative.
   27|      0|    public var isNegative: Bool {
   28|      0|        return self < 0
   29|      0|    }
   30|       |
   31|       |    #if canImport(Foundation)
   32|       |    /// SwifterSwift: Ceil of number.
   33|      0|    public var ceil: Self {
   34|      0|        return Foundation.ceil(self)
   35|      0|    }
   36|       |    #endif
   37|       |
   38|       |    /// SwifterSwift: Radian value of degree input.
   39|      0|    public var degreesToRadians: Self {
   40|      0|        return Self.pi * self / Self(180)
   41|      0|    }
   42|       |
   43|       |    #if canImport(Foundation)
   44|       |    /// SwifterSwift: Floor of number.
   45|      0|    public var floor: Self {
   46|      0|        return Foundation.floor(self)
   47|      0|    }
   48|       |    #endif
   49|       |
   50|       |    /// SwifterSwift: Degree value of radian input.
   51|      0|    public var radiansToDegrees: Self {
   52|      0|        return self * Self(180) / Self.pi
   53|      0|    }
   54|       |
   55|       |}
   56|       |
   57|       |// MARK: - Operators
   58|       |
   59|       |// swiftlint:disable next identifier_name
   60|       |infix operator ±
   61|       |/// SwifterSwift: Tuple of plus-minus operation.
   62|       |///
   63|       |/// - Parameters:
   64|       |///   - lhs: number
   65|       |///   - rhs: number
   66|       |/// - Returns: tuple of plus-minus operation ( 2.5 ± 1.5 -> (4, 1)).
   67|      0|public func ±<T: FloatingPoint> (lhs: T, rhs: T) -> (T, T) {
   68|      0|    // http://nshipster.com/swift-operators/
   69|      0|    return (lhs + rhs, lhs - rhs)
   70|      0|}
   71|       |
   72|       |// swiftlint:disable next identifier_name
   73|       |prefix operator ±
   74|       |/// SwifterSwift: Tuple of plus-minus operation.
   75|       |///
   76|       |/// - Parameter int: number
   77|       |/// - Returns: tuple of plus-minus operation (± 2.5 -> (2.5, -2.5)).
   78|      0|public prefix func ±<T: FloatingPoint> (number: T) -> (T, T) {
   79|      0|    // http://nshipster.com/swift-operators/
   80|      0|    return 0 ± number
   81|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/IntExtensions.swift:
    1|       |//
    2|       |//  IntExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/6/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(CoreGraphics)
   10|       |import CoreGraphics
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension Int {
   15|       |
   16|       |    /// SwifterSwift: CountableRange 0..<Int.
   17|      0|    public var countableRange: CountableRange<Int> {
   18|      0|        return 0..<self
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Radian value of degree input.
   22|      0|    public var degreesToRadians: Double {
   23|      0|        return Double.pi * Double(self) / 180.0
   24|      0|    }
   25|       |
   26|       |    /// SwifterSwift: Degree value of radian input
   27|      0|    public var radiansToDegrees: Double {
   28|      0|        return Double(self) * 180 / Double.pi
   29|      0|    }
   30|       |
   31|       |    /// SwifterSwift: UInt.
   32|      0|    public var uInt: UInt {
   33|      0|        return UInt(self)
   34|      0|    }
   35|       |
   36|       |    /// SwifterSwift: Double.
   37|      0|    public var double: Double {
   38|      0|        return Double(self)
   39|      0|    }
   40|       |
   41|       |    /// SwifterSwift: Float.
   42|      0|    public var float: Float {
   43|      0|        return Float(self)
   44|      0|    }
   45|       |
   46|       |    #if canImport(CoreGraphics)
   47|       |    /// SwifterSwift: CGFloat.
   48|      0|    public var cgFloat: CGFloat {
   49|      0|        return CGFloat(self)
   50|      0|    }
   51|       |    #endif
   52|       |
   53|       |    /// SwifterSwift: String formatted for values over ±1000 (example: 1k, -2k, 100k, 1kk, -5kk..)
   54|      0|    public var kFormatted: String {
   55|      0|        var sign: String {
   56|      0|            return self >= 0 ? "" : "-"
   57|      0|        }
   58|      0|        let abs = Swift.abs(self)
   59|      0|        if abs == 0 {
   60|      0|            return "0k"
   61|      0|        } else if abs >= 0 && abs < 1000 {
   62|      0|            return "0k"
   63|      0|        } else if abs >= 1000 && abs < 1000000 {
   64|      0|            return String(format: "\(sign)%ik", abs / 1000)
   65|      0|        }
   66|      0|        return String(format: "\(sign)%ikk", abs / 100000)
   67|      0|    }
   68|       |
   69|       |    /// SwifterSwift: Array of digits of integer value.
   70|      0|    public var digits: [Int] {
   71|      0|        guard self != 0 else { return [0] }
   72|      0|        var digits = [Int]()
   73|      0|        var number = self.abs
   74|      0|
   75|      0|        while number != 0 {
   76|      0|            let xNumber = number % 10
   77|      0|            digits.append(xNumber)
   78|      0|            number /= 10
   79|      0|        }
   80|      0|
   81|      0|        digits.reverse()
   82|      0|        return digits
   83|      0|    }
   84|       |
   85|       |    /// SwifterSwift: Number of digits of integer value.
   86|      0|    public var digitsCount: Int {
   87|      0|        guard self != 0 else { return 1 }
   88|      0|        let number = Double(self.abs)
   89|      0|        return Int(log10(number) + 1)
   90|      0|    }
   91|       |
   92|       |}
   93|       |
   94|       |// MARK: - Methods
   95|       |public extension Int {
   96|       |
   97|       |    /// SwifterSwift: check if given integer prime or not.
   98|       |    /// Warning: Using big numbers can be computationally expensive!
   99|       |    /// - Returns: true or false depending on prime-ness
  100|      0|    public func isPrime() -> Bool {
  101|      0|        // To improve speed on latter loop :)
  102|      0|        if self == 2 {
  103|      0|            return true
  104|      0|        }
  105|      0|
  106|      0|        guard self > 1 && self % 2 != 0 else {
  107|      0|            return false
  108|      0|        }
  109|      0|        // Explanation: It is enough to check numbers until
  110|      0|        // the square root of that number. If you go up from N by one,
  111|      0|        // other multiplier will go 1 down to get similar result
  112|      0|        // (integer-wise operation) such way increases speed of operation
  113|      0|        let base = Int(sqrt(Double(self)))
  114|      0|        for int in Swift.stride(from: 3, through: base, by: 2) where self % int == 0 {
  115|      0|            return false
  116|      0|        }
  117|      0|        return true
  118|      0|    }
  119|       |
  120|       |    /// SwifterSwift: Roman numeral string from integer (if applicable).
  121|       |    ///
  122|       |    ///10.romanNumeral() -> "X"
  123|       |    ///
  124|       |    /// - Returns: The roman numeral string.
  125|      0|    public func romanNumeral() -> String? {
  126|      0|        // https://gist.github.com/kumo/a8e1cb1f4b7cff1548c7
  127|      0|        guard self > 0 else { // there is no roman numerals for 0 or negative numbers
  128|      0|            return nil
  129|      0|        }
  130|      0|        let romanValues = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
  131|      0|        let arabicValues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  132|      0|
  133|      0|        var romanValue = ""
  134|      0|        var startingValue = self
  135|      0|
  136|      0|        for (index, romanChar) in romanValues.enumerated() {
  137|      0|            let arabicValue = arabicValues[index]
  138|      0|            let div = startingValue / arabicValue
  139|      0|            if div > 0 {
  140|      0|                for _ in 0..<div {
  141|      0|                    romanValue += romanChar
  142|      0|                }
  143|      0|                startingValue -= arabicValue * div
  144|      0|            }
  145|      0|        }
  146|      0|        return romanValue
  147|      0|    }
  148|       |
  149|       |    // swiftlint:disable next identifier_name
  150|       |    /// SwifterSwift: Rounds to the closest multiple of n
  151|      0|    public func roundToNearest(_ n: Int) -> Int {
  152|      0|        return n == 0 ? self : Int(round(Double(self) / Double(n))) * n
  153|      0|    }
  154|       |
  155|       |}
  156|       |
  157|       |// MARK: - Operators
  158|       |
  159|       |precedencegroup PowerPrecedence { higherThan: MultiplicationPrecedence }
  160|       |infix operator ** : PowerPrecedence
  161|       |/// SwifterSwift: Value of exponentiation.
  162|       |///
  163|       |/// - Parameters:
  164|       |///   - lhs: base integer.
  165|       |///   - rhs: exponent integer.
  166|       |/// - Returns: exponentiation result (example: 2 ** 3 = 8).
  167|      0|public func ** (lhs: Int, rhs: Int) -> Double {
  168|      0|    // http://nshipster.com/swift-operators/
  169|      0|    return pow(Double(lhs), Double(rhs))
  170|      0|}
  171|       |
  172|       |// swiftlint:disable next identifier_name
  173|       |prefix operator √
  174|       |/// SwifterSwift: Square root of integer.
  175|       |///
  176|       |/// - Parameter int: integer value to find square root for
  177|       |/// - Returns: square root of given integer.
  178|      0|public prefix func √ (int: Int) -> Double {
  179|      0|    // http://nshipster.com/swift-operators/
  180|      0|    return sqrt(Double(int))
  181|      0|}
  182|       |
  183|       |// swiftlint:disable next identifier_name
  184|       |infix operator ±
  185|       |/// SwifterSwift: Tuple of plus-minus operation.
  186|       |///
  187|       |/// - Parameters:
  188|       |///   - lhs: integer number.
  189|       |///   - rhs: integer number.
  190|       |/// - Returns: tuple of plus-minus operation (example: 2 ± 3 -> (5, -1)).
  191|      0|public func ± (lhs: Int, rhs: Int) -> (Int, Int) {
  192|      0|    // http://nshipster.com/swift-operators/
  193|      0|    return (lhs + rhs, lhs - rhs)
  194|      0|}
  195|       |
  196|       |// swiftlint:disable next identifier_name
  197|       |prefix operator ±
  198|       |/// SwifterSwift: Tuple of plus-minus operation.
  199|       |///
  200|       |/// - Parameter int: integer number
  201|       |/// - Returns: tuple of plus-minus operation (example: ± 2 -> (2, -2)).
  202|      0|public prefix func ± (int: Int) -> (Int, Int) {
  203|      0|    // http://nshipster.com/swift-operators/
  204|      0|    return 0 ± int
  205|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/OptionalExtensions.swift:
    1|       |//
    2|       |//  OptionalExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 3/3/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |// MARK: - Methods
   10|       |public extension Optional {
   11|       |
   12|       |    /// SwifterSwift: Get self of default value (if self is nil).
   13|       |    ///
   14|       |    ///		let foo: String? = nil
   15|       |    ///		print(foo.unwrapped(or: "bar")) -> "bar"
   16|       |    ///
   17|       |    ///		let bar: String? = "bar"
   18|       |    ///		print(bar.unwrapped(or: "foo")) -> "bar"
   19|       |    ///
   20|       |    /// - Parameter defaultValue: default value to return if self is nil.
   21|       |    /// - Returns: self if not nil or default value if nil.
   22|      0|    public func unwrapped(or defaultValue: Wrapped) -> Wrapped {
   23|      0|        // http://www.russbishop.net/improving-optionals
   24|      0|        return self ?? defaultValue
   25|      0|    }
   26|       |
   27|       |    /// SwifterSwift: Gets the wrapped value of an optional. If the optional is `nil`, throw a custom error.
   28|       |    ///
   29|       |    ///        let foo: String? = nil
   30|       |    ///        try print(foo.unwrapped(or: MyError.notFound)) -> error: MyError.notFound
   31|       |    ///
   32|       |    ///        let bar: String? = "bar"
   33|       |    ///        try print(bar.unwrapped(or: MyError.notFound)) -> "bar"
   34|       |    ///
   35|       |    /// - Parameter error: The error to throw if the optional is `nil`.
   36|       |    /// - Returns: The value wrapped by the optional.
   37|       |    /// - Throws: The error passed in.
   38|      0|    public func unwrapped(or error: Error) throws -> Wrapped {
   39|      0|        guard let wrapped = self else { throw error }
   40|      0|        return wrapped
   41|      0|    }
   42|       |
   43|       |    /// SwifterSwift: Runs a block to Wrapped if not nil
   44|       |    ///
   45|       |    ///		let foo: String? = nil
   46|       |    ///		foo.run { unwrappedFoo in
   47|       |    ///			// block will never run sice foo is nill
   48|       |    ///			print(unwrappedFoo)
   49|       |    ///		}
   50|       |    ///
   51|       |    ///		let bar: String? = "bar"
   52|       |    ///		bar.run { unwrappedBar in
   53|       |    ///			// block will run sice bar is not nill
   54|       |    ///			print(unwrappedBar) -> "bar"
   55|       |    ///		}
   56|       |    ///
   57|       |    /// - Parameter block: a block to run if self is not nil.
   58|      0|    public func run(_ block: (Wrapped) -> Void) {
   59|      0|        // http://www.russbishop.net/improving-optionals
   60|      0|        _ = self.map(block)
   61|      0|    }
   62|       |
   63|       |    /// SwifterSwift: Assign an optional value to a variable only if the value is not nil.
   64|       |    ///
   65|       |    ///     let someParameter: String? = nil
   66|       |    ///     let parameters = [String:Any]() //Some parameters to be attached to a GET request
   67|       |    ///     parameters[someKey] ??= someParameter //It won't be added to the parameters dict
   68|       |    ///
   69|       |    /// - Parameters:
   70|       |    ///   - lhs: Any?
   71|       |    ///   - rhs: Any?
   72|      0|    public static func ??= (lhs: inout Optional, rhs: Optional) {
   73|      0|        guard let rhs = rhs else { return }
   74|      0|        lhs = rhs
   75|      0|    }
   76|       |
   77|       |    /// SwifterSwift: Assign an optional value to a variable only if the variable is nil.
   78|       |    ///
   79|       |    ///     var someText: String? = nil
   80|       |    ///     let newText = "Foo"
   81|       |    ///     let defaultText = "Bar"
   82|       |    ///     someText ?= newText //someText is now "Foo" because it was nil before
   83|       |    ///     someText ?= defaultText //someText doesn't change its value because it's not nil
   84|       |    ///
   85|       |    /// - Parameters:
   86|       |    ///   - lhs: Any?
   87|       |    ///   - rhs: Any?
   88|      0|    public static func ?= (lhs: inout Optional, rhs: @autoclosure () -> Optional) {
   89|      0|        if lhs == nil {
   90|      0|            lhs = rhs()
   91|      0|        }
   92|      0|    }
   93|       |
   94|       |}
   95|       |
   96|       |// MARK: - Methods (Collection)
   97|       |public extension Optional where Wrapped: Collection {
   98|       |
   99|       |    /// SwifterSwift: Check if optional is nil or empty collection.
  100|      0|    public var isNilOrEmpty: Bool {
  101|      0|        guard let collection = self else { return true }
  102|      0|        return collection.isEmpty
  103|      0|    }
  104|       |
  105|       |}
  106|       |
  107|       |// MARK: - Operators
  108|       |infix operator ??= : AssignmentPrecedence
  109|       |infix operator ?= : AssignmentPrecedence

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/RandomAccessCollectionExtensions.swift:
    1|       |//
    2|       |//  RandomAccessCollectionExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Luciano Almeida on 7/13/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |extension RandomAccessCollection where Element: Equatable {
   10|       |
   11|       |    /// SwifterSwift: All indices of specified item.
   12|       |    ///
   13|       |    ///        [1, 2, 2, 3, 4, 2, 5].indices(of 2) -> [1, 2, 5]
   14|       |    ///        [1.2, 2.3, 4.5, 3.4, 4.5].indices(of 2.3) -> [1]
   15|       |    ///        ["h", "e", "l", "l", "o"].indices(of "l") -> [2, 3]
   16|       |    ///
   17|       |    /// - Parameter item: item to check.
   18|       |    /// - Returns: an array with all indices of the given item.
   19|      0|    public func indices(of item: Element) -> [Index] {
   20|      0|        var indices: [Index] = []
   21|      0|        var idx = startIndex
   22|      0|        while idx < endIndex {
   23|      0|            if self[idx] == item {
   24|      0|                indices.append(idx)
   25|      0|            }
   26|      0|            formIndex(after: &idx)
   27|      0|        }
   28|      0|        return indices
   29|      0|    }
   30|       |
   31|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/RangeReplaceableCollectionExtensions.swift:
    1|       |//
    2|       |//  RangeReplaceableCollectionExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Luciano Almeida on 7/2/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Initializers
   14|       |extension RangeReplaceableCollection {
   15|       |
   16|       |    /// Creates a new collection of a given size where for each position of the collection the value will be the result
   17|       |    /// of a call of the given expression.
   18|       |    ///
   19|       |    ///     let values = Array(expression: "Value", count: 3)
   20|       |    ///     print(values)
   21|       |    ///     // Prints "["Value", "Value", "Value"]"
   22|       |    ///
   23|       |    /// - Parameters:
   24|       |    ///   - expression: The expression to execute for each position of the collection.
   25|       |    ///   - count: The count of the collection.
   26|      0|    public init(expression: @autoclosure () throws -> Element, count: Int) rethrows {
   27|      0|        self.init()
   28|      0|        if count > 0 { //swiftlint:disable:this empty_count
   29|      0|            reserveCapacity(count)
   30|      0|            while self.count < count {
   31|      0|                append(try expression())
   32|      0|            }
   33|      0|        }
   34|      0|    }
   35|       |
   36|       |}
   37|       |
   38|       |// MARK: - Methods
   39|       |extension RangeReplaceableCollection {
   40|       |
   41|       |    /// SwifterSwift: Returns a new rotated collection by the given places.
   42|       |    ///
   43|       |    ///     [1, 2, 3, 4].rotated(by: 1) -> [4,1,2,3]
   44|       |    ///     [1, 2, 3, 4].rotated(by: 3) -> [2,3,4,1]
   45|       |    ///     [1, 2, 3, 4].rotated(by: -1) -> [2,3,4,1]
   46|       |    ///
   47|       |    /// - Parameter places: Number of places that the array be rotated. If the value is positive the end becomes the start, if it negative it's that start becom the end.
   48|       |    /// - Returns: The new rotated collection.
   49|      0|    public func rotated(by places: Int) -> Self {
   50|      0|        //Inspired by: https://ruby-doc.org/core-2.2.0/Array.html#method-i-rotate
   51|      0|        var copy = self
   52|      0|        return copy.rotate(by: places)
   53|      0|    }
   54|       |
   55|       |    /// SwifterSwift: Rotate the collection by the given places.
   56|       |    ///
   57|       |    ///     [1, 2, 3, 4].rotate(by: 1) -> [4,1,2,3]
   58|       |    ///     [1, 2, 3, 4].rotate(by: 3) -> [2,3,4,1]
   59|       |    ///     [1, 2, 3, 4].rotated(by: -1) -> [2,3,4,1]
   60|       |    ///
   61|       |    /// - Parameter places: The number of places that the array should be rotated. If the value is positive the end becomes the start, if it negative it's that start become the end.
   62|       |    /// - Returns: self after rotating.
   63|       |    @discardableResult
   64|       |    public mutating func rotate(by places: Int) -> Self {
   65|       |        guard places != 0 else { return self }
   66|       |        let placesToMove = places%count
   67|       |        if placesToMove > 0 {
   68|       |            let range = index(endIndex, offsetBy: -placesToMove)...
   69|       |            let slice = self[range]
   70|       |            removeSubrange(range)
   71|       |            insert(contentsOf: slice, at: startIndex)
   72|       |        } else {
   73|       |            let range = startIndex..<index(startIndex, offsetBy: -placesToMove)
   74|       |            let slice = self[range]
   75|       |            removeSubrange(range)
   76|       |            append(contentsOf: slice)
   77|       |        }
   78|       |        return self
   79|       |    }
   80|       |
   81|       |    /// SwifterSwift: Removes the first element of the collection which satisfies the given predicate.
   82|       |    ///
   83|       |    ///        [1, 2, 2, 3, 4, 2, 5].removeFirst { $0 % 2 == 0 } -> [1, 2, 3, 4, 2, 5]
   84|       |    ///        ["h", "e", "l", "l", "o"].removeFirst { $0 == "e" } -> ["h", "l", "l", "o"]
   85|       |    ///
   86|       |    /// - Parameter predicate: A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.
   87|       |    /// - Returns: The first element for which predicate returns true, after removing it. If no elements in the collection satisfy the given predicate, returns `nil`.
   88|       |    @discardableResult
   89|      0|    public mutating func removeFirst(where predicate: (Element) throws -> Bool) rethrows -> Element? {
   90|      0|        guard let index = try index(where: predicate) else { return nil }
   91|      0|        return remove(at: index)
   92|      0|    }
   93|       |
   94|       |    #if canImport(Foundation)
   95|       |    /// SwifterSwift: Remove a random value from the collection.
   96|      0|    @discardableResult public mutating func removeRandomElement() -> Element? {
   97|      0|        guard !isEmpty else { return nil }
   98|      0|        return remove(at: index(startIndex, offsetBy: Int.random(in: 0..<count)))
   99|      0|    }
  100|       |    #endif
  101|       |
  102|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/SequenceExtensions.swift:
    1|       |//
    2|       |//  SequenceExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Anton Novoselov on 04/04/2018.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |public extension Sequence {
   14|       |
   15|       |    /// SwifterSwift: Check if all elements in collection match a conditon.
   16|       |    ///
   17|       |    ///        [2, 2, 4].all(matching: {$0 % 2 == 0}) -> true
   18|       |    ///        [1,2, 2, 4].all(matching: {$0 % 2 == 0}) -> false
   19|       |    ///
   20|       |    /// - Parameter condition: condition to evaluate each element against.
   21|       |    /// - Returns: true when all elements in the array match the specified condition.
   22|      0|    public func all(matching condition: (Element) throws -> Bool) rethrows -> Bool {
   23|      0|        return try !contains { try !condition($0) }
   24|      0|    }
   25|       |
   26|       |    /// SwifterSwift: Check if no elements in collection match a conditon.
   27|       |    ///
   28|       |    ///        [2, 2, 4].none(matching: {$0 % 2 == 0}) -> false
   29|       |    ///        [1, 3, 5, 7].none(matching: {$0 % 2 == 0}) -> true
   30|       |    ///
   31|       |    /// - Parameter condition: condition to evaluate each element against.
   32|       |    /// - Returns: true when no elements in the array match the specified condition.
   33|      0|    public func none(matching condition: (Element) throws -> Bool) rethrows -> Bool {
   34|      0|        return try !contains { try condition($0) }
   35|      0|    }
   36|       |
   37|       |    /// SwifterSwift: Check if any element in collection match a conditon.
   38|       |    ///
   39|       |    ///        [2, 2, 4].any(matching: {$0 % 2 == 0}) -> false
   40|       |    ///        [1, 3, 5, 7].any(matching: {$0 % 2 == 0}) -> true
   41|       |    ///
   42|       |    /// - Parameter condition: condition to evaluate each element against.
   43|       |    /// - Returns: true when no elements in the array match the specified condition.
   44|      0|    public func any(matching condition: (Element) throws -> Bool) rethrows -> Bool {
   45|      0|        return try contains { try condition($0) }
   46|      0|    }
   47|       |
   48|       |    /// SwifterSwift: Get last element that satisfies a conditon.
   49|       |    ///
   50|       |    ///        [2, 2, 4, 7].last(where: {$0 % 2 == 0}) -> 4
   51|       |    ///
   52|       |    /// - Parameter condition: condition to evaluate each element against.
   53|       |    /// - Returns: the last element in the array matching the specified condition. (optional)
   54|      0|    public func last(where condition: (Element) throws -> Bool) rethrows -> Element? {
   55|      0|        for element in reversed() {
   56|      0|            if try condition(element) { return element }
   57|      0|        }
   58|      0|        return nil
   59|      0|    }
   60|       |
   61|       |    /// SwifterSwift: Filter elements based on a rejection condition.
   62|       |    ///
   63|       |    ///        [2, 2, 4, 7].reject(where: {$0 % 2 == 0}) -> [7]
   64|       |    ///
   65|       |    /// - Parameter condition: to evaluate the exclusion of an element from the array.
   66|       |    /// - Returns: the array with rejected values filtered from it.
   67|      0|    public func reject(where condition: (Element) throws -> Bool) rethrows -> [Element] {
   68|      0|        return try filter { return try !condition($0) }
   69|      0|    }
   70|       |
   71|       |    /// SwifterSwift: Get element count based on condition.
   72|       |    ///
   73|       |    ///        [2, 2, 4, 7].count(where: {$0 % 2 == 0}) -> 3
   74|       |    ///
   75|       |    /// - Parameter condition: condition to evaluate each element against.
   76|       |    /// - Returns: number of times the condition evaluated to true.
   77|      0|    public func count(where condition: (Element) throws -> Bool) rethrows -> Int {
   78|      0|        var count = 0
   79|      0|        for element in self where try condition(element) {
   80|      0|            count += 1
   81|      0|        }
   82|      0|        return count
   83|      0|    }
   84|       |
   85|       |    /// SwifterSwift: Iterate over a collection in reverse order. (right to left)
   86|       |    ///
   87|       |    ///        [0, 2, 4, 7].forEachReversed({ print($0)}) -> //Order of print: 7,4,2,0
   88|       |    ///
   89|       |    /// - Parameter body: a closure that takes an element of the array as a parameter.
   90|      0|    public func forEachReversed(_ body: (Element) throws -> Void) rethrows {
   91|      0|        try reversed().forEach(body)
   92|      0|    }
   93|       |
   94|       |    /// SwifterSwift: Calls the given closure with each element where condition is true.
   95|       |    ///
   96|       |    ///        [0, 2, 4, 7].forEach(where: {$0 % 2 == 0}, body: { print($0)}) -> //print: 0, 2, 4
   97|       |    ///
   98|       |    /// - Parameters:
   99|       |    ///   - condition: condition to evaluate each element against.
  100|       |    ///   - body: a closure that takes an element of the array as a parameter.
  101|      0|    public func forEach(where condition: (Element) throws -> Bool, body: (Element) throws -> Void) rethrows {
  102|      0|        for element in self where try condition(element) {
  103|      0|            try body(element)
  104|      0|        }
  105|      0|    }
  106|       |
  107|       |    /// SwifterSwift: Reduces an array while returning each interim combination.
  108|       |    ///
  109|       |    ///     [1, 2, 3].accumulate(initial: 0, next: +) -> [1, 3, 6]
  110|       |    ///
  111|       |    /// - Parameters:
  112|       |    ///   - initial: initial value.
  113|       |    ///   - next: closure that combines the accumulating value and next element of the array.
  114|       |    /// - Returns: an array of the final accumulated value and each interim combination.
  115|      0|    public func accumulate<U>(initial: U, next: (U, Element) throws -> U) rethrows -> [U] {
  116|      0|        var runningTotal = initial
  117|      0|        return try map { element in
  118|      0|            runningTotal = try next(runningTotal, element)
  119|      0|            return runningTotal
  120|      0|        }
  121|      0|    }
  122|       |
  123|       |    /// SwifterSwift: Filtered and map in a single operation.
  124|       |    ///
  125|       |    ///     [1,2,3,4,5].filtered({ $0 % 2 == 0 }, map: { $0.string }) -> ["2", "4"]
  126|       |    ///
  127|       |    /// - Parameters:
  128|       |    ///   - isIncluded: condition of inclusion to evaluate each element against.
  129|       |    ///   - transform: transform element function to evaluate every element.
  130|       |    /// - Returns: Return an filtered and mapped array.
  131|      0|    public func filtered<T>(_ isIncluded: (Element) throws -> Bool, map transform: (Element) throws -> T) rethrows ->  [T] {
  132|      0|        return try compactMap({
  133|      0|            if try isIncluded($0) {
  134|      0|                return try transform($0)
  135|      0|            }
  136|      0|            return nil
  137|      0|        })
  138|      0|    }
  139|       |
  140|       |    /// SwifterSwift: Get the only element based on a condition.
  141|       |    ///
  142|       |    ///     [].single(where: {_ in true}) -> nil
  143|       |    ///     [4].single(where: {_ in true}) -> 4
  144|       |    ///     [1, 4, 7].single(where: {$0 % 2 == 0}) -> 4
  145|       |    ///     [2, 2, 4, 7].single(where: {$0 % 2 == 0}) -> nil
  146|       |    ///
  147|       |    /// - Parameter condition: condition to evaluate each element against.
  148|       |    /// - Returns: The only element in the array matching the specified condition. If there are more matching elements, nil is returned. (optional)
  149|      0|    public func single(where condition: ((Element) throws -> Bool)) rethrows -> Element? {
  150|      0|        var singleElement: Element?
  151|      0|        for element in self where try condition(element) {
  152|      0|            guard singleElement == nil else {
  153|      0|                singleElement = nil
  154|      0|                break
  155|      0|            }
  156|      0|            singleElement = element
  157|      0|        }
  158|      0|        return singleElement
  159|      0|    }
  160|       |
  161|       |}
  162|       |
  163|       |public extension Sequence where Element: Equatable {
  164|       |
  165|       |    /// SwifterSwift: Check if array contains an array of elements.
  166|       |    ///
  167|       |    ///        [1, 2, 3, 4, 5].contains([1, 2]) -> true
  168|       |    ///        [1.2, 2.3, 4.5, 3.4, 4.5].contains([2, 6]) -> false
  169|       |    ///        ["h", "e", "l", "l", "o"].contains(["l", "o"]) -> true
  170|       |    ///
  171|       |    /// - Parameter elements: array of elements to check.
  172|       |    /// - Returns: true if array contains all given items.
  173|      0|    public func contains(_ elements: [Element]) -> Bool {
  174|      0|        guard !elements.isEmpty else { return true }
  175|      0|        for element in elements {
  176|      0|            if !contains(element) {
  177|      0|                return false
  178|      0|            }
  179|      0|        }
  180|      0|        return true
  181|      0|    }
  182|       |
  183|       |}
  184|       |
  185|       |public extension Sequence where Element: Hashable {
  186|       |
  187|       |    /// SwifterSwift: Check whether a sequence contains duplicates.
  188|       |    ///
  189|       |    /// - Returns: true if the receiver contains duplicates.
  190|      0|    public func containsDuplicates() -> Bool {
  191|      0|        var set = Set<Element>()
  192|      0|        for element in self {
  193|      0|            if !set.insert(element).inserted {
  194|      0|                return true
  195|      0|            }
  196|      0|        }
  197|      0|        return false
  198|      0|    }
  199|       |
  200|       |}
  201|       |
  202|       |// MARK: - Methods (Numeric)
  203|       |public extension Sequence where Element: Numeric {
  204|       |
  205|       |    /// SwifterSwift: Sum of all elements in array.
  206|       |    ///
  207|       |    ///        [1, 2, 3, 4, 5].sum() -> 15
  208|       |    ///
  209|       |    /// - Returns: sum of the array's elements.
  210|      0|    public func sum() -> Element {
  211|      0|        return reduce(0, {$0 + $1})
  212|      0|    }
  213|       |
  214|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/SignedIntegerExtensions.swift:
    1|       |//
    2|       |//  SignedIntegerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/15/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |#if canImport(Foundation)
    9|       |import Foundation
   10|       |#endif
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension SignedInteger {
   14|       |
   15|       |    /// SwifterSwift: Absolute value of integer number.
   16|      0|    public var abs: Self {
   17|      0|        return Swift.abs(self)
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Check if integer is positive.
   21|      0|    public var isPositive: Bool {
   22|      0|        return self > 0
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: Check if integer is negative.
   26|      0|    public var isNegative: Bool {
   27|      0|        return self < 0
   28|      0|    }
   29|       |
   30|       |    /// SwifterSwift: Check if integer is even.
   31|      0|    public var isEven: Bool {
   32|      0|        return (self % 2) == 0
   33|      0|    }
   34|       |
   35|       |    /// SwifterSwift: Check if integer is odd.
   36|      0|    public var isOdd: Bool {
   37|      0|        return (self % 2) != 0
   38|      0|    }
   39|       |
   40|       |    /// SwifterSwift: String of format (XXh XXm) from seconds Int.
   41|      0|    public var timeString: String {
   42|      0|        guard self > 0 else {
   43|      0|            return "0 sec"
   44|      0|        }
   45|      0|        if self < 60 {
   46|      0|            return "\(self) sec"
   47|      0|        }
   48|      0|        if self < 3600 {
   49|      0|            return "\(self / 60) min"
   50|      0|        }
   51|      0|        let hours = self / 3600
   52|      0|        let mins = (self % 3600) / 60
   53|      0|
   54|      0|        if hours != 0 && mins == 0 {
   55|      0|            return "\(hours)h"
   56|      0|        }
   57|      0|        return "\(hours)h \(mins)m"
   58|      0|    }
   59|       |
   60|       |}
   61|       |
   62|       |// MARK: - Methods
   63|       |public extension SignedInteger {
   64|       |
   65|       |    // swiftlint:disable next identifier_name
   66|       |    /// SwifterSwift: Greatest common divisor of integer value and n.
   67|       |    ///
   68|       |    /// - Parameter n: integer value to find gcd with.
   69|       |    /// - Returns: greatest common divisor of self and n.
   70|      0|    public func gcd(of n: Self) -> Self {
   71|      0|        return n == 0 ? self : n.gcd(of: self % n)
   72|      0|    }
   73|       |
   74|       |    // swiftlint:disable next identifier_name
   75|       |    /// SwifterSwift: Least common multiple of integer and n.
   76|       |    ///
   77|       |    /// - Parameter n: integer value to find lcm with.
   78|       |    /// - Returns: least common multiple of self and n.
   79|      0|    public func lcm(of n: Self) -> Self {
   80|      0|        return (self * n).abs / gcd(of: n)
   81|      0|    }
   82|       |
   83|       |    #if canImport(Foundation)
   84|       |    /// SwifterSwift: Ordinal representation of an integer.
   85|       |    ///
   86|       |    ///        print((12).ordinalString()) // prints "12th"
   87|       |    ///
   88|       |    /// - Parameter locale: locale, default is .current.
   89|       |    /// - Returns: string ordinal representation of number in specified locale language. E.g. input 92, output in "en": "92nd".
   90|       |    @available(iOS 9.0, macOS 10.11, *)
   91|      0|    public func ordinalString(locale: Locale = .current) -> String? {
   92|      0|        let formatter = NumberFormatter()
   93|      0|        formatter.locale = locale
   94|      0|        formatter.numberStyle = .ordinal
   95|      0|        guard let number = self as? NSNumber else { return nil }
   96|      0|        return formatter.string(from: number)
   97|      0|    }
   98|       |    #endif
   99|       |
  100|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/SignedNumericExtensions.swift:
    1|       |//
    2|       |//  SignedNumberExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/15/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |// MARK: - Properties
   14|       |public extension SignedNumeric {
   15|       |
   16|       |    /// SwifterSwift: String.
   17|      0|    public var string: String {
   18|      0|        return String(describing: self)
   19|      0|    }
   20|       |
   21|       |    #if canImport(Foundation)
   22|       |    /// SwifterSwift: String with number and current locale currency.
   23|      0|    public var asLocaleCurrency: String? {
   24|      0|        let formatter = NumberFormatter()
   25|      0|        formatter.numberStyle = .currency
   26|      0|        formatter.locale = Locale.current
   27|      0|        // swiftlint:disable next force_cast
   28|      0|        return formatter.string(from: self as! NSNumber)
   29|      0|    }
   30|       |    #endif
   31|       |
   32|       |}
   33|       |
   34|       |// MARK: - Methods
   35|       |public extension SignedNumeric {
   36|       |
   37|       |    #if canImport(Foundation)
   38|       |    /// SwifterSwift: Spelled out representation of a number.
   39|       |    ///
   40|       |    ///        print((12.32).spelledOutString()) // prints "twelve point three two"
   41|       |    ///
   42|       |    /// - Parameter locale: Locale, default is .current.
   43|       |    /// - Returns: String representation of number spelled in specified locale language. E.g. input 92, output in "en": "ninety-two"
   44|      0|    public func spelledOutString(locale: Locale = .current) -> String? {
   45|      0|        let formatter = NumberFormatter()
   46|      0|        formatter.locale = locale
   47|      0|        formatter.numberStyle = .spellOut
   48|      0|
   49|      0|        guard let number = self as? NSNumber else { return nil }
   50|      0|        return formatter.string(from: number)
   51|      0|    }
   52|       |    #endif
   53|       |
   54|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/StringExtensions.swift:
    1|       |//
    2|       |//  StringExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/5/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(Foundation)
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |#if canImport(UIKit)
   14|       |import UIKit
   15|       |#endif
   16|       |
   17|       |#if canImport(Cocoa)
   18|       |import Cocoa
   19|       |#endif
   20|       |
   21|       |#if canImport(CoreGraphics)
   22|       |import CoreGraphics
   23|       |#endif
   24|       |
   25|       |// MARK: - Properties
   26|       |public extension String {
   27|       |
   28|       |    #if canImport(Foundation)
   29|       |    /// SwifterSwift: String decoded from base64 (if applicable).
   30|       |    ///
   31|       |    ///		"SGVsbG8gV29ybGQh".base64Decoded = Optional("Hello World!")
   32|       |    ///
   33|      0|    public var base64Decoded: String? {
   34|      0|        // https://github.com/Reza-Rg/Base64-Swift-Extension/blob/master/Base64.swift
   35|      0|        guard let decodedData = Data(base64Encoded: self) else { return nil }
   36|      0|        return String(data: decodedData, encoding: .utf8)
   37|      0|    }
   38|       |    #endif
   39|       |
   40|       |    #if canImport(Foundation)
   41|       |    /// SwifterSwift: String encoded in base64 (if applicable).
   42|       |    ///
   43|       |    ///		"Hello World!".base64Encoded -> Optional("SGVsbG8gV29ybGQh")
   44|       |    ///
   45|      0|    public var base64Encoded: String? {
   46|      0|        // https://github.com/Reza-Rg/Base64-Swift-Extension/blob/master/Base64.swift
   47|      0|        let plainData = data(using: .utf8)
   48|      0|        return plainData?.base64EncodedString()
   49|      0|    }
   50|       |    #endif
   51|       |
   52|       |    /// SwifterSwift: Array of characters of a string.
   53|      0|    public var charactersArray: [Character] {
   54|      0|        return Array(self)
   55|      0|    }
   56|       |
   57|       |    #if canImport(Foundation)
   58|       |    /// SwifterSwift: CamelCase of string.
   59|       |    ///
   60|       |    ///		"sOme vAriable naMe".camelCased -> "someVariableName"
   61|       |    ///
   62|      0|    public var camelCased: String {
   63|      0|        let source = lowercased()
   64|      0|        let first = source[..<source.index(after: source.startIndex)]
   65|      0|        if source.contains(" ") {
   66|      0|            let connected = source.capitalized.replacingOccurrences(of: " ", with: "")
   67|      0|            let camel = connected.replacingOccurrences(of: "\n", with: "")
   68|      0|            let rest = String(camel.dropFirst())
   69|      0|            return first + rest
   70|      0|        }
   71|      0|        let rest = String(source.dropFirst())
   72|      0|        return first + rest
   73|      0|    }
   74|       |    #endif
   75|       |
   76|       |    /// SwifterSwift: Check if string contains one or more emojis.
   77|       |    ///
   78|       |    ///		"Hello 😀".containEmoji -> true
   79|       |    ///
   80|     15|    public var containEmoji: Bool {
   81|     15|        // http://stackoverflow.com/questions/30757193/find-out-if-character-in-string-is-emoji
   82|     85|        for scalar in unicodeScalars {
   83|     85|            switch scalar.value {
   84|     85|            case 0x3030, 0x00AE, 0x00A9, // Special Characters
   85|      1|            0x1D000...0x1F77F, // Emoticons
   86|      1|            0x2100...0x27BF, // Misc symbols and Dingbats
   87|      1|            0xFE00...0xFE0F, // Variation Selectors
   88|      1|            0x1F900...0x1F9FF: // Supplemental Symbols and Pictographs
   89|      1|                return true
   90|     85|            default:
   91|     84|                continue
   92|     85|            }
   93|     99|        }
   94|     99|        return false
   95|     15|    }
   96|       |
   97|       |    /// SwifterSwift: First character of string (if applicable).
   98|       |    ///
   99|       |    ///		"Hello".firstCharacterAsString -> Optional("H")
  100|       |    ///		"".firstCharacterAsString -> nil
  101|       |    ///
  102|      0|    public var firstCharacterAsString: String? {
  103|      0|        guard let first = self.first else { return nil }
  104|      0|        return String(first)
  105|      0|    }
  106|       |
  107|       |    #if canImport(Foundation)
  108|       |    /// SwifterSwift: Check if string contains one or more letters.
  109|       |    ///
  110|       |    ///		"123abc".hasLetters -> true
  111|       |    ///		"123".hasLetters -> false
  112|       |    ///
  113|      0|    public var hasLetters: Bool {
  114|      0|        return rangeOfCharacter(from: .letters, options: .numeric, range: nil) != nil
  115|      0|    }
  116|       |    #endif
  117|       |
  118|       |    #if canImport(Foundation)
  119|       |    /// SwifterSwift: Check if string contains one or more numbers.
  120|       |    ///
  121|       |    ///		"abcd".hasNumbers -> false
  122|       |    ///		"123abc".hasNumbers -> true
  123|       |    ///
  124|      0|    public var hasNumbers: Bool {
  125|      0|        return rangeOfCharacter(from: .decimalDigits, options: .literal, range: nil) != nil
  126|      0|    }
  127|       |    #endif
  128|       |
  129|       |    #if canImport(Foundation)
  130|       |    /// SwifterSwift: Check if string contains only letters.
  131|       |    ///
  132|       |    ///		"abc".isAlphabetic -> true
  133|       |    ///		"123abc".isAlphabetic -> false
  134|       |    ///
  135|      0|    public var isAlphabetic: Bool {
  136|      0|        let hasLetters = rangeOfCharacter(from: .letters, options: .numeric, range: nil) != nil
  137|      0|        let hasNumbers = rangeOfCharacter(from: .decimalDigits, options: .literal, range: nil) != nil
  138|      0|        return hasLetters && !hasNumbers
  139|      0|    }
  140|       |    #endif
  141|       |
  142|       |    #if canImport(Foundation)
  143|       |    /// SwifterSwift: Check if string contains at least one letter and one number.
  144|       |    ///
  145|       |    ///		// useful for passwords
  146|       |    ///		"123abc".isAlphaNumeric -> true
  147|       |    ///		"abc".isAlphaNumeric -> false
  148|       |    ///
  149|     16|    public var isAlphaNumeric: Bool {
  150|     16|        let hasLetters = rangeOfCharacter(from: .letters, options: .numeric, range: nil) != nil
  151|     16|        let hasNumbers = rangeOfCharacter(from: .decimalDigits, options: .literal, range: nil) != nil
  152|     16|        let comps = components(separatedBy: .alphanumerics)
  153|     16|        return comps.joined(separator: "").count == 0 && hasLetters && hasNumbers
  154|     16|    }
  155|       |    #endif
  156|       |
  157|       |    #if canImport(Foundation)
  158|       |    /// SwifterSwift: Check if string is valid email format.
  159|       |    ///
  160|       |    /// - Note: Note that this property does not validate the email address against an email server. It merely attempts to determine whether its format is suitable for an email address.
  161|       |    ///
  162|       |    ///		"john@doe.com".isValidEmail -> true
  163|       |    ///
  164|      0|    public var isValidEmail: Bool {
  165|      0|        // http://emailregex.com/
  166|      0|        let regex = "^(?:[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%\\&'*+/=?\\^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[\\p{L}0-9](?:[a-z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$"
  167|      0|        return range(of: regex, options: .regularExpression, range: nil, locale: nil) != nil
  168|      0|    }
  169|       |    #endif
  170|       |
  171|       |    #if canImport(Foundation)
  172|       |    /// SwifterSwift: Check if string is a valid URL.
  173|       |    ///
  174|       |    ///		"https://google.com".isValidUrl -> true
  175|       |    ///
  176|      0|    public var isValidUrl: Bool {
  177|      0|        return URL(string: self) != nil
  178|      0|    }
  179|       |    #endif
  180|       |
  181|       |    #if canImport(Foundation)
  182|       |    /// SwifterSwift: Check if string is a valid schemed URL.
  183|       |    ///
  184|       |    ///		"https://google.com".isValidSchemedUrl -> true
  185|       |    ///		"google.com".isValidSchemedUrl -> false
  186|       |    ///
  187|      0|    public var isValidSchemedUrl: Bool {
  188|      0|        guard let url = URL(string: self) else { return false }
  189|      0|        return url.scheme != nil
  190|      0|    }
  191|       |    #endif
  192|       |
  193|       |    #if canImport(Foundation)
  194|       |    /// SwifterSwift: Check if string is a valid https URL.
  195|       |    ///
  196|       |    ///		"https://google.com".isValidHttpsUrl -> true
  197|       |    ///
  198|      0|    public var isValidHttpsUrl: Bool {
  199|      0|        guard let url = URL(string: self) else { return false }
  200|      0|        return url.scheme == "https"
  201|      0|    }
  202|       |    #endif
  203|       |
  204|       |    #if canImport(Foundation)
  205|       |    /// SwifterSwift: Check if string is a valid http URL.
  206|       |    ///
  207|       |    ///		"http://google.com".isValidHttpUrl -> true
  208|       |    ///
  209|      0|    public var isValidHttpUrl: Bool {
  210|      0|        guard let url = URL(string: self) else { return false }
  211|      0|        return url.scheme == "http"
  212|      0|    }
  213|       |    #endif
  214|       |
  215|       |    #if canImport(Foundation)
  216|       |    /// SwifterSwift: Check if string is a valid file URL.
  217|       |    ///
  218|       |    ///		"file://Documents/file.txt".isValidFileUrl -> true
  219|       |    ///
  220|      0|    public var isValidFileUrl: Bool {
  221|      0|        return URL(string: self)?.isFileURL ?? false
  222|      0|    }
  223|       |    #endif
  224|       |
  225|       |    #if canImport(Foundation)
  226|       |    /// SwifterSwift: Check if string is a valid Swift number.
  227|       |    ///
  228|       |    /// Note:
  229|       |    /// In North America, "." is the decimal separator,
  230|       |    /// while in many parts of Europe "," is used,
  231|       |    ///
  232|       |    ///		"123".isNumeric -> true
  233|       |    ///     "1.3".isNumeric -> true (en_US)
  234|       |    ///     "1,3".isNumeric -> true (fr_FR)
  235|       |    ///		"abc".isNumeric -> false
  236|       |    ///
  237|      0|    public var isNumeric: Bool {
  238|      0|        let scanner = Scanner(string: self)
  239|      0|        scanner.locale = NSLocale.current
  240|      0|        return scanner.scanDecimal(nil) && scanner.isAtEnd
  241|      0|    }
  242|       |    #endif
  243|       |
  244|       |    #if canImport(Foundation)
  245|       |    /// SwifterSwift: Check if string only contains digits.
  246|       |    ///
  247|       |    ///     "123".isDigits -> true
  248|       |    ///     "1.3".isDigits -> false
  249|       |    ///     "abc".isDigits -> false
  250|       |    ///
  251|      0|    public var isDigits: Bool {
  252|      0|        return CharacterSet.decimalDigits.isSuperset(of: CharacterSet(charactersIn: self))
  253|      0|    }
  254|       |    #endif
  255|       |
  256|       |    /// SwifterSwift: Last character of string (if applicable).
  257|       |    ///
  258|       |    ///		"Hello".lastCharacterAsString -> Optional("o")
  259|       |    ///		"".lastCharacterAsString -> nil
  260|       |    ///
  261|      0|    public var lastCharacterAsString: String? {
  262|      0|        guard let last = self.last else { return nil }
  263|      0|        return String(last)
  264|      0|    }
  265|       |
  266|       |    #if canImport(Foundation)
  267|       |    /// SwifterSwift: Latinized string.
  268|       |    ///
  269|       |    ///		"Hèllö Wórld!".latinized -> "Hello World!"
  270|       |    ///
  271|      0|    public var latinized: String {
  272|      0|        return folding(options: .diacriticInsensitive, locale: Locale.current)
  273|      0|    }
  274|       |    #endif
  275|       |
  276|       |    #if canImport(Foundation)
  277|       |    /// SwifterSwift: Bool value from string (if applicable).
  278|       |    ///
  279|       |    ///		"1".bool -> true
  280|       |    ///		"False".bool -> false
  281|       |    ///		"Hello".bool = nil
  282|       |    ///
  283|      0|    public var bool: Bool? {
  284|      0|        let selfLowercased = trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
  285|      0|        switch selfLowercased {
  286|      0|        case "true", "1":
  287|      0|            return true
  288|      0|        case "false", "0":
  289|      0|            return false
  290|      0|        default:
  291|      0|            return nil
  292|      0|        }
  293|      0|    }
  294|       |    #endif
  295|       |
  296|       |    #if canImport(Foundation)
  297|       |    /// SwifterSwift: Date object from "yyyy-MM-dd" formatted string.
  298|       |    ///
  299|       |    ///		"2007-06-29".date -> Optional(Date)
  300|       |    ///
  301|      0|    public var date: Date? {
  302|      0|        let selfLowercased = trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
  303|      0|        let formatter = DateFormatter()
  304|      0|        formatter.timeZone = TimeZone.current
  305|      0|        formatter.dateFormat = "yyyy-MM-dd"
  306|      0|        return formatter.date(from: selfLowercased)
  307|      0|    }
  308|       |    #endif
  309|       |
  310|       |    #if canImport(Foundation)
  311|       |    /// SwifterSwift: Date object from "yyyy-MM-dd HH:mm:ss" formatted string.
  312|       |    ///
  313|       |    ///		"2007-06-29 14:23:09".dateTime -> Optional(Date)
  314|       |    ///
  315|      0|    public var dateTime: Date? {
  316|      0|        let selfLowercased = trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
  317|      0|        let formatter = DateFormatter()
  318|      0|        formatter.timeZone = TimeZone.current
  319|      0|        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
  320|      0|        return formatter.date(from: selfLowercased)
  321|      0|    }
  322|       |    #endif
  323|       |
  324|       |    /// SwifterSwift: Integer value from string (if applicable).
  325|       |    ///
  326|       |    ///		"101".int -> 101
  327|       |    ///
  328|      0|    public var int: Int? {
  329|      0|        return Int(self)
  330|      0|    }
  331|       |
  332|       |    /// SwifterSwift: Lorem ipsum string of given length.
  333|       |    ///
  334|       |    /// - Parameter length: number of characters to limit lorem ipsum to (default is 445 - full lorem ipsum).
  335|       |    /// - Returns: Lorem ipsum dolor sit amet... string.
  336|      0|    public static func loremIpsum(ofLength length: Int = 445) -> String {
  337|      0|        guard length > 0 else { return "" }
  338|      0|
  339|      0|        // https://www.lipsum.com/
  340|      0|        let loremIpsum = """
  341|      0|		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
  342|      0|		"""
  343|      0|        if loremIpsum.count > length {
  344|      0|            return String(loremIpsum[loremIpsum.startIndex..<loremIpsum.index(loremIpsum.startIndex, offsetBy: length)])
  345|      0|        }
  346|      0|        return loremIpsum
  347|      0|    }
  348|       |
  349|       |    #if canImport(Foundation)
  350|       |    /// SwifterSwift: URL from string (if applicable).
  351|       |    ///
  352|       |    ///		"https://google.com".url -> URL(string: "https://google.com")
  353|       |    ///		"not url".url -> nil
  354|       |    ///
  355|      0|    public var url: URL? {
  356|      0|        return URL(string: self)
  357|      0|    }
  358|       |    #endif
  359|       |
  360|       |    #if canImport(Foundation)
  361|       |    /// SwifterSwift: String with no spaces or new lines in beginning and end.
  362|       |    ///
  363|       |    ///		"   hello  \n".trimmed -> "hello"
  364|       |    ///
  365|      0|    public var trimmed: String {
  366|      0|        return trimmingCharacters(in: .whitespacesAndNewlines)
  367|      0|    }
  368|       |    #endif
  369|       |
  370|       |    #if canImport(Foundation)
  371|       |    /// SwifterSwift: Readable string from a URL string.
  372|       |    ///
  373|       |    ///		"it's%20easy%20to%20decode%20strings".urlDecoded -> "it's easy to decode strings"
  374|       |    ///
  375|      0|    public var urlDecoded: String {
  376|      0|        return removingPercentEncoding ?? self
  377|      0|    }
  378|       |    #endif
  379|       |
  380|       |    #if canImport(Foundation)
  381|       |    /// SwifterSwift: URL escaped string.
  382|       |    ///
  383|       |    ///		"it's easy to encode strings".urlEncoded -> "it's%20easy%20to%20encode%20strings"
  384|       |    ///
  385|      0|    public var urlEncoded: String {
  386|      0|        return addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
  387|      0|    }
  388|       |    #endif
  389|       |
  390|       |    #if canImport(Foundation)
  391|       |    /// SwifterSwift: String without spaces and new lines.
  392|       |    ///
  393|       |    ///		"   \n Swifter   \n  Swift  ".withoutSpacesAndNewLines -> "SwifterSwift"
  394|       |    ///
  395|      0|    public var withoutSpacesAndNewLines: String {
  396|      0|        return replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "\n", with: "")
  397|      0|    }
  398|       |    #endif
  399|       |
  400|       |    #if canImport(Foundation)
  401|       |    /// SwifterSwift: Check if the given string contains only white spaces
  402|      0|    public var isWhitespace: Bool {
  403|      0|        return self.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
  404|      0|    }
  405|       |    #endif
  406|       |
  407|       |    #if os(iOS) || os(tvOS)
  408|       |    /// SwifterSwift: Check if the given string spelled correctly
  409|      0|    public var isSpelledCorrectly: Bool {
  410|      0|        let checker = UITextChecker()
  411|      0|        let range = NSRange(location: 0, length: self.utf16.count)
  412|      0|
  413|      0|        let misspelledRange = checker.rangeOfMisspelledWord(in: self, range: range, startingAt: 0, wrap: false, language: Locale.preferredLanguages.first ?? "en")
  414|      0|        return misspelledRange.location == NSNotFound
  415|      0|    }
  416|       |    #endif
  417|       |
  418|       |}
  419|       |
  420|       |// MARK: - Methods
  421|       |public extension String {
  422|       |
  423|       |    #if canImport(Foundation)
  424|       |    /// Float value from string (if applicable).
  425|       |    ///
  426|       |    /// - Parameter locale: Locale (default is Locale.current)
  427|       |    /// - Returns: Optional Float value from given string.
  428|      0|    public func float(locale: Locale = .current) -> Float? {
  429|      0|        let formatter = NumberFormatter()
  430|      0|        formatter.locale = locale
  431|      0|        formatter.allowsFloats = true
  432|      0|        return formatter.number(from: self)?.floatValue
  433|      0|    }
  434|       |    #endif
  435|       |
  436|       |    #if canImport(Foundation)
  437|       |    /// Double value from string (if applicable).
  438|       |    ///
  439|       |    /// - Parameter locale: Locale (default is Locale.current)
  440|       |    /// - Returns: Optional Double value from given string.
  441|      0|    public func double(locale: Locale = .current) -> Double? {
  442|      0|        let formatter = NumberFormatter()
  443|      0|        formatter.locale = locale
  444|      0|        formatter.allowsFloats = true
  445|      0|        return formatter.number(from: self)?.doubleValue
  446|      0|    }
  447|       |    #endif
  448|       |
  449|       |    #if canImport(CoreGraphics) && canImport(Foundation)
  450|       |    /// CGFloat value from string (if applicable).
  451|       |    ///
  452|       |    /// - Parameter locale: Locale (default is Locale.current)
  453|       |    /// - Returns: Optional CGFloat value from given string.
  454|      0|    public func cgFloat(locale: Locale = .current) -> CGFloat? {
  455|      0|        let formatter = NumberFormatter()
  456|      0|        formatter.locale = locale
  457|      0|        formatter.allowsFloats = true
  458|      0|        return formatter.number(from: self) as? CGFloat
  459|      0|    }
  460|       |    #endif
  461|       |
  462|       |    #if canImport(Foundation)
  463|       |    /// SwifterSwift: Array of strings separated by new lines.
  464|       |    ///
  465|       |    ///		"Hello\ntest".lines() -> ["Hello", "test"]
  466|       |    ///
  467|       |    /// - Returns: Strings separated by new lines.
  468|      0|    public func lines() -> [String] {
  469|      0|        var result = [String]()
  470|      0|        enumerateLines { line, _ in
  471|      0|            result.append(line)
  472|      0|        }
  473|      0|        return result
  474|      0|    }
  475|       |    #endif
  476|       |
  477|       |    #if canImport(Foundation)
  478|       |    /// SwifterSwift: Returns a localized string, with an optional comment for translators.
  479|       |    ///
  480|       |    ///        "Hello world".localized -> Hallo Welt
  481|       |    ///
  482|      0|    public func localized(comment: String = "") -> String {
  483|      0|        return NSLocalizedString(self, comment: comment)
  484|      0|    }
  485|       |    #endif
  486|       |
  487|       |    /// SwifterSwift: The most common character in string.
  488|       |    ///
  489|       |    ///		"This is a test, since e is appearing everywhere e should be the common character".mostCommonCharacter() -> "e"
  490|       |    ///
  491|       |    /// - Returns: The most common character.
  492|      0|    public func mostCommonCharacter() -> Character? {
  493|      0|        let mostCommon = withoutSpacesAndNewLines.reduce(into: [Character: Int]()) {
  494|      0|            let count = $0[$1] ?? 0
  495|      0|            $0[$1] = count + 1
  496|      0|            }.max { $0.1 < $1.1 }?.0
  497|      0|
  498|      0|        return mostCommon
  499|      0|    }
  500|       |
  501|       |    /// SwifterSwift: Array with unicodes for all characters in a string.
  502|       |    ///
  503|       |    ///		"SwifterSwift".unicodeArray() -> [83, 119, 105, 102, 116, 101, 114, 83, 119, 105, 102, 116]
  504|       |    ///
  505|       |    /// - Returns: The unicodes for all characters in a string.
  506|      0|    public func unicodeArray() -> [Int] {
  507|      0|        return unicodeScalars.map { Int($0.value) }
  508|      0|    }
  509|       |
  510|       |    #if canImport(Foundation)
  511|       |    /// SwifterSwift: an array of all words in a string
  512|       |    ///
  513|       |    ///		"Swift is amazing".words() -> ["Swift", "is", "amazing"]
  514|       |    ///
  515|       |    /// - Returns: The words contained in a string.
  516|      0|    public func words() -> [String] {
  517|      0|        // https://stackoverflow.com/questions/42822838
  518|      0|        let chararacterSet = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)
  519|      0|        let comps = components(separatedBy: chararacterSet)
  520|      0|        return comps.filter { !$0.isEmpty }
  521|      0|    }
  522|       |    #endif
  523|       |
  524|       |    #if canImport(Foundation)
  525|       |    /// SwifterSwift: Count of words in a string.
  526|       |    ///
  527|       |    ///		"Swift is amazing".wordsCount() -> 3
  528|       |    ///
  529|       |    /// - Returns: The count of words contained in a string.
  530|      0|    public func wordCount() -> Int {
  531|      0|        // https://stackoverflow.com/questions/42822838
  532|      0|        let chararacterSet = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)
  533|      0|        let comps = components(separatedBy: chararacterSet)
  534|      0|        let words = comps.filter { !$0.isEmpty }
  535|      0|        return words.count
  536|      0|    }
  537|       |    #endif
  538|       |
  539|       |    #if canImport(Foundation)
  540|       |    /// SwifterSwift: Transforms the string into a slug string.
  541|       |    ///
  542|       |    ///        "Swift is amazing".toSlug() -> "swift-is-amazing"
  543|       |    ///
  544|       |    /// - Returns: The string in slug format.
  545|      0|    public func toSlug() -> String {
  546|      0|        let lowercased = self.lowercased()
  547|      0|        let latinized = lowercased.latinized
  548|      0|        let withDashes = latinized.replacingOccurrences(of: " ", with: "-")
  549|      0|
  550|      0|        let alphanumerics = NSCharacterSet.alphanumerics
  551|      0|        var filtered = withDashes.filter {
  552|      0|            guard String($0) != "-" else { return true }
  553|      0|            guard String($0) != "&" else { return true }
  554|      0|            return String($0).rangeOfCharacter(from: alphanumerics) != nil
  555|      0|        }
  556|      0|
  557|      0|        while filtered.lastCharacterAsString == "-" {
  558|      0|            filtered = String(filtered.dropLast())
  559|      0|        }
  560|      0|
  561|      0|        while filtered.firstCharacterAsString == "-" {
  562|      0|            filtered = String(filtered.dropFirst())
  563|      0|        }
  564|      0|
  565|      0|        return filtered.replacingOccurrences(of: "--", with: "-")
  566|      0|    }
  567|       |    #endif
  568|       |
  569|       |    // swiftlint:disable next identifier_name
  570|       |    /// SwifterSwift: Safely subscript string with index.
  571|       |    ///
  572|       |    ///		"Hello World!"[safe: 3] -> "l"
  573|       |    ///		"Hello World!"[safe: 20] -> nil
  574|       |    ///
  575|       |    /// - Parameter i: index.
  576|      0|    public subscript(safe i: Int) -> Character? {
  577|      0|        guard i >= 0 && i < count else { return nil }
  578|      0|        return self[index(startIndex, offsetBy: i)]
  579|      0|    }
  580|       |
  581|       |    /// SwifterSwift: Safely subscript string within a half-open range.
  582|       |    ///
  583|       |    ///		"Hello World!"[safe: 6..<11] -> "World"
  584|       |    ///		"Hello World!"[safe: 21..<110] -> nil
  585|       |    ///
  586|       |    /// - Parameter range: Half-open range.
  587|      0|    public subscript(safe range: CountableRange<Int>) -> String? {
  588|      0|        guard let lowerIndex = index(startIndex, offsetBy: max(0, range.lowerBound), limitedBy: endIndex) else { return nil }
  589|      0|        guard let upperIndex = index(lowerIndex, offsetBy: range.upperBound - range.lowerBound, limitedBy: endIndex) else { return nil }
  590|      0|        return String(self[lowerIndex..<upperIndex])
  591|      0|    }
  592|       |
  593|       |    /// SwifterSwift: Safely subscript string within a closed range.
  594|       |    ///
  595|       |    ///		"Hello World!"[safe: 6...11] -> "World!"
  596|       |    ///		"Hello World!"[safe: 21...110] -> nil
  597|       |    ///
  598|       |    /// - Parameter range: Closed range.
  599|      0|    public subscript(safe range: ClosedRange<Int>) -> String? {
  600|      0|        guard let lowerIndex = index(startIndex, offsetBy: max(0, range.lowerBound), limitedBy: endIndex) else { return nil }
  601|      0|        guard let upperIndex = index(lowerIndex, offsetBy: range.upperBound - range.lowerBound + 1, limitedBy: endIndex) else { return nil }
  602|      0|        return String(self[lowerIndex..<upperIndex])
  603|      0|    }
  604|       |
  605|       |    #if os(iOS) || os(macOS)
  606|       |    /// SwifterSwift: Copy string to global pasteboard.
  607|       |    ///
  608|       |    ///		"SomeText".copyToPasteboard() // copies "SomeText" to pasteboard
  609|       |    ///
  610|      0|    public func copyToPasteboard() {
  611|      0|        #if os(iOS)
  612|      0|        UIPasteboard.general.string = self
  613|      0|        #elseif os(macOS)
  614|      0|        NSPasteboard.general.clearContents()
  615|      0|        NSPasteboard.general.setString(self, forType: .string)
  616|      0|        #endif
  617|      0|    }
  618|       |    #endif
  619|       |
  620|       |    /// SwifterSwift: Converts string format to CamelCase.
  621|       |    ///
  622|       |    ///		var str = "sOme vaRiabLe Name"
  623|       |    ///		str.camelize()
  624|       |    ///		print(str) // prints "someVariableName"
  625|       |    ///
  626|      0|    public mutating func camelize() {
  627|      0|        let source = lowercased()
  628|      0|        let first = source[..<source.index(after: source.startIndex)]
  629|      0|        if source.contains(" ") {
  630|      0|            let connected = source.capitalized.replacingOccurrences(of: " ", with: "")
  631|      0|            let camel = connected.replacingOccurrences(of: "\n", with: "")
  632|      0|            let rest = String(camel.dropFirst())
  633|      0|            self = first + rest
  634|      0|            return
  635|      0|        }
  636|      0|        let rest = String(source.dropFirst())
  637|      0|
  638|      0|        self = first + rest
  639|      0|    }
  640|       |
  641|       |    /// SwifterSwift: First character of string uppercased(if applicable) while keeping the original string.
  642|       |    ///
  643|       |    ///        "hello world".firstCharacterUppercased() -> "Hello world"
  644|       |    ///        "".firstCharacterUppercased() -> ""
  645|       |    ///
  646|      0|    public mutating func firstCharacterUppercased() {
  647|      0|        guard let first = first else { return }
  648|      0|        self = String(first).uppercased() + dropFirst()
  649|      0|    }
  650|       |
  651|       |    /// SwifterSwift: Check if string contains only unique characters.
  652|       |    ///
  653|      0|    public func hasUniqueCharacters() -> Bool {
  654|      0|        guard count > 0 else { return false }
  655|      0|        var uniqueChars = Set<String>()
  656|      0|        for char in self {
  657|      0|            if uniqueChars.contains(String(char)) { return false }
  658|      0|            uniqueChars.insert(String(char))
  659|      0|        }
  660|      0|        return true
  661|      0|    }
  662|       |
  663|       |    #if canImport(Foundation)
  664|       |    /// SwifterSwift: Check if string contains one or more instance of substring.
  665|       |    ///
  666|       |    ///		"Hello World!".contain("O") -> false
  667|       |    ///		"Hello World!".contain("o", caseSensitive: false) -> true
  668|       |    ///
  669|       |    /// - Parameters:
  670|       |    ///   - string: substring to search for.
  671|       |    ///   - caseSensitive: set true for case sensitive search (default is true).
  672|       |    /// - Returns: true if string contains one or more instance of substring.
  673|       |    public func contains(_ string: String, caseSensitive: Bool = true) -> Bool {
  674|       |        if !caseSensitive {
  675|       |            return range(of: string, options: .caseInsensitive) != nil
  676|       |        }
  677|       |        return range(of: string) != nil
  678|       |    }
  679|       |    #endif
  680|       |
  681|       |    #if canImport(Foundation)
  682|       |    /// SwifterSwift: Count of substring in string.
  683|       |    ///
  684|       |    ///		"Hello World!".count(of: "o") -> 2
  685|       |    ///		"Hello World!".count(of: "L", caseSensitive: false) -> 3
  686|       |    ///
  687|       |    /// - Parameters:
  688|       |    ///   - string: substring to search for.
  689|       |    ///   - caseSensitive: set true for case sensitive search (default is true).
  690|       |    /// - Returns: count of appearance of substring in string.
  691|      0|    public func count(of string: String, caseSensitive: Bool = true) -> Int {
  692|      0|        if !caseSensitive {
  693|      0|            return lowercased().components(separatedBy: string.lowercased()).count - 1
  694|      0|        }
  695|      0|        return components(separatedBy: string).count - 1
  696|      0|    }
  697|       |    #endif
  698|       |
  699|       |    /// SwifterSwift: Check if string ends with substring.
  700|       |    ///
  701|       |    ///		"Hello World!".ends(with: "!") -> true
  702|       |    ///		"Hello World!".ends(with: "WoRld!", caseSensitive: false) -> true
  703|       |    ///
  704|       |    /// - Parameters:
  705|       |    ///   - suffix: substring to search if string ends with.
  706|       |    ///   - caseSensitive: set true for case sensitive search (default is true).
  707|       |    /// - Returns: true if string ends with substring.
  708|      0|    public func ends(with suffix: String, caseSensitive: Bool = true) -> Bool {
  709|      0|        if !caseSensitive {
  710|      0|            return lowercased().hasSuffix(suffix.lowercased())
  711|      0|        }
  712|      0|        return hasSuffix(suffix)
  713|      0|    }
  714|       |
  715|       |    #if canImport(Foundation)
  716|       |    /// SwifterSwift: Latinize string.
  717|       |    ///
  718|       |    ///		var str = "Hèllö Wórld!"
  719|       |    ///		str.latinize()
  720|       |    ///		print(str) // prints "Hello World!"
  721|       |    ///
  722|      0|    public mutating func latinize() {
  723|      0|        self = folding(options: .diacriticInsensitive, locale: Locale.current)
  724|      0|    }
  725|       |    #endif
  726|       |
  727|       |    /// SwifterSwift: Random string of given length.
  728|       |    ///
  729|       |    ///		String.random(ofLength: 18) -> "u7MMZYvGo9obcOcPj8"
  730|       |    ///
  731|       |    /// - Parameter length: number of characters in string.
  732|       |    /// - Returns: random string of given length.
  733|      0|    public static func random(ofLength length: Int) -> String {
  734|      0|        guard length > 0 else { return "" }
  735|      0|        let base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  736|      0|        var randomString = ""
  737|      0|        for _ in 1...length {
  738|      0|            let randomIndex = Int.random(in: 0..<base.count)
  739|      0|            let randomCharacter = base.charactersArray[Int(randomIndex)]
  740|      0|            randomString.append(randomCharacter)
  741|      0|        }
  742|      0|        return randomString
  743|      0|    }
  744|       |
  745|       |    /// SwifterSwift: Reverse string.
  746|      0|    public mutating func reverse() {
  747|      0|        let chars: [Character] = reversed()
  748|      0|        self = String(chars)
  749|      0|    }
  750|       |
  751|       |    // swiftlint:disable next identifier_name
  752|       |    /// SwifterSwift: Sliced string from a start index with length.
  753|       |    ///
  754|       |    ///        "Hello World".slicing(from: 6, length: 5) -> "World"
  755|       |    ///
  756|       |    /// - Parameters:
  757|       |    ///   - i: string index the slicing should start from.
  758|       |    ///   - length: amount of characters to be sliced after given index.
  759|       |    /// - Returns: sliced substring of length number of characters (if applicable) (example: "Hello World".slicing(from: 6, length: 5) -> "World")
  760|      0|    public func slicing(from i: Int, length: Int) -> String? {
  761|      0|        guard length >= 0, i >= 0, i < count  else { return nil }
  762|      0|        guard i.advanced(by: length) <= count else {
  763|      0|            return self[safe: i..<count]
  764|      0|        }
  765|      0|        guard length > 0 else { return "" }
  766|      0|        return self[safe: i..<i.advanced(by: length)]
  767|      0|    }
  768|       |
  769|       |    // swiftlint:disable next identifier_name
  770|       |    /// SwifterSwift: Slice given string from a start index with length (if applicable).
  771|       |    ///
  772|       |    ///		var str = "Hello World"
  773|       |    ///		str.slice(from: 6, length: 5)
  774|       |    ///		print(str) // prints "World"
  775|       |    ///
  776|       |    /// - Parameters:
  777|       |    ///   - i: string index the slicing should start from.
  778|       |    ///   - length: amount of characters to be sliced after given index.
  779|      0|    public mutating func slice(from i: Int, length: Int) {
  780|      0|        if let str = self.slicing(from: i, length: length) {
  781|      0|            self = String(str)
  782|      0|        }
  783|      0|    }
  784|       |
  785|       |    /// SwifterSwift: Slice given string from a start index to an end index (if applicable).
  786|       |    ///
  787|       |    ///		var str = "Hello World"
  788|       |    ///		str.slice(from: 6, to: 11)
  789|       |    ///		print(str) // prints "World"
  790|       |    ///
  791|       |    /// - Parameters:
  792|       |    ///   - start: string index the slicing should start from.
  793|       |    ///   - end: string index the slicing should end at.
  794|      0|    public mutating func slice(from start: Int, to end: Int) {
  795|      0|        guard end >= start else { return }
  796|      0|        if let str = self[safe: start..<end] {
  797|      0|            self = str
  798|      0|        }
  799|      0|    }
  800|       |
  801|       |    // swiftlint:disable next identifier_name
  802|       |    /// SwifterSwift: Slice given string from a start index (if applicable).
  803|       |    ///
  804|       |    ///		var str = "Hello World"
  805|       |    ///		str.slice(at: 6)
  806|       |    ///		print(str) // prints "World"
  807|       |    ///
  808|       |    /// - Parameter i: string index the slicing should start from.
  809|      0|    public mutating func slice(at i: Int) {
  810|      0|        guard i < count else { return }
  811|      0|        if let str = self[safe: i..<count] {
  812|      0|            self = str
  813|      0|        }
  814|      0|    }
  815|       |
  816|       |    /// SwifterSwift: Check if string starts with substring.
  817|       |    ///
  818|       |    ///		"hello World".starts(with: "h") -> true
  819|       |    ///		"hello World".starts(with: "H", caseSensitive: false) -> true
  820|       |    ///
  821|       |    /// - Parameters:
  822|       |    ///   - suffix: substring to search if string starts with.
  823|       |    ///   - caseSensitive: set true for case sensitive search (default is true).
  824|       |    /// - Returns: true if string starts with substring.
  825|      0|    public func starts(with prefix: String, caseSensitive: Bool = true) -> Bool {
  826|      0|        if !caseSensitive {
  827|      0|            return lowercased().hasPrefix(prefix.lowercased())
  828|      0|        }
  829|      0|        return hasPrefix(prefix)
  830|      0|    }
  831|       |
  832|       |    #if canImport(Foundation)
  833|       |    /// SwifterSwift: Date object from string of date format.
  834|       |    ///
  835|       |    ///		"2017-01-15".date(withFormat: "yyyy-MM-dd") -> Date set to Jan 15, 2017
  836|       |    ///		"not date string".date(withFormat: "yyyy-MM-dd") -> nil
  837|       |    ///
  838|       |    /// - Parameter format: date format.
  839|       |    /// - Returns: Date object from string (if applicable).
  840|      0|    public func date(withFormat format: String) -> Date? {
  841|      0|        let dateFormatter = DateFormatter()
  842|      0|        dateFormatter.dateFormat = format
  843|      0|        return dateFormatter.date(from: self)
  844|      0|    }
  845|       |    #endif
  846|       |
  847|       |    #if canImport(Foundation)
  848|       |    /// SwifterSwift: Removes spaces and new lines in beginning and end of string.
  849|       |    ///
  850|       |    ///		var str = "  \n Hello World \n\n\n"
  851|       |    ///		str.trim()
  852|       |    ///		print(str) // prints "Hello World"
  853|       |    ///
  854|      0|    public mutating func trim() {
  855|      0|        self = trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
  856|      0|    }
  857|       |    #endif
  858|       |
  859|       |    /// SwifterSwift: Truncate string (cut it to a given number of characters).
  860|       |    ///
  861|       |    ///		var str = "This is a very long sentence"
  862|       |    ///		str.truncate(toLength: 14)
  863|       |    ///		print(str) // prints "This is a very..."
  864|       |    ///
  865|       |    /// - Parameters:
  866|       |    ///   - toLength: maximum number of characters before cutting.
  867|       |    ///   - trailing: string to add at the end of truncated string (default is "...").
  868|      0|    public mutating func truncate(toLength length: Int, trailing: String? = "...") {
  869|      0|        guard length > 0 else { return }
  870|      0|        if count > length {
  871|      0|            self = self[startIndex..<index(startIndex, offsetBy: length)] + (trailing ?? "")
  872|      0|        }
  873|      0|    }
  874|       |
  875|       |    /// SwifterSwift: Truncated string (limited to a given number of characters).
  876|       |    ///
  877|       |    ///		"This is a very long sentence".truncated(toLength: 14) -> "This is a very..."
  878|       |    ///		"Short sentence".truncated(toLength: 14) -> "Short sentence"
  879|       |    ///
  880|       |    /// - Parameters:
  881|       |    ///   - toLength: maximum number of characters before cutting.
  882|       |    ///   - trailing: string to add at the end of truncated string.
  883|       |    /// - Returns: truncated string (this is an extr...).
  884|      0|    public func truncated(toLength length: Int, trailing: String? = "...") -> String {
  885|      0|        guard 1..<count ~= length else { return self }
  886|      0|        return self[startIndex..<index(startIndex, offsetBy: length)] + (trailing ?? "")
  887|      0|    }
  888|       |
  889|       |    #if canImport(Foundation)
  890|       |    /// SwifterSwift: Convert URL string to readable string.
  891|       |    ///
  892|       |    ///		var str = "it's%20easy%20to%20decode%20strings"
  893|       |    ///		str.urlDecode()
  894|       |    ///		print(str) // prints "it's easy to decode strings"
  895|       |    ///
  896|      0|    public mutating func urlDecode() {
  897|      0|        if let decoded = removingPercentEncoding {
  898|      0|            self = decoded
  899|      0|        }
  900|      0|    }
  901|       |    #endif
  902|       |
  903|       |    #if canImport(Foundation)
  904|       |    /// SwifterSwift: Escape string.
  905|       |    ///
  906|       |    ///		var str = "it's easy to encode strings"
  907|       |    ///		str.urlEncode()
  908|       |    ///		print(str) // prints "it's%20easy%20to%20encode%20strings"
  909|       |    ///
  910|      0|    public mutating func urlEncode() {
  911|      0|        if let encoded = addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) {
  912|      0|            self = encoded
  913|      0|        }
  914|      0|    }
  915|       |    #endif
  916|       |
  917|       |    #if canImport(Foundation)
  918|       |    /// SwifterSwift: Verify if string matches the regex pattern.
  919|       |    ///
  920|       |    /// - Parameter pattern: Pattern to verify.
  921|       |    /// - Returns: true if string matches the pattern.
  922|      0|    public func matches(pattern: String) -> Bool {
  923|      0|        return range(of: pattern, options: .regularExpression, range: nil, locale: nil) != nil
  924|      0|    }
  925|       |    #endif
  926|       |
  927|       |    /// SwifterSwift: Pad string to fit the length parameter size with another string in the start.
  928|       |    ///
  929|       |    ///   "hue".padStart(10) -> "       hue"
  930|       |    ///   "hue".padStart(10, with: "br") -> "brbrbrbhue"
  931|       |    ///
  932|       |    /// - Parameter length: The target length to pad.
  933|       |    /// - Parameter string: Pad string. Default is " ".
  934|      0|    public mutating func padStart(_ length: Int, with string: String = " ") {
  935|      0|        self = paddingStart(length, with: string)
  936|      0|    }
  937|       |
  938|       |    /// SwifterSwift: Returns a string by padding to fit the length parameter size with another string in the start.
  939|       |    ///
  940|       |    ///   "hue".paddingStart(10) -> "       hue"
  941|       |    ///   "hue".paddingStart(10, with: "br") -> "brbrbrbhue"
  942|       |    ///
  943|       |    /// - Parameter length: The target length to pad.
  944|       |    /// - Parameter string: Pad string. Default is " ".
  945|       |    /// - Returns: The string with the padding on the start.
  946|       |    public func paddingStart(_ length: Int, with string: String = " ") -> String {
  947|       |        guard count < length else { return self }
  948|       |
  949|       |        let padLength = length - count
  950|       |        if padLength < string.count {
  951|       |            return string[string.startIndex..<string.index(string.startIndex, offsetBy: padLength)] + self
  952|       |        } else {
  953|       |            var padding = string
  954|       |            while padding.count < padLength {
  955|       |                padding.append(string)
  956|       |            }
  957|       |            return padding[padding.startIndex..<padding.index(padding.startIndex, offsetBy: padLength)] + self
  958|       |        }
  959|       |    }
  960|       |
  961|       |    /// SwifterSwift: Pad string to fit the length parameter size with another string in the start.
  962|       |    ///
  963|       |    ///   "hue".padEnd(10) -> "hue       "
  964|       |    ///   "hue".padEnd(10, with: "br") -> "huebrbrbrb"
  965|       |    ///
  966|       |    /// - Parameter length: The target length to pad.
  967|       |    /// - Parameter string: Pad string. Default is " ".
  968|      0|    public mutating func padEnd(_ length: Int, with string: String = " ") {
  969|      0|        self = paddingEnd(length, with: string)
  970|      0|    }
  971|       |
  972|       |    /// SwifterSwift: Returns a string by padding to fit the length parameter size with another string in the end.
  973|       |    ///
  974|       |    ///   "hue".paddingEnd(10) -> "hue       "
  975|       |    ///   "hue".paddingEnd(10, with: "br") -> "huebrbrbrb"
  976|       |    ///
  977|       |    /// - Parameter length: The target length to pad.
  978|       |    /// - Parameter string: Pad string. Default is " ".
  979|       |    /// - Returns: The string with the padding on the end.
  980|       |    public func paddingEnd(_ length: Int, with string: String = " ") -> String {
  981|       |        guard count < length else { return self }
  982|       |
  983|       |        let padLength = length - count
  984|       |        if padLength < string.count {
  985|       |            return self + string[string.startIndex..<string.index(string.startIndex, offsetBy: padLength)]
  986|       |        } else {
  987|       |            var padding = string
  988|       |            while padding.count < padLength {
  989|       |                padding.append(string)
  990|       |            }
  991|       |            return self + padding[padding.startIndex..<padding.index(padding.startIndex, offsetBy: padLength)]
  992|       |        }
  993|       |    }
  994|       |
  995|       |    /// SwifterSwift: Removes given prefix from the string.
  996|       |    ///
  997|       |    ///   "Hello, World!".removingPrefix("Hello, ") -> "World!"
  998|       |    ///
  999|       |    /// - Parameter prefix: Prefix to remove from the string.
 1000|       |    /// - Returns: The string after prefix removing.
 1001|      0|    public func removingPrefix(_ prefix: String) -> String {
 1002|      0|        guard hasPrefix(prefix) else { return self }
 1003|      0|        return String(dropFirst(prefix.count))
 1004|      0|    }
 1005|       |
 1006|       |    /// SwifterSwift: Removes given suffix from the string.
 1007|       |    ///
 1008|       |    ///   "Hello, World!".removingSuffix(", World!") -> "Hello"
 1009|       |    ///
 1010|       |    /// - Parameter suffix: Suffix to remove from the string.
 1011|       |    /// - Returns: The string after suffix removing.
 1012|      0|    public func removingSuffix(_ suffix: String) -> String {
 1013|      0|        guard hasSuffix(suffix) else { return self }
 1014|      0|        return String(dropLast(suffix.count))
 1015|      0|    }
 1016|       |
 1017|       |}
 1018|       |
 1019|       |// MARK: - Initializers
 1020|       |public extension String {
 1021|       |
 1022|       |    #if canImport(Foundation)
 1023|       |    /// SwifterSwift: Create a new string from a base64 string (if applicable).
 1024|       |    ///
 1025|       |    ///		String(base64: "SGVsbG8gV29ybGQh") = "Hello World!"
 1026|       |    ///		String(base64: "hello") = nil
 1027|       |    ///
 1028|       |    /// - Parameter base64: base64 string.
 1029|      0|    public init?(base64: String) {
 1030|      0|        guard let decodedData = Data(base64Encoded: base64) else { return nil }
 1031|      0|        guard let str = String(data: decodedData, encoding: .utf8) else { return nil }
 1032|      0|        self.init(str)
 1033|      0|    }
 1034|       |    #endif
 1035|       |
 1036|       |    /// SwifterSwift: Create a new random string of given length.
 1037|       |    ///
 1038|       |    ///		String(randomOfLength: 10) -> "gY8r3MHvlQ"
 1039|       |    ///
 1040|       |    /// - Parameter length: number of characters in string.
 1041|      0|    public init(randomOfLength length: Int) {
 1042|      0|        guard length > 0 else {
 1043|      0|            self.init()
 1044|      0|            return
 1045|      0|        }
 1046|      0|
 1047|      0|        let base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
 1048|      0|        var randomString = ""
 1049|      0|        for _ in 1...length {
 1050|      0|            let randomIndex = Int.random(in: 0..<base.count)
 1051|      0|            let randomCharacter = Array(base)[Int(randomIndex)]
 1052|      0|            randomString.append(randomCharacter)
 1053|      0|        }
 1054|      0|        self = randomString
 1055|      0|    }
 1056|       |
 1057|       |}
 1058|       |
 1059|       |// MARK: - NSAttributedString
 1060|       |public extension String {
 1061|       |
 1062|       |    #if canImport(UIKit)
 1063|       |    private typealias Font = UIFont
 1064|       |    #endif
 1065|       |
 1066|       |    #if canImport(Cocoa)
 1067|       |    private typealias Font = NSFont
 1068|       |    #endif
 1069|       |
 1070|       |    #if os(iOS) || os(macOS)
 1071|       |    /// SwifterSwift: Bold string.
 1072|      0|    public var bold: NSAttributedString {
 1073|      0|        return NSMutableAttributedString(string: self, attributes: [.font: Font.boldSystemFont(ofSize: Font.systemFontSize)])
 1074|      0|    }
 1075|       |    #endif
 1076|       |
 1077|       |    #if canImport(Foundation)
 1078|       |    /// SwifterSwift: Underlined string
 1079|      0|    public var underline: NSAttributedString {
 1080|      0|        return NSAttributedString(string: self, attributes: [.underlineStyle: NSUnderlineStyle.single.rawValue])
 1081|      0|    }
 1082|       |    #endif
 1083|       |
 1084|       |    #if canImport(Foundation)
 1085|       |    /// SwifterSwift: Strikethrough string.
 1086|      0|    public var strikethrough: NSAttributedString {
 1087|      0|        return NSAttributedString(string: self, attributes: [.strikethroughStyle: NSNumber(value: NSUnderlineStyle.single.rawValue as Int)])
 1088|      0|    }
 1089|       |    #endif
 1090|       |
 1091|       |    #if os(iOS)
 1092|       |    /// SwifterSwift: Italic string.
 1093|      0|    public var italic: NSAttributedString {
 1094|      0|        return NSMutableAttributedString(string: self, attributes: [.font: UIFont.italicSystemFont(ofSize: UIFont.systemFontSize)])
 1095|      0|    }
 1096|       |    #endif
 1097|       |
 1098|       |    #if canImport(UIKit)
 1099|       |    /// SwifterSwift: Add color to string.
 1100|       |    ///
 1101|       |    /// - Parameter color: text color.
 1102|       |    /// - Returns: a NSAttributedString versions of string colored with given color.
 1103|      0|    public func colored(with color: UIColor) -> NSAttributedString {
 1104|      0|        return NSMutableAttributedString(string: self, attributes: [.foregroundColor: color])
 1105|      0|    }
 1106|       |    #endif
 1107|       |
 1108|       |    #if canImport(Cocoa)
 1109|       |    /// SwifterSwift: Add color to string.
 1110|       |    ///
 1111|       |    /// - Parameter color: text color.
 1112|       |    /// - Returns: a NSAttributedString versions of string colored with given color.
 1113|       |    public func colored(with color: NSColor) -> NSAttributedString {
 1114|       |        return NSMutableAttributedString(string: self, attributes: [.foregroundColor: color])
 1115|       |    }
 1116|       |    #endif
 1117|       |
 1118|       |}
 1119|       |
 1120|       |// MARK: - Operators
 1121|       |public extension String {
 1122|       |
 1123|       |    /// SwifterSwift: Repeat string multiple times.
 1124|       |    ///
 1125|       |    ///        'bar' * 3 -> "barbarbar"
 1126|       |    ///
 1127|       |    /// - Parameters:
 1128|       |    ///   - lhs: string to repeat.
 1129|       |    ///   - rhs: number of times to repeat character.
 1130|       |    /// - Returns: new string with given string repeated n times.
 1131|      0|    public static func * (lhs: String, rhs: Int) -> String {
 1132|      0|        guard rhs > 0 else { return "" }
 1133|      0|        return String(repeating: lhs, count: rhs)
 1134|      0|    }
 1135|       |
 1136|       |    /// SwifterSwift: Repeat string multiple times.
 1137|       |    ///
 1138|       |    ///        3 * 'bar' -> "barbarbar"
 1139|       |    ///
 1140|       |    /// - Parameters:
 1141|       |    ///   - lhs: number of times to repeat character.
 1142|       |    ///   - rhs: string to repeat.
 1143|       |    /// - Returns: new string with given string repeated n times.
 1144|      0|    public static func * (lhs: Int, rhs: String) -> String {
 1145|      0|        guard lhs > 0 else { return "" }
 1146|      0|        return String(repeating: rhs, count: lhs)
 1147|      0|    }
 1148|       |
 1149|       |}
 1150|       |
 1151|       |#if canImport(Foundation)
 1152|       |// MARK: - NSString extensions
 1153|       |public extension String {
 1154|       |
 1155|       |    /// SwifterSwift: NSString from a string.
 1156|      0|    public var nsString: NSString {
 1157|      0|        return NSString(string: self)
 1158|      0|    }
 1159|       |
 1160|       |    /// SwifterSwift: NSString lastPathComponent.
 1161|      0|    public var lastPathComponent: String {
 1162|      0|        return (self as NSString).lastPathComponent
 1163|      0|    }
 1164|       |
 1165|       |    /// SwifterSwift: NSString pathExtension.
 1166|      0|    public var pathExtension: String {
 1167|      0|        return (self as NSString).pathExtension
 1168|      0|    }
 1169|       |
 1170|       |    /// SwifterSwift: NSString deletingLastPathComponent.
 1171|      0|    public var deletingLastPathComponent: String {
 1172|      0|        return (self as NSString).deletingLastPathComponent
 1173|      0|    }
 1174|       |
 1175|       |    /// SwifterSwift: NSString deletingPathExtension.
 1176|      0|    public var deletingPathExtension: String {
 1177|      0|        return (self as NSString).deletingPathExtension
 1178|      0|    }
 1179|       |
 1180|       |    /// SwifterSwift: NSString pathComponents.
 1181|      0|    public var pathComponents: [String] {
 1182|      0|        return (self as NSString).pathComponents
 1183|      0|    }
 1184|       |
 1185|       |    /// SwifterSwift: NSString appendingPathComponent(str: String)
 1186|       |    ///
 1187|       |    /// - Parameter str: the path component to append to the receiver.
 1188|       |    /// - Returns: a new string made by appending aString to the receiver, preceded if necessary by a path separator.
 1189|      0|    public func appendingPathComponent(_ str: String) -> String {
 1190|      0|        return (self as NSString).appendingPathComponent(str)
 1191|      0|    }
 1192|       |
 1193|       |    /// SwifterSwift: NSString appendingPathExtension(str: String)
 1194|       |    ///
 1195|       |    /// - Parameter str: The extension to append to the receiver.
 1196|       |    /// - Returns: a new string made by appending to the receiver an extension separator followed by ext (if applicable).
 1197|      0|    public func appendingPathExtension(_ str: String) -> String? {
 1198|      0|        return (self as NSString).appendingPathExtension(str)
 1199|      0|    }
 1200|       |
 1201|       |}
 1202|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwiftStdlib/StringProtocolExtensions.swift:
    1|       |//
    2|       |//  StringProtocolExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Max Härtwig on 11/26/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public extension StringProtocol where Index == String.Index {
   12|       |
   13|       |    /// SwifterSwift: The longest common suffix.
   14|       |    ///
   15|       |    ///        "Hello world!".commonSuffix(with: "It's cold!") = "ld!"
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///     - Parameter aString: The string with which to compare the receiver.
   19|       |    ///     - Parameter options: Options for the comparison.
   20|       |    /// - Returns: The longest common suffix of the receiver and the given String
   21|      0|    public func commonSuffix<T: StringProtocol>(with aString: T, options: String.CompareOptions = []) -> String {
   22|      0|        let reversedSuffix = String(reversed()).commonPrefix(with: String(aString.reversed()), options: options)
   23|      0|        return String(reversedSuffix.reversed())
   24|      0|    }
   25|       |
   26|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/SwifterSwift.swift:
    1|       |//
    2|       |//  SwifterSwift.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/8/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)
   10|       |import UIKit
   11|       |#endif
   12|       |
   13|       |#if canImport(WatchKit)
   14|       |import WatchKit
   15|       |#endif
   16|       |
   17|       |#if canImport(Cocoa)
   18|       |import Cocoa
   19|       |#endif
   20|       |
   21|       |#if !os(Linux)
   22|       |// MARK: - Properties
   23|       |/// SwifterSwift: Common usefull properties and methods.
   24|       |public struct SwifterSwift {
   25|       |
   26|       |    #if !os(macOS)
   27|       |    /// SwifterSwift: App's name (if applicable).
   28|      0|    public static var appDisplayName: String? {
   29|      0|        // http://stackoverflow.com/questions/28254377/get-app-name-in-swift
   30|      0|        return Bundle.main.infoDictionary?[kCFBundleNameKey as String] as? String
   31|      0|    }
   32|       |    #endif
   33|       |
   34|       |    #if !os(macOS)
   35|       |    /// SwifterSwift: App's bundle ID (if applicable).
   36|      0|    public static var appBundleID: String? {
   37|      0|        return Bundle.main.bundleIdentifier
   38|      0|    }
   39|       |    #endif
   40|       |
   41|       |    #if os(iOS)
   42|       |    /// SwifterSwift: StatusBar height
   43|      0|    public static var statusBarHeight: CGFloat {
   44|      0|        return UIApplication.shared.statusBarFrame.height
   45|      0|    }
   46|       |    #endif
   47|       |
   48|       |    #if !os(macOS)
   49|       |    /// SwifterSwift: App current build number (if applicable).
   50|      0|    public static var appBuild: String? {
   51|      0|        return Bundle.main.object(forInfoDictionaryKey: kCFBundleVersionKey as String) as? String
   52|      0|    }
   53|       |    #endif
   54|       |
   55|       |    #if os(iOS) || os(tvOS)
   56|       |    /// SwifterSwift: Application icon badge current number.
   57|       |    public static var applicationIconBadgeNumber: Int {
   58|      0|        get {
   59|      0|            return UIApplication.shared.applicationIconBadgeNumber
   60|      0|        }
   61|      0|        set {
   62|      0|            UIApplication.shared.applicationIconBadgeNumber = newValue
   63|      0|        }
   64|       |    }
   65|       |    #endif
   66|       |
   67|       |    #if !os(macOS)
   68|       |    /// SwifterSwift: App's current version (if applicable).
   69|      0|    public static var appVersion: String? {
   70|      0|        return Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String
   71|      0|    }
   72|       |    #endif
   73|       |
   74|       |    #if os(iOS)
   75|       |    /// SwifterSwift: Current battery level.
   76|      0|    public static var batteryLevel: Float {
   77|      0|        return UIDevice.current.batteryLevel
   78|      0|    }
   79|       |    #endif
   80|       |
   81|       |    #if os(iOS) || os(tvOS)
   82|       |    /// SwifterSwift: Shared instance of current device.
   83|      0|    public static var currentDevice: UIDevice {
   84|      0|        return UIDevice.current
   85|      0|    }
   86|       |    #elseif os(watchOS)
   87|       |    /// SwifterSwift: Shared instance of current device.
   88|       |    public static var currentDevice: WKInterfaceDevice {
   89|       |        return WKInterfaceDevice.current()
   90|       |    }
   91|       |    #endif
   92|       |
   93|       |    #if !os(macOS)
   94|       |    /// SwifterSwift: Screen height.
   95|      0|    public static var screenHeight: CGFloat {
   96|      0|        #if os(iOS) || os(tvOS)
   97|      0|        return UIScreen.main.bounds.height
   98|      0|        #elseif os(watchOS)
   99|      0|        return currentDevice.screenBounds.height
  100|      0|        #endif
  101|      0|    }
  102|       |    #endif
  103|       |
  104|       |    #if !os(macOS)
  105|       |    /// SwifterSwift: Current device model.
  106|      0|    public static var deviceModel: String {
  107|      0|        return currentDevice.model
  108|      0|    }
  109|       |    #endif
  110|       |
  111|       |    #if !os(macOS)
  112|       |    /// SwifterSwift: Current device name.
  113|      0|    public static var deviceName: String {
  114|      0|        return currentDevice.name
  115|      0|    }
  116|       |    #endif
  117|       |
  118|       |    #if os(iOS)
  119|       |    /// SwifterSwift: Current orientation of device.
  120|      0|    public static var deviceOrientation: UIDeviceOrientation {
  121|      0|        return currentDevice.orientation
  122|      0|    }
  123|       |    #endif
  124|       |
  125|       |    #if !os(macOS)
  126|       |    /// SwifterSwift: Screen width.
  127|      0|    public static var screenWidth: CGFloat {
  128|      0|        #if os(iOS) || os(tvOS)
  129|      0|        return UIScreen.main.bounds.width
  130|      0|        #elseif os(watchOS)
  131|      0|        return currentDevice.screenBounds.width
  132|      0|        #endif
  133|      0|    }
  134|       |    #endif
  135|       |
  136|       |    /// SwifterSwift: Check if app is running in debug mode.
  137|      0|    public static var isInDebuggingMode: Bool {
  138|      0|        // http://stackoverflow.com/questions/9063100/xcode-ios-how-to-determine-whether-code-is-running-in-debug-release-build
  139|      0|        #if DEBUG
  140|      0|        return true
  141|      0|        #else
  142|      0|        return false
  143|      0|        #endif
  144|      0|    }
  145|       |
  146|       |    #if !os(macOS)
  147|       |    /// SwifterSwift: Check if app is running in TestFlight mode.
  148|      0|    public static var isInTestFlight: Bool {
  149|      0|        // http://stackoverflow.com/questions/12431994/detect-testflight
  150|      0|        return Bundle.main.appStoreReceiptURL?.path.contains("sandboxReceipt") == true
  151|      0|    }
  152|       |    #endif
  153|       |
  154|       |    #if os(iOS)
  155|       |    /// SwifterSwift: Check if multitasking is supported in current device.
  156|      0|    public static var isMultitaskingSupported: Bool {
  157|      0|        return UIDevice.current.isMultitaskingSupported
  158|      0|    }
  159|       |    #endif
  160|       |
  161|       |    #if os(iOS)
  162|       |    /// SwifterSwift: Current status bar network activity indicator state.
  163|       |    public static var isNetworkActivityIndicatorVisible: Bool {
  164|      0|        get {
  165|      0|            return UIApplication.shared.isNetworkActivityIndicatorVisible
  166|      0|        }
  167|      0|        set {
  168|      0|            UIApplication.shared.isNetworkActivityIndicatorVisible = newValue
  169|      0|        }
  170|       |    }
  171|       |    #endif
  172|       |
  173|       |    #if os(iOS)
  174|       |    /// SwifterSwift: Check if device is iPad.
  175|      0|    public static var isPad: Bool {
  176|      0|        return UIDevice.current.userInterfaceIdiom == .pad
  177|      0|    }
  178|       |    #endif
  179|       |
  180|       |    #if os(iOS)
  181|       |    /// SwifterSwift: Check if device is iPhone.
  182|      0|    public static var isPhone: Bool {
  183|      0|        return UIDevice.current.userInterfaceIdiom == .phone
  184|      0|    }
  185|       |    #endif
  186|       |
  187|       |    #if os(iOS) || os(tvOS)
  188|       |    /// SwifterSwift: Check if device is registered for remote notifications for current app (read-only).
  189|      0|    public static var isRegisteredForRemoteNotifications: Bool {
  190|      0|        return UIApplication.shared.isRegisteredForRemoteNotifications
  191|      0|    }
  192|       |    #endif
  193|       |
  194|       |    /// SwifterSwift: Check if application is running on simulator (read-only).
  195|      0|    public static var isRunningOnSimulator: Bool {
  196|      0|        // http://stackoverflow.com/questions/24869481/detect-if-app-is-being-built-for-device-or-simulator-in-swift
  197|      0|        #if targetEnvironment(simulator)
  198|      0|        return true
  199|      0|        #else
  200|      0|        return false
  201|      0|        #endif
  202|      0|    }
  203|       |
  204|       |    #if os(iOS)
  205|       |    /// SwifterSwift: Status bar visibility state.
  206|       |    public static var isStatusBarHidden: Bool {
  207|      0|        get {
  208|      0|            return UIApplication.shared.isStatusBarHidden
  209|      0|        }
  210|      0|        set {
  211|      0|            UIApplication.shared.isStatusBarHidden = newValue
  212|      0|        }
  213|       |    }
  214|       |    #endif
  215|       |
  216|       |    #if os(iOS) || os(tvOS)
  217|       |    /// SwifterSwift: Key window (read only, if applicable).
  218|      0|    public static var keyWindow: UIView? {
  219|      0|        return UIApplication.shared.keyWindow
  220|      0|    }
  221|       |    #endif
  222|       |
  223|       |    #if os(iOS) || os(tvOS)
  224|       |    /// SwifterSwift: Most top view controller (if applicable).
  225|       |    public static var mostTopViewController: UIViewController? {
  226|      0|        get {
  227|      0|            return UIApplication.shared.keyWindow?.rootViewController
  228|      0|        }
  229|      0|        set {
  230|      0|            UIApplication.shared.keyWindow?.rootViewController = newValue
  231|      0|        }
  232|       |    }
  233|       |    #endif
  234|       |
  235|       |    #if os(iOS) || os(tvOS)
  236|       |    /// SwifterSwift: Shared instance UIApplication.
  237|      0|    public static var sharedApplication: UIApplication {
  238|      0|        return UIApplication.shared
  239|      0|    }
  240|       |    #endif
  241|       |
  242|       |    #if os(iOS)
  243|       |    /// SwifterSwift: Current status bar style (if applicable).
  244|       |    public static var statusBarStyle: UIStatusBarStyle? {
  245|      0|        get {
  246|      0|            return UIApplication.shared.statusBarStyle
  247|      0|        }
  248|      0|        set {
  249|      0|            if let style = newValue {
  250|      0|                UIApplication.shared.statusBarStyle = style
  251|      0|            }
  252|      0|        }
  253|       |    }
  254|       |    #endif
  255|       |
  256|       |    #if !os(macOS)
  257|       |    /// SwifterSwift: System current version (read-only).
  258|      0|    public static var systemVersion: String {
  259|      0|        return currentDevice.systemVersion
  260|      0|    }
  261|       |    #endif
  262|       |
  263|       |}
  264|       |
  265|       |// MARK: - Methods
  266|       |public extension SwifterSwift {
  267|       |
  268|       |    /// SwifterSwift: Delay function or closure call.
  269|       |    ///
  270|       |    /// - Parameters:
  271|       |    ///   - milliseconds: execute closure after the given delay.
  272|       |    ///   - queue: a queue that completion closure should be executed on (default is DispatchQueue.main).
  273|       |    ///   - completion: closure to be executed after delay.
  274|       |    ///   - Returns: DispatchWorkItem task. You can call .cancel() on it to cancel delayed execution.
  275|      0|    @discardableResult public static func delay(milliseconds: Double, queue: DispatchQueue = .main, completion: @escaping () -> Void) -> DispatchWorkItem {
  276|      0|        let task = DispatchWorkItem { completion() }
  277|      0|        queue.asyncAfter(deadline: .now() + (milliseconds/1000), execute: task)
  278|      0|        return task
  279|      0|    }
  280|       |
  281|       |    /// SwifterSwift: Debounce function or closure call.
  282|       |    ///
  283|       |    /// - Parameters:
  284|       |    ///   - millisecondsOffset: allow execution of method if it was not called since millisecondsOffset.
  285|       |    ///   - queue: a queue that action closure should be executed on (default is DispatchQueue.main).
  286|       |    ///   - action: closure to be executed in a debounced way.
  287|      0|    public static func debounce(millisecondsDelay: Int, queue: DispatchQueue = .main, action: @escaping (() -> Void)) -> () -> Void {
  288|      0|        // http://stackoverflow.com/questions/27116684/how-can-i-debounce-a-method-call
  289|      0|        var lastFireTime = DispatchTime.now()
  290|      0|        let dispatchDelay = DispatchTimeInterval.milliseconds(millisecondsDelay)
  291|      0|        let dispatchTime: DispatchTime = lastFireTime + dispatchDelay
  292|      0|        return {
  293|      0|            queue.asyncAfter(deadline: dispatchTime) {
  294|      0|                let when: DispatchTime = lastFireTime + dispatchDelay
  295|      0|                let now = DispatchTime.now()
  296|      0|                if now.rawValue >= when.rawValue {
  297|      0|                    lastFireTime = DispatchTime.now()
  298|      0|                    action()
  299|      0|                }
  300|      0|            }
  301|      0|        }
  302|      0|    }
  303|       |
  304|       |    #if os(iOS) || os(tvOS)
  305|       |    /// SwifterSwift: Called when user takes a screenshot
  306|       |    ///
  307|       |    /// - Parameter action: a closure to run when user takes a screenshot
  308|      0|    public static func didTakeScreenShot(_ action: @escaping (_ notification: Notification) -> Void) {
  309|      0|        // http://stackoverflow.com/questions/13484516/ios-detection-of-screenshot
  310|      0|        _ = NotificationCenter.default.addObserver(forName: UIApplication.userDidTakeScreenshotNotification,
  311|      0|                                                   object: nil,
  312|      0|                                                   queue: OperationQueue.main) { notification in
  313|      0|                                                    action(notification)
  314|      0|        }
  315|      0|    }
  316|       |    #endif
  317|       |
  318|       |    /// SwifterSwift: Class name of object as string.
  319|       |    ///
  320|       |    /// - Parameter object: Any object to find its class name.
  321|       |    /// - Returns: Class name for given object.
  322|      0|    public static func typeName(for object: Any) -> String {
  323|      0|        let objectType = type(of: object.self)
  324|      0|        return String.init(describing: objectType)
  325|      0|    }
  326|       |
  327|       |}
  328|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/Deprecated/UIKitDeprecated.swift:
    1|       |//
    2|       |//  UIKitDeprecated.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 5.04.2018.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |public extension UIStoryboard {
   13|       |
   14|       |    /// SwifterSwift: Get main storyboard for application
   15|       |    @available(*, deprecated: 4.3, message: "Use main instead", renamed: "main")
   16|      0|    public static var mainStoryboard: UIStoryboard? {
   17|      0|        let bundle = Bundle.main
   18|      0|        guard let name = bundle.object(forInfoDictionaryKey: "UIMainStoryboardFile") as? String else { return nil }
   19|      0|        return UIStoryboard(name: name, bundle: bundle)
   20|      0|    }
   21|       |
   22|       |}
   23|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIAlertControllerExtensions.swift:
    1|       |//
    2|       |//  UIAlertControllerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/23/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |#if canImport(AudioToolbox)
   13|       |import AudioToolbox
   14|       |#endif
   15|       |
   16|       |// MARK: - Methodss
   17|       |public extension UIAlertController {
   18|       |
   19|       |    /// SwifterSwift: Present alert view controller in the current view controller.
   20|       |    ///
   21|       |    /// - Parameters:
   22|       |    ///   - animated: set true to animate presentation of alert controller (default is true).
   23|       |    ///   - vibrate: set true to vibrate the device while presenting the alert (default is false).
   24|       |    ///   - completion: an optional completion handler to be called after presenting alert controller (default is nil).
   25|      0|    public func show(animated: Bool = true, vibrate: Bool = false, completion: (() -> Void)? = nil) {
   26|      0|        UIApplication.shared.keyWindow?.rootViewController?.present(self, animated: animated, completion: completion)
   27|      0|        if vibrate {
   28|      0|            #if canImport(AudioToolbox)
   29|      0|            AudioServicesPlayAlertSound(kSystemSoundID_Vibrate)
   30|      0|            #endif
   31|      0|        }
   32|      0|    }
   33|       |
   34|       |    /// SwifterSwift: Add an action to Alert
   35|       |    ///
   36|       |    /// - Parameters:
   37|       |    ///   - title: action title
   38|       |    ///   - style: action style (default is UIAlertActionStyle.default)
   39|       |    ///   - isEnabled: isEnabled status for action (default is true)
   40|       |    ///   - handler: optional action handler to be called when button is tapped (default is nil)
   41|       |    /// - Returns: action created by this method
   42|      0|    @discardableResult public func addAction(title: String, style: UIAlertAction.Style = .default, isEnabled: Bool = true, handler: ((UIAlertAction) -> Void)? = nil) -> UIAlertAction {
   43|      0|        let action = UIAlertAction(title: title, style: style, handler: handler)
   44|      0|        action.isEnabled = isEnabled
   45|      0|        addAction(action)
   46|      0|        return action
   47|      0|    }
   48|       |
   49|       |    /// SwifterSwift: Add a text field to Alert
   50|       |    ///
   51|       |    /// - Parameters:
   52|       |    ///   - text: text field text (default is nil)
   53|       |    ///   - placeholder: text field placeholder text (default is nil)
   54|       |    ///   - editingChangedTarget: an optional target for text field's editingChanged
   55|       |    ///   - editingChangedSelector: an optional selector for text field's editingChanged
   56|      0|    public func addTextField(text: String? = nil, placeholder: String? = nil, editingChangedTarget: Any?, editingChangedSelector: Selector?) {
   57|      0|        addTextField { textField in
   58|      0|            textField.text = text
   59|      0|            textField.placeholder = placeholder
   60|      0|            if let target = editingChangedTarget, let selector = editingChangedSelector {
   61|      0|                textField.addTarget(target, action: selector, for: .editingChanged)
   62|      0|            }
   63|      0|        }
   64|      0|    }
   65|       |
   66|       |}
   67|       |
   68|       |// MARK: - Initializers
   69|       |public extension UIAlertController {
   70|       |
   71|       |    /// SwifterSwift: Create new alert view controller with default OK action.
   72|       |    ///
   73|       |    /// - Parameters:
   74|       |    ///   - title: alert controller's title.
   75|       |    ///   - message: alert controller's message (default is nil).
   76|       |    ///   - defaultActionButtonTitle: default action button title (default is "OK")
   77|       |    ///   - tintColor: alert controller's tint color (default is nil)
   78|      0|    public convenience init(title: String, message: String? = nil, defaultActionButtonTitle: String = "OK", tintColor: UIColor? = nil) {
   79|      0|        self.init(title: title, message: message, preferredStyle: .alert)
   80|      0|        let defaultAction = UIAlertAction(title: defaultActionButtonTitle, style: .default, handler: nil)
   81|      0|        addAction(defaultAction)
   82|      0|        if let color = tintColor {
   83|      0|            view.tintColor = color
   84|      0|        }
   85|      0|    }
   86|       |
   87|       |    /// SwifterSwift: Create new error alert view controller from Error with default OK action.
   88|       |    ///
   89|       |    /// - Parameters:
   90|       |    ///   - title: alert controller's title (default is "Error").
   91|       |    ///   - error: error to set alert controller's message to it's localizedDescription.
   92|       |    ///   - defaultActionButtonTitle: default action button title (default is "OK")
   93|       |    ///   - tintColor: alert controller's tint color (default is nil)
   94|      0|    public convenience init(title: String = "Error", error: Error, defaultActionButtonTitle: String = "OK", preferredStyle: UIAlertController.Style = .alert, tintColor: UIColor? = nil) {
   95|      0|        self.init(title: title, message: error.localizedDescription, preferredStyle: preferredStyle)
   96|      0|        let defaultAction = UIAlertAction(title: defaultActionButtonTitle, style: .default, handler: nil)
   97|      0|        addAction(defaultAction)
   98|      0|        if let color = tintColor {
   99|      0|            view.tintColor = color
  100|      0|        }
  101|      0|    }
  102|       |
  103|       |}
  104|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIBarButtonItemExtensions.swift:
    1|       |//
    2|       |//  UIBarButtonItemExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 08/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIBarButtonItem {
   14|       |
   15|       |    /// SwifterSwift: Add Target to UIBarButtonItem
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - target: target.
   19|       |    ///   - action: selector to run when button is tapped.
   20|      0|    public func addTargetForAction(_ target: AnyObject, action: Selector) {
   21|      0|        self.target = target
   22|      0|        self.action = action
   23|      0|    }
   24|       |
   25|       |}
   26|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIButtonExtensions.swift:
    1|       |//
    2|       |//  UIButtonExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/22/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UIButton {
   14|       |
   15|       |    /// SwifterSwift: Image of disabled state for button; also inspectable from Storyboard.
   16|       |    @IBInspectable public var imageForDisabled: UIImage? {
   17|       |        get {
   18|       |            return image(for: .disabled)
   19|       |        }
   20|       |        set {
   21|       |            setImage(newValue, for: .disabled)
   22|       |        }
   23|       |    }
   24|       |
   25|       |    /// SwifterSwift: Image of highlighted state for button; also inspectable from Storyboard.
   26|       |    @IBInspectable public var imageForHighlighted: UIImage? {
   27|       |        get {
   28|       |            return image(for: .highlighted)
   29|       |        }
   30|       |        set {
   31|       |            setImage(newValue, for: .highlighted)
   32|       |        }
   33|       |    }
   34|       |
   35|       |    /// SwifterSwift: Image of normal state for button; also inspectable from Storyboard.
   36|       |    @IBInspectable public var imageForNormal: UIImage? {
   37|       |        get {
   38|       |            return image(for: .normal)
   39|       |        }
   40|       |        set {
   41|       |            setImage(newValue, for: .normal)
   42|       |        }
   43|       |    }
   44|       |
   45|       |    /// SwifterSwift: Image of selected state for button; also inspectable from Storyboard.
   46|       |    @IBInspectable public var imageForSelected: UIImage? {
   47|       |        get {
   48|       |            return image(for: .selected)
   49|       |        }
   50|       |        set {
   51|       |            setImage(newValue, for: .selected)
   52|       |        }
   53|       |    }
   54|       |
   55|       |    /// SwifterSwift: Title color of disabled state for button; also inspectable from Storyboard.
   56|       |    @IBInspectable public var titleColorForDisabled: UIColor? {
   57|       |        get {
   58|       |            return titleColor(for: .disabled)
   59|       |        }
   60|       |        set {
   61|       |            setTitleColor(newValue, for: .disabled)
   62|       |        }
   63|       |    }
   64|       |
   65|       |    /// SwifterSwift: Title color of highlighted state for button; also inspectable from Storyboard.
   66|       |    @IBInspectable public var titleColorForHighlighted: UIColor? {
   67|       |        get {
   68|       |            return titleColor(for: .highlighted)
   69|       |        }
   70|       |        set {
   71|       |            setTitleColor(newValue, for: .highlighted)
   72|       |        }
   73|       |    }
   74|       |
   75|       |    /// SwifterSwift: Title color of normal state for button; also inspectable from Storyboard.
   76|       |    @IBInspectable public var titleColorForNormal: UIColor? {
   77|       |        get {
   78|       |            return titleColor(for: .normal)
   79|       |        }
   80|       |        set {
   81|       |            setTitleColor(newValue, for: .normal)
   82|       |        }
   83|       |    }
   84|       |
   85|       |    /// SwifterSwift: Title color of selected state for button; also inspectable from Storyboard.
   86|       |    @IBInspectable public var titleColorForSelected: UIColor? {
   87|       |        get {
   88|       |            return titleColor(for: .selected)
   89|       |        }
   90|       |        set {
   91|       |            setTitleColor(newValue, for: .selected)
   92|       |        }
   93|       |    }
   94|       |
   95|       |    /// SwifterSwift: Title of disabled state for button; also inspectable from Storyboard.
   96|       |    @IBInspectable public var titleForDisabled: String? {
   97|       |        get {
   98|       |            return title(for: .disabled)
   99|       |        }
  100|       |        set {
  101|       |            setTitle(newValue, for: .disabled)
  102|       |        }
  103|       |    }
  104|       |
  105|       |    /// SwifterSwift: Title of highlighted state for button; also inspectable from Storyboard.
  106|       |    @IBInspectable public var titleForHighlighted: String? {
  107|       |        get {
  108|       |            return title(for: .highlighted)
  109|       |        }
  110|       |        set {
  111|       |            setTitle(newValue, for: .highlighted)
  112|       |        }
  113|       |    }
  114|       |
  115|       |    /// SwifterSwift: Title of normal state for button; also inspectable from Storyboard.
  116|       |    @IBInspectable public var titleForNormal: String? {
  117|       |        get {
  118|       |            return title(for: .normal)
  119|       |        }
  120|       |        set {
  121|       |            setTitle(newValue, for: .normal)
  122|       |        }
  123|       |    }
  124|       |
  125|       |    /// SwifterSwift: Title of selected state for button; also inspectable from Storyboard.
  126|       |    @IBInspectable public var titleForSelected: String? {
  127|       |        get {
  128|       |            return title(for: .selected)
  129|       |        }
  130|       |        set {
  131|       |            setTitle(newValue, for: .selected)
  132|       |        }
  133|       |    }
  134|       |
  135|       |}
  136|       |
  137|       |// MARK: - Methods
  138|       |public extension UIButton {
  139|       |
  140|      0|    private var states: [UIControl.State] {
  141|      0|        return [.normal, .selected, .highlighted, .disabled]
  142|      0|    }
  143|       |
  144|       |    /// SwifterSwift: Set image for all states.
  145|       |    ///
  146|       |    /// - Parameter image: UIImage.
  147|      0|    public func setImageForAllStates(_ image: UIImage) {
  148|      0|        states.forEach { self.setImage(image, for: $0) }
  149|      0|    }
  150|       |
  151|       |    /// SwifterSwift: Set title color for all states.
  152|       |    ///
  153|       |    /// - Parameter color: UIColor.
  154|      0|    public func setTitleColorForAllStates(_ color: UIColor) {
  155|      0|        states.forEach { self.setTitleColor(color, for: $0) }
  156|      0|    }
  157|       |
  158|       |    /// SwifterSwift: Set title for all states.
  159|       |    ///
  160|       |    /// - Parameter title: title string.
  161|      0|    public func setTitleForAllStates(_ title: String) {
  162|      0|        states.forEach { self.setTitle(title, for: $0) }
  163|      0|    }
  164|       |
  165|       |    /// SwifterSwift: Center align title text and image on UIButton
  166|       |    ///
  167|       |    /// - Parameter spacing: spacing between UIButton title text and UIButton Image.
  168|      0|    public func centerTextAndImage(spacing: CGFloat) {
  169|      0|        let insetAmount = spacing / 2
  170|      0|        imageEdgeInsets = UIEdgeInsets(top: 0, left: -insetAmount, bottom: 0, right: insetAmount)
  171|      0|        titleEdgeInsets = UIEdgeInsets(top: 0, left: insetAmount, bottom: 0, right: -insetAmount)
  172|      0|        contentEdgeInsets = UIEdgeInsets(top: 0, left: insetAmount, bottom: 0, right: insetAmount)
  173|      0|    }
  174|       |
  175|       |}
  176|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UICollectionViewExtensions.swift:
    1|       |//
    2|       |//  UICollectionViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 11/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UICollectionView {
   14|       |
   15|       |    /// SwifterSwift: Index path of last item in collectionView.
   16|      0|    public var indexPathForLastItem: IndexPath? {
   17|      0|        return indexPathForLastItem(inSection: lastSection)
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Index of last section in collectionView.
   21|       |    public var lastSection: Int {
   22|       |        return numberOfSections > 0 ? numberOfSections - 1 : 0
   23|       |    }
   24|       |
   25|       |}
   26|       |
   27|       |// MARK: - Methods
   28|       |public extension UICollectionView {
   29|       |
   30|       |    /// SwifterSwift: Number of all items in all sections of collectionView.
   31|       |    ///
   32|       |    /// - Returns: The count of all rows in the collectionView.
   33|      0|    public func numberOfItems() -> Int {
   34|      0|        var section = 0
   35|      0|        var itemsCount = 0
   36|      0|        while section < self.numberOfSections {
   37|      0|            itemsCount += numberOfItems(inSection: section)
   38|      0|            section += 1
   39|      0|        }
   40|      0|        return itemsCount
   41|      0|    }
   42|       |
   43|       |    /// SwifterSwift: IndexPath for last item in section.
   44|       |    ///
   45|       |    /// - Parameter section: section to get last item in.
   46|       |    /// - Returns: optional last indexPath for last item in section (if applicable).
   47|       |    public func indexPathForLastItem(inSection section: Int) -> IndexPath? {
   48|       |        guard section >= 0 else {
   49|       |            return nil
   50|       |        }
   51|       |        guard section < numberOfSections else {
   52|       |            return nil
   53|       |        }
   54|       |        guard numberOfItems(inSection: section) > 0 else {
   55|       |            return IndexPath(item: 0, section: section)
   56|       |        }
   57|       |        return IndexPath(item: numberOfItems(inSection: section) - 1, section: section)
   58|       |    }
   59|       |
   60|       |    /// SwifterSwift: Reload data with a completion handler.
   61|       |    ///
   62|       |    /// - Parameter completion: completion handler to run after reloadData finishes.
   63|      0|    public func reloadData(_ completion: @escaping () -> Void) {
   64|      0|        UIView.animate(withDuration: 0, animations: {
   65|      0|            self.reloadData()
   66|      0|        }, completion: { _ in
   67|      0|            completion()
   68|      0|        })
   69|      0|    }
   70|       |
   71|       |    /// SwifterSwift: Dequeue reusable UICollectionViewCell using class name.
   72|       |    ///
   73|       |    /// - Parameters:
   74|       |    ///   - name: UICollectionViewCell type.
   75|       |    ///   - indexPath: location of cell in collectionView.
   76|       |    /// - Returns: UICollectionViewCell object with associated class name.
   77|      0|    public func dequeueReusableCell<T: UICollectionViewCell>(withClass name: T.Type, for indexPath: IndexPath) -> T {
   78|      0|        guard let cell = dequeueReusableCell(withReuseIdentifier: String(describing: name), for: indexPath) as? T else {
   79|      0|            fatalError("Couldn't find UICollectionViewCell for \(String(describing: name))")
   80|      0|        }
   81|      0|        return cell
   82|      0|    }
   83|       |
   84|       |    /// SwifterSwift: Dequeue reusable UICollectionReusableView using class name.
   85|       |    ///
   86|       |    /// - Parameters:
   87|       |    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
   88|       |    ///   - name: UICollectionReusableView type.
   89|       |    ///   - indexPath: location of cell in collectionView.
   90|       |    /// - Returns: UICollectionReusableView object with associated class name.
   91|      0|    public func dequeueReusableSupplementaryView<T: UICollectionReusableView>(ofKind kind: String, withClass name: T.Type, for indexPath: IndexPath) -> T {
   92|      0|        guard let cell = dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: String(describing: name), for: indexPath) as? T else {
   93|      0|            fatalError("Couldn't find UICollectionReusableView for \(String(describing: name))")
   94|      0|        }
   95|      0|        return cell
   96|      0|    }
   97|       |
   98|       |    /// SwifterSwift: Register UICollectionReusableView using class name.
   99|       |    ///
  100|       |    /// - Parameters:
  101|       |    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
  102|       |    ///   - name: UICollectionReusableView type.
  103|      0|    public func register<T: UICollectionReusableView>(supplementaryViewOfKind kind: String, withClass name: T.Type) {
  104|      0|        register(T.self, forSupplementaryViewOfKind: kind, withReuseIdentifier: String(describing: name))
  105|      0|    }
  106|       |
  107|       |    /// SwifterSwift: Register UICollectionViewCell using class name.
  108|       |    ///
  109|       |    /// - Parameters:
  110|       |    ///   - nib: Nib file used to create the collectionView cell.
  111|       |    ///   - name: UICollectionViewCell type.
  112|      0|    public func register<T: UICollectionViewCell>(nib: UINib?, forCellWithClass name: T.Type) {
  113|      0|        register(nib, forCellWithReuseIdentifier: String(describing: name))
  114|      0|    }
  115|       |
  116|       |    /// SwifterSwift: Register UICollectionViewCell using class name.
  117|       |    ///
  118|       |    /// - Parameter name: UICollectionViewCell type.
  119|      0|    public func register<T: UICollectionViewCell>(cellWithClass name: T.Type) {
  120|      0|        register(T.self, forCellWithReuseIdentifier: String(describing: name))
  121|      0|    }
  122|       |
  123|       |    /// SwifterSwift: Register UICollectionReusableView using class name.
  124|       |    ///
  125|       |    /// - Parameters:
  126|       |    ///   - nib: Nib file used to create the reusable view.
  127|       |    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
  128|       |    ///   - name: UICollectionReusableView type.
  129|      0|    public func register<T: UICollectionReusableView>(nib: UINib?, forSupplementaryViewOfKind kind: String, withClass name: T.Type) {
  130|      0|        register(nib, forSupplementaryViewOfKind: kind, withReuseIdentifier: String(describing: name))
  131|      0|    }
  132|       |
  133|       |    /// SwifterSwift: Register UICollectionViewCell with .xib file using only its corresponding class.
  134|       |    ///               Assumes that the .xib filename and cell class has the same name.
  135|       |    ///
  136|       |    /// - Parameters:
  137|       |    ///   - name: UICollectionViewCell type.
  138|       |    ///   - bundleClass: Class in which the Bundle instance will be based on.
  139|      0|    public func register<T: UICollectionViewCell>(nibWithCellClass name: T.Type, at bundleClass: AnyClass? = nil) {
  140|      0|        let identifier = String(describing: name)
  141|      0|        var bundle: Bundle?
  142|      0|
  143|      0|        if let bundleName = bundleClass {
  144|      0|            bundle = Bundle(for: bundleName)
  145|      0|        }
  146|      0|
  147|      0|        register(UINib(nibName: identifier, bundle: bundle), forCellWithReuseIdentifier: identifier)
  148|      0|    }
  149|       |
  150|       |}
  151|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIDatePickerExtensions.swift:
    1|       |//
    2|       |//  UIDatePickerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 12/9/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UIDatePicker {
   14|       |
   15|       |    /// SwifterSwift: Text color of UIDatePicker.
   16|       |    public var textColor: UIColor? {
   17|      0|        set {
   18|      0|            setValue(newValue, forKeyPath: "textColor")
   19|      0|        }
   20|       |        get {
   21|       |            return value(forKeyPath: "textColor") as? UIColor
   22|       |        }
   23|       |    }
   24|       |
   25|       |}
   26|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIEdgeInsetsExtensions.swift:
    1|       |//
    2|       |//  UIEdgeInsetsExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Luciano Almeida on 15/06/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |#if canImport(UIKit)
    9|       |import UIKit
   10|       |
   11|       |// MARK: - Properties
   12|       |extension UIEdgeInsets {
   13|       |    /// SwifterSwift: Return the vertical insets. The vertical insets is composed by top + bottom.
   14|       |    ///
   15|      0|    public var vertical: CGFloat {
   16|      0|        // Source: https://github.com/MessageKit/MessageKit/blob/master/Sources/Extensions/UIEdgeInsets%2BExtensions.swift
   17|      0|        return top + bottom
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Return the horizontal insets. The horizontal insets is composed by  left + right.
   21|       |    ///
   22|      0|    public var horizontal: CGFloat {
   23|      0|        // Source: https://github.com/MessageKit/MessageKit/blob/master/Sources/Extensions/UIEdgeInsets%2BExtensions.swift
   24|      0|        return left + right
   25|      0|    }
   26|       |
   27|       |}
   28|       |
   29|       |// MARK: - Methods
   30|       |extension UIEdgeInsets {
   31|       |    /// SwifterSwift: Creates an `UIEdgeInsets` with the inset value applied to all (top, bottom, right, left)
   32|       |    ///
   33|       |    /// - Parameter inset: Inset to be applied in all the edges.
   34|      0|    public init(inset: CGFloat) {
   35|      0|        self.init(top: inset, left: inset, bottom: inset, right: inset)
   36|      0|    }
   37|       |
   38|       |    /// SwifterSwift: Creates an `UIEdgeInsets` with the horizontal value equally divided and applied to right and left.
   39|       |    ///               And the vertical value equally divided and applied to top and bottom.
   40|       |    ///
   41|       |    ///
   42|       |    /// - Parameter horizontal: Inset to be applied to right and left.
   43|       |    /// - Parameter vertical: Inset to be applied to top and bottom.
   44|      0|    public init(horizontal: CGFloat, vertical: CGFloat) {
   45|      0|        self.init(top: vertical/2, left: horizontal/2, bottom: vertical/2, right: horizontal/2)
   46|      0|    }
   47|       |
   48|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and top offset.
   49|       |    ///
   50|       |    /// - Parameters:
   51|       |    ///   - top: Offset to be applied in to the top edge.
   52|       |    /// - Returns: UIEdgeInsets offset with given offset.
   53|      0|    public func insetBy(top: CGFloat) -> UIEdgeInsets {
   54|      0|        return UIEdgeInsets(top: self.top + top, left: left, bottom: bottom, right: right)
   55|      0|    }
   56|       |
   57|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and left offset.
   58|       |    ///
   59|       |    /// - Parameters:
   60|       |    ///   - left: Offset to be applied in to the left edge.
   61|       |    /// - Returns: UIEdgeInsets offset with given offset.
   62|      0|    public func insetBy(left: CGFloat) -> UIEdgeInsets {
   63|      0|        return UIEdgeInsets(top: top, left: self.left + left, bottom: bottom, right: right)
   64|      0|    }
   65|       |
   66|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and bottom offset.
   67|       |    ///
   68|       |    /// - Parameters:
   69|       |    ///   - bottom: Offset to be applied in to the bottom edge.
   70|       |    /// - Returns: UIEdgeInsets offset with given offset.
   71|      0|    public func insetBy(bottom: CGFloat) -> UIEdgeInsets {
   72|      0|        return UIEdgeInsets(top: top, left: left, bottom: self.bottom + bottom, right: right)
   73|      0|    }
   74|       |
   75|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and right offset.
   76|       |    ///
   77|       |    /// - Parameters:
   78|       |    ///   - right: Offset to be applied in to the right edge.
   79|       |    /// - Returns: UIEdgeInsets offset with given offset.
   80|      0|    public func insetBy(right: CGFloat) -> UIEdgeInsets {
   81|      0|        return UIEdgeInsets(top: top, left: left, bottom: bottom, right: self.right + right)
   82|      0|    }
   83|       |
   84|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and horizontal value equally divided and applied to right offset and left offset.
   85|       |    ///
   86|       |    /// - Parameters:
   87|       |    ///   - horizontal: Offset to be applied to right and left.
   88|       |    /// - Returns: UIEdgeInsets offset with given offset.
   89|      0|    public func insetBy(horizontal: CGFloat) -> UIEdgeInsets {
   90|      0|        return UIEdgeInsets(top: top, left: left + horizontal/2, bottom: bottom, right: right + horizontal/2)
   91|      0|    }
   92|       |
   93|       |    /// SwifterSwift: Creates an `UIEdgeInsets` based on current value and vertical value equally divided and applied to top and bottom.
   94|       |    ///
   95|       |    /// - Parameters:
   96|       |    ///   - vertical: Offset to be applied to top and bottom.
   97|       |    /// - Returns: UIEdgeInsets offset with given offset.
   98|      0|    public func insetBy(vertical: CGFloat) -> UIEdgeInsets {
   99|      0|        return UIEdgeInsets(top: top + vertical/2, left: left, bottom: bottom + vertical/2, right: right)
  100|      0|    }
  101|       |}
  102|       |
  103|       |// MARK: - Operators
  104|       |extension UIEdgeInsets {
  105|       |
  106|       |    /// SwifterSwift: Add all the properties of two `UIEdgeInsets` to create their addition.
  107|       |    ///
  108|       |    /// - Parameters:
  109|       |    ///   - lhs: The left-hand expression
  110|       |    ///   - rhs: The right-hand expression
  111|       |    /// - Returns: A new `UIEdgeInsets` instance where the values of `lhs` and `rhs` are added together.
  112|      0|    public static func + (_ lhs: UIEdgeInsets, _ rhs: UIEdgeInsets) -> UIEdgeInsets {
  113|      0|        return UIEdgeInsets(top: lhs.top + rhs.top,
  114|      0|                            left: lhs.left + rhs.left,
  115|      0|                            bottom: lhs.bottom + rhs.bottom,
  116|      0|                            right: lhs.right + rhs.right)
  117|      0|    }
  118|       |
  119|       |    /// SwifterSwift: Add all the properties of two `UIEdgeInsets` to the left-hand instance.
  120|       |    ///
  121|       |    /// - Parameters:
  122|       |    ///   - lhs: The left-hand expression to be mutated
  123|       |    ///   - rhs: The right-hand expression
  124|      0|    public static func += (_ lhs: inout UIEdgeInsets, _ rhs: UIEdgeInsets) {
  125|      0|        lhs.top += rhs.top
  126|      0|        lhs.left += rhs.left
  127|      0|        lhs.bottom += rhs.bottom
  128|      0|        lhs.right += rhs.right
  129|      0|    }
  130|       |
  131|       |}
  132|       |
  133|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIFontExtensions.swift:
    1|       |//
    2|       |//  UIFontExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Benjamin Meyer on 9/16/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UIFont {
   14|       |
   15|       |    /// SwifterSwift: Font as bold font
   16|      0|    public var bold: UIFont {
   17|      0|        return UIFont(descriptor: fontDescriptor.withSymbolicTraits(.traitBold)!, size: 0)
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Font as italic font
   21|      0|    public var italic: UIFont {
   22|      0|        return UIFont(descriptor: fontDescriptor.withSymbolicTraits(.traitItalic)!, size: 0)
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: Font as monospaced font
   26|       |    ///
   27|       |    ///     UIFont.preferredFont(forTextStyle: .body).monospaced
   28|       |    ///
   29|      0|    public var monospaced: UIFont {
   30|      0|        let settings = [[UIFontDescriptor.FeatureKey.featureIdentifier: kNumberSpacingType, UIFontDescriptor.FeatureKey.typeIdentifier: kMonospacedNumbersSelector]]
   31|      0|
   32|      0|        let attributes = [UIFontDescriptor.AttributeName.featureSettings: settings]
   33|      0|        let newDescriptor = fontDescriptor.addingAttributes(attributes)
   34|      0|        return UIFont(descriptor: newDescriptor, size: 0)
   35|      0|    }
   36|       |
   37|       |}
   38|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIGestureRecognizerExtensions.swift:
    1|       |//
    2|       |//  UIGestureRecognizerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Morgan Dock on 4/21/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIGestureRecognizer {
   14|       |
   15|       |    /// SwifterSwift: Remove Gesture Recognizer from its view.
   16|      0|    public func removeFromView() {
   17|      0|        self.view?.removeGestureRecognizer(self)
   18|      0|    }
   19|       |
   20|       |}
   21|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIImageExtensions.swift:
    1|       |//
    2|       |//  UIImageExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/6/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UIImage {
   14|       |
   15|       |    /// SwifterSwift: Size in bytes of UIImage
   16|      0|    public var bytesSize: Int {
   17|      0|        return jpegData(compressionQuality: 1)?.count ?? 0
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Size in kilo bytes of UIImage
   21|      0|    public var kilobytesSize: Int {
   22|      0|        return bytesSize / 1024
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: UIImage with .alwaysOriginal rendering mode.
   26|      0|    public var original: UIImage {
   27|      0|        return withRenderingMode(.alwaysOriginal)
   28|      0|    }
   29|       |
   30|       |    /// SwifterSwift: UIImage with .alwaysTemplate rendering mode.
   31|      0|    public var template: UIImage {
   32|      0|        return withRenderingMode(.alwaysTemplate)
   33|      0|    }
   34|       |
   35|       |}
   36|       |
   37|       |// MARK: - Methods
   38|       |public extension UIImage {
   39|       |
   40|       |    /// SwifterSwift: Compressed UIImage from original UIImage.
   41|       |    ///
   42|       |    /// - Parameter quality: The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality), (default is 0.5).
   43|       |    /// - Returns: optional UIImage (if applicable).
   44|      0|    public func compressed(quality: CGFloat = 0.5) -> UIImage? {
   45|      0|        guard let data = compressedData(quality: quality) else { return nil }
   46|      0|        return UIImage(data: data)
   47|      0|    }
   48|       |
   49|       |    /// SwifterSwift: Compressed UIImage data from original UIImage.
   50|       |    ///
   51|       |    /// - Parameter quality: The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality), (default is 0.5).
   52|       |    /// - Returns: optional Data (if applicable).
   53|       |    public func compressedData(quality: CGFloat = 0.5) -> Data? {
   54|       |        return jpegData(compressionQuality: quality)
   55|       |    }
   56|       |
   57|       |    /// SwifterSwift: UIImage Cropped to CGRect.
   58|       |    ///
   59|       |    /// - Parameter rect: CGRect to crop UIImage to.
   60|       |    /// - Returns: cropped UIImage
   61|      0|    public func cropped(to rect: CGRect) -> UIImage {
   62|      0|        guard rect.size.height < size.height && rect.size.height < size.height else { return self }
   63|      0|        guard let image: CGImage = cgImage?.cropping(to: rect) else { return self }
   64|      0|        return UIImage(cgImage: image)
   65|      0|    }
   66|       |
   67|       |    /// SwifterSwift: UIImage scaled to height with respect to aspect ratio.
   68|       |    ///
   69|       |    /// - Parameters:
   70|       |    ///   - toHeight: new height.
   71|       |    ///   - opaque: flag indicating whether the bitmap is opaque.
   72|       |    /// - Returns: optional scaled UIImage (if applicable).
   73|      0|    public func scaled(toHeight: CGFloat, opaque: Bool = false) -> UIImage? {
   74|      0|        let scale = toHeight / size.height
   75|      0|        let newWidth = size.width * scale
   76|      0|        UIGraphicsBeginImageContextWithOptions(CGSize(width: newWidth, height: toHeight), opaque, 0)
   77|      0|        draw(in: CGRect(x: 0, y: 0, width: newWidth, height: toHeight))
   78|      0|        let newImage = UIGraphicsGetImageFromCurrentImageContext()
   79|      0|        UIGraphicsEndImageContext()
   80|      0|        return newImage
   81|      0|    }
   82|       |
   83|       |    /// SwifterSwift: UIImage scaled to width with respect to aspect ratio.
   84|       |    ///
   85|       |    /// - Parameters:
   86|       |    ///   - toWidth: new width.
   87|       |    ///   - opaque: flag indicating whether the bitmap is opaque.
   88|       |    /// - Returns: optional scaled UIImage (if applicable).
   89|      0|    public func scaled(toWidth: CGFloat, opaque: Bool = false) -> UIImage? {
   90|      0|        let scale = toWidth / size.width
   91|      0|        let newHeight = size.height * scale
   92|      0|        UIGraphicsBeginImageContextWithOptions(CGSize(width: toWidth, height: newHeight), opaque, 0)
   93|      0|        draw(in: CGRect(x: 0, y: 0, width: toWidth, height: newHeight))
   94|      0|        let newImage = UIGraphicsGetImageFromCurrentImageContext()
   95|      0|        UIGraphicsEndImageContext()
   96|      0|        return newImage
   97|      0|    }
   98|       |
   99|       |    /// SwifterSwift: Creates a copy of the receiver rotated by the given angle.
  100|       |    ///
  101|       |    ///     // Rotate the image by 180°
  102|       |    ///     image.rotated(by: Measurement(value: 180, unit: .degrees))
  103|       |    ///
  104|       |    /// - Parameter angle: The angle measurement by which to rotate the image.
  105|       |    /// - Returns: A new image rotated by the given angle.
  106|       |    @available(iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  107|      0|    public func rotated(by angle: Measurement<UnitAngle>) -> UIImage? {
  108|      0|        let radians = CGFloat(angle.converted(to: .radians).value)
  109|      0|
  110|      0|        let destRect = CGRect(origin: .zero, size: size)
  111|      0|            .applying(CGAffineTransform(rotationAngle: radians))
  112|      0|        let roundedDestRect = CGRect(x: destRect.origin.x.rounded(),
  113|      0|                                     y: destRect.origin.y.rounded(),
  114|      0|                                     width: destRect.width.rounded(),
  115|      0|                                     height: destRect.height.rounded())
  116|      0|
  117|      0|        UIGraphicsBeginImageContext(roundedDestRect.size)
  118|      0|        guard let contextRef = UIGraphicsGetCurrentContext() else { return nil }
  119|      0|
  120|      0|        contextRef.translateBy(x: roundedDestRect.width / 2, y: roundedDestRect.height / 2)
  121|      0|        contextRef.rotate(by: radians)
  122|      0|
  123|      0|        draw(in: CGRect(origin: CGPoint(x: -size.width / 2,
  124|      0|                                        y: -size.height / 2),
  125|      0|                        size: size))
  126|      0|
  127|      0|        let newImage = UIGraphicsGetImageFromCurrentImageContext()
  128|      0|        UIGraphicsEndImageContext()
  129|      0|        return newImage
  130|      0|    }
  131|       |
  132|       |    /// SwifterSwift: Creates a copy of the receiver rotated by the given angle (in radians).
  133|       |    ///
  134|       |    ///     // Rotate the image by 180°
  135|       |    ///     image.rotated(by: .pi)
  136|       |    ///
  137|       |    /// - Parameter radians: The angle, in radians, by which to rotate the image.
  138|       |    /// - Returns: A new image rotated by the given angle.
  139|      0|    public func rotated(by radians: CGFloat) -> UIImage? {
  140|      0|        let destRect = CGRect(origin: .zero, size: size)
  141|      0|            .applying(CGAffineTransform(rotationAngle: radians))
  142|      0|        let roundedDestRect = CGRect(x: destRect.origin.x.rounded(),
  143|      0|                                     y: destRect.origin.y.rounded(),
  144|      0|                                     width: destRect.width.rounded(),
  145|      0|                                     height: destRect.height.rounded())
  146|      0|
  147|      0|        UIGraphicsBeginImageContext(roundedDestRect.size)
  148|      0|        guard let contextRef = UIGraphicsGetCurrentContext() else { return nil }
  149|      0|
  150|      0|        contextRef.translateBy(x: roundedDestRect.width / 2, y: roundedDestRect.height / 2)
  151|      0|        contextRef.rotate(by: radians)
  152|      0|
  153|      0|        draw(in: CGRect(origin: CGPoint(x: -size.width / 2,
  154|      0|                                        y: -size.height / 2),
  155|      0|                        size: size))
  156|      0|
  157|      0|        let newImage = UIGraphicsGetImageFromCurrentImageContext()
  158|      0|        UIGraphicsEndImageContext()
  159|      0|        return newImage
  160|      0|    }
  161|       |
  162|       |    /// SwifterSwift: UIImage filled with color
  163|       |    ///
  164|       |    /// - Parameter color: color to fill image with.
  165|       |    /// - Returns: UIImage filled with given color.
  166|      0|    public func filled(withColor color: UIColor) -> UIImage {
  167|      0|        UIGraphicsBeginImageContextWithOptions(size, false, scale)
  168|      0|        color.setFill()
  169|      0|        guard let context = UIGraphicsGetCurrentContext() else { return self }
  170|      0|
  171|      0|        context.translateBy(x: 0, y: size.height)
  172|      0|        context.scaleBy(x: 1.0, y: -1.0)
  173|      0|        context.setBlendMode(CGBlendMode.normal)
  174|      0|
  175|      0|        let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height)
  176|      0|        guard let mask = self.cgImage else { return self }
  177|      0|        context.clip(to: rect, mask: mask)
  178|      0|        context.fill(rect)
  179|      0|
  180|      0|        let newImage = UIGraphicsGetImageFromCurrentImageContext()!
  181|      0|        UIGraphicsEndImageContext()
  182|      0|        return newImage
  183|      0|    }
  184|       |
  185|       |    /// SwifterSwift: UIImage tinted with color
  186|       |    ///
  187|       |    /// - Parameters:
  188|       |    ///   - color: color to tint image with.
  189|       |    ///   - blendMode: how to blend the tint
  190|       |    /// - Returns: UIImage tinted with given color.
  191|      0|    public func tint(_ color: UIColor, blendMode: CGBlendMode) -> UIImage {
  192|      0|        let drawRect = CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height)
  193|      0|        UIGraphicsBeginImageContextWithOptions(size, false, scale)
  194|      0|        let context = UIGraphicsGetCurrentContext()
  195|      0|        context!.clip(to: drawRect, mask: cgImage!)
  196|      0|        color.setFill()
  197|      0|        UIRectFill(drawRect)
  198|      0|        draw(in: drawRect, blendMode: blendMode, alpha: 1.0)
  199|      0|        let tintedImage = UIGraphicsGetImageFromCurrentImageContext()
  200|      0|        UIGraphicsEndImageContext()
  201|      0|        return tintedImage!
  202|      0|    }
  203|       |
  204|       |    /// SwifterSwift: UIImage with rounded corners
  205|       |    ///
  206|       |    /// - Parameters:
  207|       |    ///   - radius: corner radius (optional), resulting image will be round if unspecified
  208|       |    /// - Returns: UIImage with all corners rounded
  209|      0|    public func withRoundedCorners(radius: CGFloat? = nil) -> UIImage? {
  210|      0|        let maxRadius = min(size.width, size.height) / 2
  211|      0|        let cornerRadius: CGFloat
  212|      0|        if let radius = radius, radius > 0 && radius <= maxRadius {
  213|      0|            cornerRadius = radius
  214|      0|        } else {
  215|      0|            cornerRadius = maxRadius
  216|      0|        }
  217|      0|
  218|      0|        UIGraphicsBeginImageContextWithOptions(size, false, scale)
  219|      0|
  220|      0|        let rect = CGRect(origin: .zero, size: size)
  221|      0|        UIBezierPath(roundedRect: rect, cornerRadius: cornerRadius).addClip()
  222|      0|        draw(in: rect)
  223|      0|
  224|      0|        let image = UIGraphicsGetImageFromCurrentImageContext()
  225|      0|        UIGraphicsEndImageContext()
  226|      0|        return image
  227|      0|    }
  228|       |
  229|       |}
  230|       |
  231|       |// MARK: - Initializers
  232|       |public extension UIImage {
  233|       |
  234|       |    /// SwifterSwift: Create UIImage from color and size.
  235|       |    ///
  236|       |    /// - Parameters:
  237|       |    ///   - color: image fill color.
  238|       |    ///   - size: image size.
  239|      0|    public convenience init(color: UIColor, size: CGSize) {
  240|      0|        UIGraphicsBeginImageContextWithOptions(size, false, 1)
  241|      0|
  242|      0|        defer {
  243|      0|            UIGraphicsEndImageContext()
  244|      0|        }
  245|      0|
  246|      0|        color.setFill()
  247|      0|        UIRectFill(CGRect(origin: .zero, size: size))
  248|      0|
  249|      0|        guard let aCgImage = UIGraphicsGetImageFromCurrentImageContext()?.cgImage else {
  250|      0|            self.init()
  251|      0|            return
  252|      0|        }
  253|      0|
  254|      0|        self.init(cgImage: aCgImage)
  255|      0|    }
  256|       |
  257|       |}
  258|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIImageViewExtensions.swift:
    1|       |//
    2|       |//  UIImageViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/25/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIImageView {
   14|       |
   15|       |    /// SwifterSwift: Set image from a URL.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - url: URL of image.
   19|       |    ///   - contentMode: imageView content mode (default is .scaleAspectFit).
   20|       |    ///   - placeHolder: optional placeholder image
   21|       |    ///   - completionHandler: optional completion handler to run when download finishs (default is nil).
   22|       |    public func download(
   23|       |        from url: URL,
   24|       |        contentMode: UIView.ContentMode = .scaleAspectFit,
   25|       |        placeholder: UIImage? = nil,
   26|      0|        completionHandler: ((UIImage?) -> Void)? = nil) {
   27|      0|
   28|      0|        image = placeholder
   29|      0|        self.contentMode = contentMode
   30|      0|        URLSession.shared.dataTask(with: url) { (data, response, _) in
   31|      0|            guard
   32|      0|                let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode == 200,
   33|      0|                let mimeType = response?.mimeType, mimeType.hasPrefix("image"),
   34|      0|                let data = data,
   35|      0|                let image = UIImage(data: data)
   36|      0|                else {
   37|      0|                    completionHandler?(nil)
   38|      0|                    return
   39|      0|            }
   40|      0|            DispatchQueue.main.async {
   41|      0|                self.image = image
   42|      0|                completionHandler?(image)
   43|      0|            }
   44|      0|            }.resume()
   45|      0|    }
   46|       |
   47|       |    /// SwifterSwift: Make image view blurry
   48|       |    ///
   49|       |    /// - Parameter style: UIBlurEffectStyle (default is .light).
   50|      0|    public func blur(withStyle style: UIBlurEffect.Style = .light) {
   51|      0|        let blurEffect = UIBlurEffect(style: style)
   52|      0|        let blurEffectView = UIVisualEffectView(effect: blurEffect)
   53|      0|        blurEffectView.frame = bounds
   54|      0|        blurEffectView.autoresizingMask = [.flexibleWidth, .flexibleHeight] // for supporting device rotation
   55|      0|        addSubview(blurEffectView)
   56|      0|        clipsToBounds = true
   57|      0|    }
   58|       |
   59|       |    /// SwifterSwift: Blurred version of an image view
   60|       |    ///
   61|       |    /// - Parameter style: UIBlurEffectStyle (default is .light).
   62|       |    /// - Returns: blurred version of self.
   63|      0|    public func blurred(withStyle style: UIBlurEffect.Style = .light) -> UIImageView {
   64|      0|        let imgView = self
   65|      0|        imgView.blur(withStyle: style)
   66|      0|        return imgView
   67|      0|    }
   68|       |
   69|       |}
   70|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UILabelExtensions.swift:
    1|       |//
    2|       |//  UILabelExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/23/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UILabel {
   14|       |
   15|       |    /// SwifterSwift: Initialize a UILabel with text
   16|      0|    public convenience init(text: String?) {
   17|      0|        self.init()
   18|      0|        self.text = text
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Required height for a label
   22|      0|    public var requiredHeight: CGFloat {
   23|      0|        let label = UILabel(frame: CGRect(x: 0, y: 0, width: frame.width, height: CGFloat.greatestFiniteMagnitude))
   24|      0|        label.numberOfLines = 0
   25|      0|        label.lineBreakMode = NSLineBreakMode.byWordWrapping
   26|      0|        label.font = font
   27|      0|        label.text = text
   28|      0|        label.attributedText = attributedText
   29|      0|        label.sizeToFit()
   30|      0|        return label.frame.height
   31|      0|    }
   32|       |
   33|       |}
   34|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UILayoutPriorityExtensions.swift:
    1|       |//
    2|       |//  UILayoutPriorityExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by diamantidis on 8/19/18.
    6|       |//  Copyright © 2018 SwifterSwift. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |
   12|       |extension UILayoutPriority: ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral {
   13|       |
   14|       |    // MARK: - Initializers
   15|       |
   16|       |    /// SwifterSwift: Initialize `UILayoutPriority` with a float literal
   17|       |    ///
   18|       |    ///     constraint.priority = 0.5
   19|       |    ///
   20|       |    /// - Parameter value: The float value of the constraint
   21|      0|    public init(floatLiteral value: Float) {
   22|      0|        self.init(rawValue: value)
   23|      0|    }
   24|       |
   25|       |    /// SwifterSwift: Initialize `UILayoutPriority` with an integer literal
   26|       |    ///
   27|       |    ///     constraint.priority = 5
   28|       |    ///
   29|       |    /// - Parameter value: The integer value of the constraint
   30|      0|    public init(integerLiteral value: Int) {
   31|      0|        self.init(rawValue: Float(value))
   32|      0|    }
   33|       |}
   34|       |
   35|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UINavigationBarExtensions.swift:
    1|       |//
    2|       |//  UINavigationBarExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/22/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UINavigationBar {
   14|       |
   15|       |    /// SwifterSwift: Set Navigation Bar title, title color and font.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - font: title font
   19|       |    ///   - color: title text color (default is .black).
   20|      0|    public func setTitleFont(_ font: UIFont, color: UIColor = .black) {
   21|      0|        var attrs = [NSAttributedString.Key: Any]()
   22|      0|        attrs[.font] = font
   23|      0|        attrs[.foregroundColor] = color
   24|      0|        titleTextAttributes = attrs
   25|      0|    }
   26|       |
   27|       |    /// SwifterSwift: Make navigation bar transparent.
   28|       |    ///
   29|       |    /// - Parameter tint: tint color (default is .white).
   30|      0|    public func makeTransparent(withTint tint: UIColor = .white) {
   31|      0|        isTranslucent = true
   32|      0|        backgroundColor = .clear
   33|      0|        barTintColor = .clear
   34|      0|        setBackgroundImage(UIImage(), for: .default)
   35|      0|        tintColor = tint
   36|      0|        titleTextAttributes = [.foregroundColor: tint]
   37|      0|        shadowImage = UIImage()
   38|      0|    }
   39|       |
   40|       |    /// SwifterSwift: Set navigationBar background and text colors
   41|       |    ///
   42|       |    /// - Parameters:
   43|       |    ///   - background: backgound color
   44|       |    ///   - text: text color
   45|      0|    public func setColors(background: UIColor, text: UIColor) {
   46|      0|        isTranslucent = false
   47|      0|        backgroundColor = background
   48|      0|        barTintColor = background
   49|      0|        setBackgroundImage(UIImage(), for: .default)
   50|      0|        tintColor = text
   51|      0|        titleTextAttributes = [.foregroundColor: text]
   52|      0|    }
   53|       |
   54|       |}
   55|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UINavigationControllerExtensions.swift:
    1|       |//
    2|       |//  UINavigationControllerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/6/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UINavigationController {
   14|       |
   15|       |    /// SwifterSwift: Pop ViewController with completion handler.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - animated: Set this value to true to animate the transition (default is true).
   19|       |    ///   - completion: optional completion handler (default is nil).
   20|      0|    public func popViewController(animated: Bool = true, _ completion: (() -> Void)? = nil) {
   21|      0|        // https://github.com/cotkjaer/UserInterface/blob/master/UserInterface/UIViewController.swift
   22|      0|        CATransaction.begin()
   23|      0|        CATransaction.setCompletionBlock(completion)
   24|      0|        popViewController(animated: animated)
   25|      0|        CATransaction.commit()
   26|      0|    }
   27|       |
   28|       |    /// SwifterSwift: Push ViewController with completion handler.
   29|       |    ///
   30|       |    /// - Parameters:
   31|       |    ///   - viewController: viewController to push.
   32|       |    ///   - completion: optional completion handler (default is nil).
   33|      0|    public func pushViewController(_ viewController: UIViewController, completion: (() -> Void)? = nil) {
   34|      0|        // https://github.com/cotkjaer/UserInterface/blob/master/UserInterface/UIViewController.swift
   35|      0|        CATransaction.begin()
   36|      0|        CATransaction.setCompletionBlock(completion)
   37|      0|        pushViewController(viewController, animated: true)
   38|      0|        CATransaction.commit()
   39|      0|    }
   40|       |
   41|       |    /// SwifterSwift: Make navigation controller's navigation bar transparent.
   42|       |    ///
   43|       |    /// - Parameter tint: tint color (default is .white).
   44|      0|    public func makeTransparent(withTint tint: UIColor = .white) {
   45|      0|        navigationBar.setBackgroundImage(UIImage(), for: .default)
   46|      0|        navigationBar.shadowImage = UIImage()
   47|      0|        navigationBar.isTranslucent = true
   48|      0|        navigationBar.tintColor = tint
   49|      0|        navigationBar.titleTextAttributes = [.foregroundColor: tint]
   50|      0|    }
   51|       |
   52|       |}
   53|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UINavigationItemExtensions.swift:
    1|       |//
    2|       |//  UINavigationItemExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/28/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UINavigationItem {
   14|       |
   15|       |    /// SwifterSwift: Replace title label with an image in navigation item.
   16|       |    ///
   17|       |    /// - Parameter image: UIImage to replace title with.
   18|      0|    public func replaceTitle(with image: UIImage) {
   19|      0|        let logoImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 100, height: 30))
   20|      0|        logoImageView.contentMode = .scaleAspectFit
   21|      0|        logoImageView.image = image
   22|      0|        titleView = logoImageView
   23|      0|    }
   24|       |
   25|       |}
   26|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIRefreshControlExtensions.swift:
    1|       |//
    2|       |//  UIRefreshControlExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by ratul sharker on 7/24/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIRefreshControl {
   14|       |
   15|       |    /// SwifterSwift: Programatically begin refresh control inside of UITableView.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - tableView: UITableView instance, inside which the refresh control is contained.
   19|       |    ///   - animated: Boolean, indicates that is the content offset changing should be animated or not.
   20|       |    ///   - sendAction: Boolean, indicates that should it fire sendActions method for valueChanged UIControlEvents
   21|      0|    public func beginRefreshing(in tableView: UITableView, animated: Bool, sendAction: Bool = false) {
   22|      0|        //https://stackoverflow.com/questions/14718850/uirefreshcontrol-beginrefreshing-not-working-when-uitableviewcontroller-is-ins/14719658#14719658
   23|      0|        assert(superview == tableView, "Refresh control does not belong to the receiving table view")
   24|      0|
   25|      0|        beginRefreshing()
   26|      0|        let offsetPoint = CGPoint(x: 0, y: -frame.height)
   27|      0|        tableView.setContentOffset(offsetPoint, animated: animated)
   28|      0|
   29|      0|        if sendAction {
   30|      0|            sendActions(for: .valueChanged)
   31|      0|        }
   32|      0|    }
   33|       |
   34|       |}
   35|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIScrollViewExtensions.swift:
    1|       |//
    2|       |//  UIScrollViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by camila oliveira on 22/04/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIScrollView {
   14|       |
   15|       |    /// SwifterSwift: Takes a snapshot of an entire ScrollView
   16|       |    ///
   17|       |    ///    AnySubclassOfUIScroolView().snapshot
   18|       |    ///    UITableView().snapshot
   19|       |    ///
   20|       |    /// - Returns: Snapshot as UIimage for rendered ScrollView
   21|      0|    public var snapshot: UIImage? {
   22|      0|        // Original Source: https://gist.github.com/thestoics/1204051
   23|      0|        UIGraphicsBeginImageContextWithOptions(contentSize, false, 0)
   24|      0|        defer {
   25|      0|            UIGraphicsEndImageContext()
   26|      0|        }
   27|      0|        guard let context = UIGraphicsGetCurrentContext() else { return nil }
   28|      0|        let previousFrame = frame
   29|      0|        frame = CGRect(origin: frame.origin, size: contentSize)
   30|      0|        layer.render(in: context)
   31|      0|        frame = previousFrame
   32|      0|        return UIGraphicsGetImageFromCurrentImageContext()
   33|      0|    }
   34|       |}
   35|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UISearchBarExtensions.swift:
    1|       |//
    2|       |//  UISearchBarExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/23/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UISearchBar {
   14|       |
   15|       |    /// SwifterSwift: Text field inside search bar (if applicable).
   16|      0|    public var textField: UITextField? {
   17|      0|        let subViews = subviews.flatMap { $0.subviews }
   18|      0|        guard let textField = (subViews.filter { $0 is UITextField }).first as? UITextField else {
   19|      0|            return nil
   20|      0|        }
   21|      0|        return textField
   22|      0|    }
   23|       |
   24|       |    /// SwifterSwift: Text with no spaces or new lines in beginning and end (if applicable).
   25|      0|    public var trimmedText: String? {
   26|      0|        return text?.trimmingCharacters(in: .whitespacesAndNewlines)
   27|      0|    }
   28|       |
   29|       |}
   30|       |
   31|       |// MARK: - Methods
   32|       |public extension UISearchBar {
   33|       |
   34|       |    /// SwifterSwift: Clear text.
   35|      0|    public func clear() {
   36|      0|        text = ""
   37|      0|    }
   38|       |
   39|       |}
   40|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UISegmentedControlExtensions.swift:
    1|       |//
    2|       |//  UISegmentedControlExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/28/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UISegmentedControl {
   14|       |
   15|       |    /// SwifterSwift: Segments titles.
   16|       |    public var segmentTitles: [String] {
   17|      0|        get {
   18|      0|            let range = 0..<numberOfSegments
   19|      0|            return range.compactMap { titleForSegment(at: $0) }
   20|      0|        }
   21|      0|        set {
   22|      0|            removeAllSegments()
   23|      0|            for (index, title) in newValue.enumerated() {
   24|      0|                insertSegment(withTitle: title, at: index, animated: false)
   25|      0|            }
   26|      0|        }
   27|       |    }
   28|       |
   29|       |    /// SwifterSwift: Segments images.
   30|       |    public var segmentImages: [UIImage] {
   31|      0|        get {
   32|      0|            let range = 0..<numberOfSegments
   33|      0|            return range.compactMap { imageForSegment(at: $0) }
   34|      0|        }
   35|      0|        set {
   36|      0|            removeAllSegments()
   37|      0|            for (index, image) in newValue.enumerated() {
   38|      0|                insertSegment(with: image, at: index, animated: false)
   39|      0|            }
   40|      0|        }
   41|       |    }
   42|       |
   43|       |}
   44|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UISliderExtensions.swift:
    1|       |//
    2|       |//  UISliderExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/28/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UISlider {
   14|       |
   15|       |    /// SwifterSwift: Set slide bar value with completion handler.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - value: slider value.
   19|       |    ///   - animated: set true to animate value change (default is true).
   20|       |    ///   - duration: animation duration in seconds (default is 1 second).
   21|       |    ///   - completion: an optional completion handler to run after value is changed (default is nil)
   22|      0|    public func setValue(_ value: Float, animated: Bool = true, duration: TimeInterval = 1, completion: (() -> Void)? = nil) {
   23|      0|        if animated {
   24|      0|            UIView.animate(withDuration: duration, animations: {
   25|      0|                self.setValue(value, animated: true)
   26|      0|            }, completion: { _ in
   27|      0|                completion?()
   28|      0|            })
   29|      0|        } else {
   30|      0|            setValue(value, animated: false)
   31|      0|            completion?()
   32|      0|        }
   33|      0|    }
   34|       |
   35|       |}
   36|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIStackViewExtensions.swift:
    1|       |//
    2|       |//  UIStackViewExtensions.swift
    3|       |//  SwifterSwift-iOS
    4|       |//
    5|       |//  Created by Benjamin Meyer on 2/18/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Initializers
   13|       |@available(iOS 9.0, *)
   14|       |public extension UIStackView {
   15|       |
   16|       |    /// SwifterSwift: Initialize an UIStackView with an array of UIView and common parameters.
   17|       |    ///
   18|       |    ///     let stackView = UIStackView(arrangedSubviews: [UIView(), UIView()], axis: .vertical)
   19|       |    ///
   20|       |    /// - Parameters:
   21|       |    ///   - arrangedSubviews: The UIViews to add to the stack.
   22|       |    ///   - axis: The axis along which the arranged views are laid out.
   23|       |    ///   - spacing: The distance in points between the adjacent edges of the stack view’s arranged views.(default: 0.0)
   24|       |    ///   - alignment: The alignment of the arranged subviews perpendicular to the stack view’s axis. (default: .fill)
   25|       |    ///   - distribution: The distribution of the arranged views along the stack view’s axis.(default: .fill)
   26|       |    public convenience init(arrangedSubviews: [UIView], axis: NSLayoutConstraint.Axis,
   27|       |                            spacing: CGFloat = 0.0,
   28|       |                            alignment: UIStackView.Alignment = .fill,
   29|      0|                            distribution: UIStackView.Distribution = .fill) {
   30|      0|        self.init(arrangedSubviews: arrangedSubviews)
   31|      0|        self.axis = axis
   32|      0|        self.spacing = spacing
   33|      0|        self.alignment = alignment
   34|      0|        self.distribution = distribution
   35|      0|    }
   36|       |
   37|       |    /// SwifterSwift: Adds array of views to the end of the arrangedSubviews array.
   38|       |    ///
   39|       |    /// - Parameter views: views array.
   40|      0|    public func addArrangedSubviews(_ views: [UIView]) {
   41|      0|        for view in views {
   42|      0|            addArrangedSubview(view)
   43|      0|        }
   44|      0|    }
   45|       |
   46|       |    /// SwifterSwift: Removes all views in stack’s array of arranged subviews.
   47|      0|    public func removeArrangedSubviews() {
   48|      0|        for view in arrangedSubviews {
   49|      0|            removeArrangedSubview(view)
   50|      0|        }
   51|      0|    }
   52|       |
   53|       |}
   54|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIStoryboardExtensions.swift:
    1|       |//
    2|       |//  UIStoryboardExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Steven on 2/6/17.
    6|       |//  Copyright © 2017 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)  && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIStoryboard {
   14|       |
   15|       |    /// SwifterSwift: Get main storyboard for application
   16|      0|    public static var main: UIStoryboard? {
   17|      0|        let bundle = Bundle.main
   18|      0|        guard let name = bundle.object(forInfoDictionaryKey: "UIMainStoryboardFile") as? String else { return nil }
   19|      0|        return UIStoryboard(name: name, bundle: bundle)
   20|      0|    }
   21|       |
   22|       |    /// SwifterSwift: Instantiate a UIViewController using its class name
   23|       |    ///
   24|       |    /// - Parameter name: UIViewController type
   25|       |    /// - Returns: The view controller corresponding to specified class name
   26|      0|    public func instantiateViewController<T: UIViewController>(withClass name: T.Type) -> T? {
   27|      0|        return instantiateViewController(withIdentifier: String(describing: name)) as? T
   28|      0|    }
   29|       |
   30|       |}
   31|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UISwitchExtensions.swift:
    1|       |//
    2|       |//  UISwitchExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 08/12/2016.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit)  && os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UISwitch {
   14|       |
   15|       |    /// SwifterSwift: Toggle a UISwitch
   16|       |    ///
   17|       |    /// - Parameter animated: set true to animate the change (default is true)
   18|      0|    public func toggle(animated: Bool = true) {
   19|      0|        setOn(!isOn, animated: animated)
   20|      0|    }
   21|       |
   22|       |}
   23|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UITabBarExtensions.swift:
    1|       |//
    2|       |//  UITabBarExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/28/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UITabBar {
   14|       |
   15|       |    /// SwifterSwift: Set tabBar colors.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - background: background color.
   19|       |    ///   - selectedBackground: background color for selected tab.
   20|       |    ///   - item: icon tint color for items.
   21|       |    ///   - selectedItem: icon tint color for item.
   22|       |    public func setColors(
   23|       |        background: UIColor? = nil,
   24|       |        selectedBackground: UIColor? = nil,
   25|       |        item: UIColor? = nil,
   26|      0|        selectedItem: UIColor? = nil) {
   27|      0|
   28|      0|        // background
   29|      0|        barTintColor = background ?? barTintColor
   30|      0|
   31|      0|        // selectedItem
   32|      0|        tintColor = selectedItem ?? tintColor
   33|      0|        // shadowImage = UIImage()
   34|      0|        backgroundImage = UIImage()
   35|      0|        isTranslucent = false
   36|      0|
   37|      0|        // selectedBackgoundColor
   38|      0|        guard let barItems = items else {
   39|      0|            return
   40|      0|        }
   41|      0|
   42|      0|        if let selectedbg = selectedBackground {
   43|      0|            let rect = CGSize(width: frame.width/CGFloat(barItems.count), height: frame.height)
   44|      0|            selectionIndicatorImage = { (color: UIColor, size: CGSize) -> UIImage in
   45|      0|                UIGraphicsBeginImageContextWithOptions(size, false, 1)
   46|      0|                color.setFill()
   47|      0|                UIRectFill(CGRect(x: 0, y: 0, width: size.width, height: size.height))
   48|      0|                guard let image = UIGraphicsGetImageFromCurrentImageContext() else { return UIImage() }
   49|      0|                UIGraphicsEndImageContext()
   50|      0|                guard let aCgImage = image.cgImage else { return UIImage() }
   51|      0|                return UIImage(cgImage: aCgImage)
   52|      0|            }(selectedbg, rect)
   53|      0|        }
   54|      0|
   55|      0|        if let itemColor = item {
   56|      0|            for barItem in barItems as [UITabBarItem] {
   57|      0|                // item
   58|      0|                guard let image = barItem.image else { continue }
   59|      0|
   60|      0|                barItem.image = { (image: UIImage, color: UIColor) -> UIImage in
   61|      0|                    UIGraphicsBeginImageContextWithOptions(image.size, false, image.scale)
   62|      0|                    color.setFill()
   63|      0|                    guard let context = UIGraphicsGetCurrentContext() else {
   64|      0|                        return image
   65|      0|                    }
   66|      0|
   67|      0|                    context.translateBy(x: 0, y: image.size.height)
   68|      0|                    context.scaleBy(x: 1.0, y: -1.0)
   69|      0|                    context.setBlendMode(CGBlendMode.normal)
   70|      0|
   71|      0|                    let rect = CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height)
   72|      0|                    guard let mask = image.cgImage else { return image }
   73|      0|                    context.clip(to: rect, mask: mask)
   74|      0|                    context.fill(rect)
   75|      0|
   76|      0|                    let newImage = UIGraphicsGetImageFromCurrentImageContext()!
   77|      0|                    UIGraphicsEndImageContext()
   78|      0|                    return newImage
   79|      0|                    }(image, itemColor).withRenderingMode(.alwaysOriginal)
   80|      0|
   81|      0|                barItem.setTitleTextAttributes([.foregroundColor: itemColor], for: .normal)
   82|      0|                if let selected = selectedItem {
   83|      0|                    barItem.setTitleTextAttributes([.foregroundColor: selected], for: .selected)
   84|      0|                }
   85|      0|            }
   86|      0|        }
   87|      0|    }
   88|       |
   89|       |}
   90|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UITableViewExtensions.swift:
    1|       |//
    2|       |//  UITableViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/22/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UITableView {
   14|       |
   15|       |    /// SwifterSwift: Index path of last row in tableView.
   16|      0|    public var indexPathForLastRow: IndexPath? {
   17|      0|        return indexPathForLastRow(inSection: lastSection)
   18|      0|    }
   19|       |
   20|       |    /// SwifterSwift: Index of last section in tableView.
   21|       |    public var lastSection: Int {
   22|       |        return numberOfSections > 0 ? numberOfSections - 1 : 0
   23|       |    }
   24|       |
   25|       |}
   26|       |
   27|       |// MARK: - Methods
   28|       |public extension UITableView {
   29|       |
   30|       |    /// SwifterSwift: Number of all rows in all sections of tableView.
   31|       |    ///
   32|       |    /// - Returns: The count of all rows in the tableView.
   33|      0|    public func numberOfRows() -> Int {
   34|      0|        var section = 0
   35|      0|        var rowCount = 0
   36|      0|        while section < numberOfSections {
   37|      0|            rowCount += numberOfRows(inSection: section)
   38|      0|            section += 1
   39|      0|        }
   40|      0|        return rowCount
   41|      0|    }
   42|       |
   43|       |    /// SwifterSwift: IndexPath for last row in section.
   44|       |    ///
   45|       |    /// - Parameter section: section to get last row in.
   46|       |    /// - Returns: optional last indexPath for last row in section (if applicable).
   47|       |    public func indexPathForLastRow(inSection section: Int) -> IndexPath? {
   48|       |        guard section >= 0 else { return nil }
   49|       |        guard numberOfRows(inSection: section) > 0  else {
   50|       |            return IndexPath(row: 0, section: section)
   51|       |        }
   52|       |        return IndexPath(row: numberOfRows(inSection: section) - 1, section: section)
   53|       |    }
   54|       |
   55|       |    /// Reload data with a completion handler.
   56|       |    ///
   57|       |    /// - Parameter completion: completion handler to run after reloadData finishes.
   58|      0|    public func reloadData(_ completion: @escaping () -> Void) {
   59|      0|        UIView.animate(withDuration: 0, animations: {
   60|      0|            self.reloadData()
   61|      0|        }, completion: { _ in
   62|      0|            completion()
   63|      0|        })
   64|      0|    }
   65|       |
   66|       |    /// SwifterSwift: Remove TableFooterView.
   67|      0|    public func removeTableFooterView() {
   68|      0|        tableFooterView = nil
   69|      0|    }
   70|       |
   71|       |    /// SwifterSwift: Remove TableHeaderView.
   72|      0|    public func removeTableHeaderView() {
   73|      0|        tableHeaderView = nil
   74|      0|    }
   75|       |
   76|       |    /// SwifterSwift: Scroll to bottom of TableView.
   77|       |    ///
   78|       |    /// - Parameter animated: set true to animate scroll (default is true).
   79|      0|    public func scrollToBottom(animated: Bool = true) {
   80|      0|        let bottomOffset = CGPoint(x: 0, y: contentSize.height - bounds.size.height)
   81|      0|        setContentOffset(bottomOffset, animated: animated)
   82|      0|    }
   83|       |
   84|       |    /// SwifterSwift: Scroll to top of TableView.
   85|       |    ///
   86|       |    /// - Parameter animated: set true to animate scroll (default is true).
   87|      0|    public func scrollToTop(animated: Bool = true) {
   88|      0|        setContentOffset(CGPoint.zero, animated: animated)
   89|      0|    }
   90|       |
   91|       |    /// SwifterSwift: Dequeue reusable UITableViewCell using class name
   92|       |    ///
   93|       |    /// - Parameter name: UITableViewCell type
   94|       |    /// - Returns: UITableViewCell object with associated class name.
   95|      0|    public func dequeueReusableCell<T: UITableViewCell>(withClass name: T.Type) -> T {
   96|      0|        guard let cell = dequeueReusableCell(withIdentifier: String(describing: name)) as? T else {
   97|      0|            fatalError("Couldn't find UITableViewCell for \(String(describing: name))")
   98|      0|        }
   99|      0|        return cell
  100|      0|    }
  101|       |
  102|       |    /// SwiferSwift: Dequeue reusable UITableViewCell using class name for indexPath
  103|       |    ///
  104|       |    /// - Parameters:
  105|       |    ///   - name: UITableViewCell type.
  106|       |    ///   - indexPath: location of cell in tableView.
  107|       |    /// - Returns: UITableViewCell object with associated class name.
  108|      0|    public func dequeueReusableCell<T: UITableViewCell>(withClass name: T.Type, for indexPath: IndexPath) -> T {
  109|      0|        guard let cell = dequeueReusableCell(withIdentifier: String(describing: name), for: indexPath) as? T else {
  110|      0|            fatalError("Couldn't find UITableViewCell for \(String(describing: name))")
  111|      0|        }
  112|      0|        return cell
  113|      0|    }
  114|       |
  115|       |    /// SwiferSwift: Dequeue reusable UITableViewHeaderFooterView using class name
  116|       |    ///
  117|       |    /// - Parameter name: UITableViewHeaderFooterView type
  118|       |    /// - Returns: UITableViewHeaderFooterView object with associated class name.
  119|      0|    public func dequeueReusableHeaderFooterView<T: UITableViewHeaderFooterView>(withClass name: T.Type) -> T {
  120|      0|        guard let headerFooterView = dequeueReusableHeaderFooterView(withIdentifier: String(describing: name)) as? T else {
  121|      0|            fatalError("Couldn't find UITableViewHeaderFooterView for \(String(describing: name))")
  122|      0|        }
  123|      0|        return headerFooterView
  124|      0|    }
  125|       |
  126|       |    /// SwifterSwift: Register UITableViewHeaderFooterView using class name
  127|       |    ///
  128|       |    /// - Parameters:
  129|       |    ///   - nib: Nib file used to create the header or footer view.
  130|       |    ///   - name: UITableViewHeaderFooterView type.
  131|      0|    public func register<T: UITableViewHeaderFooterView>(nib: UINib?, withHeaderFooterViewClass name: T.Type) {
  132|      0|        register(nib, forHeaderFooterViewReuseIdentifier: String(describing: name))
  133|      0|    }
  134|       |
  135|       |    /// SwifterSwift: Register UITableViewHeaderFooterView using class name
  136|       |    ///
  137|       |    /// - Parameter name: UITableViewHeaderFooterView type
  138|      0|    public func register<T: UITableViewHeaderFooterView>(headerFooterViewClassWith name: T.Type) {
  139|      0|        register(T.self, forHeaderFooterViewReuseIdentifier: String(describing: name))
  140|      0|    }
  141|       |
  142|       |    /// SwifterSwift: Register UITableViewCell using class name
  143|       |    ///
  144|       |    /// - Parameter name: UITableViewCell type
  145|      0|    public func register<T: UITableViewCell>(cellWithClass name: T.Type) {
  146|      0|        register(T.self, forCellReuseIdentifier: String(describing: name))
  147|      0|    }
  148|       |
  149|       |    /// SwifterSwift: Register UITableViewCell using class name
  150|       |    ///
  151|       |    /// - Parameters:
  152|       |    ///   - nib: Nib file used to create the tableView cell.
  153|       |    ///   - name: UITableViewCell type.
  154|      0|    public func register<T: UITableViewCell>(nib: UINib?, withCellClass name: T.Type) {
  155|      0|        register(nib, forCellReuseIdentifier: String(describing: name))
  156|      0|    }
  157|       |
  158|       |    /// SwifterSwift: Register UITableViewCell with .xib file using only its corresponding class.
  159|       |    ///               Assumes that the .xib filename and cell class has the same name.
  160|       |    ///
  161|       |    /// - Parameters:
  162|       |    ///   - name: UITableViewCell type.
  163|       |    ///   - bundleClass: Class in which the Bundle instance will be based on.
  164|      0|    public func register<T: UITableViewCell>(nibWithCellClass name: T.Type, at bundleClass: AnyClass? = nil) {
  165|      0|        let identifier = String(describing: name)
  166|      0|        var bundle: Bundle?
  167|      0|
  168|      0|        if let bundleName = bundleClass {
  169|      0|            bundle = Bundle(for: bundleName)
  170|      0|        }
  171|      0|
  172|      0|        register(UINib(nibName: identifier, bundle: bundle), forCellReuseIdentifier: identifier)
  173|      0|    }
  174|       |
  175|       |    /// SwifterSwift: Check whether IndexPath is valid within the tableView
  176|       |    ///
  177|       |    /// - Parameter indexPath: An IndexPath to check
  178|       |    /// - Returns: Boolean value for valid or invalid IndexPath
  179|      0|    public func isValidIndexPath(_ indexPath: IndexPath) -> Bool {
  180|      0|        return indexPath.section < self.numberOfSections && indexPath.row < self.numberOfRows(inSection: indexPath.section)
  181|      0|    }
  182|       |
  183|       |    /// SwifterSwift: Safely scroll to possibly invalid IndexPath
  184|       |    ///
  185|       |    /// - Parameters:
  186|       |    ///   - indexPath: Target IndexPath to scroll to
  187|       |    ///   - scrollPosition: Scroll position
  188|       |    ///   - animated: Whether to animate or not
  189|      0|    public func safeScrollToRow(at indexPath: IndexPath, at scrollPosition: UITableView.ScrollPosition, animated: Bool) {
  190|      0|        guard indexPath.section < numberOfSections else { return }
  191|      0|        guard indexPath.row < numberOfRows(inSection: indexPath.section) else { return }
  192|      0|        scrollToRow(at: indexPath, at: scrollPosition, animated: animated)
  193|      0|    }
  194|       |
  195|       |}
  196|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UITextFieldExtensions.swift:
    1|       |//
    2|       |//  UITextFieldExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/5/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Enums
   13|       |public extension UITextField {
   14|       |
   15|       |    /// SwifterSwift: UITextField text type.
   16|       |    ///
   17|       |    /// - emailAddress: UITextField is used to enter email addresses.
   18|       |    /// - password: UITextField is used to enter passwords.
   19|       |    /// - generic: UITextField is used to enter generic text.
   20|       |    public enum TextType {
   21|       |        /// UITextField is used to enter email addresses.
   22|       |        case emailAddress
   23|       |
   24|       |        /// UITextField is used to enter passwords.
   25|       |        case password
   26|       |
   27|       |        /// UITextField is used to enter generic text.
   28|       |        case generic
   29|       |    }
   30|       |
   31|       |}
   32|       |
   33|       |// MARK: - Properties
   34|       |public extension UITextField {
   35|       |
   36|       |    /// SwifterSwift: Set textField for common text types.
   37|       |    public var textType: TextType {
   38|      0|        get {
   39|      0|            if keyboardType == .emailAddress {
   40|      0|                return .emailAddress
   41|      0|            } else if isSecureTextEntry {
   42|      0|                return .password
   43|      0|            }
   44|      0|            return .generic
   45|      0|        }
   46|      0|        set {
   47|      0|            switch newValue {
   48|      0|            case .emailAddress:
   49|      0|                keyboardType = .emailAddress
   50|      0|                autocorrectionType = .no
   51|      0|                autocapitalizationType = .none
   52|      0|                isSecureTextEntry = false
   53|      0|                placeholder = "Email Address"
   54|      0|
   55|      0|            case .password:
   56|      0|                keyboardType = .asciiCapable
   57|      0|                autocorrectionType = .no
   58|      0|                autocapitalizationType = .none
   59|      0|                isSecureTextEntry = true
   60|      0|                placeholder = "Password"
   61|      0|
   62|      0|            case .generic:
   63|      0|                isSecureTextEntry = false
   64|      0|            }
   65|      0|        }
   66|       |    }
   67|       |
   68|       |    /// SwifterSwift: Check if text field is empty.
   69|      0|    public var isEmpty: Bool {
   70|      0|        return text?.isEmpty == true
   71|      0|    }
   72|       |
   73|       |    /// SwifterSwift: Return text with no spaces or new lines in beginning and end.
   74|      0|    public var trimmedText: String? {
   75|      0|        return text?.trimmingCharacters(in: .whitespacesAndNewlines)
   76|      0|    }
   77|       |
   78|       |    /// SwifterSwift: Check if textFields text is a valid email format.
   79|       |    ///
   80|       |    ///		textField.text = "john@doe.com"
   81|       |    ///		textField.hasValidEmail -> true
   82|       |    ///
   83|       |    ///		textField.text = "swifterswift"
   84|       |    ///		textField.hasValidEmail -> false
   85|       |    ///
   86|      0|    public var hasValidEmail: Bool {
   87|      0|        // http://stackoverflow.com/questions/25471114/how-to-validate-an-e-mail-address-in-swift
   88|      0|        return text!.range(of: "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}",
   89|      0|                           options: String.CompareOptions.regularExpression,
   90|      0|                           range: nil, locale: nil) != nil
   91|      0|    }
   92|       |
   93|       |    /// SwifterSwift: Left view tint color.
   94|       |    @IBInspectable public var leftViewTintColor: UIColor? {
   95|       |        get {
   96|       |            guard let iconView = leftView as? UIImageView else { return nil }
   97|       |            return iconView.tintColor
   98|       |        }
   99|       |        set {
  100|       |            guard let iconView = leftView as? UIImageView else { return }
  101|       |            iconView.image = iconView.image?.withRenderingMode(.alwaysTemplate)
  102|       |            iconView.tintColor = newValue
  103|       |        }
  104|       |    }
  105|       |
  106|       |    /// SwifterSwift: Right view tint color.
  107|       |    @IBInspectable public var rightViewTintColor: UIColor? {
  108|       |        get {
  109|       |            guard let iconView = rightView as? UIImageView else { return nil }
  110|       |            return iconView.tintColor
  111|       |        }
  112|       |        set {
  113|       |            guard let iconView = rightView as? UIImageView else { return }
  114|       |            iconView.image = iconView.image?.withRenderingMode(.alwaysTemplate)
  115|       |            iconView.tintColor = newValue
  116|       |        }
  117|       |    }
  118|       |
  119|       |}
  120|       |
  121|       |// MARK: - Methods
  122|       |public extension UITextField {
  123|       |
  124|       |    /// SwifterSwift: Clear text.
  125|      0|    public func clear() {
  126|      0|        text = ""
  127|      0|        attributedText = NSAttributedString(string: "")
  128|      0|    }
  129|       |
  130|       |    /// SwifterSwift: Set placeholder text color.
  131|       |    ///
  132|       |    /// - Parameter color: placeholder text color.
  133|      6|    public func setPlaceHolderTextColor(_ color: UIColor) {
  134|      6|        guard let holder = placeholder, !holder.isEmpty else { return }
  135|      6|        self.attributedPlaceholder = NSAttributedString(string: holder, attributes: [.foregroundColor: color])
  136|      6|    }
  137|       |
  138|       |    /// SwifterSwift: Add padding to the left of the textfield rect.
  139|       |    ///
  140|       |    /// - Parameter padding: amount of padding to apply to the left of the textfield rect.
  141|      0|    public func addPaddingLeft(_ padding: CGFloat) {
  142|      0|        let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: padding, height: frame.height))
  143|      0|        leftView = paddingView
  144|      0|        leftViewMode = .always
  145|      0|    }
  146|       |
  147|       |    /// SwifterSwift: Add padding to the left of the textfield rect.
  148|       |    ///
  149|       |    /// - Parameters:
  150|       |    ///   - image: left image
  151|       |    ///   - padding: amount of padding between icon and the left of textfield
  152|      0|    public func addPaddingLeftIcon(_ image: UIImage, padding: CGFloat) {
  153|      0|        let imageView = UIImageView(image: image)
  154|      0|        imageView.contentMode = .center
  155|      0|        self.leftView = imageView
  156|      0|        self.leftView?.frame.size = CGSize(width: image.size.width + padding, height: image.size.height)
  157|      0|        self.leftViewMode = UITextField.ViewMode.always
  158|      0|    }
  159|       |
  160|       |}
  161|       |
  162|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UITextViewExtensions.swift:
    1|       |//
    2|       |//  UITextViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 9/28/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UITextView {
   14|       |
   15|       |    /// SwifterSwift: Clear text.
   16|      0|    public func clear() {
   17|      0|        text = ""
   18|      0|        attributedText = NSAttributedString(string: "")
   19|      0|    }
   20|       |
   21|       |    /// SwifterSwift: Scroll to the bottom of text view
   22|      0|    public func scrollToBottom() {
   23|      0|        // swiftlint:disable next legacy_constructor
   24|      0|        let range = NSMakeRange((text as NSString).length - 1, 1)
   25|      0|        scrollRangeToVisible(range)
   26|      0|    }
   27|       |
   28|       |    /// SwifterSwift: Scroll to the top of text view
   29|      0|    public func scrollToTop() {
   30|      0|        // swiftlint:disable next legacy_constructor
   31|      0|        let range = NSMakeRange(0, 1)
   32|      0|        scrollRangeToVisible(range)
   33|      0|    }
   34|       |
   35|       |    /// SwifterSwift: Wrap to the content (Text / Attributed Text).
   36|      0|    public func wrapToContent() {
   37|      0|        contentInset = UIEdgeInsets.zero
   38|      0|        scrollIndicatorInsets = UIEdgeInsets.zero
   39|      0|        contentOffset = CGPoint.zero
   40|      0|        textContainerInset = UIEdgeInsets.zero
   41|      0|        textContainer.lineFragmentPadding = 0
   42|      0|        sizeToFit()
   43|      0|    }
   44|       |
   45|       |}
   46|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIViewControllerExtensions.swift:
    1|       |//
    2|       |//  UIViewControllerExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Emirhan Erdogan on 07/08/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Properties
   13|       |public extension UIViewController {
   14|       |
   15|       |    /// SwifterSwift: Check if ViewController is onscreen and not hidden.
   16|      0|    public var isVisible: Bool {
   17|      0|        // http://stackoverflow.com/questions/2777438/how-to-tell-if-uiviewcontrollers-view-is-visible
   18|      0|        return self.isViewLoaded && view.window != nil
   19|      0|    }
   20|       |
   21|       |}
   22|       |
   23|       |// MARK: - Methods
   24|       |public extension UIViewController {
   25|       |
   26|       |    /// SwifterSwift: Assign as listener to notification.
   27|       |    ///
   28|       |    /// - Parameters:
   29|       |    ///   - name: notification name.
   30|       |    ///   - selector: selector to run with notified.
   31|      0|    public func addNotificationObserver(name: Notification.Name, selector: Selector) {
   32|      0|        NotificationCenter.default.addObserver(self, selector: selector, name: name, object: nil)
   33|      0|    }
   34|       |
   35|       |    /// SwifterSwift: Unassign as listener to notification.
   36|       |    ///
   37|       |    /// - Parameter name: notification name.
   38|      0|    public func removeNotificationObserver(name: Notification.Name) {
   39|      0|        NotificationCenter.default.removeObserver(self, name: name, object: nil)
   40|      0|    }
   41|       |
   42|       |    /// SwifterSwift: Unassign as listener from all notifications.
   43|      0|    public func removeNotificationsObserver() {
   44|      0|        NotificationCenter.default.removeObserver(self)
   45|      0|    }
   46|       |
   47|       |    /// SwifterSwift: Helper method to display an alert on any UIViewController subclass. Uses UIAlertController to show an alert
   48|       |    ///
   49|       |    /// - Parameters:
   50|       |    ///   - title: title of the alert
   51|       |    ///   - message: message/body of the alert
   52|       |    ///   - buttonTitles: (Optional)list of button titles for the alert. Default button i.e "OK" will be shown if this paramter is nil
   53|       |    ///   - highlightedButtonIndex: (Optional) index of the button from buttonTitles that should be highlighted. If this parameter is nil no button will be highlighted
   54|       |    ///   - completion: (Optional) completion block to be invoked when any one of the buttons is tapped. It passes the index of the tapped button as an argument
   55|       |    /// - Returns: UIAlertController object (discardable).
   56|      0|    @discardableResult public func showAlert(title: String?, message: String?, buttonTitles: [String]? = nil, highlightedButtonIndex: Int? = nil, completion: ((Int) -> Void)? = nil) -> UIAlertController {
   57|      0|        let alertController = UIAlertController(title: title, message: message, preferredStyle: .alert)
   58|      0|        var allButtons = buttonTitles ?? [String]()
   59|      0|        if allButtons.count == 0 {
   60|      0|            allButtons.append("OK")
   61|      0|        }
   62|      0|
   63|      0|        for index in 0..<allButtons.count {
   64|      0|            let buttonTitle = allButtons[index]
   65|      0|            let action = UIAlertAction(title: buttonTitle, style: .default, handler: { (_) in
   66|      0|                completion?(index)
   67|      0|            })
   68|      0|            alertController.addAction(action)
   69|      0|            // Check which button to highlight
   70|      0|            if let highlightedButtonIndex = highlightedButtonIndex, index == highlightedButtonIndex {
   71|      0|                if #available(iOS 9.0, *) {
   72|      0|                    alertController.preferredAction = action
   73|      0|                }
   74|      0|            }
   75|      0|        }
   76|      0|        present(alertController, animated: true, completion: nil)
   77|      0|        return alertController
   78|      0|    }
   79|       |
   80|       |    /// SwifterSwift: Helper method to add a UIViewController as a childViewController.
   81|       |    ///
   82|       |    /// - Parameters:
   83|       |    ///   - child: the view controller to add as a child
   84|       |    ///   - containerView: the containerView for the child viewcontroller's root view.
   85|      0|    public func addChildViewController(_ child: UIViewController, toContainerView containerView: UIView) {
   86|      0|        addChild(child)
   87|      0|        containerView.addSubview(child.view)
   88|      0|        child.didMove(toParent: self)
   89|      0|    }
   90|       |
   91|       |    /// SwifterSwift: Helper method to remove a UIViewController from its parent.
   92|      0|    public func removeViewAndControllerFromParentViewController() {
   93|      0|        guard parent != nil else { return }
   94|      0|
   95|      0|        willMove(toParent: nil)
   96|      0|        removeFromParent()
   97|      0|        view.removeFromSuperview()
   98|      0|    }
   99|       |}
  100|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIViewExtensions.swift:
    1|       |//
    2|       |//  UIViewExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 8/5/16.
    6|       |//  Copyright © 2016 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && !os(watchOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - enums
   13|       |public extension UIView {
   14|       |
   15|       |    /// SwifterSwift: Shake directions of a view.
   16|       |    ///
   17|       |    /// - horizontal: Shake left and right.
   18|       |    /// - vertical: Shake up and down.
   19|       |    public enum ShakeDirection {
   20|       |        /// Shake left and right.
   21|       |        case horizontal
   22|       |
   23|       |        /// Shake up and down.
   24|       |        case vertical
   25|       |    }
   26|       |
   27|       |    /// SwifterSwift: Angle units.
   28|       |    ///
   29|       |    /// - degrees: degrees.
   30|       |    /// - radians: radians.
   31|       |    public enum AngleUnit {
   32|       |        /// degrees.
   33|       |        case degrees
   34|       |
   35|       |        /// radians.
   36|       |        case radians
   37|       |    }
   38|       |
   39|       |    /// SwifterSwift: Shake animations types.
   40|       |    ///
   41|       |    /// - linear: linear animation.
   42|       |    /// - easeIn: easeIn animation.
   43|       |    /// - easeOut: easeOut animation.
   44|       |    /// - easeInOut: easeInOut animation.
   45|       |    public enum ShakeAnimationType {
   46|       |        /// linear animation.
   47|       |        case linear
   48|       |
   49|       |        /// easeIn animation.
   50|       |        case easeIn
   51|       |
   52|       |        /// easeOut animation.
   53|       |        case easeOut
   54|       |
   55|       |        /// easeInOut animation.
   56|       |        case easeInOut
   57|       |    }
   58|       |
   59|       |}
   60|       |
   61|       |// MARK: - Properties
   62|       |public extension UIView {
   63|       |
   64|       |    /// SwifterSwift: Border color of view; also inspectable from Storyboard.
   65|       |    @IBInspectable public var borderColor: UIColor? {
   66|       |        get {
   67|       |            guard let color = layer.borderColor else { return nil }
   68|       |            return UIColor(cgColor: color)
   69|       |        }
   70|       |        set {
   71|       |            guard let color = newValue else {
   72|       |                layer.borderColor = nil
   73|       |                return
   74|       |            }
   75|       |            // Fix React-Native conflict issue
   76|       |            guard String(describing: type(of: color)) != "__NSCFType" else { return }
   77|       |            layer.borderColor = color.cgColor
   78|       |        }
   79|       |    }
   80|       |
   81|       |    /// SwifterSwift: Border width of view; also inspectable from Storyboard.
   82|       |    @IBInspectable public var borderWidth: CGFloat {
   83|       |        get {
   84|       |            return layer.borderWidth
   85|       |        }
   86|       |        set {
   87|       |            layer.borderWidth = newValue
   88|       |        }
   89|       |    }
   90|       |
   91|       |    /// SwifterSwift: Corner radius of view; also inspectable from Storyboard.
   92|       |    @IBInspectable public var cornerRadius: CGFloat {
   93|       |        get {
   94|       |            return layer.cornerRadius
   95|       |        }
   96|       |        set {
   97|       |            layer.masksToBounds = true
   98|       |            layer.cornerRadius = abs(CGFloat(Int(newValue * 100)) / 100)
   99|       |        }
  100|       |    }
  101|       |
  102|       |    /// SwifterSwift: Height of view.
  103|       |    public var height: CGFloat {
  104|      2|        get {
  105|      2|            return frame.size.height
  106|      2|        }
  107|      0|        set {
  108|      0|            frame.size.height = newValue
  109|      0|        }
  110|       |    }
  111|       |
  112|       |    /// SwifterSwift: Check if view is in RTL format.
  113|      0|    public var isRightToLeft: Bool {
  114|      0|        if #available(iOS 10.0, *, tvOS 10.0, *) {
  115|      0|            return effectiveUserInterfaceLayoutDirection == .rightToLeft
  116|      0|        } else {
  117|      0|            return false
  118|      0|        }
  119|      0|    }
  120|       |
  121|       |    /// SwifterSwift: Take screenshot of view (if applicable).
  122|      0|    public var screenshot: UIImage? {
  123|      0|        UIGraphicsBeginImageContextWithOptions(layer.frame.size, false, 0)
  124|      0|        defer {
  125|      0|            UIGraphicsEndImageContext()
  126|      0|        }
  127|      0|        guard let context = UIGraphicsGetCurrentContext() else { return nil }
  128|      0|        layer.render(in: context)
  129|      0|        return UIGraphicsGetImageFromCurrentImageContext()
  130|      0|    }
  131|       |
  132|       |    /// SwifterSwift: Shadow color of view; also inspectable from Storyboard.
  133|       |    @IBInspectable public var shadowColor: UIColor? {
  134|       |        get {
  135|       |            guard let color = layer.shadowColor else { return nil }
  136|       |            return UIColor(cgColor: color)
  137|       |        }
  138|       |        set {
  139|       |            layer.shadowColor = newValue?.cgColor
  140|       |        }
  141|       |    }
  142|       |
  143|       |    /// SwifterSwift: Shadow offset of view; also inspectable from Storyboard.
  144|       |    @IBInspectable public var shadowOffset: CGSize {
  145|       |        get {
  146|       |            return layer.shadowOffset
  147|       |        }
  148|       |        set {
  149|       |            layer.shadowOffset = newValue
  150|       |        }
  151|       |    }
  152|       |
  153|       |    /// SwifterSwift: Shadow opacity of view; also inspectable from Storyboard.
  154|       |    @IBInspectable public var shadowOpacity: Float {
  155|       |        get {
  156|       |            return layer.shadowOpacity
  157|       |        }
  158|       |        set {
  159|       |            layer.shadowOpacity = newValue
  160|       |        }
  161|       |    }
  162|       |
  163|       |    /// SwifterSwift: Shadow radius of view; also inspectable from Storyboard.
  164|       |    @IBInspectable public var shadowRadius: CGFloat {
  165|       |        get {
  166|       |            return layer.shadowRadius
  167|       |        }
  168|       |        set {
  169|       |            layer.shadowRadius = newValue
  170|       |        }
  171|       |    }
  172|       |
  173|       |    /// SwifterSwift: Size of view.
  174|       |    public var size: CGSize {
  175|      0|        get {
  176|      0|            return frame.size
  177|      0|        }
  178|      0|        set {
  179|      0|            width = newValue.width
  180|      0|            height = newValue.height
  181|      0|        }
  182|       |    }
  183|       |
  184|       |    /// SwifterSwift: Get view's parent view controller
  185|      0|    public var parentViewController: UIViewController? {
  186|      0|        weak var parentResponder: UIResponder? = self
  187|      0|        while parentResponder != nil {
  188|      0|            parentResponder = parentResponder!.next
  189|      0|            if let viewController = parentResponder as? UIViewController {
  190|      0|                return viewController
  191|      0|            }
  192|      0|        }
  193|      0|        return nil
  194|      0|    }
  195|       |
  196|       |    /// SwifterSwift: Width of view.
  197|       |    public var width: CGFloat {
  198|      0|        get {
  199|      0|            return frame.size.width
  200|      0|        }
  201|       |        set {
  202|       |            frame.size.width = newValue
  203|       |        }
  204|       |    }
  205|       |
  206|       |    // swiftlint:disable next identifier_name
  207|       |    /// SwifterSwift: x origin of view.
  208|       |    public var x: CGFloat {
  209|      0|        get {
  210|      0|            return frame.origin.x
  211|      0|        }
  212|      0|        set {
  213|      0|            frame.origin.x = newValue
  214|      0|        }
  215|       |    }
  216|       |
  217|       |    // swiftlint:disable next identifier_name
  218|       |    /// SwifterSwift: y origin of view.
  219|       |    public var y: CGFloat {
  220|      0|        get {
  221|      0|            return frame.origin.y
  222|      0|        }
  223|      0|        set {
  224|      0|            frame.origin.y = newValue
  225|      0|        }
  226|       |    }
  227|       |
  228|       |}
  229|       |
  230|       |// MARK: - Methods
  231|       |public extension UIView {
  232|       |
  233|       |    /// SwifterSwift: Recursively find the first responder.
  234|      0|    public func firstResponder() -> UIView? {
  235|      0|        var views = [UIView](arrayLiteral: self)
  236|      0|        var i = 0
  237|      0|        repeat {
  238|      0|            let view = views[i]
  239|      0|            if view.isFirstResponder {
  240|      0|                return view
  241|      0|            }
  242|      0|            views.append(contentsOf: view.subviews)
  243|      0|            i += 1
  244|      0|        } while i < views.count
  245|      0|        return nil
  246|      0|    }
  247|       |
  248|       |    /// SwifterSwift: Set some or all corners radiuses of view.
  249|       |    ///
  250|       |    /// - Parameters:
  251|       |    ///   - corners: array of corners to change (example: [.bottomLeft, .topRight]).
  252|       |    ///   - radius: radius for selected corners.
  253|      0|    public func roundCorners(_ corners: UIRectCorner, radius: CGFloat) {
  254|      0|        let maskPath = UIBezierPath(
  255|      0|            roundedRect: bounds,
  256|      0|            byRoundingCorners: corners,
  257|      0|            cornerRadii: CGSize(width: radius, height: radius))
  258|      0|
  259|      0|        let shape = CAShapeLayer()
  260|      0|        shape.path = maskPath.cgPath
  261|      0|        layer.mask = shape
  262|      0|    }
  263|       |
  264|       |    /// SwifterSwift: Add shadow to view.
  265|       |    ///
  266|       |    /// - Parameters:
  267|       |    ///   - color: shadow color (default is #137992).
  268|       |    ///   - radius: shadow radius (default is 3).
  269|       |    ///   - offset: shadow offset (default is .zero).
  270|       |    ///   - opacity: shadow opacity (default is 0.5).
  271|      0|    public func addShadow(ofColor color: UIColor = UIColor(red: 0.07, green: 0.47, blue: 0.57, alpha: 1.0), radius: CGFloat = 3, offset: CGSize = .zero, opacity: Float = 0.5) {
  272|      0|        layer.shadowColor = color.cgColor
  273|      0|        layer.shadowOffset = offset
  274|      0|        layer.shadowRadius = radius
  275|      0|        layer.shadowOpacity = opacity
  276|      0|        layer.masksToBounds = false
  277|      0|    }
  278|       |
  279|       |    /// SwifterSwift: Add array of subviews to view.
  280|       |    ///
  281|       |    /// - Parameter subviews: array of subviews to add to self.
  282|      0|    public func addSubviews(_ subviews: [UIView]) {
  283|      0|        subviews.forEach({ self.addSubview($0) })
  284|      0|    }
  285|       |
  286|       |    /// SwifterSwift: Fade in view.
  287|       |    ///
  288|       |    /// - Parameters:
  289|       |    ///   - duration: animation duration in seconds (default is 1 second).
  290|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil)
  291|      0|    public func fadeIn(duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil) {
  292|      0|        if isHidden {
  293|      0|            isHidden = false
  294|      0|        }
  295|      0|        UIView.animate(withDuration: duration, animations: {
  296|      0|            self.alpha = 1
  297|      0|        }, completion: completion)
  298|      0|    }
  299|       |
  300|       |    /// SwifterSwift: Fade out view.
  301|       |    ///
  302|       |    /// - Parameters:
  303|       |    ///   - duration: animation duration in seconds (default is 1 second).
  304|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil)
  305|      0|    public func fadeOut(duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil) {
  306|      0|        if isHidden {
  307|      0|            isHidden = false
  308|      0|        }
  309|      0|        UIView.animate(withDuration: duration, animations: {
  310|      0|            self.alpha = 0
  311|      0|        }, completion: completion)
  312|      0|    }
  313|       |
  314|       |    /// SwifterSwift: Load view from nib.
  315|       |    ///
  316|       |    /// - Parameters:
  317|       |    ///   - name: nib name.
  318|       |    ///   - bundle: bundle of nib (default is nil).
  319|       |    /// - Returns: optional UIView (if applicable).
  320|      0|    public class func loadFromNib(named name: String, bundle: Bundle? = nil) -> UIView? {
  321|      0|        return UINib(nibName: name, bundle: bundle).instantiate(withOwner: nil, options: nil)[0] as? UIView
  322|      0|    }
  323|       |
  324|       |    /// SwifterSwift: Remove all subviews in view.
  325|      0|    public func removeSubviews() {
  326|      0|        subviews.forEach({ $0.removeFromSuperview() })
  327|      0|    }
  328|       |
  329|       |    /// SwifterSwift: Remove all gesture recognizers from view.
  330|      0|    public func removeGestureRecognizers() {
  331|      0|        gestureRecognizers?.forEach(removeGestureRecognizer)
  332|      0|    }
  333|       |
  334|       |    /// SwifterSwift: Attaches gesture recognizers to the view.
  335|       |    ///
  336|       |    /// Attaching gesture recognizers to a view defines the scope of the represented
  337|       |    /// gesture, causing it to receive touches hit-tested to that view and all of its
  338|       |    /// subviews. The view establishes a strong reference to the gesture recognizers.
  339|       |    ///
  340|       |    /// - Parameter gestureRecognizers: The array of gesture recognizers to be added to the view.
  341|      0|    public func addGestureRecognizers(_ gestureRecognizers: [UIGestureRecognizer]) {
  342|      0|        for recognizer in gestureRecognizers {
  343|      0|            addGestureRecognizer(recognizer)
  344|      0|        }
  345|      0|    }
  346|       |
  347|       |    /// SwifterSwift: Detaches gesture recognizers from the receiving view.
  348|       |    ///
  349|       |    /// This method releases gestureRecognizers in addition to detaching them from the view.
  350|       |    ///
  351|       |    /// - Parameter gestureRecognizers: The array of gesture recognizers to be removed from the view.
  352|      0|    public func removeGestureRecognizers(_ gestureRecognizers: [UIGestureRecognizer]) {
  353|      0|        for recognizer in gestureRecognizers {
  354|      0|            removeGestureRecognizer(recognizer)
  355|      0|        }
  356|      0|    }
  357|       |
  358|       |    /// SwifterSwift: Rotate view by angle on relative axis.
  359|       |    ///
  360|       |    /// - Parameters:
  361|       |    ///   - angle: angle to rotate view by.
  362|       |    ///   - type: type of the rotation angle.
  363|       |    ///   - animated: set true to animate rotation (default is true).
  364|       |    ///   - duration: animation duration in seconds (default is 1 second).
  365|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil).
  366|      0|    public func rotate(byAngle angle: CGFloat, ofType type: AngleUnit, animated: Bool = false, duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil) {
  367|      0|        let angleWithType = (type == .degrees) ? .pi * angle / 180.0 : angle
  368|      0|        let aDuration = animated ? duration : 0
  369|      0|        UIView.animate(withDuration: aDuration, delay: 0, options: .curveLinear, animations: { () -> Void in
  370|      0|            self.transform = self.transform.rotated(by: angleWithType)
  371|      0|        }, completion: completion)
  372|      0|    }
  373|       |
  374|       |    /// SwifterSwift: Rotate view to angle on fixed axis.
  375|       |    ///
  376|       |    /// - Parameters:
  377|       |    ///   - angle: angle to rotate view to.
  378|       |    ///   - type: type of the rotation angle.
  379|       |    ///   - animated: set true to animate rotation (default is false).
  380|       |    ///   - duration: animation duration in seconds (default is 1 second).
  381|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil).
  382|      0|    public func rotate(toAngle angle: CGFloat, ofType type: AngleUnit, animated: Bool = false, duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil) {
  383|      0|        let angleWithType = (type == .degrees) ? .pi * angle / 180.0 : angle
  384|      0|        let aDuration = animated ? duration : 0
  385|      0|        UIView.animate(withDuration: aDuration, animations: {
  386|      0|            self.transform = self.transform.concatenating(CGAffineTransform(rotationAngle: angleWithType))
  387|      0|        }, completion: completion)
  388|      0|    }
  389|       |
  390|       |    /// SwifterSwift: Scale view by offset.
  391|       |    ///
  392|       |    /// - Parameters:
  393|       |    ///   - offset: scale offset
  394|       |    ///   - animated: set true to animate scaling (default is false).
  395|       |    ///   - duration: animation duration in seconds (default is 1 second).
  396|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil).
  397|      0|    public func scale(by offset: CGPoint, animated: Bool = false, duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil) {
  398|      0|        if animated {
  399|      0|            UIView.animate(withDuration: duration, delay: 0, options: .curveLinear, animations: { () -> Void in
  400|      0|                self.transform = self.transform.scaledBy(x: offset.x, y: offset.y)
  401|      0|            }, completion: completion)
  402|      0|        } else {
  403|      0|            transform = transform.scaledBy(x: offset.x, y: offset.y)
  404|      0|            completion?(true)
  405|      0|        }
  406|      0|    }
  407|       |
  408|       |    /// SwifterSwift: Shake view.
  409|       |    ///
  410|       |    /// - Parameters:
  411|       |    ///   - direction: shake direction (horizontal or vertical), (default is .horizontal)
  412|       |    ///   - duration: animation duration in seconds (default is 1 second).
  413|       |    ///   - animationType: shake animation type (default is .easeOut).
  414|       |    ///   - completion: optional completion handler to run with animation finishes (default is nil).
  415|      0|    public func shake(direction: ShakeDirection = .horizontal, duration: TimeInterval = 1, animationType: ShakeAnimationType = .easeOut, completion:(() -> Void)? = nil) {
  416|      0|        CATransaction.begin()
  417|      0|        let animation: CAKeyframeAnimation
  418|      0|        switch direction {
  419|      0|        case .horizontal:
  420|      0|            animation = CAKeyframeAnimation(keyPath: "transform.translation.x")
  421|      0|        case .vertical:
  422|      0|            animation = CAKeyframeAnimation(keyPath: "transform.translation.y")
  423|      0|        }
  424|      0|        switch animationType {
  425|      0|        case .linear:
  426|      0|            animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.linear)
  427|      0|        case .easeIn:
  428|      0|            animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeIn)
  429|      0|        case .easeOut:
  430|      0|            animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeOut)
  431|      0|        case .easeInOut:
  432|      0|            animation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
  433|      0|        }
  434|      0|        CATransaction.setCompletionBlock(completion)
  435|      0|        animation.duration = duration
  436|      0|        animation.values = [-20.0, 20.0, -20.0, 20.0, -10.0, 10.0, -5.0, 5.0, 0.0 ]
  437|      0|        layer.add(animation, forKey: "shake")
  438|      0|        CATransaction.commit()
  439|      0|    }
  440|       |
  441|       |    /// SwifterSwift: Add Visual Format constraints.
  442|       |    ///
  443|       |    /// - Parameters:
  444|       |    ///   - withFormat: visual Format language
  445|       |    ///   - views: array of views which will be accessed starting with index 0 (example: [v0], [v1], [v2]..)
  446|      0|    @available(iOS 9, *) public func addConstraints(withFormat: String, views: UIView...) {
  447|      0|        // https://videos.letsbuildthatapp.com/
  448|      0|        var viewsDictionary: [String: UIView] = [:]
  449|      0|        for (index, view) in views.enumerated() {
  450|      0|            let key = "v\(index)"
  451|      0|            view.translatesAutoresizingMaskIntoConstraints = false
  452|      0|            viewsDictionary[key] = view
  453|      0|        }
  454|      0|        addConstraints(NSLayoutConstraint.constraints(withVisualFormat: withFormat, options: NSLayoutConstraint.FormatOptions(), metrics: nil, views: viewsDictionary))
  455|      0|    }
  456|       |
  457|       |    /// SwifterSwift: Anchor all sides of the view into it's superview.
  458|      0|    @available(iOS 9, *) public func fillToSuperview() {
  459|      0|        // https://videos.letsbuildthatapp.com/
  460|      0|        translatesAutoresizingMaskIntoConstraints = false
  461|      0|        if let superview = superview {
  462|      0|            let left = leftAnchor.constraint(equalTo: superview.leftAnchor)
  463|      0|            let right = rightAnchor.constraint(equalTo: superview.rightAnchor)
  464|      0|            let top = topAnchor.constraint(equalTo: superview.topAnchor)
  465|      0|            let bottom = bottomAnchor.constraint(equalTo: superview.bottomAnchor)
  466|      0|            NSLayoutConstraint.activate([left, right, top, bottom])
  467|      0|        }
  468|      0|    }
  469|       |
  470|       |    /// SwifterSwift: Add anchors from any side of the current view into the specified anchors and returns the newly added constraints.
  471|       |    ///
  472|       |    /// - Parameters:
  473|       |    ///   - top: current view's top anchor will be anchored into the specified anchor
  474|       |    ///   - left: current view's left anchor will be anchored into the specified anchor
  475|       |    ///   - bottom: current view's bottom anchor will be anchored into the specified anchor
  476|       |    ///   - right: current view's right anchor will be anchored into the specified anchor
  477|       |    ///   - topConstant: current view's top anchor margin
  478|       |    ///   - leftConstant: current view's left anchor margin
  479|       |    ///   - bottomConstant: current view's bottom anchor margin
  480|       |    ///   - rightConstant: current view's right anchor margin
  481|       |    ///   - widthConstant: current view's width
  482|       |    ///   - heightConstant: current view's height
  483|       |    /// - Returns: array of newly added constraints (if applicable).
  484|       |    @available(iOS 9, *) @discardableResult public func anchor(
  485|       |        top: NSLayoutYAxisAnchor? = nil,
  486|       |        left: NSLayoutXAxisAnchor? = nil,
  487|       |        bottom: NSLayoutYAxisAnchor? = nil,
  488|       |        right: NSLayoutXAxisAnchor? = nil,
  489|       |        topConstant: CGFloat = 0,
  490|       |        leftConstant: CGFloat = 0,
  491|       |        bottomConstant: CGFloat = 0,
  492|       |        rightConstant: CGFloat = 0,
  493|       |        widthConstant: CGFloat = 0,
  494|      0|        heightConstant: CGFloat = 0) -> [NSLayoutConstraint] {
  495|      0|        // https://videos.letsbuildthatapp.com/
  496|      0|        translatesAutoresizingMaskIntoConstraints = false
  497|      0|
  498|      0|        var anchors = [NSLayoutConstraint]()
  499|      0|
  500|      0|        if let top = top {
  501|      0|            anchors.append(topAnchor.constraint(equalTo: top, constant: topConstant))
  502|      0|        }
  503|      0|
  504|      0|        if let left = left {
  505|      0|            anchors.append(leftAnchor.constraint(equalTo: left, constant: leftConstant))
  506|      0|        }
  507|      0|
  508|      0|        if let bottom = bottom {
  509|      0|            anchors.append(bottomAnchor.constraint(equalTo: bottom, constant: -bottomConstant))
  510|      0|        }
  511|      0|
  512|      0|        if let right = right {
  513|      0|            anchors.append(rightAnchor.constraint(equalTo: right, constant: -rightConstant))
  514|      0|        }
  515|      0|
  516|      0|        if widthConstant > 0 {
  517|      0|            anchors.append(widthAnchor.constraint(equalToConstant: widthConstant))
  518|      0|        }
  519|      0|
  520|      0|        if heightConstant > 0 {
  521|      0|            anchors.append(heightAnchor.constraint(equalToConstant: heightConstant))
  522|      0|        }
  523|      0|
  524|      0|        anchors.forEach({$0.isActive = true})
  525|      0|
  526|      0|        return anchors
  527|      0|    }
  528|       |
  529|       |    /// SwifterSwift: Anchor center X into current view's superview with a constant margin value.
  530|       |    ///
  531|       |    /// - Parameter constant: constant of the anchor constraint (default is 0).
  532|      0|    @available(iOS 9, *) public func anchorCenterXToSuperview(constant: CGFloat = 0) {
  533|      0|        // https://videos.letsbuildthatapp.com/
  534|      0|        translatesAutoresizingMaskIntoConstraints = false
  535|      0|        if let anchor = superview?.centerXAnchor {
  536|      0|            centerXAnchor.constraint(equalTo: anchor, constant: constant).isActive = true
  537|      0|        }
  538|      0|    }
  539|       |
  540|       |    /// SwifterSwift: Anchor center Y into current view's superview with a constant margin value.
  541|       |    ///
  542|       |    /// - Parameter withConstant: constant of the anchor constraint (default is 0).
  543|      0|    @available(iOS 9, *) public func anchorCenterYToSuperview(constant: CGFloat = 0) {
  544|      0|        // https://videos.letsbuildthatapp.com/
  545|      0|        translatesAutoresizingMaskIntoConstraints = false
  546|      0|        if let anchor = superview?.centerYAnchor {
  547|      0|            centerYAnchor.constraint(equalTo: anchor, constant: constant).isActive = true
  548|      0|        }
  549|      0|    }
  550|       |
  551|       |    /// SwifterSwift: Anchor center X and Y into current view's superview
  552|      0|    @available(iOS 9, *) public func anchorCenterSuperview() {
  553|      0|        // https://videos.letsbuildthatapp.com/
  554|      0|        anchorCenterXToSuperview()
  555|      0|        anchorCenterYToSuperview()
  556|      0|    }
  557|       |
  558|       |    /// SwifterSwift: Search all superviews until a view with the condition is found.
  559|       |    ///
  560|       |    /// - Parameter predicate: predicate to evaluate on superviews.
  561|      0|    public func ancestorView(where predicate: (UIView?) -> Bool) -> UIView? {
  562|      0|        if predicate(superview) {
  563|      0|            return superview
  564|      0|        }
  565|      0|        return superview?.ancestorView(where: predicate)
  566|      0|    }
  567|       |
  568|       |    /// SwifterSwift: Search all superviews until a view with this class is found.
  569|       |    ///
  570|       |    /// - Parameter name: class of the view to search.
  571|      0|    public func ancestorView<T: UIView>(withClass name: T.Type) -> T? {
  572|      0|        return ancestorView(where: { $0 is T }) as? T
  573|      0|    }
  574|       |
  575|       |}
  576|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwifterSwift/Sources/Extensions/UIKit/UIWindowExtensions.swift:
    1|       |//
    2|       |//  UIWindowExtensions.swift
    3|       |//  SwifterSwift
    4|       |//
    5|       |//  Created by Omar Albeik on 6/2/18.
    6|       |//  Copyright © 2018 SwifterSwift
    7|       |//
    8|       |
    9|       |#if canImport(UIKit) && os(iOS)
   10|       |import UIKit
   11|       |
   12|       |// MARK: - Methods
   13|       |public extension UIWindow {
   14|       |
   15|       |    /// SwifterSwift: Switch current root view controller with a new view controller.
   16|       |    ///
   17|       |    /// - Parameters:
   18|       |    ///   - viewController: new view controller.
   19|       |    ///   - animated: set to true to animate view controller change (default is true).
   20|       |    ///   - duration: animation duration in seconds (default is 0.5).
   21|       |    ///   - options: animataion options (default is .transitionFlipFromRight).
   22|       |    ///   - completion: optional completion handler called after view controller is changed.
   23|       |    public func switchRootViewController(
   24|       |        to viewController: UIViewController,
   25|       |        animated: Bool = true,
   26|       |        duration: TimeInterval = 0.5,
   27|       |        options: UIView.AnimationOptions = .transitionFlipFromRight,
   28|      0|        _ completion: (() -> Void)? = nil) {
   29|      0|
   30|      0|        guard animated else {
   31|      0|            rootViewController = viewController
   32|      0|            completion?()
   33|      0|            return
   34|      0|        }
   35|      0|
   36|      0|        UIView.transition(with: self, duration: duration, options: options, animations: {
   37|      0|            let oldState = UIView.areAnimationsEnabled
   38|      0|            UIView.setAnimationsEnabled(false)
   39|      0|            self.rootViewController = viewController
   40|      0|            UIView.setAnimationsEnabled(oldState)
   41|      0|        }, completion: { _ in
   42|      0|            completion?()
   43|      0|        })
   44|      0|    }
   45|       |
   46|       |}
   47|       |#endif

