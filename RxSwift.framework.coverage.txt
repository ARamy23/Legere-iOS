/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/AtomicInt.swift:
    1|       |//
    2|       |//  AtomicInt.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/28/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSLock
   10|       |
   11|       |final class AtomicInt: NSLock {
   12|       |    fileprivate var value: Int32
   13|      0|    public init(_ value: Int32 = 0) {
   14|      0|        self.value = value
   15|      0|    }
   16|       |}
   17|       |
   18|       |@discardableResult
   19|       |@inline(__always)
   20|      0|func add(_ this: AtomicInt, _ value: Int32) -> Int32 {
   21|      0|    this.lock()
   22|      0|    let oldValue = this.value
   23|      0|    this.value += value
   24|      0|    this.unlock()
   25|      0|    return oldValue
   26|      0|}
   27|       |
   28|       |@discardableResult
   29|       |@inline(__always)
   30|      0|func sub(_ this: AtomicInt, _ value: Int32) -> Int32 {
   31|      0|    this.lock()
   32|      0|    let oldValue = this.value
   33|      0|    this.value -= value
   34|      0|    this.unlock()
   35|      0|    return oldValue
   36|      0|}
   37|       |
   38|       |@discardableResult
   39|       |@inline(__always)
   40|      0|func fetchOr(_ this: AtomicInt, _ mask: Int32) -> Int32 {
   41|      0|    this.lock()
   42|      0|    let oldValue = this.value
   43|      0|    this.value |= mask
   44|      0|    this.unlock()
   45|      0|    return oldValue
   46|      0|}
   47|       |
   48|       |@inline(__always)
   49|      0|func load(_ this: AtomicInt) -> Int32 {
   50|      0|    this.lock()
   51|      0|    let oldValue = this.value
   52|      0|    this.unlock()
   53|      0|    return oldValue
   54|      0|}
   55|       |
   56|       |@discardableResult
   57|       |@inline(__always)
   58|      0|func increment(_ this: AtomicInt) -> Int32 {
   59|      0|    return add(this, 1)
   60|      0|}
   61|       |
   62|       |@discardableResult
   63|       |@inline(__always)
   64|      0|func decrement(_ this: AtomicInt) -> Int32 {
   65|      0|    return sub(this, 1)
   66|      0|}
   67|       |
   68|       |@inline(__always)
   69|      0|func isFlagSet(_ this: AtomicInt, _ mask: Int32) -> Bool {
   70|      0|    return (load(this) & mask) != 0
   71|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion and deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey?
   44|       |    var _value0: T?
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey: T]?
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|      0|    init() {
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|      0|    mutating func insert(_ element: T) -> BagKey {
   65|      0|        let key = _nextKey
   66|      0|
   67|      0|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|      0|
   69|      0|        if _key0 == nil {
   70|      0|            _key0 = key
   71|      0|            _value0 = element
   72|      0|            return key
   73|      0|        }
   74|      0|
   75|      0|        _onlyFastPath = false
   76|      0|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|      0|        }
   81|      0|
   82|      0|        if _pairs.count < arrayDictionaryMaxSize {
   83|      0|            _pairs.append((key: key, value: element))
   84|      0|            return key
   85|      0|        }
   86|      0|        
   87|      0|        _dictionary = [key: element]
   88|      0|        
   89|      0|        return key
   90|      0|    }
   91|       |    
   92|       |    /// - returns: Number of elements in bag.
   93|      0|    var count: Int {
   94|      0|        let dictionaryCount: Int = _dictionary?.count ?? 0
   95|      0|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
   96|      0|    }
   97|       |    
   98|       |    /// Removes all elements from bag and clears capacity.
   99|      0|    mutating func removeAll() {
  100|      0|        _key0 = nil
  101|      0|        _value0 = nil
  102|      0|
  103|      0|        _pairs.removeAll(keepingCapacity: false)
  104|      0|        _dictionary?.removeAll(keepingCapacity: false)
  105|      0|    }
  106|       |    
  107|       |    /**
  108|       |    Removes element with a specific `key` from bag.
  109|       |    
  110|       |    - parameter key: Key that identifies element to remove from bag.
  111|       |    - returns: Element that bag contained, or nil in case element was already removed.
  112|       |    */
  113|      0|    mutating func removeKey(_ key: BagKey) -> T? {
  114|      0|        if _key0 == key {
  115|      0|            _key0 = nil
  116|      0|            let value = _value0!
  117|      0|            _value0 = nil
  118|      0|            return value
  119|      0|        }
  120|      0|
  121|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  122|      0|            return existingObject
  123|      0|        }
  124|      0|
  125|      0|        for i in 0 ..< _pairs.count where _pairs[i].key == key {
  126|      0|            let value = _pairs[i].value
  127|      0|            _pairs.remove(at: i)
  128|      0|            return value
  129|      0|        }
  130|      0|
  131|      0|        return nil
  132|      0|    }
  133|       |}
  134|       |
  135|       |extension Bag {
  136|       |    /// A textual representation of `self`, suitable for debugging.
  137|       |    var debugDescription : String {
  138|       |        return "\(self.count) elements in Bag"
  139|       |    }
  140|       |}
  141|       |
  142|       |extension Bag {
  143|       |    /// Enumerates elements inside the bag.
  144|       |    ///
  145|       |    /// - parameter action: Enumeration closure.
  146|      0|    func forEach(_ action: (T) -> Void) {
  147|      0|        if _onlyFastPath {
  148|      0|            if let value0 = _value0 {
  149|      0|                action(value0)
  150|      0|            }
  151|      0|            return
  152|      0|        }
  153|      0|
  154|      0|        let value0 = _value0
  155|      0|        let dictionary = _dictionary
  156|      0|
  157|      0|        if let value0 = value0 {
  158|      0|            action(value0)
  159|      0|        }
  160|      0|
  161|      0|        for i in 0 ..< _pairs.count {
  162|      0|            action(_pairs[i].value)
  163|      0|        }
  164|      0|
  165|      0|        if dictionary?.count ?? 0 > 0 {
  166|      0|            for element in dictionary!.values {
  167|      0|                action(element)
  168|      0|            }
  169|      0|        }
  170|      0|    }
  171|       |}
  172|       |
  173|       |extension BagKey: Hashable {
  174|       |    #if swift(>=4.2)
  175|      0|    func hash(into hasher: inout Hasher) {
  176|      0|        hasher.combine(rawValue)
  177|      0|    }
  178|       |    #else
  179|       |    var hashValue: Int {
  180|       |        return rawValue.hashValue
  181|       |    }
  182|       |    #endif
  183|       |}
  184|       |
  185|       |func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|       |    return lhs.rawValue == rhs.rawValue
  187|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      0|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      0|        _hasHigherPriority = hasHigherPriority
   17|      0|        _isEqual = isEqual
   18|      0|    }
   19|       |
   20|      0|    mutating func enqueue(_ element: Element) {
   21|      0|        _elements.append(element)
   22|      0|        bubbleToHigherPriority(_elements.count - 1)
   23|      0|    }
   24|       |
   25|      0|    func peek() -> Element? {
   26|      0|        return _elements.first
   27|      0|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      0|    mutating func remove(_ element: Element) {
   44|      0|        for i in 0 ..< _elements.count {
   45|      0|            if _isEqual(_elements[i], element) {
   46|      0|                removeAt(i)
   47|      0|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|       |    private mutating func removeAt(_ index: Int) {
   53|       |        let removingLast = index == _elements.count - 1
   54|       |        if !removingLast {
   55|       |            _elements.swapAt(index, _elements.count - 1)
   56|       |        }
   57|       |
   58|       |        _ = _elements.popLast()
   59|       |
   60|       |        if !removingLast {
   61|       |            bubbleToHigherPriority(index)
   62|       |            bubbleToLowerPriority(index)
   63|       |        }
   64|       |    }
   65|       |
   66|       |    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|       |        precondition(initialUnbalancedIndex >= 0)
   68|       |        precondition(initialUnbalancedIndex < _elements.count)
   69|       |
   70|       |        var unbalancedIndex = initialUnbalancedIndex
   71|       |
   72|       |        while unbalancedIndex > 0 {
   73|       |            let parentIndex = (unbalancedIndex - 1) / 2
   74|       |            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|       |            _elements.swapAt(unbalancedIndex, parentIndex)
   76|       |            unbalancedIndex = parentIndex
   77|       |        }
   78|       |    }
   79|       |
   80|       |    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   81|       |        precondition(initialUnbalancedIndex >= 0)
   82|       |        precondition(initialUnbalancedIndex < _elements.count)
   83|       |
   84|       |        var unbalancedIndex = initialUnbalancedIndex
   85|       |        while true {
   86|       |            let leftChildIndex = unbalancedIndex * 2 + 1
   87|       |            let rightChildIndex = unbalancedIndex * 2 + 2
   88|       |
   89|       |            var highestPriorityIndex = unbalancedIndex
   90|       |
   91|       |            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   92|       |                highestPriorityIndex = leftChildIndex
   93|       |            }
   94|       |
   95|       |            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   96|       |                highestPriorityIndex = rightChildIndex
   97|       |            }
   98|       |
   99|       |            guard highestPriorityIndex != unbalancedIndex else { break }
  100|       |            _elements.swapAt(highestPriorityIndex, unbalancedIndex)
  101|       |
  102|       |            unbalancedIndex = highestPriorityIndex
  103|       |        }
  104|       |    }
  105|       |}
  106|       |
  107|       |extension PriorityQueue : CustomDebugStringConvertible {
  108|      0|    var debugDescription: String {
  109|      0|        return _elements.debugDescription
  110|      0|    }
  111|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      0|    init(capacity: Int) {
   34|      0|        _initialCapacity = capacity
   35|      0|
   36|      0|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      0|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|       |    var count: Int {
   51|       |        return _count
   52|       |    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DeprecationWarner.swift:
    1|       |//
    2|       |//  DeprecationWarner.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Shai Mishali on 1/9/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |#if DEBUG
   12|       |    class DeprecationWarner {
   13|       |        private static var warned = Set<Kind>()
   14|       |        private static var _lock = NSRecursiveLock()
   15|       |        
   16|      0|        static func warnIfNeeded(_ kind: Kind) {
   17|      0|            _lock.lock(); defer { _lock.unlock() }
   18|      0|            guard !warned.contains(kind) else { return }
   19|      0|            
   20|      0|            warned.insert(kind)
   21|      0|            print("ℹ️ [DEPRECATED] \(kind.message)")
   22|      0|        }
   23|       |    }
   24|       |    
   25|       |    extension DeprecationWarner {
   26|       |        enum Kind {
   27|       |            case variable
   28|       |            case globalTestFunctionNext
   29|       |            case globalTestFunctionError
   30|       |            case globalTestFunctionCompleted
   31|       |            
   32|       |            var message: String {
   33|       |                switch self {
   34|       |                case .variable: return "`Variable` is planned for future deprecation. Please consider `BehaviorRelay` as a replacement. Read more at: https://git.io/vNqvx"
   35|       |                case .globalTestFunctionNext: return "The `next()` global function is planned for future deprecation. Please use `Recorded.next()` instead."
   36|       |                case .globalTestFunctionError: return "The `error()` global function is planned for future deprecation. Please use `Recorded.error()` instead."
   37|       |                case .globalTestFunctionCompleted: return "The `completed()` global function is planned for future deprecation. Please use `Recorded.completed()` instead."
   38|       |                }
   39|       |            }
   40|       |        }
   41|       |    }
   42|       |#endif
   43|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|      0|    private static var token: DispatchSpecificKey<()> = {
   13|      0|        let key = DispatchSpecificKey<()>()
   14|      0|        DispatchQueue.main.setSpecific(key: key, value: ())
   15|      0|        return key
   16|      0|    }()
   17|       |
   18|      0|    static var isMain: Bool {
   19|      0|        return DispatchQueue.getSpecific(key: token) != nil
   20|      0|    }
   21|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import protocol Foundation.NSCopying
   14|       |
   15|       |    extension Thread {
   16|      0|        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying) {
   17|      0|            let currentThread = Thread.current
   18|      0|            let threadDictionary = currentThread.threadDictionary
   19|      0|
   20|      0|            if let newValue = value {
   21|      0|                threadDictionary[key] = newValue
   22|      0|            }
   23|      0|            else {
   24|      0|                threadDictionary[key] = nil
   25|      0|            }
   26|      0|        }
   27|       |
   28|      0|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   29|      0|            let currentThread = Thread.current
   30|      0|            let threadDictionary = currentThread.threadDictionary
   31|      0|            
   32|      0|            return threadDictionary[key] as? T
   33|      0|        }
   34|       |    }
   35|       |
   36|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/AnyObserver.swift:
    1|       |//
    2|       |//  AnyObserver.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A type-erased `ObserverType`.
   10|       |///
   11|       |/// Forwards operations to an arbitrary underlying observer with the same `Element` type, hiding the specifics of the underlying observer type.
   12|       |public struct AnyObserver<Element> : ObserverType {
   13|       |    /// The type of elements in sequence that observer can observe.
   14|       |    public typealias E = Element
   15|       |    
   16|       |    /// Anonymous event handler type.
   17|       |    public typealias EventHandler = (Event<Element>) -> Void
   18|       |
   19|       |    private let observer: EventHandler
   20|       |
   21|       |    /// Construct an instance whose `on(event)` calls `eventHandler(event)`
   22|       |    ///
   23|       |    /// - parameter eventHandler: Event handler that observes sequences events.
   24|      0|    public init(eventHandler: @escaping EventHandler) {
   25|      0|        self.observer = eventHandler
   26|      0|    }
   27|       |    
   28|       |    /// Construct an instance whose `on(event)` calls `observer.on(event)`
   29|       |    ///
   30|       |    /// - parameter observer: Observer that receives sequence events.
   31|      0|    public init<O : ObserverType>(_ observer: O) where O.E == Element {
   32|      0|        self.observer = observer.on
   33|      0|    }
   34|       |    
   35|       |    /// Send `event` to this observer.
   36|       |    ///
   37|       |    /// - parameter event: Event instance.
   38|      0|    public func on(_ event: Event<Element>) {
   39|      0|        return self.observer(event)
   40|      0|    }
   41|       |
   42|       |    /// Erases type of observer and returns canonical observer.
   43|       |    ///
   44|       |    /// - returns: type erased observer.
   45|      0|    public func asObserver() -> AnyObserver<E> {
   46|      0|        return self
   47|      0|    }
   48|       |}
   49|       |
   50|       |extension AnyObserver {
   51|       |    /// Collection of `AnyObserver`s
   52|       |    typealias s = Bag<(Event<Element>) -> Void>
   53|       |}
   54|       |
   55|       |extension ObserverType {
   56|       |    /// Erases type of observer and returns canonical observer.
   57|       |    ///
   58|       |    /// - returns: type erased observer.
   59|      0|    public func asObserver() -> AnyObserver<E> {
   60|      0|        return AnyObserver(self)
   61|      0|    }
   62|       |
   63|       |    /// Transforms observer of type R to type E using custom transform method.
   64|       |    /// Each event sent to result observer is transformed and sent to `self`.
   65|       |    ///
   66|       |    /// - returns: observer that transforms events.
   67|      0|    public func mapObserver<R>(_ transform: @escaping (R) throws -> E) -> AnyObserver<R> {
   68|      0|        return AnyObserver { e in
   69|      0|            self.on(e.map(transform))
   70|      0|        }
   71|      0|    }
   72|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Concurrency/AsyncLock.swift:
    1|       |//
    2|       |//  AsyncLock.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |In case nobody holds this lock, the work will be queued and executed immediately
   11|       |on thread that is requesting lock.
   12|       |
   13|       |In case there is somebody currently holding that lock, action will be enqueued.
   14|       |When owned of the lock finishes with it's processing, it will also execute
   15|       |and pending work.
   16|       |
   17|       |That means that enqueued work could possibly be executed later on a different thread.
   18|       |*/
   19|       |final class AsyncLock<I: InvocableType>
   20|       |    : Disposable
   21|       |    , Lock
   22|       |    , SynchronizedDisposeType {
   23|       |    typealias Action = () -> Void
   24|       |    
   25|       |    var _lock = SpinLock()
   26|       |    
   27|       |    private var _queue: Queue<I> = Queue(capacity: 0)
   28|       |
   29|       |    private var _isExecuting: Bool = false
   30|       |    private var _hasFaulted: Bool = false
   31|       |
   32|       |    // lock {
   33|      0|    func lock() {
   34|      0|        self._lock.lock()
   35|      0|    }
   36|       |
   37|      0|    func unlock() {
   38|      0|        self._lock.unlock()
   39|      0|    }
   40|       |    // }
   41|       |
   42|      0|    private func enqueue(_ action: I) -> I? {
   43|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   44|      0|            if self._hasFaulted {
   45|      0|                return nil
   46|      0|            }
   47|      0|
   48|      0|            if self._isExecuting {
   49|      0|                self._queue.enqueue(action)
   50|      0|                return nil
   51|      0|            }
   52|      0|
   53|      0|            self._isExecuting = true
   54|      0|
   55|      0|            return action
   56|      0|        // }
   57|      0|    }
   58|       |
   59|      0|    private func dequeue() -> I? {
   60|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   61|      0|            if !self._queue.isEmpty {
   62|      0|                return self._queue.dequeue()
   63|      0|            }
   64|      0|            else {
   65|      0|                self._isExecuting = false
   66|      0|                return nil
   67|      0|            }
   68|      0|        // }
   69|      0|    }
   70|       |
   71|      0|    func invoke(_ action: I) {
   72|      0|        let firstEnqueuedAction = self.enqueue(action)
   73|      0|        
   74|      0|        if let firstEnqueuedAction = firstEnqueuedAction {
   75|      0|            firstEnqueuedAction.invoke()
   76|      0|        }
   77|      0|        else {
   78|      0|            // action is enqueued, it's somebody else's concern now
   79|      0|            return
   80|      0|        }
   81|      0|        
   82|      0|        while true {
   83|      0|            let nextAction = self.dequeue()
   84|      0|
   85|      0|            if let nextAction = nextAction {
   86|      0|                nextAction.invoke()
   87|      0|            }
   88|      0|            else {
   89|      0|                return
   90|      0|            }
   91|      0|        }
   92|      0|    }
   93|       |    
   94|      0|    func dispose() {
   95|      0|        self.synchronizedDispose()
   96|      0|    }
   97|       |
   98|      0|    func _synchronized_dispose() {
   99|      0|        self._queue = Queue(capacity: 0)
  100|      0|        self._hasFaulted = true
  101|      0|    }
  102|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Concurrency/Lock.swift:
    1|       |//
    2|       |//  Lock.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol Lock {
   10|       |    func lock()
   11|       |    func unlock()
   12|       |}
   13|       |
   14|       |// https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151214/000321.html
   15|       |typealias SpinLock = RecursiveLock
   16|       |
   17|       |extension RecursiveLock : Lock {
   18|       |    @inline(__always)
   19|      0|    final func performLocked(_ action: () -> Void) {
   20|      0|        self.lock(); defer { self.unlock() }
   21|      0|        action()
   22|      0|    }
   23|       |
   24|       |    @inline(__always)
   25|      0|    final func calculateLocked<T>(_ action: () -> T) -> T {
   26|      0|        self.lock(); defer { self.unlock() }
   27|      0|        return action()
   28|      0|    }
   29|       |
   30|       |    @inline(__always)
   31|      0|    final func calculateLockedOrFail<T>(_ action: () throws -> T) throws -> T {
   32|      0|        self.lock(); defer { self.unlock() }
   33|      0|        let result = try action()
   34|      0|        return result
   35|      0|    }
   36|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Concurrency/LockOwnerType.swift:
    1|       |//
    2|       |//  LockOwnerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol LockOwnerType : class, Lock {
   10|       |    var _lock: RecursiveLock { get }
   11|       |}
   12|       |
   13|       |extension LockOwnerType {
   14|      0|    func lock() {
   15|      0|        self._lock.lock()
   16|      0|    }
   17|       |
   18|      0|    func unlock() {
   19|      0|        self._lock.unlock()
   20|      0|    }
   21|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Concurrency/SynchronizedDisposeType.swift:
    1|       |//
    2|       |//  SynchronizedDisposeType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol SynchronizedDisposeType : class, Disposable, Lock {
   10|       |    func _synchronized_dispose()
   11|       |}
   12|       |
   13|       |extension SynchronizedDisposeType {
   14|      0|    func synchronizedDispose() {
   15|      0|        self.lock(); defer { self.unlock() }
   16|      0|        self._synchronized_dispose()
   17|      0|    }
   18|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Concurrency/SynchronizedOnType.swift:
    1|       |//
    2|       |//  SynchronizedOnType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol SynchronizedOnType : class, ObserverType, Lock {
   10|       |    func _synchronized_on(_ event: Event<E>)
   11|       |}
   12|       |
   13|       |extension SynchronizedOnType {
   14|      0|    func synchronizedOn(_ event: Event<E>) {
   15|      0|        self.lock(); defer { self.unlock() }
   16|      0|        self._synchronized_on(event)
   17|      0|    }
   18|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Deprecated.swift:
    1|       |//
    2|       |//  Deprecated.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/5/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension Observable {
   10|       |    /**
   11|       |     Converts a optional to an observable sequence.
   12|       |     
   13|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   14|       |     
   15|       |     - parameter optional: Optional element in the resulting observable sequence.
   16|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   17|       |     */
   18|       |    @available(*, deprecated, message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.", renamed: "from(optional:)")
   19|      0|    public static func from(_ optional: E?) -> Observable<E> {
   20|      0|        return Observable.from(optional: optional)
   21|      0|    }
   22|       |
   23|       |    /**
   24|       |     Converts a optional to an observable sequence.
   25|       |
   26|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   27|       |
   28|       |     - parameter optional: Optional element in the resulting observable sequence.
   29|       |     - parameter scheduler: Scheduler to send the optional element on.
   30|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   31|       |     */
   32|       |    @available(*, deprecated, message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.", renamed: "from(optional:scheduler:)")
   33|      0|    public static func from(_ optional: E?, scheduler: ImmediateSchedulerType) -> Observable<E> {
   34|      0|        return Observable.from(optional: optional, scheduler: scheduler)
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension ObservableType {
   39|       |    /**
   40|       |
   41|       |    Projects each element of an observable sequence into a new form by incorporating the element's index.
   42|       |
   43|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
   44|       |
   45|       |     - parameter selector: A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
   46|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
   47|       |     */
   48|       |    @available(*, deprecated, message: "Please use enumerated().map()")
   49|       |    public func mapWithIndex<R>(_ selector: @escaping (E, Int) throws -> R)
   50|      0|        -> Observable<R> {
   51|      0|        return self.enumerated().map { try selector($0.element, $0.index) }
   52|      0|    }
   53|       |
   54|       |
   55|       |    /**
   56|       |
   57|       |     Projects each element of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.
   58|       |
   59|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
   60|       |
   61|       |     - parameter selector: A transform function to apply to each element; the second parameter of the function represents the index of the source element.
   62|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
   63|       |     */
   64|       |    @available(*, deprecated, message: "Please use enumerated().flatMap()")
   65|       |    public func flatMapWithIndex<O: ObservableConvertibleType>(_ selector: @escaping (E, Int) throws -> O)
   66|      0|        -> Observable<O.E> {
   67|      0|        return self.enumerated().flatMap { try selector($0.element, $0.index) }
   68|      0|    }
   69|       |
   70|       |    /**
   71|       |
   72|       |     Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
   73|       |     The element's index is used in the logic of the predicate function.
   74|       |
   75|       |     - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html)
   76|       |
   77|       |     - parameter predicate: A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   78|       |     - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
   79|       |     */
   80|       |    @available(*, deprecated, message: "Please use enumerated().skipWhile().map()")
   81|      0|    public func skipWhileWithIndex(_ predicate: @escaping (E, Int) throws -> Bool) -> Observable<E> {
   82|      0|        return self.enumerated().skipWhile { try predicate($0.element, $0.index) }.map { $0.element }
   83|      0|    }
   84|       |
   85|       |
   86|       |    /**
   87|       |
   88|       |     Returns elements from an observable sequence as long as a specified condition is true.
   89|       |
   90|       |     The element's index is used in the logic of the predicate function.
   91|       |
   92|       |     - seealso: [takeWhile operator on reactivex.io](http://reactivex.io/documentation/operators/takewhile.html)
   93|       |
   94|       |     - parameter predicate: A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   95|       |     - returns: An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   96|       |     */
   97|       |    @available(*, deprecated, message: "Please use enumerated().takeWhile().map()")
   98|      0|    public func takeWhileWithIndex(_ predicate: @escaping (E, Int) throws -> Bool) -> Observable<E> {
   99|      0|        return self.enumerated().takeWhile { try predicate($0.element, $0.index) }.map { $0.element }
  100|      0|    }
  101|       |}
  102|       |
  103|       |extension Disposable {
  104|       |    /// Deprecated in favor of `disposed(by:)`
  105|       |    ///
  106|       |    ///
  107|       |    /// Adds `self` to `bag`.
  108|       |    ///
  109|       |    /// - parameter bag: `DisposeBag` to add `self` to.
  110|       |    @available(*, deprecated, message: "use disposed(by:) instead", renamed: "disposed(by:)")
  111|      0|    public func addDisposableTo(_ bag: DisposeBag) {
  112|      0|        self.disposed(by: bag)
  113|      0|    }
  114|       |}
  115|       |
  116|       |
  117|       |extension ObservableType {
  118|       |
  119|       |    /**
  120|       |     Returns an observable sequence that shares a single subscription to the underlying sequence, and immediately upon subscription replays latest element in buffer.
  121|       |
  122|       |     This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
  123|       |
  124|       |     - seealso: [shareReplay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
  125|       |
  126|       |     - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  127|       |     */
  128|       |    @available(*, deprecated, message: "use share(replay: 1) instead", renamed: "share(replay:)")
  129|       |    public func shareReplayLatestWhileConnected()
  130|      0|        -> Observable<E> {
  131|      0|        return self.share(replay: 1, scope: .whileConnected)
  132|      0|    }
  133|       |}
  134|       |
  135|       |
  136|       |extension ObservableType {
  137|       |
  138|       |    /**
  139|       |     Returns an observable sequence that shares a single subscription to the underlying sequence, and immediately upon subscription replays maximum number of elements in buffer.
  140|       |
  141|       |     This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
  142|       |
  143|       |     - seealso: [shareReplay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
  144|       |
  145|       |     - parameter bufferSize: Maximum element count of the replay buffer.
  146|       |     - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  147|       |     */
  148|       |    @available(*, deprecated, message: "Suggested replacement is `share(replay: 1)`. In case old 3.x behavior of `shareReplay` is required please use `share(replay: 1, scope: .forever)` instead.", renamed: "share(replay:)")
  149|       |    public func shareReplay(_ bufferSize: Int)
  150|      0|        -> Observable<E> {
  151|      0|        return self.share(replay: bufferSize, scope: .forever)
  152|      0|    }
  153|       |}
  154|       |
  155|       |/// Variable is a wrapper for `BehaviorSubject`.
  156|       |///
  157|       |/// Unlike `BehaviorSubject` it can't terminate with error, and when variable is deallocated
  158|       |/// it will complete its observable sequence (`asObservable`).
  159|       |///
  160|       |/// **This concept will be deprecated from RxSwift but offical migration path hasn't been decided yet.**
  161|       |/// https://github.com/ReactiveX/RxSwift/issues/1501
  162|       |///
  163|       |/// Current recommended replacement for this API is `RxCocoa.BehaviorRelay` because:
  164|       |/// * `Variable` isn't a standard cross platform concept, hence it's out of place in RxSwift target.
  165|       |/// * It doesn't have a counterpart for handling events (`PublishRelay`). It models state only.
  166|       |/// * It doesn't have a consistent naming with *Relay or other Rx concepts.
  167|       |/// * It has an inconsistent memory management model compared to other parts of RxSwift (completes on `deinit`).
  168|       |///
  169|       |/// Once plans are finalized, official availability attribute will be added in one of upcoming versions.
  170|       |public final class Variable<Element> {
  171|       |
  172|       |    public typealias E = Element
  173|       |
  174|       |    private let _subject: BehaviorSubject<Element>
  175|       |
  176|       |    private var _lock = SpinLock()
  177|       |
  178|       |    // state
  179|       |    private var _value: E
  180|       |
  181|       |    #if DEBUG
  182|       |    fileprivate let _synchronizationTracker = SynchronizationTracker()
  183|       |    #endif
  184|       |
  185|       |    /// Gets or sets current value of variable.
  186|       |    ///
  187|       |    /// Whenever a new value is set, all the observers are notified of the change.
  188|       |    ///
  189|       |    /// Even if the newly set value is same as the old value, observers are still notified for change.
  190|       |    public var value: E {
  191|      0|        get {
  192|      0|            self._lock.lock(); defer { self._lock.unlock() }
  193|      0|            return self._value
  194|      0|        }
  195|      0|        set(newValue) {
  196|      0|            #if DEBUG
  197|      0|                self._synchronizationTracker.register(synchronizationErrorMessage: .variable)
  198|      0|                defer { self._synchronizationTracker.unregister() }
  199|      0|            #endif
  200|      0|            self._lock.lock()
  201|      0|            self._value = newValue
  202|      0|            self._lock.unlock()
  203|      0|
  204|      0|            self._subject.on(.next(newValue))
  205|      0|        }
  206|       |    }
  207|       |
  208|       |    /// Initializes variable with initial value.
  209|       |    ///
  210|       |    /// - parameter value: Initial variable value.
  211|      0|    public init(_ value: Element) {
  212|      0|        #if DEBUG
  213|      0|            DeprecationWarner.warnIfNeeded(.variable)
  214|      0|        #endif
  215|      0|
  216|      0|        self._value = value
  217|      0|        self._subject = BehaviorSubject(value: value)
  218|      0|    }
  219|       |
  220|       |    /// - returns: Canonical interface for push style sequence
  221|      0|    public func asObservable() -> Observable<E> {
  222|      0|        return self._subject
  223|      0|    }
  224|       |
  225|      0|    deinit {
  226|      0|        self._subject.on(.completed)
  227|      0|    }
  228|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/AnonymousDisposable.swift:
    1|       |//
    2|       |//  AnonymousDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an Action-based disposable.
   10|       |///
   11|       |/// When dispose method is called, disposal action will be dereferenced.
   12|       |fileprivate final class AnonymousDisposable : DisposeBase, Cancelable {
   13|       |    public typealias DisposeAction = () -> Void
   14|       |
   15|       |    private let _isDisposed = AtomicInt(0)
   16|       |    private var _disposeAction: DisposeAction?
   17|       |
   18|       |    /// - returns: Was resource disposed.
   19|      0|    public var isDisposed: Bool {
   20|      0|        return isFlagSet(self._isDisposed, 1)
   21|      0|    }
   22|       |
   23|       |    /// Constructs a new disposable with the given action used for disposal.
   24|       |    ///
   25|       |    /// - parameter disposeAction: Disposal action which will be run upon calling `dispose`.
   26|      0|    fileprivate init(_ disposeAction: @escaping DisposeAction) {
   27|      0|        self._disposeAction = disposeAction
   28|      0|        super.init()
   29|      0|    }
   30|       |
   31|       |    // Non-deprecated version of the constructor, used by `Disposables.create(with:)`
   32|      0|    fileprivate init(disposeAction: @escaping DisposeAction) {
   33|      0|        self._disposeAction = disposeAction
   34|      0|        super.init()
   35|      0|    }
   36|       |
   37|       |    /// Calls the disposal action if and only if the current instance hasn't been disposed yet.
   38|       |    ///
   39|       |    /// After invoking disposal action, disposal action will be dereferenced.
   40|      0|    fileprivate func dispose() {
   41|      0|        if fetchOr(self._isDisposed, 1) == 0 {
   42|      0|            if let action = self._disposeAction {
   43|      0|                self._disposeAction = nil
   44|      0|                action()
   45|      0|            }
   46|      0|        }
   47|      0|    }
   48|       |}
   49|       |
   50|       |extension Disposables {
   51|       |
   52|       |    /// Constructs a new disposable with the given action used for disposal.
   53|       |    ///
   54|       |    /// - parameter dispose: Disposal action which will be run upon calling `dispose`.
   55|      0|    public static func create(with dispose: @escaping () -> Void) -> Cancelable {
   56|      0|        return AnonymousDisposable(disposeAction: dispose)
   57|      0|    }
   58|       |
   59|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/BinaryDisposable.swift:
    1|       |//
    2|       |//  BinaryDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents two disposable resources that are disposed together.
   10|       |private final class BinaryDisposable : DisposeBase, Cancelable {
   11|       |
   12|       |    private let _isDisposed = AtomicInt(0)
   13|       |
   14|       |    // state
   15|       |    private var _disposable1: Disposable?
   16|       |    private var _disposable2: Disposable?
   17|       |
   18|       |    /// - returns: Was resource disposed.
   19|      0|    var isDisposed: Bool {
   20|      0|        return isFlagSet(self._isDisposed, 1)
   21|      0|    }
   22|       |
   23|       |    /// Constructs new binary disposable from two disposables.
   24|       |    ///
   25|       |    /// - parameter disposable1: First disposable
   26|       |    /// - parameter disposable2: Second disposable
   27|      0|    init(_ disposable1: Disposable, _ disposable2: Disposable) {
   28|      0|        self._disposable1 = disposable1
   29|      0|        self._disposable2 = disposable2
   30|      0|        super.init()
   31|      0|    }
   32|       |
   33|       |    /// Calls the disposal action if and only if the current instance hasn't been disposed yet.
   34|       |    ///
   35|       |    /// After invoking disposal action, disposal action will be dereferenced.
   36|      0|    func dispose() {
   37|      0|        if fetchOr(self._isDisposed, 1) == 0 {
   38|      0|            self._disposable1?.dispose()
   39|      0|            self._disposable2?.dispose()
   40|      0|            self._disposable1 = nil
   41|      0|            self._disposable2 = nil
   42|      0|        }
   43|      0|    }
   44|       |}
   45|       |
   46|       |extension Disposables {
   47|       |
   48|       |    /// Creates a disposable with the given disposables.
   49|      0|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable) -> Cancelable {
   50|      0|        return BinaryDisposable(disposable1, disposable2)
   51|      0|    }
   52|       |
   53|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/BooleanDisposable.swift:
    1|       |//
    2|       |//  BooleanDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 10/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource that can be checked for disposal status.
   10|       |public final class BooleanDisposable : Cancelable {
   11|       |
   12|       |    internal static let BooleanDisposableTrue = BooleanDisposable(isDisposed: true)
   13|       |    private var _isDisposed = false
   14|       |    
   15|       |    /// Initializes a new instance of the `BooleanDisposable` class
   16|      0|    public init() {
   17|      0|    }
   18|       |    
   19|       |    /// Initializes a new instance of the `BooleanDisposable` class with given value
   20|      0|    public init(isDisposed: Bool) {
   21|      0|        self._isDisposed = isDisposed
   22|      0|    }
   23|       |    
   24|       |    /// - returns: Was resource disposed.
   25|      0|    public var isDisposed: Bool {
   26|      0|        return self._isDisposed
   27|      0|    }
   28|       |    
   29|       |    /// Sets the status to disposed, which can be observer through the `isDisposed` property.
   30|      0|    public func dispose() {
   31|      0|        self._isDisposed = true
   32|      0|    }
   33|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/CompositeDisposable.swift:
    1|       |//
    2|       |//  CompositeDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/20/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a group of disposable resources that are disposed together.
   10|       |public final class CompositeDisposable : DisposeBase, Cancelable {
   11|       |    /// Key used to remove disposable from composite disposable
   12|       |    public struct DisposeKey {
   13|       |        fileprivate let key: BagKey
   14|      0|        fileprivate init(key: BagKey) {
   15|      0|            self.key = key
   16|      0|        }
   17|       |    }
   18|       |
   19|       |    private var _lock = SpinLock()
   20|       |    
   21|       |    // state
   22|       |    private var _disposables: Bag<Disposable>? = Bag()
   23|       |
   24|      0|    public var isDisposed: Bool {
   25|      0|        self._lock.lock(); defer { self._lock.unlock() }
   26|      0|        return self._disposables == nil
   27|      0|    }
   28|       |    
   29|      0|    public override init() {
   30|      0|    }
   31|       |    
   32|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   33|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable) {
   34|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   35|      0|        _ = self._disposables!.insert(disposable1)
   36|      0|        _ = self._disposables!.insert(disposable2)
   37|      0|    }
   38|       |    
   39|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   40|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable) {
   41|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   42|      0|        _ = self._disposables!.insert(disposable1)
   43|      0|        _ = self._disposables!.insert(disposable2)
   44|      0|        _ = self._disposables!.insert(disposable3)
   45|      0|    }
   46|       |    
   47|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   48|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable, _ disposable4: Disposable, _ disposables: Disposable...) {
   49|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   50|      0|        _ = self._disposables!.insert(disposable1)
   51|      0|        _ = self._disposables!.insert(disposable2)
   52|      0|        _ = self._disposables!.insert(disposable3)
   53|      0|        _ = self._disposables!.insert(disposable4)
   54|      0|        
   55|      0|        for disposable in disposables {
   56|      0|            _ = self._disposables!.insert(disposable)
   57|      0|        }
   58|      0|    }
   59|       |    
   60|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   61|      0|    public init(disposables: [Disposable]) {
   62|      0|        for disposable in disposables {
   63|      0|            _ = self._disposables!.insert(disposable)
   64|      0|        }
   65|      0|    }
   66|       |
   67|       |    /**
   68|       |     Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   69|       |     
   70|       |     - parameter disposable: Disposable to add.
   71|       |     - returns: Key that can be used to remove disposable from composite disposable. In case dispose bag was already
   72|       |     disposed `nil` will be returned.
   73|       |     */
   74|      0|    public func insert(_ disposable: Disposable) -> DisposeKey? {
   75|      0|        let key = self._insert(disposable)
   76|      0|        
   77|      0|        if key == nil {
   78|      0|            disposable.dispose()
   79|      0|        }
   80|      0|        
   81|      0|        return key
   82|      0|    }
   83|       |    
   84|       |    private func _insert(_ disposable: Disposable) -> DisposeKey? {
   85|       |        self._lock.lock(); defer { self._lock.unlock() }
   86|       |
   87|       |        let bagKey = self._disposables?.insert(disposable)
   88|       |        return bagKey.map(DisposeKey.init)
   89|       |    }
   90|       |    
   91|       |    /// - returns: Gets the number of disposables contained in the `CompositeDisposable`.
   92|      0|    public var count: Int {
   93|      0|        self._lock.lock(); defer { self._lock.unlock() }
   94|      0|        return self._disposables?.count ?? 0
   95|      0|    }
   96|       |    
   97|       |    /// Removes and disposes the disposable identified by `disposeKey` from the CompositeDisposable.
   98|       |    ///
   99|       |    /// - parameter disposeKey: Key used to identify disposable to be removed.
  100|      0|    public func remove(for disposeKey: DisposeKey) {
  101|      0|        self._remove(for: disposeKey)?.dispose()
  102|      0|    }
  103|       |    
  104|       |    private func _remove(for disposeKey: DisposeKey) -> Disposable? {
  105|       |        self._lock.lock(); defer { self._lock.unlock() }
  106|       |        return self._disposables?.removeKey(disposeKey.key)
  107|       |    }
  108|       |    
  109|       |    /// Disposes all disposables in the group and removes them from the group.
  110|      0|    public func dispose() {
  111|      0|        if let disposables = self._dispose() {
  112|      0|            disposeAll(in: disposables)
  113|      0|        }
  114|      0|    }
  115|       |
  116|       |    private func _dispose() -> Bag<Disposable>? {
  117|       |        self._lock.lock(); defer { self._lock.unlock() }
  118|       |
  119|       |        let disposeBag = self._disposables
  120|       |        self._disposables = nil
  121|       |
  122|       |        return disposeBag
  123|       |    }
  124|       |}
  125|       |
  126|       |extension Disposables {
  127|       |
  128|       |    /// Creates a disposable with the given disposables.
  129|      0|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable) -> Cancelable {
  130|      0|        return CompositeDisposable(disposable1, disposable2, disposable3)
  131|      0|    }
  132|       |    
  133|       |    /// Creates a disposable with the given disposables.
  134|      0|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable, _ disposables: Disposable ...) -> Cancelable {
  135|      0|        var disposables = disposables
  136|      0|        disposables.append(disposable1)
  137|      0|        disposables.append(disposable2)
  138|      0|        disposables.append(disposable3)
  139|      0|        return CompositeDisposable(disposables: disposables)
  140|      0|    }
  141|       |    
  142|       |    /// Creates a disposable with the given disposables.
  143|      0|    public static func create(_ disposables: [Disposable]) -> Cancelable {
  144|      0|        switch disposables.count {
  145|      0|        case 2:
  146|      0|            return Disposables.create(disposables[0], disposables[1])
  147|      0|        default:
  148|      0|            return CompositeDisposable(disposables: disposables)
  149|      0|        }
  150|      0|    }
  151|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/Disposables.swift:
    1|       |//
    2|       |//  Disposables.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Mohsen Ramezanpoor on 01/08/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A collection of utility methods for common disposable operations.
   10|       |public struct Disposables {
   11|      0|    private init() {}
   12|       |}
   13|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/DisposeBag.swift:
    1|       |//
    2|       |//  DisposeBag.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension Disposable {
   10|       |    /// Adds `self` to `bag`
   11|       |    ///
   12|       |    /// - parameter bag: `DisposeBag` to add `self` to.
   13|      0|    public func disposed(by bag: DisposeBag) {
   14|      0|        bag.insert(self)
   15|      0|    }
   16|       |}
   17|       |
   18|       |/**
   19|       |Thread safe bag that disposes added disposables on `deinit`.
   20|       |
   21|       |This returns ARC (RAII) like resource management to `RxSwift`.
   22|       |
   23|       |In case contained disposables need to be disposed, just put a different dispose bag
   24|       |or create a new one in its place.
   25|       |
   26|       |    self.existingDisposeBag = DisposeBag()
   27|       |
   28|       |In case explicit disposal is necessary, there is also `CompositeDisposable`.
   29|       |*/
   30|       |public final class DisposeBag: DisposeBase {
   31|       |    
   32|       |    private var _lock = SpinLock()
   33|       |    
   34|       |    // state
   35|       |    fileprivate var _disposables = [Disposable]()
   36|       |    fileprivate var _isDisposed = false
   37|       |    
   38|       |    /// Constructs new empty dispose bag.
   39|     12|    public override init() {
   40|     12|        super.init()
   41|     12|    }
   42|       |
   43|       |    /// Adds `disposable` to be disposed when dispose bag is being deinited.
   44|       |    ///
   45|       |    /// - parameter disposable: Disposable to add.
   46|       |    public func insert(_ disposable: Disposable) {
   47|       |        self._insert(disposable)?.dispose()
   48|       |    }
   49|       |    
   50|       |    private func _insert(_ disposable: Disposable) -> Disposable? {
   51|       |        self._lock.lock(); defer { self._lock.unlock() }
   52|       |        if self._isDisposed {
   53|       |            return disposable
   54|       |        }
   55|       |
   56|       |        self._disposables.append(disposable)
   57|       |
   58|       |        return nil
   59|       |    }
   60|       |
   61|       |    /// This is internal on purpose, take a look at `CompositeDisposable` instead.
   62|      0|    private func dispose() {
   63|      0|        let oldDisposables = self._dispose()
   64|      0|
   65|      0|        for disposable in oldDisposables {
   66|      0|            disposable.dispose()
   67|      0|        }
   68|      0|    }
   69|       |
   70|       |    private func _dispose() -> [Disposable] {
   71|       |        self._lock.lock(); defer { self._lock.unlock() }
   72|       |
   73|       |        let disposables = self._disposables
   74|       |        
   75|       |        self._disposables.removeAll(keepingCapacity: false)
   76|       |        self._isDisposed = true
   77|       |        
   78|       |        return disposables
   79|       |    }
   80|       |    
   81|      0|    deinit {
   82|      0|        self.dispose()
   83|      0|    }
   84|       |}
   85|       |
   86|       |extension DisposeBag {
   87|       |
   88|       |    /// Convenience init allows a list of disposables to be gathered for disposal.
   89|      0|    public convenience init(disposing disposables: Disposable...) {
   90|      0|        self.init()
   91|      0|        self._disposables += disposables
   92|      0|    }
   93|       |
   94|       |    /// Convenience init allows an array of disposables to be gathered for disposal.
   95|      0|    public convenience init(disposing disposables: [Disposable]) {
   96|      0|        self.init()
   97|      0|        self._disposables += disposables
   98|      0|    }
   99|       |
  100|       |    /// Convenience function allows a list of disposables to be gathered for disposal.
  101|      0|    public func insert(_ disposables: Disposable...) {
  102|      0|        self.insert(disposables)
  103|      0|    }
  104|       |
  105|       |    /// Convenience function allows an array of disposables to be gathered for disposal.
  106|       |    public func insert(_ disposables: [Disposable]) {
  107|       |        self._lock.lock(); defer { self._lock.unlock() }
  108|       |        if self._isDisposed {
  109|      0|            disposables.forEach { $0.dispose() }
  110|       |        } else {
  111|       |            self._disposables += disposables
  112|       |        }
  113|       |    }
  114|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/DisposeBase.swift:
    1|       |//
    2|       |//  DisposeBase.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Base class for all disposables.
   10|       |public class DisposeBase {
   11|     12|    init() {
   12|     12|#if TRACE_RESOURCES
   13|     12|    _ = Resources.incrementTotal()
   14|     12|#endif
   15|     12|    }
   16|       |    
   17|      0|    deinit {
   18|      0|#if TRACE_RESOURCES
   19|      0|    _ = Resources.decrementTotal()
   20|      0|#endif
   21|      0|    }
   22|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/NopDisposable.swift:
    1|       |//
    2|       |//  NopDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable that does nothing on disposal.
   10|       |///
   11|       |/// Nop = No Operation
   12|       |fileprivate struct NopDisposable : Disposable {
   13|       | 
   14|       |    fileprivate static let noOp: Disposable = NopDisposable()
   15|       |    
   16|      0|    fileprivate init() {
   17|      0|        
   18|      0|    }
   19|       |    
   20|       |    /// Does nothing.
   21|      0|    public func dispose() {
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension Disposables {
   26|       |    /**
   27|       |     Creates a disposable that does nothing on disposal.
   28|       |     */
   29|      0|    static public func create() -> Disposable {
   30|      0|        return NopDisposable.noOp
   31|      0|    }
   32|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/RefCountDisposable.swift:
    1|       |//
    2|       |//  RefCountDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 10/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
   10|       |public final class RefCountDisposable : DisposeBase, Cancelable {
   11|       |    private var _lock = SpinLock()
   12|       |    private var _disposable = nil as Disposable?
   13|       |    private var _primaryDisposed = false
   14|       |    private var _count = 0
   15|       |
   16|       |    /// - returns: Was resource disposed.
   17|      0|    public var isDisposed: Bool {
   18|      0|        self._lock.lock(); defer { self._lock.unlock() }
   19|      0|        return self._disposable == nil
   20|      0|    }
   21|       |
   22|       |    /// Initializes a new instance of the `RefCountDisposable`.
   23|      0|    public init(disposable: Disposable) {
   24|      0|        self._disposable = disposable
   25|      0|        super.init()
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |     Holds a dependent disposable that when disposed decreases the refcount on the underlying disposable.
   30|       |
   31|       |     When getter is called, a dependent disposable contributing to the reference count that manages the underlying disposable's lifetime is returned.
   32|       |     */
   33|      0|    public func retain() -> Disposable {
   34|      0|        return self._lock.calculateLocked {
   35|      0|            if self._disposable != nil {
   36|      0|                do {
   37|      0|                    _ = try incrementChecked(&self._count)
   38|      0|                } catch {
   39|      0|                    rxFatalError("RefCountDisposable increment failed")
   40|      0|                }
   41|      0|
   42|      0|                return RefCountInnerDisposable(self)
   43|      0|            } else {
   44|      0|                return Disposables.create()
   45|      0|            }
   46|      0|        }
   47|      0|    }
   48|       |
   49|       |    /// Disposes the underlying disposable only when all dependent disposables have been disposed.
   50|      0|    public func dispose() {
   51|      0|        let oldDisposable: Disposable? = self._lock.calculateLocked {
   52|      0|            if let oldDisposable = self._disposable, !self._primaryDisposed {
   53|      0|                self._primaryDisposed = true
   54|      0|
   55|      0|                if self._count == 0 {
   56|      0|                    self._disposable = nil
   57|      0|                    return oldDisposable
   58|      0|                }
   59|      0|            }
   60|      0|
   61|      0|            return nil
   62|      0|        }
   63|      0|
   64|      0|        if let disposable = oldDisposable {
   65|      0|            disposable.dispose()
   66|      0|        }
   67|      0|    }
   68|       |
   69|      0|    fileprivate func release() {
   70|      0|        let oldDisposable: Disposable? = self._lock.calculateLocked {
   71|      0|            if let oldDisposable = self._disposable {
   72|      0|                do {
   73|      0|                    _ = try decrementChecked(&self._count)
   74|      0|                } catch {
   75|      0|                    rxFatalError("RefCountDisposable decrement on release failed")
   76|      0|                }
   77|      0|
   78|      0|                guard self._count >= 0 else {
   79|      0|                    rxFatalError("RefCountDisposable counter is lower than 0")
   80|      0|                }
   81|      0|
   82|      0|                if self._primaryDisposed && self._count == 0 {
   83|      0|                    self._disposable = nil
   84|      0|                    return oldDisposable
   85|      0|                }
   86|      0|            }
   87|      0|
   88|      0|            return nil
   89|      0|        }
   90|      0|
   91|      0|        if let disposable = oldDisposable {
   92|      0|            disposable.dispose()
   93|      0|        }
   94|      0|    }
   95|       |}
   96|       |
   97|       |internal final class RefCountInnerDisposable: DisposeBase, Disposable
   98|       |{
   99|       |    private let _parent: RefCountDisposable
  100|       |    private let _isDisposed = AtomicInt(0)
  101|       |
  102|      0|    init(_ parent: RefCountDisposable) {
  103|      0|        self._parent = parent
  104|      0|        super.init()
  105|      0|    }
  106|       |
  107|       |    internal func dispose()
  108|      0|    {
  109|      0|        if fetchOr(self._isDisposed, 1) == 0 {
  110|      0|            self._parent.release()
  111|      0|        }
  112|      0|    }
  113|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/ScheduledDisposable.swift:
    1|       |//
    2|       |//  ScheduledDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|      0|private let disposeScheduledDisposable: (ScheduledDisposable) -> Disposable = { sd in
   10|      0|    sd.disposeInner()
   11|      0|    return Disposables.create()
   12|      0|}
   13|       |
   14|       |/// Represents a disposable resource whose disposal invocation will be scheduled on the specified scheduler.
   15|       |public final class ScheduledDisposable : Cancelable {
   16|       |    public let scheduler: ImmediateSchedulerType
   17|       |
   18|       |    private let _isDisposed = AtomicInt(0)
   19|       |
   20|       |    // state
   21|       |    private var _disposable: Disposable?
   22|       |
   23|       |    /// - returns: Was resource disposed.
   24|      0|    public var isDisposed: Bool {
   25|      0|        return isFlagSet(self._isDisposed, 1)
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |    Initializes a new instance of the `ScheduledDisposable` that uses a `scheduler` on which to dispose the `disposable`.
   30|       |
   31|       |    - parameter scheduler: Scheduler where the disposable resource will be disposed on.
   32|       |    - parameter disposable: Disposable resource to dispose on the given scheduler.
   33|       |    */
   34|      0|    public init(scheduler: ImmediateSchedulerType, disposable: Disposable) {
   35|      0|        self.scheduler = scheduler
   36|      0|        self._disposable = disposable
   37|      0|    }
   38|       |
   39|       |    /// Disposes the wrapped disposable on the provided scheduler.
   40|      0|    public func dispose() {
   41|      0|        _ = self.scheduler.schedule(self, action: disposeScheduledDisposable)
   42|      0|    }
   43|       |
   44|       |    func disposeInner() {
   45|       |        if fetchOr(self._isDisposed, 1) == 0 {
   46|       |            self._disposable!.dispose()
   47|       |            self._disposable = nil
   48|       |        }
   49|       |    }
   50|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/SerialDisposable.swift:
    1|       |//
    2|       |//  SerialDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource whose underlying disposable resource can be replaced by another disposable resource, causing automatic disposal of the previous underlying disposable resource.
   10|       |public final class SerialDisposable : DisposeBase, Cancelable {
   11|       |    private var _lock = SpinLock()
   12|       |    
   13|       |    // state
   14|       |    private var _current = nil as Disposable?
   15|       |    private var _isDisposed = false
   16|       |    
   17|       |    /// - returns: Was resource disposed.
   18|      0|    public var isDisposed: Bool {
   19|      0|        return self._isDisposed
   20|      0|    }
   21|       |    
   22|       |    /// Initializes a new instance of the `SerialDisposable`.
   23|      0|    override public init() {
   24|      0|        super.init()
   25|      0|    }
   26|       |    
   27|       |    /**
   28|       |    Gets or sets the underlying disposable.
   29|       |    
   30|       |    Assigning this property disposes the previous disposable object.
   31|       |    
   32|       |    If the `SerialDisposable` has already been disposed, assignment to this property causes immediate disposal of the given disposable object.
   33|       |    */
   34|       |    public var disposable: Disposable {
   35|      0|        get {
   36|      0|            return self._lock.calculateLocked {
   37|      0|                return self._current ?? Disposables.create()
   38|      0|            }
   39|      0|        }
   40|      0|        set (newDisposable) {
   41|      0|            let disposable: Disposable? = self._lock.calculateLocked {
   42|      0|                if self._isDisposed {
   43|      0|                    return newDisposable
   44|      0|                }
   45|      0|                else {
   46|      0|                    let toDispose = self._current
   47|      0|                    self._current = newDisposable
   48|      0|                    return toDispose
   49|      0|                }
   50|      0|            }
   51|      0|            
   52|      0|            if let disposable = disposable {
   53|      0|                disposable.dispose()
   54|      0|            }
   55|      0|        }
   56|       |    }
   57|       |    
   58|       |    /// Disposes the underlying disposable as well as all future replacements.
   59|      0|    public func dispose() {
   60|      0|        self._dispose()?.dispose()
   61|      0|    }
   62|       |
   63|       |    private func _dispose() -> Disposable? {
   64|       |        self._lock.lock(); defer { self._lock.unlock() }
   65|       |        if self._isDisposed {
   66|       |            return nil
   67|       |        }
   68|       |        else {
   69|       |            self._isDisposed = true
   70|       |            let current = self._current
   71|       |            self._current = nil
   72|       |            return current
   73|       |        }
   74|       |    }
   75|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/SingleAssignmentDisposable.swift:
    1|       |//
    2|       |//  SingleAssignmentDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Represents a disposable resource which only allows a single assignment of its underlying disposable resource.
   11|       |
   12|       |If an underlying disposable resource has already been set, future attempts to set the underlying disposable resource will throw an exception.
   13|       |*/
   14|       |public final class SingleAssignmentDisposable : DisposeBase, Cancelable {
   15|       |
   16|       |    fileprivate enum DisposeState: Int32 {
   17|       |        case disposed = 1
   18|       |        case disposableSet = 2
   19|       |    }
   20|       |
   21|       |    // state
   22|       |    private let _state = AtomicInt(0)
   23|       |    private var _disposable = nil as Disposable?
   24|       |
   25|       |    /// - returns: A value that indicates whether the object is disposed.
   26|      0|    public var isDisposed: Bool {
   27|      0|        return isFlagSet(self._state, DisposeState.disposed.rawValue)
   28|      0|    }
   29|       |
   30|       |    /// Initializes a new instance of the `SingleAssignmentDisposable`.
   31|      0|    public override init() {
   32|      0|        super.init()
   33|      0|    }
   34|       |
   35|       |    /// Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
   36|       |    ///
   37|       |    /// **Throws exception if the `SingleAssignmentDisposable` has already been assigned to.**
   38|      0|    public func setDisposable(_ disposable: Disposable) {
   39|      0|        self._disposable = disposable
   40|      0|
   41|      0|        let previousState = fetchOr(self._state, DisposeState.disposableSet.rawValue)
   42|      0|
   43|      0|        if (previousState & DisposeState.disposableSet.rawValue) != 0 {
   44|      0|            rxFatalError("oldState.disposable != nil")
   45|      0|        }
   46|      0|
   47|      0|        if (previousState & DisposeState.disposed.rawValue) != 0 {
   48|      0|            disposable.dispose()
   49|      0|            self._disposable = nil
   50|      0|        }
   51|      0|    }
   52|       |
   53|       |    /// Disposes the underlying disposable.
   54|      0|    public func dispose() {
   55|      0|        let previousState = fetchOr(self._state, DisposeState.disposed.rawValue)
   56|      0|
   57|      0|        if (previousState & DisposeState.disposed.rawValue) != 0 {
   58|      0|            return
   59|      0|        }
   60|      0|
   61|      0|        if (previousState & DisposeState.disposableSet.rawValue) != 0 {
   62|      0|            guard let disposable = self._disposable else {
   63|      0|                rxFatalError("Disposable not set")
   64|      0|            }
   65|      0|            disposable.dispose()
   66|      0|            self._disposable = nil
   67|      0|        }
   68|      0|    }
   69|       |
   70|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Disposables/SubscriptionDisposable.swift:
    1|       |//
    2|       |//  SubscriptionDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct SubscriptionDisposable<T: SynchronizedUnsubscribeType> : Disposable {
   10|       |    private let _key: T.DisposeKey
   11|       |    private weak var _owner: T?
   12|       |
   13|      0|    init(owner: T, key: T.DisposeKey) {
   14|      0|        self._owner = owner
   15|      0|        self._key = key
   16|      0|    }
   17|       |
   18|      0|    func dispose() {
   19|      0|        self._owner?.synchronizedUnsubscribe(self._key)
   20|      0|    }
   21|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Event.swift:
    1|       |//
    2|       |//  Event.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a sequence event.
   10|       |///
   11|       |/// Sequence grammar: 
   12|       |/// **next\* (error | completed)**
   13|       |public enum Event<Element> {
   14|       |    /// Next element is produced.
   15|       |    case next(Element)
   16|       |
   17|       |    /// Sequence terminated with an error.
   18|       |    case error(Swift.Error)
   19|       |
   20|       |    /// Sequence completed successfully.
   21|       |    case completed
   22|       |}
   23|       |
   24|       |extension Event : CustomDebugStringConvertible {
   25|       |    /// Description of event.
   26|      0|    public var debugDescription: String {
   27|      0|        switch self {
   28|      0|        case .next(let value):
   29|      0|            return "next(\(value))"
   30|      0|        case .error(let error):
   31|      0|            return "error(\(error))"
   32|      0|        case .completed:
   33|      0|            return "completed"
   34|      0|        }
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension Event {
   39|       |    /// Is `completed` or `error` event.
   40|      0|    public var isStopEvent: Bool {
   41|      0|        switch self {
   42|      0|        case .next: return false
   43|      0|        case .error, .completed: return true
   44|      0|        }
   45|      0|    }
   46|       |
   47|       |    /// If `next` event, returns element value.
   48|      0|    public var element: Element? {
   49|      0|        if case .next(let value) = self {
   50|      0|            return value
   51|      0|        }
   52|      0|        return nil
   53|      0|    }
   54|       |
   55|       |    /// If `error` event, returns error.
   56|      0|    public var error: Swift.Error? {
   57|      0|        if case .error(let error) = self {
   58|      0|            return error
   59|      0|        }
   60|      0|        return nil
   61|      0|    }
   62|       |
   63|       |    /// If `completed` event, returns `true`.
   64|      0|    public var isCompleted: Bool {
   65|      0|        if case .completed = self {
   66|      0|            return true
   67|      0|        }
   68|      0|        return false
   69|      0|    }
   70|       |}
   71|       |
   72|       |extension Event {
   73|       |    /// Maps sequence elements using transform. If error happens during the transform, `.error`
   74|       |    /// will be returned as value.
   75|      0|    public func map<Result>(_ transform: (Element) throws -> Result) -> Event<Result> {
   76|      0|        do {
   77|      0|            switch self {
   78|      0|            case let .next(element):
   79|      0|                return .next(try transform(element))
   80|      0|            case let .error(error):
   81|      0|                return .error(error)
   82|      0|            case .completed:
   83|      0|                return .completed
   84|      0|            }
   85|      0|        }
   86|      0|        catch let e {
   87|      0|            return .error(e)
   88|      0|        }
   89|      0|    }
   90|       |}
   91|       |
   92|       |/// A type that can be converted to `Event<Element>`.
   93|       |public protocol EventConvertible {
   94|       |    /// Type of element in event
   95|       |    associatedtype ElementType
   96|       |
   97|       |    /// Event representation of this instance
   98|       |    var event: Event<ElementType> { get }
   99|       |}
  100|       |
  101|       |extension Event : EventConvertible {
  102|       |    /// Event representation of this instance
  103|      0|    public var event: Event<Element> {
  104|      0|        return self
  105|      0|    }
  106|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Extensions/Bag+Rx.swift:
    1|       |//
    2|       |//  Bag+Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/19/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |// MARK: forEach
   11|       |
   12|       |@inline(__always)
   13|      0|func dispatch<E>(_ bag: Bag<(Event<E>) -> Void>, _ event: Event<E>) {
   14|      0|    bag._value0?(event)
   15|      0|
   16|      0|    if bag._onlyFastPath {
   17|      0|        return
   18|      0|    }
   19|      0|
   20|      0|    let pairs = bag._pairs
   21|      0|    for i in 0 ..< pairs.count {
   22|      0|        pairs[i].value(event)
   23|      0|    }
   24|      0|
   25|      0|    if let dictionary = bag._dictionary {
   26|      0|        for element in dictionary.values {
   27|      0|            element(event)
   28|      0|        }
   29|      0|    }
   30|      0|}
   31|       |
   32|       |/// Dispatches `dispose` to all disposables contained inside bag.
   33|      0|func disposeAll(in bag: Bag<Disposable>) {
   34|      0|    bag._value0?.dispose()
   35|      0|
   36|      0|    if bag._onlyFastPath {
   37|      0|        return
   38|      0|    }
   39|      0|
   40|      0|    let pairs = bag._pairs
   41|      0|    for i in 0 ..< pairs.count {
   42|      0|        pairs[i].value.dispose()
   43|      0|    }
   44|      0|
   45|      0|    if let dictionary = bag._dictionary {
   46|      0|        for element in dictionary.values {
   47|      0|            element.dispose()
   48|      0|        }
   49|      0|    }
   50|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Extensions/String+Rx.swift:
    1|       |//
    2|       |//  String+Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension String {
   10|       |    /// This is needed because on Linux Swift doesn't have `rangeOfString(..., options: .BackwardsSearch)`
   11|      0|    func lastIndexOf(_ character: Character) -> Index? {
   12|      0|        var index = self.endIndex
   13|      0|        while index > self.startIndex {
   14|      0|            index = self.index(before: index)
   15|      0|            if self[index] == character {
   16|      0|                return index
   17|      0|            }
   18|      0|        }
   19|      0|
   20|      0|        return nil
   21|      0|    }
   22|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/GroupedObservable.swift:
    1|       |//
    2|       |//  GroupedObservable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 01/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an observable sequence of elements that have a common key.
   10|       |public struct GroupedObservable<Key, Element> : ObservableType {
   11|       |    public typealias E = Element
   12|       |
   13|       |    /// Gets the common key.
   14|       |    public let key: Key
   15|       |
   16|       |    private let source: Observable<Element>
   17|       |
   18|       |    /// Initializes grouped observable sequence with key and source observable sequence.
   19|       |    ///
   20|       |    /// - parameter key: Grouped observable sequence key
   21|       |    /// - parameter source: Observable sequence that represents sequence of elements for the key
   22|       |    /// - returns: Grouped observable sequence of elements for the specific key
   23|      0|    public init(key: Key, source: Observable<Element>) {
   24|      0|        self.key = key
   25|      0|        self.source = source
   26|      0|    }
   27|       |
   28|       |    /// Subscribes `observer` to receive events for this sequence.
   29|      0|    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   30|      0|        return self.source.subscribe(observer)
   31|      0|    }
   32|       |
   33|       |    /// Converts `self` to `Observable` sequence. 
   34|      0|    public func asObservable() -> Observable<Element> {
   35|      0|        return self.source
   36|      0|    }
   37|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/ImmediateSchedulerType.swift:
    1|       |//
    2|       |//  ImmediateSchedulerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that immediately schedules units of work.
   10|       |public protocol ImmediateSchedulerType {
   11|       |    /**
   12|       |    Schedules an action to be executed immediately.
   13|       |    
   14|       |    - parameter state: State passed to the action to be executed.
   15|       |    - parameter action: Action to be executed.
   16|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   17|       |    */
   18|       |    func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable
   19|       |}
   20|       |
   21|       |extension ImmediateSchedulerType {
   22|       |    /**
   23|       |    Schedules an action to be executed recursively.
   24|       |    
   25|       |    - parameter state: State passed to the action to be executed.
   26|       |    - parameter action: Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
   27|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   28|       |    */
   29|      0|    public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> Void) -> Void) -> Disposable {
   30|      0|        let recursiveScheduler = RecursiveImmediateScheduler(action: action, scheduler: self)
   31|      0|        
   32|      0|        recursiveScheduler.schedule(state)
   33|      0|        
   34|      0|        return Disposables.create(with: recursiveScheduler.dispose)
   35|      0|    }
   36|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observable.swift:
    1|       |//
    2|       |//  Observable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A type-erased `ObservableType`. 
   10|       |///
   11|       |/// It represents a push style sequence.
   12|       |public class Observable<Element> : ObservableType {
   13|       |    /// Type of elements in sequence.
   14|       |    public typealias E = Element
   15|       |    
   16|      0|    init() {
   17|      0|#if TRACE_RESOURCES
   18|      0|        _ = Resources.incrementTotal()
   19|      0|#endif
   20|      0|    }
   21|       |    
   22|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   23|      0|        rxAbstractMethod()
   24|      0|    }
   25|       |    
   26|      0|    public func asObservable() -> Observable<E> {
   27|      0|        return self
   28|      0|    }
   29|       |    
   30|      0|    deinit {
   31|      0|#if TRACE_RESOURCES
   32|      0|        _ = Resources.decrementTotal()
   33|      0|#endif
   34|      0|    }
   35|       |
   36|       |    // this is kind of ugly I know :(
   37|       |    // Swift compiler reports "Not supported yet" when trying to override protocol extensions, so ¯\_(ツ)_/¯
   38|       |
   39|       |    /// Optimizations for map operator
   40|      0|    internal func composeMap<R>(_ transform: @escaping (Element) throws -> R) -> Observable<R> {
   41|      0|        return _map(source: self, transform: transform)
   42|      0|    }
   43|       |}
   44|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/ObservableType+Extensions.swift:
    1|       |//
    2|       |//  ObservableType+Extensions.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if DEBUG
   10|       |    import Foundation
   11|       |#endif
   12|       |
   13|       |extension ObservableType {
   14|       |    /**
   15|       |     Subscribes an event handler to an observable sequence.
   16|       |     
   17|       |     - parameter on: Action to invoke for each event in the observable sequence.
   18|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   19|       |     */
   20|       |    public func subscribe(_ on: @escaping (Event<E>) -> Void)
   21|      0|        -> Disposable {
   22|      0|            let observer = AnonymousObserver { e in
   23|      0|                on(e)
   24|      0|            }
   25|      0|            return self.asObservable().subscribe(observer)
   26|      0|    }
   27|       |    
   28|       |    
   29|       |    /**
   30|       |     Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.
   31|       |     
   32|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
   33|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   34|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   35|       |     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
   36|       |     gracefully completed, errored, or if the generation is canceled by disposing subscription).
   37|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   38|       |     */
   39|       |    public func subscribe(onNext: ((E) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil)
   40|      0|        -> Disposable {
   41|      0|            let disposable: Disposable
   42|      0|            
   43|      0|            if let disposed = onDisposed {
   44|      0|                disposable = Disposables.create(with: disposed)
   45|      0|            }
   46|      0|            else {
   47|      0|                disposable = Disposables.create()
   48|      0|            }
   49|      0|            
   50|      0|            #if DEBUG
   51|      0|                let synchronizationTracker = SynchronizationTracker()
   52|      0|            #endif
   53|      0|            
   54|      0|            let callStack = Hooks.recordCallStackOnError ? Hooks.customCaptureSubscriptionCallstack() : []
   55|      0|            
   56|      0|            let observer = AnonymousObserver<E> { event in
   57|      0|                
   58|      0|                #if DEBUG
   59|      0|                    synchronizationTracker.register(synchronizationErrorMessage: .default)
   60|      0|                    defer { synchronizationTracker.unregister() }
   61|      0|                #endif
   62|      0|                
   63|      0|                switch event {
   64|      0|                case .next(let value):
   65|      0|                    onNext?(value)
   66|      0|                case .error(let error):
   67|      0|                    if let onError = onError {
   68|      0|                        onError(error)
   69|      0|                    }
   70|      0|                    else {
   71|      0|                        Hooks.defaultErrorHandler(callStack, error)
   72|      0|                    }
   73|      0|                    disposable.dispose()
   74|      0|                case .completed:
   75|      0|                    onCompleted?()
   76|      0|                    disposable.dispose()
   77|      0|                }
   78|      0|            }
   79|      0|            return Disposables.create(
   80|      0|                self.asObservable().subscribe(observer),
   81|      0|                disposable
   82|      0|            )
   83|      0|    }
   84|       |}
   85|       |
   86|       |import class Foundation.NSRecursiveLock
   87|       |
   88|       |extension Hooks {
   89|       |    public typealias DefaultErrorHandler = (_ subscriptionCallStack: [String], _ error: Error) -> Void
   90|       |    public typealias CustomCaptureSubscriptionCallstack = () -> [String]
   91|       |
   92|       |    fileprivate static let _lock = RecursiveLock()
   93|      0|    fileprivate static var _defaultErrorHandler: DefaultErrorHandler = { subscriptionCallStack, error in
   94|      0|        #if DEBUG
   95|      0|            let serializedCallStack = subscriptionCallStack.joined(separator: "\n")
   96|      0|            print("Unhandled error happened: \(error)\n subscription called from:\n\(serializedCallStack)")
   97|      0|        #endif
   98|      0|    }
   99|      0|    fileprivate static var _customCaptureSubscriptionCallstack: CustomCaptureSubscriptionCallstack = {
  100|      0|        #if DEBUG
  101|      0|            return Thread.callStackSymbols
  102|      0|        #else
  103|      0|            return []
  104|      0|        #endif
  105|      0|    }
  106|       |
  107|       |    /// Error handler called in case onError handler wasn't provided.
  108|       |    public static var defaultErrorHandler: DefaultErrorHandler {
  109|       |        get {
  110|       |            _lock.lock(); defer { _lock.unlock() }
  111|       |            return _defaultErrorHandler
  112|       |        }
  113|      0|        set {
  114|      0|            _lock.lock(); defer { _lock.unlock() }
  115|      0|            _defaultErrorHandler = newValue
  116|      0|        }
  117|       |    }
  118|       |    
  119|       |    /// Subscription callstack block to fetch custom callstack information.
  120|       |    public static var customCaptureSubscriptionCallstack: CustomCaptureSubscriptionCallstack {
  121|       |        get {
  122|       |            _lock.lock(); defer { _lock.unlock() }
  123|       |            return _customCaptureSubscriptionCallstack
  124|       |        }
  125|      0|        set {
  126|      0|            _lock.lock(); defer { _lock.unlock() }
  127|      0|            _customCaptureSubscriptionCallstack = newValue
  128|      0|        }
  129|       |    }
  130|       |}
  131|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/ObservableType.swift:
    1|       |//
    2|       |//  ObservableType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a push style sequence.
   10|       |public protocol ObservableType : ObservableConvertibleType {
   11|       |    /**
   12|       |    Subscribes `observer` to receive events for this sequence.
   13|       |    
   14|       |    ### Grammar
   15|       |    
   16|       |    **Next\* (Error | Completed)?**
   17|       |    
   18|       |    * sequences can produce zero or more elements so zero or more `Next` events can be sent to `observer`
   19|       |    * once an `Error` or `Completed` event is sent, the sequence terminates and can't produce any other elements
   20|       |    
   21|       |    It is possible that events are sent from different threads, but no two events can be sent concurrently to
   22|       |    `observer`.
   23|       |    
   24|       |    ### Resource Management
   25|       |    
   26|       |    When sequence sends `Complete` or `Error` event all internal resources that compute sequence elements
   27|       |    will be freed.
   28|       |    
   29|       |    To cancel production of sequence elements and free resources immediately, call `dispose` on returned
   30|       |    subscription.
   31|       |    
   32|       |    - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
   33|       |    */
   34|       |    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
   35|       |}
   36|       |
   37|       |extension ObservableType {
   38|       |    
   39|       |    /// Default implementation of converting `ObservableType` to `Observable`.
   40|      0|    public func asObservable() -> Observable<E> {
   41|      0|        // temporary workaround
   42|      0|        //return Observable.create(subscribe: self.subscribe)
   43|      0|        return Observable.create { o in
   44|      0|            return self.subscribe(o)
   45|      0|        }
   46|      0|    }
   47|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/AddRef.swift:
    1|       |//
    2|       |//  AddRef.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 30/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class AddRefSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias Element = O.E
   11|       |    
   12|      0|    override init(observer: O, cancel: Cancelable) {
   13|      0|        super.init(observer: observer, cancel: cancel)
   14|      0|    }
   15|       |    
   16|      0|    func on(_ event: Event<Element>) {
   17|      0|        switch event {
   18|      0|        case .next:
   19|      0|            self.forwardOn(event)
   20|      0|        case .completed, .error:
   21|      0|            self.forwardOn(event)
   22|      0|            self.dispose()
   23|      0|        }
   24|      0|    }
   25|       |}
   26|       |
   27|       |final class AddRef<Element> : Producer<Element> {
   28|       |    
   29|       |    private let _source: Observable<Element>
   30|       |    private let _refCount: RefCountDisposable
   31|       |    
   32|      0|    init(source: Observable<Element>, refCount: RefCountDisposable) {
   33|      0|        self._source = source
   34|      0|        self._refCount = refCount
   35|      0|    }
   36|       |    
   37|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   38|      0|        let releaseDisposable = self._refCount.retain()
   39|      0|        let sink = AddRefSink(observer: observer, cancel: cancel)
   40|      0|        let subscription = Disposables.create(releaseDisposable, self._source.subscribe(sink))
   41|      0|
   42|      0|        return (sink: sink, subscription: subscription)
   43|      0|    }
   44|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Amb.swift:
    1|       |//
    2|       |//  Amb.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Propagates the observable sequence that reacts first.
   12|       |
   13|       |     - seealso: [amb operator on reactivex.io](http://reactivex.io/documentation/operators/amb.html)
   14|       |
   15|       |     - returns: An observable sequence that surfaces any of the given sequences, whichever reacted first.
   16|       |     */
   17|       |    public static func amb<S: Sequence>(_ sequence: S) -> Observable<E>
   18|      0|        where S.Iterator.Element == Observable<E> {
   19|      0|            return sequence.reduce(Observable<S.Iterator.Element.E>.never()) { a, o in
   20|      0|                return a.amb(o.asObservable())
   21|      0|            }
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension ObservableType {
   26|       |
   27|       |    /**
   28|       |     Propagates the observable sequence that reacts first.
   29|       |
   30|       |     - seealso: [amb operator on reactivex.io](http://reactivex.io/documentation/operators/amb.html)
   31|       |
   32|       |     - parameter right: Second observable sequence.
   33|       |     - returns: An observable sequence that surfaces either of the given sequences, whichever reacted first.
   34|       |     */
   35|       |    public func amb<O2: ObservableType>
   36|       |        (_ right: O2)
   37|       |        -> Observable<E> where O2.E == E {
   38|       |        return Amb(left: self.asObservable(), right: right.asObservable())
   39|       |    }
   40|       |}
   41|       |
   42|       |fileprivate enum AmbState {
   43|       |    case neither
   44|       |    case left
   45|       |    case right
   46|       |}
   47|       |
   48|       |final private class AmbObserver<O: ObserverType>: ObserverType {
   49|       |    typealias Element = O.E
   50|       |    typealias Parent = AmbSink<O>
   51|       |    typealias This = AmbObserver<O>
   52|       |    typealias Sink = (This, Event<Element>) -> Void
   53|       |    
   54|       |    fileprivate let _parent: Parent
   55|       |    fileprivate var _sink: Sink
   56|       |    fileprivate var _cancel: Disposable
   57|       |    
   58|      0|    init(parent: Parent, cancel: Disposable, sink: @escaping Sink) {
   59|      0|#if TRACE_RESOURCES
   60|      0|        _ = Resources.incrementTotal()
   61|      0|#endif
   62|      0|        
   63|      0|        self._parent = parent
   64|      0|        self._sink = sink
   65|      0|        self._cancel = cancel
   66|      0|    }
   67|       |    
   68|      0|    func on(_ event: Event<Element>) {
   69|      0|        self._sink(self, event)
   70|      0|        if event.isStopEvent {
   71|      0|            self._cancel.dispose()
   72|      0|        }
   73|      0|    }
   74|       |    
   75|      0|    deinit {
   76|      0|#if TRACE_RESOURCES
   77|      0|        _ = Resources.decrementTotal()
   78|      0|#endif
   79|      0|    }
   80|       |}
   81|       |
   82|       |final private class AmbSink<O: ObserverType>: Sink<O> {
   83|       |    typealias ElementType = O.E
   84|       |    typealias Parent = Amb<ElementType>
   85|       |    typealias AmbObserverType = AmbObserver<O>
   86|       |
   87|       |    private let _parent: Parent
   88|       |    
   89|       |    private let _lock = RecursiveLock()
   90|       |    // state
   91|       |    private var _choice = AmbState.neither
   92|       |    
   93|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   94|      0|        self._parent = parent
   95|      0|        super.init(observer: observer, cancel: cancel)
   96|      0|    }
   97|       |    
   98|      0|    func run() -> Disposable {
   99|      0|        let subscription1 = SingleAssignmentDisposable()
  100|      0|        let subscription2 = SingleAssignmentDisposable()
  101|      0|        let disposeAll = Disposables.create(subscription1, subscription2)
  102|      0|        
  103|      0|        let forwardEvent = { (o: AmbObserverType, event: Event<ElementType>) -> Void in
  104|      0|            self.forwardOn(event)
  105|      0|            if event.isStopEvent {
  106|      0|                self.dispose()
  107|      0|            }
  108|      0|        }
  109|      0|
  110|      0|        let decide = { (o: AmbObserverType, event: Event<ElementType>, me: AmbState, otherSubscription: Disposable) in
  111|      0|            self._lock.performLocked {
  112|      0|                if self._choice == .neither {
  113|      0|                    self._choice = me
  114|      0|                    o._sink = forwardEvent
  115|      0|                    o._cancel = disposeAll
  116|      0|                    otherSubscription.dispose()
  117|      0|                }
  118|      0|                
  119|      0|                if self._choice == me {
  120|      0|                    self.forwardOn(event)
  121|      0|                    if event.isStopEvent {
  122|      0|                        self.dispose()
  123|      0|                    }
  124|      0|                }
  125|      0|            }
  126|      0|        }
  127|      0|        
  128|      0|        let sink1 = AmbObserver(parent: self, cancel: subscription1) { o, e in
  129|      0|            decide(o, e, .left, subscription2)
  130|      0|        }
  131|      0|        
  132|      0|        let sink2 = AmbObserver(parent: self, cancel: subscription1) { o, e in
  133|      0|            decide(o, e, .right, subscription1)
  134|      0|        }
  135|      0|        
  136|      0|        subscription1.setDisposable(self._parent._left.subscribe(sink1))
  137|      0|        subscription2.setDisposable(self._parent._right.subscribe(sink2))
  138|      0|        
  139|      0|        return disposeAll
  140|      0|    }
  141|       |}
  142|       |
  143|       |final private class Amb<Element>: Producer<Element> {
  144|       |    fileprivate let _left: Observable<Element>
  145|       |    fileprivate let _right: Observable<Element>
  146|       |    
  147|      0|    init(left: Observable<Element>, right: Observable<Element>) {
  148|      0|        self._left = left
  149|      0|        self._right = right
  150|      0|    }
  151|       |    
  152|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  153|      0|        let sink = AmbSink(parent: self, observer: observer, cancel: cancel)
  154|      0|        let subscription = sink.run()
  155|      0|        return (sink: sink, subscription: subscription)
  156|      0|    }
  157|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/AsMaybe.swift:
    1|       |//
    2|       |//  AsMaybe.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class AsMaybeSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ElementType = O.E
   11|       |    typealias E = ElementType
   12|       |
   13|       |    private var _element: Event<E>?
   14|       |
   15|      0|    func on(_ event: Event<E>) {
   16|      0|        switch event {
   17|      0|        case .next:
   18|      0|            if self._element != nil {
   19|      0|                self.forwardOn(.error(RxError.moreThanOneElement))
   20|      0|                self.dispose()
   21|      0|            }
   22|      0|
   23|      0|            self._element = event
   24|      0|        case .error:
   25|      0|            self.forwardOn(event)
   26|      0|            self.dispose()
   27|      0|        case .completed:
   28|      0|            if let element = self._element {
   29|      0|                self.forwardOn(element)
   30|      0|            }
   31|      0|            self.forwardOn(.completed)
   32|      0|            self.dispose()
   33|      0|        }
   34|      0|    }
   35|       |}
   36|       |
   37|       |final class AsMaybe<Element>: Producer<Element> {
   38|       |    fileprivate let _source: Observable<Element>
   39|       |
   40|      0|    init(source: Observable<Element>) {
   41|      0|        self._source = source
   42|      0|    }
   43|       |
   44|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   45|      0|        let sink = AsMaybeSink(observer: observer, cancel: cancel)
   46|      0|        let subscription = self._source.subscribe(sink)
   47|      0|        return (sink: sink, subscription: subscription)
   48|      0|    }
   49|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/AsSingle.swift:
    1|       |//
    2|       |//  AsSingle.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class AsSingleSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ElementType = O.E
   11|       |    typealias E = ElementType
   12|       |
   13|       |    private var _element: Event<E>?
   14|       |
   15|      0|    func on(_ event: Event<E>) {
   16|      0|        switch event {
   17|      0|        case .next:
   18|      0|            if self._element != nil {
   19|      0|                self.forwardOn(.error(RxError.moreThanOneElement))
   20|      0|                self.dispose()
   21|      0|            }
   22|      0|
   23|      0|            self._element = event
   24|      0|        case .error:
   25|      0|            self.forwardOn(event)
   26|      0|            self.dispose()
   27|      0|        case .completed:
   28|      0|            if let element = self._element {
   29|      0|                self.forwardOn(element)
   30|      0|                self.forwardOn(.completed)
   31|      0|            }
   32|      0|            else {
   33|      0|                self.forwardOn(.error(RxError.noElements))
   34|      0|            }
   35|      0|            self.dispose()
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |final class AsSingle<Element>: Producer<Element> {
   41|       |    fileprivate let _source: Observable<Element>
   42|       |
   43|      0|    init(source: Observable<Element>) {
   44|      0|        self._source = source
   45|      0|    }
   46|       |
   47|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   48|      0|        let sink = AsSingleSink(observer: observer, cancel: cancel)
   49|      0|        let subscription = self._source.subscribe(sink)
   50|      0|        return (sink: sink, subscription: subscription)
   51|      0|    }
   52|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Buffer.swift:
    1|       |//
    2|       |//  Buffer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers.
   13|       |
   14|       |     A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
   15|       |
   16|       |     - seealso: [buffer operator on reactivex.io](http://reactivex.io/documentation/operators/buffer.html)
   17|       |
   18|       |     - parameter timeSpan: Maximum time length of a buffer.
   19|       |     - parameter count: Maximum element count of a buffer.
   20|       |     - parameter scheduler: Scheduler to run buffering timers on.
   21|       |     - returns: An observable sequence of buffers.
   22|       |     */
   23|       |    public func buffer(timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType)
   24|      0|        -> Observable<[E]> {
   25|      0|        return BufferTimeCount(source: self.asObservable(), timeSpan: timeSpan, count: count, scheduler: scheduler)
   26|      0|    }
   27|       |}
   28|       |
   29|       |final private class BufferTimeCount<Element>: Producer<[Element]> {
   30|       |    
   31|       |    fileprivate let _timeSpan: RxTimeInterval
   32|       |    fileprivate let _count: Int
   33|       |    fileprivate let _scheduler: SchedulerType
   34|       |    fileprivate let _source: Observable<Element>
   35|       |    
   36|      0|    init(source: Observable<Element>, timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType) {
   37|      0|        self._source = source
   38|      0|        self._timeSpan = timeSpan
   39|      0|        self._count = count
   40|      0|        self._scheduler = scheduler
   41|      0|    }
   42|       |    
   43|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == [Element] {
   44|      0|        let sink = BufferTimeCountSink(parent: self, observer: observer, cancel: cancel)
   45|      0|        let subscription = sink.run()
   46|      0|        return (sink: sink, subscription: subscription)
   47|      0|    }
   48|       |}
   49|       |
   50|       |final private class BufferTimeCountSink<Element, O: ObserverType>
   51|       |    : Sink<O>
   52|       |    , LockOwnerType
   53|       |    , ObserverType
   54|       |    , SynchronizedOnType where O.E == [Element] {
   55|       |    typealias Parent = BufferTimeCount<Element>
   56|       |    typealias E = Element
   57|       |    
   58|       |    private let _parent: Parent
   59|       |    
   60|       |    let _lock = RecursiveLock()
   61|       |    
   62|       |    // state
   63|       |    private let _timerD = SerialDisposable()
   64|       |    private var _buffer = [Element]()
   65|       |    private var _windowID = 0
   66|       |    
   67|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   68|      0|        self._parent = parent
   69|      0|        super.init(observer: observer, cancel: cancel)
   70|      0|    }
   71|       | 
   72|       |    func run() -> Disposable {
   73|       |        self.createTimer(self._windowID)
   74|       |        return Disposables.create(_timerD, _parent._source.subscribe(self))
   75|       |    }
   76|       |    
   77|      0|    func startNewWindowAndSendCurrentOne() {
   78|      0|        self._windowID = self._windowID &+ 1
   79|      0|        let windowID = self._windowID
   80|      0|        
   81|      0|        let buffer = self._buffer
   82|      0|        self._buffer = []
   83|      0|        self.forwardOn(.next(buffer))
   84|      0|        
   85|      0|        self.createTimer(windowID)
   86|      0|    }
   87|       |    
   88|      0|    func on(_ event: Event<E>) {
   89|      0|        self.synchronizedOn(event)
   90|      0|    }
   91|       |
   92|      0|    func _synchronized_on(_ event: Event<E>) {
   93|      0|        switch event {
   94|      0|        case .next(let element):
   95|      0|            self._buffer.append(element)
   96|      0|            
   97|      0|            if self._buffer.count == self._parent._count {
   98|      0|                self.startNewWindowAndSendCurrentOne()
   99|      0|            }
  100|      0|            
  101|      0|        case .error(let error):
  102|      0|            self._buffer = []
  103|      0|            self.forwardOn(.error(error))
  104|      0|            self.dispose()
  105|      0|        case .completed:
  106|      0|            self.forwardOn(.next(self._buffer))
  107|      0|            self.forwardOn(.completed)
  108|      0|            self.dispose()
  109|      0|        }
  110|      0|    }
  111|       |    
  112|       |    func createTimer(_ windowID: Int) {
  113|       |        if self._timerD.isDisposed {
  114|       |            return
  115|       |        }
  116|       |        
  117|       |        if self._windowID != windowID {
  118|       |            return
  119|       |        }
  120|       |
  121|       |        let nextTimer = SingleAssignmentDisposable()
  122|       |        
  123|       |        self._timerD.disposable = nextTimer
  124|       |
  125|      0|        let disposable = self._parent._scheduler.scheduleRelative(windowID, dueTime: self._parent._timeSpan) { previousWindowID in
  126|      0|            self._lock.performLocked {
  127|      0|                if previousWindowID != self._windowID {
  128|      0|                    return
  129|      0|                }
  130|      0|             
  131|      0|                self.startNewWindowAndSendCurrentOne()
  132|      0|            }
  133|      0|            
  134|      0|            return Disposables.create()
  135|      0|        }
  136|       |
  137|       |        nextTimer.setDisposable(disposable)
  138|       |    }
  139|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Catch.swift:
    1|       |//
    2|       |//  Catch.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Continues an observable sequence that is terminated by an error with the observable sequence produced by the handler.
   13|       |
   14|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
   15|       |
   16|       |     - parameter handler: Error handler function, producing another observable sequence.
   17|       |     - returns: An observable sequence containing the source sequence's elements, followed by the elements produced by the handler's resulting observable sequence in case an error occurred.
   18|       |     */
   19|       |    public func catchError(_ handler: @escaping (Swift.Error) throws -> Observable<E>)
   20|      0|        -> Observable<E> {
   21|      0|        return Catch(source: self.asObservable(), handler: handler)
   22|      0|    }
   23|       |
   24|       |    /**
   25|       |     Continues an observable sequence that is terminated by an error with a single element.
   26|       |
   27|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
   28|       |
   29|       |     - parameter element: Last element in an observable sequence in case error occurs.
   30|       |     - returns: An observable sequence containing the source sequence's elements, followed by the `element` in case an error occurred.
   31|       |     */
   32|       |    public func catchErrorJustReturn(_ element: E)
   33|      0|        -> Observable<E> {
   34|      0|        return Catch(source: self.asObservable(), handler: { _ in Observable.just(element) })
   35|      0|    }
   36|       |    
   37|       |}
   38|       |
   39|       |extension ObservableType {
   40|       |    /**
   41|       |     Continues an observable sequence that is terminated by an error with the next observable sequence.
   42|       |
   43|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
   44|       |
   45|       |     - returns: An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
   46|       |     */
   47|       |    public static func catchError<S: Sequence>(_ sequence: S) -> Observable<E>
   48|      0|        where S.Iterator.Element == Observable<E> {
   49|      0|        return CatchSequence(sources: sequence)
   50|      0|    }
   51|       |}
   52|       |
   53|       |extension ObservableType {
   54|       |
   55|       |    /**
   56|       |     Repeats the source observable sequence until it successfully terminates.
   57|       |
   58|       |     **This could potentially create an infinite sequence.**
   59|       |
   60|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
   61|       |
   62|       |     - returns: Observable sequence to repeat until it successfully terminates.
   63|       |     */
   64|      0|    public func retry() -> Observable<E> {
   65|      0|        return CatchSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()))
   66|      0|    }
   67|       |
   68|       |    /**
   69|       |     Repeats the source observable sequence the specified number of times in case of an error or until it successfully terminates.
   70|       |
   71|       |     If you encounter an error and want it to retry once, then you must use `retry(2)`
   72|       |
   73|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
   74|       |
   75|       |     - parameter maxAttemptCount: Maximum number of times to repeat the sequence.
   76|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
   77|       |     */
   78|       |    public func retry(_ maxAttemptCount: Int)
   79|      0|        -> Observable<E> {
   80|      0|        return CatchSequence(sources: Swift.repeatElement(self.asObservable(), count: maxAttemptCount))
   81|      0|    }
   82|       |}
   83|       |
   84|       |// catch with callback
   85|       |
   86|       |final private class CatchSinkProxy<O: ObserverType>: ObserverType {
   87|       |    typealias E = O.E
   88|       |    typealias Parent = CatchSink<O>
   89|       |    
   90|       |    private let _parent: Parent
   91|       |    
   92|      0|    init(parent: Parent) {
   93|      0|        self._parent = parent
   94|      0|    }
   95|       |    
   96|      0|    func on(_ event: Event<E>) {
   97|      0|        self._parent.forwardOn(event)
   98|      0|        
   99|      0|        switch event {
  100|      0|        case .next:
  101|      0|            break
  102|      0|        case .error, .completed:
  103|      0|            self._parent.dispose()
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |final private class CatchSink<O: ObserverType>: Sink<O>, ObserverType {
  109|       |    typealias E = O.E
  110|       |    typealias Parent = Catch<E>
  111|       |    
  112|       |    private let _parent: Parent
  113|       |    private let _subscription = SerialDisposable()
  114|       |    
  115|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  116|      0|        self._parent = parent
  117|      0|        super.init(observer: observer, cancel: cancel)
  118|      0|    }
  119|       |    
  120|      0|    func run() -> Disposable {
  121|      0|        let d1 = SingleAssignmentDisposable()
  122|      0|        self._subscription.disposable = d1
  123|      0|        d1.setDisposable(self._parent._source.subscribe(self))
  124|      0|
  125|      0|        return self._subscription
  126|      0|    }
  127|       |    
  128|      0|    func on(_ event: Event<E>) {
  129|      0|        switch event {
  130|      0|        case .next:
  131|      0|            self.forwardOn(event)
  132|      0|        case .completed:
  133|      0|            self.forwardOn(event)
  134|      0|            self.dispose()
  135|      0|        case .error(let error):
  136|      0|            do {
  137|      0|                let catchSequence = try self._parent._handler(error)
  138|      0|
  139|      0|                let observer = CatchSinkProxy(parent: self)
  140|      0|                
  141|      0|                self._subscription.disposable = catchSequence.subscribe(observer)
  142|      0|            }
  143|      0|            catch let e {
  144|      0|                self.forwardOn(.error(e))
  145|      0|                self.dispose()
  146|      0|            }
  147|      0|        }
  148|      0|    }
  149|       |}
  150|       |
  151|       |final private class Catch<Element>: Producer<Element> {
  152|       |    typealias Handler = (Swift.Error) throws -> Observable<Element>
  153|       |    
  154|       |    fileprivate let _source: Observable<Element>
  155|       |    fileprivate let _handler: Handler
  156|       |    
  157|      0|    init(source: Observable<Element>, handler: @escaping Handler) {
  158|      0|        self._source = source
  159|      0|        self._handler = handler
  160|      0|    }
  161|       |    
  162|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  163|      0|        let sink = CatchSink(parent: self, observer: observer, cancel: cancel)
  164|      0|        let subscription = sink.run()
  165|      0|        return (sink: sink, subscription: subscription)
  166|      0|    }
  167|       |}
  168|       |
  169|       |// catch enumerable
  170|       |
  171|       |final private class CatchSequenceSink<S: Sequence, O: ObserverType>
  172|       |    : TailRecursiveSink<S, O>
  173|       |    , ObserverType where S.Iterator.Element: ObservableConvertibleType, S.Iterator.Element.E == O.E {
  174|       |    typealias Element = O.E
  175|       |    typealias Parent = CatchSequence<S>
  176|       |    
  177|       |    private var _lastError: Swift.Error?
  178|       |    
  179|      0|    override init(observer: O, cancel: Cancelable) {
  180|      0|        super.init(observer: observer, cancel: cancel)
  181|      0|    }
  182|       |    
  183|      0|    func on(_ event: Event<Element>) {
  184|      0|        switch event {
  185|      0|        case .next:
  186|      0|            self.forwardOn(event)
  187|      0|        case .error(let error):
  188|      0|            self._lastError = error
  189|      0|            self.schedule(.moveNext)
  190|      0|        case .completed:
  191|      0|            self.forwardOn(event)
  192|      0|            self.dispose()
  193|      0|        }
  194|      0|    }
  195|       |
  196|      0|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
  197|      0|        return source.subscribe(self)
  198|      0|    }
  199|       |    
  200|      0|    override func done() {
  201|      0|        if let lastError = self._lastError {
  202|      0|            self.forwardOn(.error(lastError))
  203|      0|        }
  204|      0|        else {
  205|      0|            self.forwardOn(.completed)
  206|      0|        }
  207|      0|        
  208|      0|        self.dispose()
  209|      0|    }
  210|       |    
  211|      0|    override func extract(_ observable: Observable<Element>) -> SequenceGenerator? {
  212|      0|        if let onError = observable as? CatchSequence<S> {
  213|      0|            return (onError.sources.makeIterator(), nil)
  214|      0|        }
  215|      0|        else {
  216|      0|            return nil
  217|      0|        }
  218|      0|    }
  219|       |}
  220|       |
  221|       |final private class CatchSequence<S: Sequence>: Producer<S.Iterator.Element.E> where S.Iterator.Element: ObservableConvertibleType {
  222|       |    typealias Element = S.Iterator.Element.E
  223|       |    
  224|       |    let sources: S
  225|       |    
  226|      0|    init(sources: S) {
  227|      0|        self.sources = sources
  228|      0|    }
  229|       |    
  230|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  231|      0|        let sink = CatchSequenceSink<S, O>(observer: observer, cancel: cancel)
  232|      0|        let subscription = sink.run((self.sources.makeIterator(), nil))
  233|      0|        return (sink: sink, subscription: subscription)
  234|      0|    }
  235|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/CombineLatest+Collection.swift:
    1|       |//
    2|       |//  CombineLatest+Collection.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   12|       |
   13|       |     - seealso: [combinelatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   14|       |
   15|       |     - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   16|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   17|       |     */
   18|       |    public static func combineLatest<C: Collection>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> E) -> Observable<E>
   19|      0|        where C.Iterator.Element: ObservableType {
   20|      0|        return CombineLatestCollectionType(sources: collection, resultSelector: resultSelector)
   21|      0|    }
   22|       |
   23|       |    /**
   24|       |     Merges the specified observable sequences into one observable sequence whenever any of the observable sequences produces an element.
   25|       |
   26|       |     - seealso: [combinelatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   27|       |
   28|       |     - returns: An observable sequence containing the result of combining elements of the sources.
   29|       |     */
   30|       |    public static func combineLatest<C: Collection>(_ collection: C) -> Observable<[E]>
   31|      0|        where C.Iterator.Element: ObservableType, C.Iterator.Element.E == E {
   32|      0|        return CombineLatestCollectionType(sources: collection, resultSelector: { $0 })
   33|      0|    }
   34|       |}
   35|       |
   36|       |final private class CombineLatestCollectionTypeSink<C: Collection, O: ObserverType>
   37|       |    : Sink<O> where C.Iterator.Element: ObservableConvertibleType {
   38|       |    typealias R = O.E
   39|       |    typealias Parent = CombineLatestCollectionType<C, R>
   40|       |    typealias SourceElement = C.Iterator.Element.E
   41|       |    
   42|       |    let _parent: Parent
   43|       |    
   44|       |    let _lock = RecursiveLock()
   45|       |
   46|       |    // state
   47|       |    var _numberOfValues = 0
   48|       |    var _values: [SourceElement?]
   49|       |    var _isDone: [Bool]
   50|       |    var _numberOfDone = 0
   51|       |    var _subscriptions: [SingleAssignmentDisposable]
   52|       |    
   53|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   54|      0|        self._parent = parent
   55|      0|        self._values = [SourceElement?](repeating: nil, count: parent._count)
   56|      0|        self._isDone = [Bool](repeating: false, count: parent._count)
   57|      0|        self._subscriptions = [SingleAssignmentDisposable]()
   58|      0|        self._subscriptions.reserveCapacity(parent._count)
   59|      0|        
   60|      0|        for _ in 0 ..< parent._count {
   61|      0|            self._subscriptions.append(SingleAssignmentDisposable())
   62|      0|        }
   63|      0|        
   64|      0|        super.init(observer: observer, cancel: cancel)
   65|      0|    }
   66|       |    
   67|      0|    func on(_ event: Event<SourceElement>, atIndex: Int) {
   68|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   69|      0|            switch event {
   70|      0|            case .next(let element):
   71|      0|                if self._values[atIndex] == nil {
   72|      0|                   self._numberOfValues += 1
   73|      0|                }
   74|      0|                
   75|      0|                self._values[atIndex] = element
   76|      0|                
   77|      0|                if self._numberOfValues < self._parent._count {
   78|      0|                    let numberOfOthersThatAreDone = self._numberOfDone - (self._isDone[atIndex] ? 1 : 0)
   79|      0|                    if numberOfOthersThatAreDone == self._parent._count - 1 {
   80|      0|                        self.forwardOn(.completed)
   81|      0|                        self.dispose()
   82|      0|                    }
   83|      0|                    return
   84|      0|                }
   85|      0|                
   86|      0|                do {
   87|      0|                    let result = try self._parent._resultSelector(self._values.map { $0! })
   88|      0|                    self.forwardOn(.next(result))
   89|      0|                }
   90|      0|                catch let error {
   91|      0|                    self.forwardOn(.error(error))
   92|      0|                    self.dispose()
   93|      0|                }
   94|      0|                
   95|      0|            case .error(let error):
   96|      0|                self.forwardOn(.error(error))
   97|      0|                self.dispose()
   98|      0|            case .completed:
   99|      0|                if self._isDone[atIndex] {
  100|      0|                    return
  101|      0|                }
  102|      0|                
  103|      0|                self._isDone[atIndex] = true
  104|      0|                self._numberOfDone += 1
  105|      0|                
  106|      0|                if self._numberOfDone == self._parent._count {
  107|      0|                    self.forwardOn(.completed)
  108|      0|                    self.dispose()
  109|      0|                }
  110|      0|                else {
  111|      0|                    self._subscriptions[atIndex].dispose()
  112|      0|                }
  113|      0|            }
  114|      0|        // }
  115|      0|    }
  116|       |    
  117|      0|    func run() -> Disposable {
  118|      0|        var j = 0
  119|      0|        for i in self._parent._sources {
  120|      0|            let index = j
  121|      0|            let source = i.asObservable()
  122|      0|            let disposable = source.subscribe(AnyObserver { event in
  123|      0|                self.on(event, atIndex: index)
  124|      0|            })
  125|      0|
  126|      0|            self._subscriptions[j].setDisposable(disposable)
  127|      0|            
  128|      0|            j += 1
  129|      0|        }
  130|      0|
  131|      0|        if self._parent._sources.isEmpty {
  132|      0|            self.forwardOn(.completed)
  133|      0|        }
  134|      0|        
  135|      0|        return Disposables.create(_subscriptions)
  136|      0|    }
  137|       |}
  138|       |
  139|       |final private class CombineLatestCollectionType<C: Collection, R>: Producer<R> where C.Iterator.Element: ObservableConvertibleType {
  140|       |    typealias ResultSelector = ([C.Iterator.Element.E]) throws -> R
  141|       |    
  142|       |    let _sources: C
  143|       |    let _resultSelector: ResultSelector
  144|       |    let _count: Int
  145|       |
  146|      0|    init(sources: C, resultSelector: @escaping ResultSelector) {
  147|      0|        self._sources = sources
  148|      0|        self._resultSelector = resultSelector
  149|      0|        self._count = Int(Int64(self._sources.count))
  150|      0|    }
  151|       |    
  152|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  153|      0|        let sink = CombineLatestCollectionTypeSink(parent: self, observer: observer, cancel: cancel)
  154|      0|        let subscription = sink.run()
  155|      0|        return (sink: sink, subscription: subscription)
  156|      0|    }
  157|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/CombineLatest+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  CombineLatest+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 4/22/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension ObservableType {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   17|       |
   18|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType>
   24|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   25|      0|            -> Observable<E> {
   26|      0|        return CombineLatest2(
   27|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   28|      0|            resultSelector: resultSelector
   29|      0|        )
   30|      0|    }
   31|       |}
   32|       |
   33|       |extension ObservableType where E == Any {
   34|       |    /**
   35|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
   36|       |
   37|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   38|       |
   39|       |    - returns: An observable sequence containing the result of combining elements of the sources.
   40|       |    */
   41|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType>
   42|       |        (_ source1: O1, _ source2: O2)
   43|      0|            -> Observable<(O1.E, O2.E)> {
   44|      0|        return CombineLatest2(
   45|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   46|      0|            resultSelector: { ($0, $1) }
   47|      0|        )
   48|      0|    }
   49|       |}
   50|       |
   51|       |final class CombineLatestSink2_<E1, E2, O: ObserverType> : CombineLatestSink<O> {
   52|       |    typealias R = O.E
   53|       |    typealias Parent = CombineLatest2<E1, E2, R>
   54|       |
   55|       |    let _parent: Parent
   56|       |
   57|       |    var _latestElement1: E1! = nil
   58|       |    var _latestElement2: E2! = nil
   59|       |
   60|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   61|      0|        self._parent = parent
   62|      0|        super.init(arity: 2, observer: observer, cancel: cancel)
   63|      0|    }
   64|       |
   65|      0|    func run() -> Disposable {
   66|      0|        let subscription1 = SingleAssignmentDisposable()
   67|      0|        let subscription2 = SingleAssignmentDisposable()
   68|      0|
   69|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
   70|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
   71|      0|
   72|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
   73|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
   74|      0|
   75|      0|        return Disposables.create([
   76|      0|                subscription1,
   77|      0|                subscription2
   78|      0|        ])
   79|      0|    }
   80|       |
   81|      0|    override func getResult() throws -> R {
   82|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2)
   83|      0|    }
   84|       |}
   85|       |
   86|       |final class CombineLatest2<E1, E2, R> : Producer<R> {
   87|       |    typealias ResultSelector = (E1, E2) throws -> R
   88|       |
   89|       |    let _source1: Observable<E1>
   90|       |    let _source2: Observable<E2>
   91|       |
   92|       |    let _resultSelector: ResultSelector
   93|       |
   94|      0|    init(source1: Observable<E1>, source2: Observable<E2>, resultSelector: @escaping ResultSelector) {
   95|      0|        self._source1 = source1
   96|      0|        self._source2 = source2
   97|      0|
   98|      0|        self._resultSelector = resultSelector
   99|      0|    }
  100|       |
  101|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  102|      0|        let sink = CombineLatestSink2_(parent: self, observer: observer, cancel: cancel)
  103|      0|        let subscription = sink.run()
  104|      0|        return (sink: sink, subscription: subscription)
  105|      0|    }
  106|       |}
  107|       |
  108|       |
  109|       |
  110|       |// 3
  111|       |
  112|       |extension ObservableType {
  113|       |    /**
  114|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  115|       |
  116|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  117|       |
  118|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  119|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  120|       |    */
  121|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  122|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  123|      0|            -> Observable<E> {
  124|      0|        return CombineLatest3(
  125|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  126|      0|            resultSelector: resultSelector
  127|      0|        )
  128|      0|    }
  129|       |}
  130|       |
  131|       |extension ObservableType where E == Any {
  132|       |    /**
  133|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  134|       |
  135|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  136|       |
  137|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  138|       |    */
  139|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  140|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  141|      0|            -> Observable<(O1.E, O2.E, O3.E)> {
  142|      0|        return CombineLatest3(
  143|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  144|      0|            resultSelector: { ($0, $1, $2) }
  145|      0|        )
  146|      0|    }
  147|       |}
  148|       |
  149|       |final class CombineLatestSink3_<E1, E2, E3, O: ObserverType> : CombineLatestSink<O> {
  150|       |    typealias R = O.E
  151|       |    typealias Parent = CombineLatest3<E1, E2, E3, R>
  152|       |
  153|       |    let _parent: Parent
  154|       |
  155|       |    var _latestElement1: E1! = nil
  156|       |    var _latestElement2: E2! = nil
  157|       |    var _latestElement3: E3! = nil
  158|       |
  159|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  160|      0|        self._parent = parent
  161|      0|        super.init(arity: 3, observer: observer, cancel: cancel)
  162|      0|    }
  163|       |
  164|      0|    func run() -> Disposable {
  165|      0|        let subscription1 = SingleAssignmentDisposable()
  166|      0|        let subscription2 = SingleAssignmentDisposable()
  167|      0|        let subscription3 = SingleAssignmentDisposable()
  168|      0|
  169|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  170|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  171|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  172|      0|
  173|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  174|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  175|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  176|      0|
  177|      0|        return Disposables.create([
  178|      0|                subscription1,
  179|      0|                subscription2,
  180|      0|                subscription3
  181|      0|        ])
  182|      0|    }
  183|       |
  184|      0|    override func getResult() throws -> R {
  185|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3)
  186|      0|    }
  187|       |}
  188|       |
  189|       |final class CombineLatest3<E1, E2, E3, R> : Producer<R> {
  190|       |    typealias ResultSelector = (E1, E2, E3) throws -> R
  191|       |
  192|       |    let _source1: Observable<E1>
  193|       |    let _source2: Observable<E2>
  194|       |    let _source3: Observable<E3>
  195|       |
  196|       |    let _resultSelector: ResultSelector
  197|       |
  198|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, resultSelector: @escaping ResultSelector) {
  199|      0|        self._source1 = source1
  200|      0|        self._source2 = source2
  201|      0|        self._source3 = source3
  202|      0|
  203|      0|        self._resultSelector = resultSelector
  204|      0|    }
  205|       |
  206|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  207|      0|        let sink = CombineLatestSink3_(parent: self, observer: observer, cancel: cancel)
  208|      0|        let subscription = sink.run()
  209|      0|        return (sink: sink, subscription: subscription)
  210|      0|    }
  211|       |}
  212|       |
  213|       |
  214|       |
  215|       |// 4
  216|       |
  217|       |extension ObservableType {
  218|       |    /**
  219|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  220|       |
  221|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  222|       |
  223|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  224|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  225|       |    */
  226|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  227|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  228|      0|            -> Observable<E> {
  229|      0|        return CombineLatest4(
  230|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  231|      0|            resultSelector: resultSelector
  232|      0|        )
  233|      0|    }
  234|       |}
  235|       |
  236|       |extension ObservableType where E == Any {
  237|       |    /**
  238|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  239|       |
  240|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  241|       |
  242|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  243|       |    */
  244|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  245|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  246|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E)> {
  247|      0|        return CombineLatest4(
  248|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  249|      0|            resultSelector: { ($0, $1, $2, $3) }
  250|      0|        )
  251|      0|    }
  252|       |}
  253|       |
  254|       |final class CombineLatestSink4_<E1, E2, E3, E4, O: ObserverType> : CombineLatestSink<O> {
  255|       |    typealias R = O.E
  256|       |    typealias Parent = CombineLatest4<E1, E2, E3, E4, R>
  257|       |
  258|       |    let _parent: Parent
  259|       |
  260|       |    var _latestElement1: E1! = nil
  261|       |    var _latestElement2: E2! = nil
  262|       |    var _latestElement3: E3! = nil
  263|       |    var _latestElement4: E4! = nil
  264|       |
  265|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  266|      0|        self._parent = parent
  267|      0|        super.init(arity: 4, observer: observer, cancel: cancel)
  268|      0|    }
  269|       |
  270|      0|    func run() -> Disposable {
  271|      0|        let subscription1 = SingleAssignmentDisposable()
  272|      0|        let subscription2 = SingleAssignmentDisposable()
  273|      0|        let subscription3 = SingleAssignmentDisposable()
  274|      0|        let subscription4 = SingleAssignmentDisposable()
  275|      0|
  276|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  277|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  278|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  279|      0|        let observer4 = CombineLatestObserver(lock: self._lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  280|      0|
  281|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  282|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  283|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  284|      0|         subscription4.setDisposable(self._parent._source4.subscribe(observer4))
  285|      0|
  286|      0|        return Disposables.create([
  287|      0|                subscription1,
  288|      0|                subscription2,
  289|      0|                subscription3,
  290|      0|                subscription4
  291|      0|        ])
  292|      0|    }
  293|       |
  294|      0|    override func getResult() throws -> R {
  295|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3, self._latestElement4)
  296|      0|    }
  297|       |}
  298|       |
  299|       |final class CombineLatest4<E1, E2, E3, E4, R> : Producer<R> {
  300|       |    typealias ResultSelector = (E1, E2, E3, E4) throws -> R
  301|       |
  302|       |    let _source1: Observable<E1>
  303|       |    let _source2: Observable<E2>
  304|       |    let _source3: Observable<E3>
  305|       |    let _source4: Observable<E4>
  306|       |
  307|       |    let _resultSelector: ResultSelector
  308|       |
  309|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, resultSelector: @escaping ResultSelector) {
  310|      0|        self._source1 = source1
  311|      0|        self._source2 = source2
  312|      0|        self._source3 = source3
  313|      0|        self._source4 = source4
  314|      0|
  315|      0|        self._resultSelector = resultSelector
  316|      0|    }
  317|       |
  318|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  319|      0|        let sink = CombineLatestSink4_(parent: self, observer: observer, cancel: cancel)
  320|      0|        let subscription = sink.run()
  321|      0|        return (sink: sink, subscription: subscription)
  322|      0|    }
  323|       |}
  324|       |
  325|       |
  326|       |
  327|       |// 5
  328|       |
  329|       |extension ObservableType {
  330|       |    /**
  331|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  332|       |
  333|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  334|       |
  335|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  336|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  337|       |    */
  338|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  339|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  340|      0|            -> Observable<E> {
  341|      0|        return CombineLatest5(
  342|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  343|      0|            resultSelector: resultSelector
  344|      0|        )
  345|      0|    }
  346|       |}
  347|       |
  348|       |extension ObservableType where E == Any {
  349|       |    /**
  350|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  351|       |
  352|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  353|       |
  354|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  355|       |    */
  356|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  357|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  358|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> {
  359|      0|        return CombineLatest5(
  360|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  361|      0|            resultSelector: { ($0, $1, $2, $3, $4) }
  362|      0|        )
  363|      0|    }
  364|       |}
  365|       |
  366|       |final class CombineLatestSink5_<E1, E2, E3, E4, E5, O: ObserverType> : CombineLatestSink<O> {
  367|       |    typealias R = O.E
  368|       |    typealias Parent = CombineLatest5<E1, E2, E3, E4, E5, R>
  369|       |
  370|       |    let _parent: Parent
  371|       |
  372|       |    var _latestElement1: E1! = nil
  373|       |    var _latestElement2: E2! = nil
  374|       |    var _latestElement3: E3! = nil
  375|       |    var _latestElement4: E4! = nil
  376|       |    var _latestElement5: E5! = nil
  377|       |
  378|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  379|      0|        self._parent = parent
  380|      0|        super.init(arity: 5, observer: observer, cancel: cancel)
  381|      0|    }
  382|       |
  383|      0|    func run() -> Disposable {
  384|      0|        let subscription1 = SingleAssignmentDisposable()
  385|      0|        let subscription2 = SingleAssignmentDisposable()
  386|      0|        let subscription3 = SingleAssignmentDisposable()
  387|      0|        let subscription4 = SingleAssignmentDisposable()
  388|      0|        let subscription5 = SingleAssignmentDisposable()
  389|      0|
  390|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  391|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  392|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  393|      0|        let observer4 = CombineLatestObserver(lock: self._lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  394|      0|        let observer5 = CombineLatestObserver(lock: self._lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  395|      0|
  396|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  397|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  398|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  399|      0|         subscription4.setDisposable(self._parent._source4.subscribe(observer4))
  400|      0|         subscription5.setDisposable(self._parent._source5.subscribe(observer5))
  401|      0|
  402|      0|        return Disposables.create([
  403|      0|                subscription1,
  404|      0|                subscription2,
  405|      0|                subscription3,
  406|      0|                subscription4,
  407|      0|                subscription5
  408|      0|        ])
  409|      0|    }
  410|       |
  411|      0|    override func getResult() throws -> R {
  412|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3, self._latestElement4, self._latestElement5)
  413|      0|    }
  414|       |}
  415|       |
  416|       |final class CombineLatest5<E1, E2, E3, E4, E5, R> : Producer<R> {
  417|       |    typealias ResultSelector = (E1, E2, E3, E4, E5) throws -> R
  418|       |
  419|       |    let _source1: Observable<E1>
  420|       |    let _source2: Observable<E2>
  421|       |    let _source3: Observable<E3>
  422|       |    let _source4: Observable<E4>
  423|       |    let _source5: Observable<E5>
  424|       |
  425|       |    let _resultSelector: ResultSelector
  426|       |
  427|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, resultSelector: @escaping ResultSelector) {
  428|      0|        self._source1 = source1
  429|      0|        self._source2 = source2
  430|      0|        self._source3 = source3
  431|      0|        self._source4 = source4
  432|      0|        self._source5 = source5
  433|      0|
  434|      0|        self._resultSelector = resultSelector
  435|      0|    }
  436|       |
  437|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  438|      0|        let sink = CombineLatestSink5_(parent: self, observer: observer, cancel: cancel)
  439|      0|        let subscription = sink.run()
  440|      0|        return (sink: sink, subscription: subscription)
  441|      0|    }
  442|       |}
  443|       |
  444|       |
  445|       |
  446|       |// 6
  447|       |
  448|       |extension ObservableType {
  449|       |    /**
  450|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  451|       |
  452|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  453|       |
  454|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  455|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  456|       |    */
  457|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  458|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  459|      0|            -> Observable<E> {
  460|      0|        return CombineLatest6(
  461|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  462|      0|            resultSelector: resultSelector
  463|      0|        )
  464|      0|    }
  465|       |}
  466|       |
  467|       |extension ObservableType where E == Any {
  468|       |    /**
  469|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  470|       |
  471|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  472|       |
  473|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  474|       |    */
  475|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  476|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  477|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> {
  478|      0|        return CombineLatest6(
  479|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  480|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5) }
  481|      0|        )
  482|      0|    }
  483|       |}
  484|       |
  485|       |final class CombineLatestSink6_<E1, E2, E3, E4, E5, E6, O: ObserverType> : CombineLatestSink<O> {
  486|       |    typealias R = O.E
  487|       |    typealias Parent = CombineLatest6<E1, E2, E3, E4, E5, E6, R>
  488|       |
  489|       |    let _parent: Parent
  490|       |
  491|       |    var _latestElement1: E1! = nil
  492|       |    var _latestElement2: E2! = nil
  493|       |    var _latestElement3: E3! = nil
  494|       |    var _latestElement4: E4! = nil
  495|       |    var _latestElement5: E5! = nil
  496|       |    var _latestElement6: E6! = nil
  497|       |
  498|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  499|      0|        self._parent = parent
  500|      0|        super.init(arity: 6, observer: observer, cancel: cancel)
  501|      0|    }
  502|       |
  503|      0|    func run() -> Disposable {
  504|      0|        let subscription1 = SingleAssignmentDisposable()
  505|      0|        let subscription2 = SingleAssignmentDisposable()
  506|      0|        let subscription3 = SingleAssignmentDisposable()
  507|      0|        let subscription4 = SingleAssignmentDisposable()
  508|      0|        let subscription5 = SingleAssignmentDisposable()
  509|      0|        let subscription6 = SingleAssignmentDisposable()
  510|      0|
  511|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  512|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  513|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  514|      0|        let observer4 = CombineLatestObserver(lock: self._lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  515|      0|        let observer5 = CombineLatestObserver(lock: self._lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  516|      0|        let observer6 = CombineLatestObserver(lock: self._lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  517|      0|
  518|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  519|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  520|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  521|      0|         subscription4.setDisposable(self._parent._source4.subscribe(observer4))
  522|      0|         subscription5.setDisposable(self._parent._source5.subscribe(observer5))
  523|      0|         subscription6.setDisposable(self._parent._source6.subscribe(observer6))
  524|      0|
  525|      0|        return Disposables.create([
  526|      0|                subscription1,
  527|      0|                subscription2,
  528|      0|                subscription3,
  529|      0|                subscription4,
  530|      0|                subscription5,
  531|      0|                subscription6
  532|      0|        ])
  533|      0|    }
  534|       |
  535|      0|    override func getResult() throws -> R {
  536|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3, self._latestElement4, self._latestElement5, self._latestElement6)
  537|      0|    }
  538|       |}
  539|       |
  540|       |final class CombineLatest6<E1, E2, E3, E4, E5, E6, R> : Producer<R> {
  541|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6) throws -> R
  542|       |
  543|       |    let _source1: Observable<E1>
  544|       |    let _source2: Observable<E2>
  545|       |    let _source3: Observable<E3>
  546|       |    let _source4: Observable<E4>
  547|       |    let _source5: Observable<E5>
  548|       |    let _source6: Observable<E6>
  549|       |
  550|       |    let _resultSelector: ResultSelector
  551|       |
  552|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, resultSelector: @escaping ResultSelector) {
  553|      0|        self._source1 = source1
  554|      0|        self._source2 = source2
  555|      0|        self._source3 = source3
  556|      0|        self._source4 = source4
  557|      0|        self._source5 = source5
  558|      0|        self._source6 = source6
  559|      0|
  560|      0|        self._resultSelector = resultSelector
  561|      0|    }
  562|       |
  563|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  564|      0|        let sink = CombineLatestSink6_(parent: self, observer: observer, cancel: cancel)
  565|      0|        let subscription = sink.run()
  566|      0|        return (sink: sink, subscription: subscription)
  567|      0|    }
  568|       |}
  569|       |
  570|       |
  571|       |
  572|       |// 7
  573|       |
  574|       |extension ObservableType {
  575|       |    /**
  576|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  577|       |
  578|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  579|       |
  580|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  581|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  582|       |    */
  583|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  584|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  585|      0|            -> Observable<E> {
  586|      0|        return CombineLatest7(
  587|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  588|      0|            resultSelector: resultSelector
  589|      0|        )
  590|      0|    }
  591|       |}
  592|       |
  593|       |extension ObservableType where E == Any {
  594|       |    /**
  595|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  596|       |
  597|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  598|       |
  599|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  600|       |    */
  601|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  602|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  603|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> {
  604|      0|        return CombineLatest7(
  605|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  606|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
  607|      0|        )
  608|      0|    }
  609|       |}
  610|       |
  611|       |final class CombineLatestSink7_<E1, E2, E3, E4, E5, E6, E7, O: ObserverType> : CombineLatestSink<O> {
  612|       |    typealias R = O.E
  613|       |    typealias Parent = CombineLatest7<E1, E2, E3, E4, E5, E6, E7, R>
  614|       |
  615|       |    let _parent: Parent
  616|       |
  617|       |    var _latestElement1: E1! = nil
  618|       |    var _latestElement2: E2! = nil
  619|       |    var _latestElement3: E3! = nil
  620|       |    var _latestElement4: E4! = nil
  621|       |    var _latestElement5: E5! = nil
  622|       |    var _latestElement6: E6! = nil
  623|       |    var _latestElement7: E7! = nil
  624|       |
  625|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  626|      0|        self._parent = parent
  627|      0|        super.init(arity: 7, observer: observer, cancel: cancel)
  628|      0|    }
  629|       |
  630|      0|    func run() -> Disposable {
  631|      0|        let subscription1 = SingleAssignmentDisposable()
  632|      0|        let subscription2 = SingleAssignmentDisposable()
  633|      0|        let subscription3 = SingleAssignmentDisposable()
  634|      0|        let subscription4 = SingleAssignmentDisposable()
  635|      0|        let subscription5 = SingleAssignmentDisposable()
  636|      0|        let subscription6 = SingleAssignmentDisposable()
  637|      0|        let subscription7 = SingleAssignmentDisposable()
  638|      0|
  639|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  640|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  641|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  642|      0|        let observer4 = CombineLatestObserver(lock: self._lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  643|      0|        let observer5 = CombineLatestObserver(lock: self._lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  644|      0|        let observer6 = CombineLatestObserver(lock: self._lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  645|      0|        let observer7 = CombineLatestObserver(lock: self._lock, parent: self, index: 6, setLatestValue: { (e: E7) -> Void in self._latestElement7 = e }, this: subscription7)
  646|      0|
  647|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  648|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  649|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  650|      0|         subscription4.setDisposable(self._parent._source4.subscribe(observer4))
  651|      0|         subscription5.setDisposable(self._parent._source5.subscribe(observer5))
  652|      0|         subscription6.setDisposable(self._parent._source6.subscribe(observer6))
  653|      0|         subscription7.setDisposable(self._parent._source7.subscribe(observer7))
  654|      0|
  655|      0|        return Disposables.create([
  656|      0|                subscription1,
  657|      0|                subscription2,
  658|      0|                subscription3,
  659|      0|                subscription4,
  660|      0|                subscription5,
  661|      0|                subscription6,
  662|      0|                subscription7
  663|      0|        ])
  664|      0|    }
  665|       |
  666|      0|    override func getResult() throws -> R {
  667|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3, self._latestElement4, self._latestElement5, self._latestElement6, self._latestElement7)
  668|      0|    }
  669|       |}
  670|       |
  671|       |final class CombineLatest7<E1, E2, E3, E4, E5, E6, E7, R> : Producer<R> {
  672|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7) throws -> R
  673|       |
  674|       |    let _source1: Observable<E1>
  675|       |    let _source2: Observable<E2>
  676|       |    let _source3: Observable<E3>
  677|       |    let _source4: Observable<E4>
  678|       |    let _source5: Observable<E5>
  679|       |    let _source6: Observable<E6>
  680|       |    let _source7: Observable<E7>
  681|       |
  682|       |    let _resultSelector: ResultSelector
  683|       |
  684|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, resultSelector: @escaping ResultSelector) {
  685|      0|        self._source1 = source1
  686|      0|        self._source2 = source2
  687|      0|        self._source3 = source3
  688|      0|        self._source4 = source4
  689|      0|        self._source5 = source5
  690|      0|        self._source6 = source6
  691|      0|        self._source7 = source7
  692|      0|
  693|      0|        self._resultSelector = resultSelector
  694|      0|    }
  695|       |
  696|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  697|      0|        let sink = CombineLatestSink7_(parent: self, observer: observer, cancel: cancel)
  698|      0|        let subscription = sink.run()
  699|      0|        return (sink: sink, subscription: subscription)
  700|      0|    }
  701|       |}
  702|       |
  703|       |
  704|       |
  705|       |// 8
  706|       |
  707|       |extension ObservableType {
  708|       |    /**
  709|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  710|       |
  711|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  712|       |
  713|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  714|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  715|       |    */
  716|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  717|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  718|      0|            -> Observable<E> {
  719|      0|        return CombineLatest8(
  720|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  721|      0|            resultSelector: resultSelector
  722|      0|        )
  723|      0|    }
  724|       |}
  725|       |
  726|       |extension ObservableType where E == Any {
  727|       |    /**
  728|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  729|       |
  730|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  731|       |
  732|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  733|       |    */
  734|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  735|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  736|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> {
  737|      0|        return CombineLatest8(
  738|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  739|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
  740|      0|        )
  741|      0|    }
  742|       |}
  743|       |
  744|       |final class CombineLatestSink8_<E1, E2, E3, E4, E5, E6, E7, E8, O: ObserverType> : CombineLatestSink<O> {
  745|       |    typealias R = O.E
  746|       |    typealias Parent = CombineLatest8<E1, E2, E3, E4, E5, E6, E7, E8, R>
  747|       |
  748|       |    let _parent: Parent
  749|       |
  750|       |    var _latestElement1: E1! = nil
  751|       |    var _latestElement2: E2! = nil
  752|       |    var _latestElement3: E3! = nil
  753|       |    var _latestElement4: E4! = nil
  754|       |    var _latestElement5: E5! = nil
  755|       |    var _latestElement6: E6! = nil
  756|       |    var _latestElement7: E7! = nil
  757|       |    var _latestElement8: E8! = nil
  758|       |
  759|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  760|      0|        self._parent = parent
  761|      0|        super.init(arity: 8, observer: observer, cancel: cancel)
  762|      0|    }
  763|       |
  764|      0|    func run() -> Disposable {
  765|      0|        let subscription1 = SingleAssignmentDisposable()
  766|      0|        let subscription2 = SingleAssignmentDisposable()
  767|      0|        let subscription3 = SingleAssignmentDisposable()
  768|      0|        let subscription4 = SingleAssignmentDisposable()
  769|      0|        let subscription5 = SingleAssignmentDisposable()
  770|      0|        let subscription6 = SingleAssignmentDisposable()
  771|      0|        let subscription7 = SingleAssignmentDisposable()
  772|      0|        let subscription8 = SingleAssignmentDisposable()
  773|      0|
  774|      0|        let observer1 = CombineLatestObserver(lock: self._lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  775|      0|        let observer2 = CombineLatestObserver(lock: self._lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  776|      0|        let observer3 = CombineLatestObserver(lock: self._lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  777|      0|        let observer4 = CombineLatestObserver(lock: self._lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  778|      0|        let observer5 = CombineLatestObserver(lock: self._lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  779|      0|        let observer6 = CombineLatestObserver(lock: self._lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  780|      0|        let observer7 = CombineLatestObserver(lock: self._lock, parent: self, index: 6, setLatestValue: { (e: E7) -> Void in self._latestElement7 = e }, this: subscription7)
  781|      0|        let observer8 = CombineLatestObserver(lock: self._lock, parent: self, index: 7, setLatestValue: { (e: E8) -> Void in self._latestElement8 = e }, this: subscription8)
  782|      0|
  783|      0|         subscription1.setDisposable(self._parent._source1.subscribe(observer1))
  784|      0|         subscription2.setDisposable(self._parent._source2.subscribe(observer2))
  785|      0|         subscription3.setDisposable(self._parent._source3.subscribe(observer3))
  786|      0|         subscription4.setDisposable(self._parent._source4.subscribe(observer4))
  787|      0|         subscription5.setDisposable(self._parent._source5.subscribe(observer5))
  788|      0|         subscription6.setDisposable(self._parent._source6.subscribe(observer6))
  789|      0|         subscription7.setDisposable(self._parent._source7.subscribe(observer7))
  790|      0|         subscription8.setDisposable(self._parent._source8.subscribe(observer8))
  791|      0|
  792|      0|        return Disposables.create([
  793|      0|                subscription1,
  794|      0|                subscription2,
  795|      0|                subscription3,
  796|      0|                subscription4,
  797|      0|                subscription5,
  798|      0|                subscription6,
  799|      0|                subscription7,
  800|      0|                subscription8
  801|      0|        ])
  802|      0|    }
  803|       |
  804|      0|    override func getResult() throws -> R {
  805|      0|        return try self._parent._resultSelector(self._latestElement1, self._latestElement2, self._latestElement3, self._latestElement4, self._latestElement5, self._latestElement6, self._latestElement7, self._latestElement8)
  806|      0|    }
  807|       |}
  808|       |
  809|       |final class CombineLatest8<E1, E2, E3, E4, E5, E6, E7, E8, R> : Producer<R> {
  810|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7, E8) throws -> R
  811|       |
  812|       |    let _source1: Observable<E1>
  813|       |    let _source2: Observable<E2>
  814|       |    let _source3: Observable<E3>
  815|       |    let _source4: Observable<E4>
  816|       |    let _source5: Observable<E5>
  817|       |    let _source6: Observable<E6>
  818|       |    let _source7: Observable<E7>
  819|       |    let _source8: Observable<E8>
  820|       |
  821|       |    let _resultSelector: ResultSelector
  822|       |
  823|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, source8: Observable<E8>, resultSelector: @escaping ResultSelector) {
  824|      0|        self._source1 = source1
  825|      0|        self._source2 = source2
  826|      0|        self._source3 = source3
  827|      0|        self._source4 = source4
  828|      0|        self._source5 = source5
  829|      0|        self._source6 = source6
  830|      0|        self._source7 = source7
  831|      0|        self._source8 = source8
  832|      0|
  833|      0|        self._resultSelector = resultSelector
  834|      0|    }
  835|       |
  836|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  837|      0|        let sink = CombineLatestSink8_(parent: self, observer: observer, cancel: cancel)
  838|      0|        let subscription = sink.run()
  839|      0|        return (sink: sink, subscription: subscription)
  840|      0|    }
  841|       |}
  842|       |
  843|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/CombineLatest.swift:
    1|       |//
    2|       |//  CombineLatest.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol CombineLatestProtocol : class {
   10|       |    func next(_ index: Int)
   11|       |    func fail(_ error: Swift.Error)
   12|       |    func done(_ index: Int)
   13|       |}
   14|       |
   15|       |class CombineLatestSink<O: ObserverType>
   16|       |    : Sink<O>
   17|       |    , CombineLatestProtocol {
   18|       |    typealias Element = O.E
   19|       |   
   20|       |    let _lock = RecursiveLock()
   21|       |
   22|       |    private let _arity: Int
   23|       |    private var _numberOfValues = 0
   24|       |    private var _numberOfDone = 0
   25|       |    private var _hasValue: [Bool]
   26|       |    private var _isDone: [Bool]
   27|       |   
   28|      0|    init(arity: Int, observer: O, cancel: Cancelable) {
   29|      0|        self._arity = arity
   30|      0|        self._hasValue = [Bool](repeating: false, count: arity)
   31|      0|        self._isDone = [Bool](repeating: false, count: arity)
   32|      0|        
   33|      0|        super.init(observer: observer, cancel: cancel)
   34|      0|    }
   35|       |    
   36|      0|    func getResult() throws -> Element {
   37|      0|        rxAbstractMethod()
   38|      0|    }
   39|       |    
   40|      0|    func next(_ index: Int) {
   41|      0|        if !self._hasValue[index] {
   42|      0|            self._hasValue[index] = true
   43|      0|            self._numberOfValues += 1
   44|      0|        }
   45|      0|
   46|      0|        if self._numberOfValues == self._arity {
   47|      0|            do {
   48|      0|                let result = try self.getResult()
   49|      0|                self.forwardOn(.next(result))
   50|      0|            }
   51|      0|            catch let e {
   52|      0|                self.forwardOn(.error(e))
   53|      0|                self.dispose()
   54|      0|            }
   55|      0|        }
   56|      0|        else {
   57|      0|            var allOthersDone = true
   58|      0|
   59|      0|            for i in 0 ..< self._arity {
   60|      0|                if i != index && !self._isDone[i] {
   61|      0|                    allOthersDone = false
   62|      0|                    break
   63|      0|                }
   64|      0|            }
   65|      0|            
   66|      0|            if allOthersDone {
   67|      0|                self.forwardOn(.completed)
   68|      0|                self.dispose()
   69|      0|            }
   70|      0|        }
   71|      0|    }
   72|       |    
   73|      0|    func fail(_ error: Swift.Error) {
   74|      0|        self.forwardOn(.error(error))
   75|      0|        self.dispose()
   76|      0|    }
   77|       |    
   78|      0|    func done(_ index: Int) {
   79|      0|        if self._isDone[index] {
   80|      0|            return
   81|      0|        }
   82|      0|
   83|      0|        self._isDone[index] = true
   84|      0|        self._numberOfDone += 1
   85|      0|
   86|      0|        if self._numberOfDone == self._arity {
   87|      0|            self.forwardOn(.completed)
   88|      0|            self.dispose()
   89|      0|        }
   90|      0|    }
   91|       |}
   92|       |
   93|       |final class CombineLatestObserver<ElementType>
   94|       |    : ObserverType
   95|       |    , LockOwnerType
   96|       |    , SynchronizedOnType {
   97|       |    typealias Element = ElementType
   98|       |    typealias ValueSetter = (Element) -> Void
   99|       |    
  100|       |    private let _parent: CombineLatestProtocol
  101|       |    
  102|       |    let _lock: RecursiveLock
  103|       |    private let _index: Int
  104|       |    private let _this: Disposable
  105|       |    private let _setLatestValue: ValueSetter
  106|       |    
  107|      0|    init(lock: RecursiveLock, parent: CombineLatestProtocol, index: Int, setLatestValue: @escaping ValueSetter, this: Disposable) {
  108|      0|        self._lock = lock
  109|      0|        self._parent = parent
  110|      0|        self._index = index
  111|      0|        self._this = this
  112|      0|        self._setLatestValue = setLatestValue
  113|      0|    }
  114|       |    
  115|      0|    func on(_ event: Event<Element>) {
  116|      0|        self.synchronizedOn(event)
  117|      0|    }
  118|       |
  119|      0|    func _synchronized_on(_ event: Event<Element>) {
  120|      0|        switch event {
  121|      0|        case .next(let value):
  122|      0|            self._setLatestValue(value)
  123|      0|            self._parent.next(self._index)
  124|      0|        case .error(let error):
  125|      0|            self._this.dispose()
  126|      0|            self._parent.fail(error)
  127|      0|        case .completed:
  128|      0|            self._this.dispose()
  129|      0|            self._parent.done(self._index)
  130|      0|        }
  131|      0|    }
  132|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Concat.swift:
    1|       |//
    2|       |//  Concat.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
   13|       |
   14|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   15|       |
   16|       |     - parameter second: Second observable sequence.
   17|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
   18|       |     */
   19|      0|    public func concat<O: ObservableConvertibleType>(_ second: O) -> Observable<E> where O.E == E {
   20|      0|        return Observable.concat([self.asObservable(), second.asObservable()])
   21|      0|    }
   22|       |}
   23|       |
   24|       |extension ObservableType {
   25|       |    /**
   26|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
   27|       |
   28|       |     This operator has tail recursive optimizations that will prevent stack overflow.
   29|       |
   30|       |     Optimizations will be performed in cases equivalent to following:
   31|       |
   32|       |     [1, [2, [3, .....].concat()].concat].concat()
   33|       |
   34|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   35|       |
   36|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
   37|       |     */
   38|       |    public static func concat<S: Sequence >(_ sequence: S) -> Observable<E>
   39|      0|        where S.Iterator.Element == Observable<E> {
   40|      0|            return Concat(sources: sequence, count: nil)
   41|      0|    }
   42|       |
   43|       |    /**
   44|       |     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.
   45|       |
   46|       |     This operator has tail recursive optimizations that will prevent stack overflow.
   47|       |
   48|       |     Optimizations will be performed in cases equivalent to following:
   49|       |
   50|       |     [1, [2, [3, .....].concat()].concat].concat()
   51|       |
   52|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   53|       |
   54|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
   55|       |     */
   56|       |    public static func concat<S: Collection >(_ collection: S) -> Observable<E>
   57|       |        where S.Iterator.Element == Observable<E> {
   58|       |            return Concat(sources: collection, count: Int64(collection.count))
   59|       |    }
   60|       |
   61|       |    /**
   62|       |     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.
   63|       |
   64|       |     This operator has tail recursive optimizations that will prevent stack overflow.
   65|       |
   66|       |     Optimizations will be performed in cases equivalent to following:
   67|       |
   68|       |     [1, [2, [3, .....].concat()].concat].concat()
   69|       |
   70|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   71|       |
   72|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
   73|       |     */
   74|      0|    public static func concat(_ sources: Observable<E> ...) -> Observable<E> {
   75|      0|        return Concat(sources: sources, count: Int64(sources.count))
   76|      0|    }
   77|       |}
   78|       |
   79|       |final private class ConcatSink<S: Sequence, O: ObserverType>
   80|       |    : TailRecursiveSink<S, O>
   81|       |    , ObserverType where S.Iterator.Element: ObservableConvertibleType, S.Iterator.Element.E == O.E {
   82|       |    typealias Element = O.E
   83|       |    
   84|      0|    override init(observer: O, cancel: Cancelable) {
   85|      0|        super.init(observer: observer, cancel: cancel)
   86|      0|    }
   87|       |    
   88|      0|    func on(_ event: Event<Element>){
   89|      0|        switch event {
   90|      0|        case .next:
   91|      0|            self.forwardOn(event)
   92|      0|        case .error:
   93|      0|            self.forwardOn(event)
   94|      0|            self.dispose()
   95|      0|        case .completed:
   96|      0|            self.schedule(.moveNext)
   97|      0|        }
   98|      0|    }
   99|       |
  100|      0|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
  101|      0|        return source.subscribe(self)
  102|      0|    }
  103|       |    
  104|      0|    override func extract(_ observable: Observable<E>) -> SequenceGenerator? {
  105|      0|        if let source = observable as? Concat<S> {
  106|      0|            return (source._sources.makeIterator(), source._count)
  107|      0|        }
  108|      0|        else {
  109|      0|            return nil
  110|      0|        }
  111|      0|    }
  112|       |}
  113|       |
  114|       |final private class Concat<S: Sequence>: Producer<S.Iterator.Element.E> where S.Iterator.Element: ObservableConvertibleType {
  115|       |    typealias Element = S.Iterator.Element.E
  116|       |    
  117|       |    fileprivate let _sources: S
  118|       |    fileprivate let _count: IntMax?
  119|       |
  120|      0|    init(sources: S, count: IntMax?) {
  121|      0|        self._sources = sources
  122|      0|        self._count = count
  123|      0|    }
  124|       |    
  125|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  126|      0|        let sink = ConcatSink<S, O>(observer: observer, cancel: cancel)
  127|      0|        let subscription = sink.run((self._sources.makeIterator(), self._count))
  128|      0|        return (sink: sink, subscription: subscription)
  129|      0|    }
  130|       |}
  131|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Create.swift:
    1|       |//
    2|       |//  Create.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    // MARK: create
   11|       |
   12|       |    /**
   13|       |     Creates an observable sequence from a specified subscribe method implementation.
   14|       |
   15|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   16|       |
   17|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   18|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
   19|       |     */
   20|      0|    public static func create(_ subscribe: @escaping (AnyObserver<E>) -> Disposable) -> Observable<E> {
   21|      0|        return AnonymousObservable(subscribe)
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class AnonymousObservableSink<O: ObserverType>: Sink<O>, ObserverType {
   26|       |    typealias E = O.E
   27|       |    typealias Parent = AnonymousObservable<E>
   28|       |
   29|       |    // state
   30|       |    private let _isStopped = AtomicInt(0)
   31|       |
   32|       |    #if DEBUG
   33|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   34|       |    #endif
   35|       |
   36|      0|    override init(observer: O, cancel: Cancelable) {
   37|      0|        super.init(observer: observer, cancel: cancel)
   38|      0|    }
   39|       |
   40|      0|    func on(_ event: Event<E>) {
   41|      0|        #if DEBUG
   42|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
   43|      0|            defer { self._synchronizationTracker.unregister() }
   44|      0|        #endif
   45|      0|        switch event {
   46|      0|        case .next:
   47|      0|            if load(self._isStopped) == 1 {
   48|      0|                return
   49|      0|            }
   50|      0|            self.forwardOn(event)
   51|      0|        case .error, .completed:
   52|      0|            if fetchOr(self._isStopped, 1) == 0 {
   53|      0|                self.forwardOn(event)
   54|      0|                self.dispose()
   55|      0|            }
   56|      0|        }
   57|      0|    }
   58|       |
   59|      0|    func run(_ parent: Parent) -> Disposable {
   60|      0|        return parent._subscribeHandler(AnyObserver(self))
   61|      0|    }
   62|       |}
   63|       |
   64|       |final private class AnonymousObservable<Element>: Producer<Element> {
   65|       |    typealias SubscribeHandler = (AnyObserver<Element>) -> Disposable
   66|       |
   67|       |    let _subscribeHandler: SubscribeHandler
   68|       |
   69|      0|    init(_ subscribeHandler: @escaping SubscribeHandler) {
   70|      0|        self._subscribeHandler = subscribeHandler
   71|      0|    }
   72|       |
   73|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   74|      0|        let sink = AnonymousObservableSink(observer: observer, cancel: cancel)
   75|      0|        let subscription = sink.run(self)
   76|      0|        return (sink: sink, subscription: subscription)
   77|      0|    }
   78|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Debounce.swift:
    1|       |//
    2|       |//  Debounce.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/11/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Ignores elements from an observable sequence which are followed by another element within a specified relative time duration, using the specified scheduler to run throttling timers.
   13|       |
   14|       |     - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
   15|       |
   16|       |     - parameter dueTime: Throttling duration for each element.
   17|       |     - parameter scheduler: Scheduler to run the throttle timers on.
   18|       |     - returns: The throttled sequence.
   19|       |     */
   20|       |    public func debounce(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   21|      0|        -> Observable<E> {
   22|      0|            return Debounce(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
   23|      0|    }
   24|       |}
   25|       |
   26|       |final private class DebounceSink<O: ObserverType>
   27|       |    : Sink<O>
   28|       |    , ObserverType
   29|       |    , LockOwnerType
   30|       |    , SynchronizedOnType {
   31|       |    typealias Element = O.E
   32|       |    typealias ParentType = Debounce<Element>
   33|       |
   34|       |    private let _parent: ParentType
   35|       |
   36|       |    let _lock = RecursiveLock()
   37|       |
   38|       |    // state
   39|       |    private var _id = 0 as UInt64
   40|       |    private var _value: Element?
   41|       |
   42|       |    let cancellable = SerialDisposable()
   43|       |
   44|      0|    init(parent: ParentType, observer: O, cancel: Cancelable) {
   45|      0|        self._parent = parent
   46|      0|
   47|      0|        super.init(observer: observer, cancel: cancel)
   48|      0|    }
   49|       |
   50|      0|    func run() -> Disposable {
   51|      0|        let subscription = self._parent._source.subscribe(self)
   52|      0|
   53|      0|        return Disposables.create(subscription, cancellable)
   54|      0|    }
   55|       |
   56|      0|    func on(_ event: Event<Element>) {
   57|      0|        self.synchronizedOn(event)
   58|      0|    }
   59|       |
   60|      0|    func _synchronized_on(_ event: Event<Element>) {
   61|      0|        switch event {
   62|      0|        case .next(let element):
   63|      0|            self._id = self._id &+ 1
   64|      0|            let currentId = self._id
   65|      0|            self._value = element
   66|      0|
   67|      0|
   68|      0|            let scheduler = self._parent._scheduler
   69|      0|            let dueTime = self._parent._dueTime
   70|      0|
   71|      0|            let d = SingleAssignmentDisposable()
   72|      0|            self.cancellable.disposable = d
   73|      0|            d.setDisposable(scheduler.scheduleRelative(currentId, dueTime: dueTime, action: self.propagate))
   74|      0|        case .error:
   75|      0|            self._value = nil
   76|      0|            self.forwardOn(event)
   77|      0|            self.dispose()
   78|      0|        case .completed:
   79|      0|            if let value = self._value {
   80|      0|                self._value = nil
   81|      0|                self.forwardOn(.next(value))
   82|      0|            }
   83|      0|            self.forwardOn(.completed)
   84|      0|            self.dispose()
   85|      0|        }
   86|      0|    }
   87|       |
   88|       |    func propagate(_ currentId: UInt64) -> Disposable {
   89|       |        self._lock.lock(); defer { self._lock.unlock() } // {
   90|       |        let originalValue = self._value
   91|       |
   92|       |        if let value = originalValue, self._id == currentId {
   93|       |            self._value = nil
   94|       |            self.forwardOn(.next(value))
   95|       |        }
   96|       |        // }
   97|       |        return Disposables.create()
   98|       |    }
   99|       |}
  100|       |
  101|       |final private class Debounce<Element>: Producer<Element> {
  102|       |    fileprivate let _source: Observable<Element>
  103|       |    fileprivate let _dueTime: RxTimeInterval
  104|       |    fileprivate let _scheduler: SchedulerType
  105|       |
  106|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
  107|      0|        self._source = source
  108|      0|        self._dueTime = dueTime
  109|      0|        self._scheduler = scheduler
  110|      0|    }
  111|       |
  112|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  113|      0|        let sink = DebounceSink(parent: self, observer: observer, cancel: cancel)
  114|      0|        let subscription = sink.run()
  115|      0|        return (sink: sink, subscription: subscription)
  116|      0|    }
  117|       |    
  118|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Debug.swift:
    1|       |//
    2|       |//  Debug.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import class Foundation.DateFormatter
   11|       |
   12|       |extension ObservableType {
   13|       |
   14|       |    /**
   15|       |     Prints received events for all observers on standard output.
   16|       |
   17|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
   18|       |
   19|       |     - parameter identifier: Identifier that is printed together with event description to standard output.
   20|       |     - parameter trimOutput: Should output be trimmed to max 40 characters.
   21|       |     - returns: An observable sequence whose events are printed to standard output.
   22|       |     */
   23|       |    public func debug(_ identifier: String? = nil, trimOutput: Bool = false, file: String = #file, line: UInt = #line, function: String = #function)
   24|      0|        -> Observable<E> {
   25|      0|            return Debug(source: self, identifier: identifier, trimOutput: trimOutput, file: file, line: line, function: function)
   26|      0|    }
   27|       |}
   28|       |
   29|       |fileprivate let dateFormat = "yyyy-MM-dd HH:mm:ss.SSS"
   30|       |
   31|      0|fileprivate func logEvent(_ identifier: String, dateFormat: DateFormatter, content: String) {
   32|      0|    print("\(dateFormat.string(from: Date())): \(identifier) -> \(content)")
   33|      0|}
   34|       |
   35|       |final private class DebugSink<Source: ObservableType, O: ObserverType>: Sink<O>, ObserverType where O.E == Source.E {
   36|       |    typealias Element = O.E
   37|       |    typealias Parent = Debug<Source>
   38|       |    
   39|       |    private let _parent: Parent
   40|       |    private let _timestampFormatter = DateFormatter()
   41|       |    
   42|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   43|      0|        self._parent = parent
   44|      0|        self._timestampFormatter.dateFormat = dateFormat
   45|      0|
   46|      0|        logEvent(self._parent._identifier, dateFormat: self._timestampFormatter, content: "subscribed")
   47|      0|
   48|      0|        super.init(observer: observer, cancel: cancel)
   49|      0|    }
   50|       |    
   51|      0|    func on(_ event: Event<Element>) {
   52|      0|        let maxEventTextLength = 40
   53|      0|        let eventText = "\(event)"
   54|      0|
   55|      0|        let eventNormalized = (eventText.count > maxEventTextLength) && self._parent._trimOutput
   56|      0|            ? String(eventText.prefix(maxEventTextLength / 2)) + "..." + String(eventText.suffix(maxEventTextLength / 2))
   57|      0|            : eventText
   58|      0|
   59|      0|        logEvent(self._parent._identifier, dateFormat: self._timestampFormatter, content: "Event \(eventNormalized)")
   60|      0|
   61|      0|        self.forwardOn(event)
   62|      0|        if event.isStopEvent {
   63|      0|            self.dispose()
   64|      0|        }
   65|      0|    }
   66|       |    
   67|       |    override func dispose() {
   68|       |        if !self.disposed {
   69|       |            logEvent(self._parent._identifier, dateFormat: self._timestampFormatter, content: "isDisposed")
   70|       |        }
   71|       |        super.dispose()
   72|       |    }
   73|       |}
   74|       |
   75|       |final private class Debug<Source: ObservableType>: Producer<Source.E> {
   76|       |    fileprivate let _identifier: String
   77|       |    fileprivate let _trimOutput: Bool
   78|       |    fileprivate let _source: Source
   79|       |
   80|      0|    init(source: Source, identifier: String?, trimOutput: Bool, file: String, line: UInt, function: String) {
   81|      0|        self._trimOutput = trimOutput
   82|      0|        if let identifier = identifier {
   83|      0|            self._identifier = identifier
   84|      0|        }
   85|      0|        else {
   86|      0|            let trimmedFile: String
   87|      0|            if let lastIndex = file.lastIndexOf("/") {
   88|      0|                trimmedFile = String(file[file.index(after: lastIndex) ..< file.endIndex])
   89|      0|            }
   90|      0|            else {
   91|      0|                trimmedFile = file
   92|      0|            }
   93|      0|            self._identifier = "\(trimmedFile):\(line) (\(function))"
   94|      0|        }
   95|      0|        self._source = source
   96|      0|    }
   97|       |    
   98|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Source.E {
   99|      0|        let sink = DebugSink(parent: self, observer: observer, cancel: cancel)
  100|      0|        let subscription = self._source.subscribe(sink)
  101|      0|        return (sink: sink, subscription: subscription)
  102|      0|    }
  103|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/DefaultIfEmpty.swift:
    1|       |//
    2|       |//  DefaultIfEmpty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 23/12/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Emits elements from the source observable sequence, or a default element if the source observable sequence is empty.
   13|       |
   14|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
   15|       |
   16|       |     - parameter default: Default element to be sent if the source does not emit any elements
   17|       |     - returns: An observable sequence which emits default element end completes in case the original sequence is empty
   18|       |     */
   19|      0|    public func ifEmpty(default: E) -> Observable<E> {
   20|      0|        return DefaultIfEmpty(source: self.asObservable(), default: `default`)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class DefaultIfEmptySink<O: ObserverType>: Sink<O>, ObserverType {
   25|       |    typealias E = O.E
   26|       |    private let _default: E
   27|       |    private var _isEmpty = true
   28|       |    
   29|      0|    init(default: E, observer: O, cancel: Cancelable) {
   30|      0|        self._default = `default`
   31|      0|        super.init(observer: observer, cancel: cancel)
   32|      0|    }
   33|       |    
   34|      0|    func on(_ event: Event<E>) {
   35|      0|        switch event {
   36|      0|        case .next:
   37|      0|            self._isEmpty = false
   38|      0|            self.forwardOn(event)
   39|      0|        case .error:
   40|      0|            self.forwardOn(event)
   41|      0|            self.dispose()
   42|      0|        case .completed:
   43|      0|            if self._isEmpty {
   44|      0|                self.forwardOn(.next(self._default))
   45|      0|            }
   46|      0|            self.forwardOn(.completed)
   47|      0|            self.dispose()
   48|      0|        }
   49|      0|    }
   50|       |}
   51|       |
   52|       |final private class DefaultIfEmpty<SourceType>: Producer<SourceType> {
   53|       |    private let _source: Observable<SourceType>
   54|       |    private let _default: SourceType
   55|       |    
   56|      0|    init(source: Observable<SourceType>, `default`: SourceType) {
   57|      0|        self._source = source
   58|      0|        self._default = `default`
   59|      0|    }
   60|       |    
   61|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceType {
   62|      0|        let sink = DefaultIfEmptySink(default: self._default, observer: observer, cancel: cancel)
   63|      0|        let subscription = self._source.subscribe(sink)
   64|      0|        return (sink: sink, subscription: subscription)
   65|      0|    }
   66|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Deferred.swift:
    1|       |//
    2|       |//  Deferred.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
   12|       |
   13|       |     - seealso: [defer operator on reactivex.io](http://reactivex.io/documentation/operators/defer.html)
   14|       |
   15|       |     - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
   16|       |     - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
   17|       |     */
   18|       |    public static func deferred(_ observableFactory: @escaping () throws -> Observable<E>)
   19|      0|        -> Observable<E> {
   20|      0|        return Deferred(observableFactory: observableFactory)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class DeferredSink<S: ObservableType, O: ObserverType>: Sink<O>, ObserverType where S.E == O.E {
   25|       |    typealias E = O.E
   26|       |
   27|       |    private let _observableFactory: () throws -> S
   28|       |
   29|      0|    init(observableFactory: @escaping () throws -> S, observer: O, cancel: Cancelable) {
   30|      0|        self._observableFactory = observableFactory
   31|      0|        super.init(observer: observer, cancel: cancel)
   32|      0|    }
   33|       |    
   34|      0|    func run() -> Disposable {
   35|      0|        do {
   36|      0|            let result = try self._observableFactory()
   37|      0|            return result.subscribe(self)
   38|      0|        }
   39|      0|        catch let e {
   40|      0|            self.forwardOn(.error(e))
   41|      0|            self.dispose()
   42|      0|            return Disposables.create()
   43|      0|        }
   44|      0|    }
   45|       |    
   46|      0|    func on(_ event: Event<E>) {
   47|      0|        self.forwardOn(event)
   48|      0|        
   49|      0|        switch event {
   50|      0|        case .next:
   51|      0|            break
   52|      0|        case .error:
   53|      0|            self.dispose()
   54|      0|        case .completed:
   55|      0|            self.dispose()
   56|      0|        }
   57|      0|    }
   58|       |}
   59|       |
   60|       |final private class Deferred<S: ObservableType>: Producer<S.E> {
   61|       |    typealias Factory = () throws -> S
   62|       |    
   63|       |    private let _observableFactory : Factory
   64|       |    
   65|      0|    init(observableFactory: @escaping Factory) {
   66|      0|        self._observableFactory = observableFactory
   67|      0|    }
   68|       |    
   69|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
   70|      0|        let sink = DeferredSink(observableFactory: self._observableFactory, observer: observer, cancel: cancel)
   71|      0|        let subscription = sink.run()
   72|      0|        return (sink: sink, subscription: subscription)
   73|      0|    }
   74|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Delay.swift:
    1|       |//
    2|       |//  Delay.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by tarunon on 2016/02/09.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |extension ObservableType {
   12|       |
   13|       |    /**
   14|       |     Returns an observable sequence by the source observable sequence shifted forward in time by a specified delay. Error events from the source observable sequence are not delayed.
   15|       |
   16|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
   17|       |
   18|       |     - parameter dueTime: Relative time shift of the source by.
   19|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
   20|       |     - returns: the source Observable shifted in time by the specified delay.
   21|       |     */
   22|       |    public func delay(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   23|      0|        -> Observable<E> {
   24|      0|            return Delay(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
   25|      0|    }
   26|       |}
   27|       |
   28|       |final private class DelaySink<O: ObserverType>
   29|       |    : Sink<O>
   30|       |    , ObserverType {
   31|       |    typealias E = O.E
   32|       |    typealias Source = Observable<E>
   33|       |    typealias DisposeKey = Bag<Disposable>.KeyType
   34|       |    
   35|       |    private let _lock = RecursiveLock()
   36|       |
   37|       |    private let _dueTime: RxTimeInterval
   38|       |    private let _scheduler: SchedulerType
   39|       |    
   40|       |    private let _sourceSubscription = SingleAssignmentDisposable()
   41|       |    private let _cancelable = SerialDisposable()
   42|       |
   43|       |    // is scheduled some action
   44|       |    private var _active = false
   45|       |    // is "run loop" on different scheduler running
   46|       |    private var _running = false
   47|       |    private var _errorEvent: Event<E>?
   48|       |
   49|       |    // state
   50|       |    private var _queue = Queue<(eventTime: RxTime, event: Event<E>)>(capacity: 0)
   51|       |    private var _disposed = false
   52|       |    
   53|      0|    init(observer: O, dueTime: RxTimeInterval, scheduler: SchedulerType, cancel: Cancelable) {
   54|      0|        self._dueTime = dueTime
   55|      0|        self._scheduler = scheduler
   56|      0|        super.init(observer: observer, cancel: cancel)
   57|      0|    }
   58|       |
   59|       |    // All of these complications in this method are caused by the fact that 
   60|       |    // error should be propagated immediately. Error can be potentially received on different
   61|       |    // scheduler so this process needs to be synchronized somehow.
   62|       |    //
   63|       |    // Another complication is that scheduler is potentially concurrent so internal queue is used.
   64|      0|    func drainQueue(state: (), scheduler: AnyRecursiveScheduler<()>) {
   65|      0|
   66|      0|        self._lock.lock()    // {
   67|      0|            let hasFailed = self._errorEvent != nil
   68|      0|            if !hasFailed {
   69|      0|                self._running = true
   70|      0|            }
   71|      0|        self._lock.unlock()  // }
   72|      0|
   73|      0|        if hasFailed {
   74|      0|            return
   75|      0|        }
   76|      0|
   77|      0|        var ranAtLeastOnce = false
   78|      0|
   79|      0|        while true {
   80|      0|            self._lock.lock() // {
   81|      0|                let errorEvent = self._errorEvent
   82|      0|
   83|      0|                let eventToForwardImmediately = ranAtLeastOnce ? nil : self._queue.dequeue()?.event
   84|      0|                let nextEventToScheduleOriginalTime: Date? = ranAtLeastOnce && !self._queue.isEmpty ? self._queue.peek().eventTime : nil
   85|      0|
   86|      0|                if errorEvent == nil {
   87|      0|                    if eventToForwardImmediately != nil {
   88|      0|                    }
   89|      0|                    else if nextEventToScheduleOriginalTime != nil {
   90|      0|                        self._running = false
   91|      0|                    }
   92|      0|                    else {
   93|      0|                        self._running = false
   94|      0|                        self._active = false
   95|      0|                    }
   96|      0|                }
   97|      0|            self._lock.unlock() // {
   98|      0|
   99|      0|            if let errorEvent = errorEvent {
  100|      0|                self.forwardOn(errorEvent)
  101|      0|                self.dispose()
  102|      0|                return
  103|      0|            }
  104|      0|            else {
  105|      0|                if let eventToForwardImmediately = eventToForwardImmediately {
  106|      0|                    ranAtLeastOnce = true
  107|      0|                    self.forwardOn(eventToForwardImmediately)
  108|      0|                    if case .completed = eventToForwardImmediately {
  109|      0|                        self.dispose()
  110|      0|                        return
  111|      0|                    }
  112|      0|                }
  113|      0|                else if let nextEventToScheduleOriginalTime = nextEventToScheduleOriginalTime {
  114|      0|                    let elapsedTime = self._scheduler.now.timeIntervalSince(nextEventToScheduleOriginalTime)
  115|      0|                    let interval = self._dueTime - elapsedTime
  116|      0|                    let normalizedInterval = interval < 0.0 ? 0.0 : interval
  117|      0|                    scheduler.schedule((), dueTime: normalizedInterval)
  118|      0|                    return
  119|      0|                }
  120|      0|                else {
  121|      0|                    return
  122|      0|                }
  123|      0|            }
  124|      0|        }
  125|      0|    }
  126|       |    
  127|      0|    func on(_ event: Event<E>) {
  128|      0|        if event.isStopEvent {
  129|      0|            self._sourceSubscription.dispose()
  130|      0|        }
  131|      0|
  132|      0|        switch event {
  133|      0|        case .error:
  134|      0|            self._lock.lock()    // {
  135|      0|                let shouldSendImmediately = !self._running
  136|      0|                self._queue = Queue(capacity: 0)
  137|      0|                self._errorEvent = event
  138|      0|            self._lock.unlock()  // }
  139|      0|
  140|      0|            if shouldSendImmediately {
  141|      0|                self.forwardOn(event)
  142|      0|                self.dispose()
  143|      0|            }
  144|      0|        default:
  145|      0|            self._lock.lock()    // {
  146|      0|                let shouldSchedule = !self._active
  147|      0|                self._active = true
  148|      0|                self._queue.enqueue((self._scheduler.now, event))
  149|      0|            self._lock.unlock()  // }
  150|      0|
  151|      0|            if shouldSchedule {
  152|      0|                self._cancelable.disposable = self._scheduler.scheduleRecursive((), dueTime: self._dueTime, action: self.drainQueue)
  153|      0|            }
  154|      0|        }
  155|      0|    }
  156|       |    
  157|      0|    func run(source: Observable<E>) -> Disposable {
  158|      0|        self._sourceSubscription.setDisposable(source.subscribe(self))
  159|      0|        return Disposables.create(_sourceSubscription, _cancelable)
  160|      0|    }
  161|       |}
  162|       |
  163|       |final private class Delay<Element>: Producer<Element> {
  164|       |    private let _source: Observable<Element>
  165|       |    private let _dueTime: RxTimeInterval
  166|       |    private let _scheduler: SchedulerType
  167|       |    
  168|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
  169|      0|        self._source = source
  170|      0|        self._dueTime = dueTime
  171|      0|        self._scheduler = scheduler
  172|      0|    }
  173|       |
  174|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  175|      0|        let sink = DelaySink(observer: observer, dueTime: self._dueTime, scheduler: self._scheduler, cancel: cancel)
  176|      0|        let subscription = sink.run(source: self._source)
  177|      0|        return (sink: sink, subscription: subscription)
  178|      0|    }
  179|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/DelaySubscription.swift:
    1|       |//
    2|       |//  DelaySubscription.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
   13|       |
   14|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
   15|       |
   16|       |     - parameter dueTime: Relative time shift of the subscription.
   17|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
   18|       |     - returns: Time-shifted sequence.
   19|       |     */
   20|       |    public func delaySubscription(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   21|      0|        -> Observable<E> {
   22|      0|        return DelaySubscription(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
   23|      0|    }
   24|       |}
   25|       |
   26|       |final private class DelaySubscriptionSink<O: ObserverType>
   27|       |    : Sink<O>, ObserverType {
   28|       |    typealias E = O.E
   29|       |    
   30|      0|    func on(_ event: Event<E>) {
   31|      0|        self.forwardOn(event)
   32|      0|        if event.isStopEvent {
   33|      0|            self.dispose()
   34|      0|        }
   35|      0|    }
   36|       |    
   37|       |}
   38|       |
   39|       |final private class DelaySubscription<Element>: Producer<Element> {
   40|       |    private let _source: Observable<Element>
   41|       |    private let _dueTime: RxTimeInterval
   42|       |    private let _scheduler: SchedulerType
   43|       |    
   44|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
   45|      0|        self._source = source
   46|      0|        self._dueTime = dueTime
   47|      0|        self._scheduler = scheduler
   48|      0|    }
   49|       |    
   50|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   51|      0|        let sink = DelaySubscriptionSink(observer: observer, cancel: cancel)
   52|      0|        let subscription = self._scheduler.scheduleRelative((), dueTime: self._dueTime) { _ in
   53|      0|            return self._source.subscribe(sink)
   54|      0|        }
   55|      0|
   56|      0|        return (sink: sink, subscription: subscription)
   57|      0|    }
   58|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Dematerialize.swift:
    1|       |//
    2|       |//  Dematerialize.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Jamie Pinkham on 3/13/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType where E: EventConvertible {
   10|       |    /**
   11|       |     Convert any previously materialized Observable into it's original form.
   12|       |     - seealso: [materialize operator on reactivex.io](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
   13|       |     - returns: The dematerialized observable sequence.
   14|       |     */
   15|      0|    public func dematerialize() -> Observable<E.ElementType> {
   16|      0|        return Dematerialize(source: self.asObservable())
   17|      0|    }
   18|       |
   19|       |}
   20|       |
   21|       |fileprivate final class DematerializeSink<Element: EventConvertible, O: ObserverType>: Sink<O>, ObserverType where O.E == Element.ElementType {
   22|      0|    fileprivate func on(_ event: Event<Element>) {
   23|      0|        switch event {
   24|      0|        case .next(let element):
   25|      0|            self.forwardOn(element.event)
   26|      0|            if element.event.isStopEvent {
   27|      0|                self.dispose()
   28|      0|            }
   29|      0|        case .completed:
   30|      0|            self.forwardOn(.completed)
   31|      0|            self.dispose()
   32|      0|        case .error(let error):
   33|      0|            self.forwardOn(.error(error))
   34|      0|            self.dispose()
   35|      0|        }
   36|      0|    }
   37|       |}
   38|       |
   39|       |final private class Dematerialize<Element: EventConvertible>: Producer<Element.ElementType> {
   40|       |    private let _source: Observable<Element>
   41|       |    
   42|      0|    init(source: Observable<Element>) {
   43|      0|        self._source = source
   44|      0|    }
   45|       |    
   46|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element.ElementType {
   47|      0|        let sink = DematerializeSink<Element, O>(observer: observer, cancel: cancel)
   48|      0|        let subscription = self._source.subscribe(sink)
   49|      0|        return (sink: sink, subscription: subscription)
   50|      0|    }
   51|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/DistinctUntilChanged.swift:
    1|       |//
    2|       |//  DistinctUntilChanged.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType where E: Equatable {
   10|       |
   11|       |    /**
   12|       |     Returns an observable sequence that contains only distinct contiguous elements according to equality operator.
   13|       |
   14|       |     - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   15|       |
   16|       |     - returns: An observable sequence only containing the distinct contiguous elements, based on equality operator, from the source sequence.
   17|       |     */
   18|       |    public func distinctUntilChanged()
   19|      0|        -> Observable<E> {
   20|      0|            return self.distinctUntilChanged({ $0 }, comparer: { ($0 == $1) })
   21|      0|    }
   22|       |}
   23|       |
   24|       |extension ObservableType {
   25|       |    /**
   26|       |     Returns an observable sequence that contains only distinct contiguous elements according to the `keySelector`.
   27|       |
   28|       |     - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   29|       |
   30|       |     - parameter keySelector: A function to compute the comparison key for each element.
   31|       |     - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
   32|       |     */
   33|       |    public func distinctUntilChanged<K: Equatable>(_ keySelector: @escaping (E) throws -> K)
   34|      0|        -> Observable<E> {
   35|      0|            return self.distinctUntilChanged(keySelector, comparer: { $0 == $1 })
   36|      0|    }
   37|       |
   38|       |    /**
   39|       |     Returns an observable sequence that contains only distinct contiguous elements according to the `comparer`.
   40|       |
   41|       |     - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   42|       |
   43|       |     - parameter comparer: Equality comparer for computed key values.
   44|       |     - returns: An observable sequence only containing the distinct contiguous elements, based on `comparer`, from the source sequence.
   45|       |     */
   46|       |    public func distinctUntilChanged(_ comparer: @escaping (E, E) throws -> Bool)
   47|      0|        -> Observable<E> {
   48|      0|            return self.distinctUntilChanged({ $0 }, comparer: comparer)
   49|      0|    }
   50|       |
   51|       |    /**
   52|       |     Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
   53|       |
   54|       |     - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   55|       |
   56|       |     - parameter keySelector: A function to compute the comparison key for each element.
   57|       |     - parameter comparer: Equality comparer for computed key values.
   58|       |     - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value and the comparer, from the source sequence.
   59|       |     */
   60|       |    public func distinctUntilChanged<K>(_ keySelector: @escaping (E) throws -> K, comparer: @escaping (K, K) throws -> Bool)
   61|       |        -> Observable<E> {
   62|       |            return DistinctUntilChanged(source: self.asObservable(), selector: keySelector, comparer: comparer)
   63|       |    }
   64|       |}
   65|       |
   66|       |final private class DistinctUntilChangedSink<O: ObserverType, Key>: Sink<O>, ObserverType {
   67|       |    typealias E = O.E
   68|       |    
   69|       |    private let _parent: DistinctUntilChanged<E, Key>
   70|       |    private var _currentKey: Key?
   71|       |    
   72|      0|    init(parent: DistinctUntilChanged<E, Key>, observer: O, cancel: Cancelable) {
   73|      0|        self._parent = parent
   74|      0|        super.init(observer: observer, cancel: cancel)
   75|      0|    }
   76|       |    
   77|      0|    func on(_ event: Event<E>) {
   78|      0|        switch event {
   79|      0|        case .next(let value):
   80|      0|            do {
   81|      0|                let key = try self._parent._selector(value)
   82|      0|                var areEqual = false
   83|      0|                if let currentKey = self._currentKey {
   84|      0|                    areEqual = try self._parent._comparer(currentKey, key)
   85|      0|                }
   86|      0|                
   87|      0|                if areEqual {
   88|      0|                    return
   89|      0|                }
   90|      0|                
   91|      0|                self._currentKey = key
   92|      0|                
   93|      0|                self.forwardOn(event)
   94|      0|            }
   95|      0|            catch let error {
   96|      0|                self.forwardOn(.error(error))
   97|      0|                self.dispose()
   98|      0|            }
   99|      0|        case .error, .completed:
  100|      0|            self.forwardOn(event)
  101|      0|            self.dispose()
  102|      0|        }
  103|      0|    }
  104|       |}
  105|       |
  106|       |final private class DistinctUntilChanged<Element, Key>: Producer<Element> {
  107|       |    typealias KeySelector = (Element) throws -> Key
  108|       |    typealias EqualityComparer = (Key, Key) throws -> Bool
  109|       |    
  110|       |    fileprivate let _source: Observable<Element>
  111|       |    fileprivate let _selector: KeySelector
  112|       |    fileprivate let _comparer: EqualityComparer
  113|       |    
  114|      0|    init(source: Observable<Element>, selector: @escaping KeySelector, comparer: @escaping EqualityComparer) {
  115|      0|        self._source = source
  116|      0|        self._selector = selector
  117|      0|        self._comparer = comparer
  118|      0|    }
  119|       |    
  120|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  121|      0|        let sink = DistinctUntilChangedSink(parent: self, observer: observer, cancel: cancel)
  122|      0|        let subscription = self._source.subscribe(sink)
  123|      0|        return (sink: sink, subscription: subscription)
  124|      0|    }
  125|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Do.swift:
    1|       |//
    2|       |//  Do.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
   12|       |
   13|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
   14|       |
   15|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
   16|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   17|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   18|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
   19|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
   20|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
   21|       |     - returns: The source sequence with the side-effecting behavior applied.
   22|       |     */
   23|       |    public func `do`(onNext: ((E) throws -> Void)? = nil, onError: ((Swift.Error) throws -> Void)? = nil, onCompleted: (() throws -> Void)? = nil, onSubscribe: (() -> Void)? = nil, onSubscribed: (() -> Void)? = nil, onDispose: (() -> Void)? = nil)
   24|      0|        -> Observable<E> {
   25|      0|            return Do(source: self.asObservable(), eventHandler: { e in
   26|      0|                switch e {
   27|      0|                case .next(let element):
   28|      0|                    try onNext?(element)
   29|      0|                case .error(let e):
   30|      0|                    try onError?(e)
   31|      0|                case .completed:
   32|      0|                    try onCompleted?()
   33|      0|                }
   34|      0|            }, onSubscribe: onSubscribe, onSubscribed: onSubscribed, onDispose: onDispose)
   35|      0|    }
   36|       |}
   37|       |
   38|       |final private class DoSink<O: ObserverType>: Sink<O>, ObserverType {
   39|       |    typealias Element = O.E
   40|       |    typealias EventHandler = (Event<Element>) throws -> Void
   41|       |    
   42|       |    private let _eventHandler: EventHandler
   43|       |    
   44|      0|    init(eventHandler: @escaping EventHandler, observer: O, cancel: Cancelable) {
   45|      0|        self._eventHandler = eventHandler
   46|      0|        super.init(observer: observer, cancel: cancel)
   47|      0|    }
   48|       |    
   49|      0|    func on(_ event: Event<Element>) {
   50|      0|        do {
   51|      0|            try self._eventHandler(event)
   52|      0|            self.forwardOn(event)
   53|      0|            if event.isStopEvent {
   54|      0|                self.dispose()
   55|      0|            }
   56|      0|        }
   57|      0|        catch let error {
   58|      0|            self.forwardOn(.error(error))
   59|      0|            self.dispose()
   60|      0|        }
   61|      0|    }
   62|       |}
   63|       |
   64|       |final private class Do<Element>: Producer<Element> {
   65|       |    typealias EventHandler = (Event<Element>) throws -> Void
   66|       |    
   67|       |    fileprivate let _source: Observable<Element>
   68|       |    fileprivate let _eventHandler: EventHandler
   69|       |    fileprivate let _onSubscribe: (() -> Void)?
   70|       |    fileprivate let _onSubscribed: (() -> Void)?
   71|       |    fileprivate let _onDispose: (() -> Void)?
   72|       |    
   73|      0|    init(source: Observable<Element>, eventHandler: @escaping EventHandler, onSubscribe: (() -> Void)?, onSubscribed: (() -> Void)?, onDispose: (() -> Void)?) {
   74|      0|        self._source = source
   75|      0|        self._eventHandler = eventHandler
   76|      0|        self._onSubscribe = onSubscribe
   77|      0|        self._onSubscribed = onSubscribed
   78|      0|        self._onDispose = onDispose
   79|      0|    }
   80|       |    
   81|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   82|      0|        self._onSubscribe?()
   83|      0|        let sink = DoSink(eventHandler: self._eventHandler, observer: observer, cancel: cancel)
   84|      0|        let subscription = self._source.subscribe(sink)
   85|      0|        self._onSubscribed?()
   86|      0|        let onDispose = self._onDispose
   87|      0|        let allSubscriptions = Disposables.create {
   88|      0|            subscription.dispose()
   89|      0|            onDispose?()
   90|      0|        }
   91|      0|        return (sink: sink, subscription: allSubscriptions)
   92|      0|    }
   93|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/ElementAt.swift:
    1|       |//
    2|       |//  ElementAt.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 21/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns a sequence emitting only element _n_ emitted by an Observable
   13|       |
   14|       |     - seealso: [elementAt operator on reactivex.io](http://reactivex.io/documentation/operators/elementat.html)
   15|       |
   16|       |     - parameter index: The index of the required element (starting from 0).
   17|       |     - returns: An observable sequence that emits the desired element as its own sole emission.
   18|       |     */
   19|       |    public func elementAt(_ index: Int)
   20|      0|        -> Observable<E> {
   21|      0|        return ElementAt(source: self.asObservable(), index: index, throwOnEmpty: true)
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class ElementAtSink<O: ObserverType>: Sink<O>, ObserverType {
   26|       |    typealias SourceType = O.E
   27|       |    typealias Parent = ElementAt<SourceType>
   28|       |    
   29|       |    let _parent: Parent
   30|       |    var _i: Int
   31|       |    
   32|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   33|      0|        self._parent = parent
   34|      0|        self._i = parent._index
   35|      0|        
   36|      0|        super.init(observer: observer, cancel: cancel)
   37|      0|    }
   38|       |    
   39|      0|    func on(_ event: Event<SourceType>) {
   40|      0|        switch event {
   41|      0|        case .next:
   42|      0|
   43|      0|            if self._i == 0 {
   44|      0|                self.forwardOn(event)
   45|      0|                self.forwardOn(.completed)
   46|      0|                self.dispose()
   47|      0|            }
   48|      0|            
   49|      0|            do {
   50|      0|                _ = try decrementChecked(&self._i)
   51|      0|            } catch let e {
   52|      0|                self.forwardOn(.error(e))
   53|      0|                self.dispose()
   54|      0|                return
   55|      0|            }
   56|      0|            
   57|      0|        case .error(let e):
   58|      0|            self.forwardOn(.error(e))
   59|      0|            self.dispose()
   60|      0|        case .completed:
   61|      0|            if self._parent._throwOnEmpty {
   62|      0|                self.forwardOn(.error(RxError.argumentOutOfRange))
   63|      0|            } else {
   64|      0|                self.forwardOn(.completed)
   65|      0|            }
   66|      0|            
   67|      0|            self.dispose()
   68|      0|        }
   69|      0|    }
   70|       |}
   71|       |
   72|       |final private class ElementAt<SourceType>: Producer<SourceType> {
   73|       |    let _source: Observable<SourceType>
   74|       |    let _throwOnEmpty: Bool
   75|       |    let _index: Int
   76|       |    
   77|      0|    init(source: Observable<SourceType>, index: Int, throwOnEmpty: Bool) {
   78|      0|        if index < 0 {
   79|      0|            rxFatalError("index can't be negative")
   80|      0|        }
   81|      0|
   82|      0|        self._source = source
   83|      0|        self._index = index
   84|      0|        self._throwOnEmpty = throwOnEmpty
   85|      0|    }
   86|       |    
   87|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceType {
   88|      0|        let sink = ElementAtSink(parent: self, observer: observer, cancel: cancel)
   89|      0|        let subscription = self._source.subscribe(sink)
   90|      0|        return (sink: sink, subscription: subscription)
   91|      0|    }
   92|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Empty.swift:
    1|       |//
    2|       |//  Empty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
   12|       |
   13|       |     - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   14|       |
   15|       |     - returns: An observable sequence with no elements.
   16|       |     */
   17|      0|    public static func empty() -> Observable<E> {
   18|      0|        return EmptyProducer<E>()
   19|      0|    }
   20|       |}
   21|       |
   22|       |final private class EmptyProducer<Element>: Producer<Element> {
   23|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   24|      0|        observer.on(.completed)
   25|      0|        return Disposables.create()
   26|      0|    }
   27|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Enumerated.swift:
    1|       |//
    2|       |//  Enumerated.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/6/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Enumerates the elements of an observable sequence.
   13|       |
   14|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
   15|       |
   16|       |     - returns: An observable sequence that contains tuples of source sequence elements and their indexes.
   17|       |     */
   18|       |    public func enumerated()
   19|      0|        -> Observable<(index: Int, element: E)> {
   20|      0|        return Enumerated(source: self.asObservable())
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class EnumeratedSink<Element, O: ObserverType>: Sink<O>, ObserverType where O.E == (index: Int, element: Element) {
   25|       |    typealias E = Element
   26|       |    var index = 0
   27|       |    
   28|      0|    func on(_ event: Event<Element>) {
   29|      0|        switch event {
   30|      0|        case .next(let value):
   31|      0|            do {
   32|      0|                let nextIndex = try incrementChecked(&self.index)
   33|      0|                let next = (index: nextIndex, element: value)
   34|      0|                self.forwardOn(.next(next))
   35|      0|            }
   36|      0|            catch let e {
   37|      0|                self.forwardOn(.error(e))
   38|      0|                self.dispose()
   39|      0|            }
   40|      0|        case .completed:
   41|      0|            self.forwardOn(.completed)
   42|      0|            self.dispose()
   43|      0|        case .error(let error):
   44|      0|            self.forwardOn(.error(error))
   45|      0|            self.dispose()
   46|      0|        }
   47|      0|    }
   48|       |}
   49|       |
   50|       |final private class Enumerated<Element>: Producer<(index: Int, element: Element)> {
   51|       |    private let _source: Observable<Element>
   52|       |
   53|      0|    init(source: Observable<Element>) {
   54|      0|        self._source = source
   55|      0|    }
   56|       |
   57|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == (index: Int, element: Element) {
   58|      0|        let sink = EnumeratedSink<Element, O>(observer: observer, cancel: cancel)
   59|      0|        let subscription = self._source.subscribe(sink)
   60|      0|        return (sink: sink, subscription: subscription)
   61|      0|    }
   62|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Error.swift:
    1|       |//
    2|       |//  Error.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Returns an observable sequence that terminates with an `error`.
   12|       |
   13|       |     - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   14|       |
   15|       |     - returns: The observable sequence that terminates with specified error.
   16|       |     */
   17|      0|    public static func error(_ error: Swift.Error) -> Observable<E> {
   18|      0|        return ErrorProducer(error: error)
   19|      0|    }
   20|       |}
   21|       |
   22|       |final private class ErrorProducer<Element>: Producer<Element> {
   23|       |    private let _error: Swift.Error
   24|       |    
   25|      0|    init(error: Swift.Error) {
   26|      0|        self._error = error
   27|      0|    }
   28|       |    
   29|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   30|      0|        observer.on(.error(self._error))
   31|      0|        return Disposables.create()
   32|      0|    }
   33|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Filter.swift:
    1|       |//
    2|       |//  Filter.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Filters the elements of an observable sequence based on a predicate.
   13|       |
   14|       |     - seealso: [filter operator on reactivex.io](http://reactivex.io/documentation/operators/filter.html)
   15|       |
   16|       |     - parameter predicate: A function to test each source element for a condition.
   17|       |     - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
   18|       |     */
   19|       |    public func filter(_ predicate: @escaping (E) throws -> Bool)
   20|      0|        -> Observable<E> {
   21|      0|        return Filter(source: self.asObservable(), predicate: predicate)
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension ObservableType {
   26|       |
   27|       |    /**
   28|       |     Skips elements and completes (or errors) when the observable sequence completes (or errors). Equivalent to filter that always returns false.
   29|       |
   30|       |     - seealso: [ignoreElements operator on reactivex.io](http://reactivex.io/documentation/operators/ignoreelements.html)
   31|       |
   32|       |     - returns: An observable sequence that skips all elements of the source sequence.
   33|       |     */
   34|       |    public func ignoreElements()
   35|      0|        -> Completable {
   36|      0|            return self.flatMap { _ in
   37|      0|                return Observable<Never>.empty()
   38|      0|            }
   39|      0|            .asCompletable()
   40|      0|    }
   41|       |}
   42|       |
   43|       |final private class FilterSink<O: ObserverType>: Sink<O>, ObserverType {
   44|       |    typealias Predicate = (Element) throws -> Bool
   45|       |    typealias Element = O.E
   46|       |    
   47|       |    private let _predicate: Predicate
   48|       |    
   49|      0|    init(predicate: @escaping Predicate, observer: O, cancel: Cancelable) {
   50|      0|        self._predicate = predicate
   51|      0|        super.init(observer: observer, cancel: cancel)
   52|      0|    }
   53|       |    
   54|      0|    func on(_ event: Event<Element>) {
   55|      0|        switch event {
   56|      0|        case .next(let value):
   57|      0|            do {
   58|      0|                let satisfies = try self._predicate(value)
   59|      0|                if satisfies {
   60|      0|                    self.forwardOn(.next(value))
   61|      0|                }
   62|      0|            }
   63|      0|            catch let e {
   64|      0|                self.forwardOn(.error(e))
   65|      0|                self.dispose()
   66|      0|            }
   67|      0|        case .completed, .error:
   68|      0|            self.forwardOn(event)
   69|      0|            self.dispose()
   70|      0|        }
   71|      0|    }
   72|       |}
   73|       |
   74|       |final private class Filter<Element>: Producer<Element> {
   75|       |    typealias Predicate = (Element) throws -> Bool
   76|       |    
   77|       |    private let _source: Observable<Element>
   78|       |    private let _predicate: Predicate
   79|       |    
   80|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
   81|      0|        self._source = source
   82|      0|        self._predicate = predicate
   83|      0|    }
   84|       |    
   85|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   86|      0|        let sink = FilterSink(predicate: self._predicate, observer: observer, cancel: cancel)
   87|      0|        let subscription = self._source.subscribe(sink)
   88|      0|        return (sink: sink, subscription: subscription)
   89|      0|    }
   90|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/First.swift:
    1|       |//
    2|       |//  First.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/31/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class FirstSink<Element, O: ObserverType> : Sink<O>, ObserverType where O.E == Element? {
   10|       |    typealias E = Element
   11|       |    typealias Parent = First<E>
   12|       |
   13|      0|    func on(_ event: Event<E>) {
   14|      0|        switch event {
   15|      0|        case .next(let value):
   16|      0|            self.forwardOn(.next(value))
   17|      0|            self.forwardOn(.completed)
   18|      0|            self.dispose()
   19|      0|        case .error(let error):
   20|      0|            self.forwardOn(.error(error))
   21|      0|            self.dispose()
   22|      0|        case .completed:
   23|      0|            self.forwardOn(.next(nil))
   24|      0|            self.forwardOn(.completed)
   25|      0|            self.dispose()
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |final class First<Element>: Producer<Element?> {
   31|       |    fileprivate let _source: Observable<Element>
   32|       |
   33|      0|    init(source: Observable<Element>) {
   34|      0|        self._source = source
   35|      0|    }
   36|       |
   37|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element? {
   38|      0|        let sink = FirstSink(observer: observer, cancel: cancel)
   39|      0|        let subscription = self._source.subscribe(sink)
   40|      0|        return (sink: sink, subscription: subscription)
   41|      0|    }
   42|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Generate.swift:
    1|       |//
    2|       |//  Generate.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler
   12|       |     to run the loop send out observer messages.
   13|       |
   14|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   15|       |
   16|       |     - parameter initialState: Initial state.
   17|       |     - parameter condition: Condition to terminate generation (upon returning `false`).
   18|       |     - parameter iterate: Iteration step function.
   19|       |     - parameter scheduler: Scheduler on which to run the generator loop.
   20|       |     - returns: The generated sequence.
   21|       |     */
   22|      0|    public static func generate(initialState: E, condition: @escaping (E) throws -> Bool, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (E) throws -> E) -> Observable<E> {
   23|      0|        return Generate(initialState: initialState, condition: condition, iterate: iterate, resultSelector: { $0 }, scheduler: scheduler)
   24|      0|    }
   25|       |}
   26|       |
   27|       |final private class GenerateSink<S, O: ObserverType>: Sink<O> {
   28|       |    typealias Parent = Generate<S, O.E>
   29|       |    
   30|       |    private let _parent: Parent
   31|       |    
   32|       |    private var _state: S
   33|       |    
   34|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   35|      0|        self._parent = parent
   36|      0|        self._state = parent._initialState
   37|      0|        super.init(observer: observer, cancel: cancel)
   38|      0|    }
   39|       |    
   40|      0|    func run() -> Disposable {
   41|      0|        return self._parent._scheduler.scheduleRecursive(true) { isFirst, recurse -> Void in
   42|      0|            do {
   43|      0|                if !isFirst {
   44|      0|                    self._state = try self._parent._iterate(self._state)
   45|      0|                }
   46|      0|                
   47|      0|                if try self._parent._condition(self._state) {
   48|      0|                    let result = try self._parent._resultSelector(self._state)
   49|      0|                    self.forwardOn(.next(result))
   50|      0|                    
   51|      0|                    recurse(false)
   52|      0|                }
   53|      0|                else {
   54|      0|                    self.forwardOn(.completed)
   55|      0|                    self.dispose()
   56|      0|                }
   57|      0|            }
   58|      0|            catch let error {
   59|      0|                self.forwardOn(.error(error))
   60|      0|                self.dispose()
   61|      0|            }
   62|      0|        }
   63|      0|    }
   64|       |}
   65|       |
   66|       |final private class Generate<S, E>: Producer<E> {
   67|       |    fileprivate let _initialState: S
   68|       |    fileprivate let _condition: (S) throws -> Bool
   69|       |    fileprivate let _iterate: (S) throws -> S
   70|       |    fileprivate let _resultSelector: (S) throws -> E
   71|       |    fileprivate let _scheduler: ImmediateSchedulerType
   72|       |    
   73|      0|    init(initialState: S, condition: @escaping (S) throws -> Bool, iterate: @escaping (S) throws -> S, resultSelector: @escaping (S) throws -> E, scheduler: ImmediateSchedulerType) {
   74|      0|        self._initialState = initialState
   75|      0|        self._condition = condition
   76|      0|        self._iterate = iterate
   77|      0|        self._resultSelector = resultSelector
   78|      0|        self._scheduler = scheduler
   79|      0|        super.init()
   80|      0|    }
   81|       |    
   82|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   83|      0|        let sink = GenerateSink(parent: self, observer: observer, cancel: cancel)
   84|      0|        let subscription = sink.run()
   85|      0|        return (sink: sink, subscription: subscription)
   86|      0|    }
   87|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/GroupBy.swift:
    1|       |//
    2|       |//  GroupBy.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 01/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /*
   11|       |     Groups the elements of an observable sequence according to a specified key selector function.
   12|       |
   13|       |     - seealso: [groupBy operator on reactivex.io](http://reactivex.io/documentation/operators/groupby.html)
   14|       |
   15|       |     - parameter keySelector: A function to extract the key for each element.
   16|       |     - returns: A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
   17|       |     */
   18|       |    public func groupBy<K: Hashable>(keySelector: @escaping (E) throws -> K)
   19|      0|        -> Observable<GroupedObservable<K,E>> {
   20|      0|        return GroupBy(source: self.asObservable(), selector: keySelector)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class GroupedObservableImpl<Element>: Observable<Element> {
   25|       |    private var _subject: PublishSubject<Element>
   26|       |    private var _refCount: RefCountDisposable
   27|       |    
   28|      0|    init(subject: PublishSubject<Element>, refCount: RefCountDisposable) {
   29|      0|        self._subject = subject
   30|      0|        self._refCount = refCount
   31|      0|    }
   32|       |
   33|      0|    override public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   34|      0|        let release = self._refCount.retain()
   35|      0|        let subscription = self._subject.subscribe(observer)
   36|      0|        return Disposables.create(release, subscription)
   37|      0|    }
   38|       |}
   39|       |
   40|       |
   41|       |final private class GroupBySink<Key: Hashable, Element, O: ObserverType>
   42|       |    : Sink<O>
   43|       |    , ObserverType where O.E == GroupedObservable<Key, Element> {
   44|       |    typealias E = Element
   45|       |    typealias ResultType = O.E
   46|       |    typealias Parent = GroupBy<Key, Element>
   47|       |
   48|       |    private let _parent: Parent
   49|       |    private let _subscription = SingleAssignmentDisposable()
   50|       |    private var _refCountDisposable: RefCountDisposable!
   51|       |    private var _groupedSubjectTable: [Key: PublishSubject<Element>]
   52|       |    
   53|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   54|      0|        self._parent = parent
   55|      0|        self._groupedSubjectTable = [Key: PublishSubject<Element>]()
   56|      0|        super.init(observer: observer, cancel: cancel)
   57|      0|    }
   58|       |    
   59|      0|    func run() -> Disposable {
   60|      0|        self._refCountDisposable = RefCountDisposable(disposable: self._subscription)
   61|      0|        
   62|      0|        self._subscription.setDisposable(self._parent._source.subscribe(self))
   63|      0|        
   64|      0|        return self._refCountDisposable
   65|      0|    }
   66|       |    
   67|      0|    private func onGroupEvent(key: Key, value: Element) {
   68|      0|        if let writer = self._groupedSubjectTable[key] {
   69|      0|            writer.on(.next(value))
   70|      0|        } else {
   71|      0|            let writer = PublishSubject<Element>()
   72|      0|            self._groupedSubjectTable[key] = writer
   73|      0|            
   74|      0|            let group = GroupedObservable(
   75|      0|                key: key,
   76|      0|                source: GroupedObservableImpl(subject: writer, refCount: _refCountDisposable)
   77|      0|            )
   78|      0|            
   79|      0|            self.forwardOn(.next(group))
   80|      0|            writer.on(.next(value))
   81|      0|        }
   82|      0|    }
   83|       |
   84|      0|    final func on(_ event: Event<Element>) {
   85|      0|        switch event {
   86|      0|        case let .next(value):
   87|      0|            do {
   88|      0|                let groupKey = try self._parent._selector(value)
   89|      0|                self.onGroupEvent(key: groupKey, value: value)
   90|      0|            }
   91|      0|            catch let e {
   92|      0|                self.error(e)
   93|      0|                return
   94|      0|            }
   95|      0|        case let .error(e):
   96|      0|            self.error(e)
   97|      0|        case .completed:
   98|      0|            self.forwardOnGroups(event: .completed)
   99|      0|            self.forwardOn(.completed)
  100|      0|            self._subscription.dispose()
  101|      0|            self.dispose()
  102|      0|        }
  103|      0|    }
  104|       |
  105|       |    final func error(_ error: Swift.Error) {
  106|       |        self.forwardOnGroups(event: .error(error))
  107|       |        self.forwardOn(.error(error))
  108|       |        self._subscription.dispose()
  109|       |        self.dispose()
  110|       |    }
  111|       |    
  112|       |    final func forwardOnGroups(event: Event<Element>) {
  113|       |        for writer in self._groupedSubjectTable.values {
  114|       |            writer.on(event)
  115|       |        }
  116|       |    }
  117|       |}
  118|       |
  119|       |final private class GroupBy<Key: Hashable, Element>: Producer<GroupedObservable<Key,Element>> {
  120|       |    typealias KeySelector = (Element) throws -> Key
  121|       |
  122|       |    fileprivate let _source: Observable<Element>
  123|       |    fileprivate let _selector: KeySelector
  124|       |    
  125|      0|    init(source: Observable<Element>, selector: @escaping KeySelector) {
  126|      0|        self._source = source
  127|      0|        self._selector = selector
  128|      0|    }
  129|       |
  130|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == GroupedObservable<Key,Element> {
  131|      0|        let sink = GroupBySink(parent: self, observer: observer, cancel: cancel)
  132|      0|        return (sink: sink, subscription: sink.run())
  133|      0|    }
  134|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Just.swift:
    1|       |//
    2|       |//  Just.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Returns an observable sequence that contains a single element.
   12|       |
   13|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
   14|       |
   15|       |     - parameter element: Single element in the resulting observable sequence.
   16|       |     - returns: An observable sequence containing the single specified element.
   17|       |     */
   18|      0|    public static func just(_ element: E) -> Observable<E> {
   19|      0|        return Just(element: element)
   20|      0|    }
   21|       |
   22|       |    /**
   23|       |     Returns an observable sequence that contains a single element.
   24|       |
   25|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
   26|       |
   27|       |     - parameter element: Single element in the resulting observable sequence.
   28|       |     - parameter scheduler: Scheduler to send the single element on.
   29|       |     - returns: An observable sequence containing the single specified element.
   30|       |     */
   31|      0|    public static func just(_ element: E, scheduler: ImmediateSchedulerType) -> Observable<E> {
   32|      0|        return JustScheduled(element: element, scheduler: scheduler)
   33|      0|    }
   34|       |}
   35|       |
   36|       |final private class JustScheduledSink<O: ObserverType>: Sink<O> {
   37|       |    typealias Parent = JustScheduled<O.E>
   38|       |
   39|       |    private let _parent: Parent
   40|       |
   41|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   42|      0|        self._parent = parent
   43|      0|        super.init(observer: observer, cancel: cancel)
   44|      0|    }
   45|       |
   46|      0|    func run() -> Disposable {
   47|      0|        let scheduler = self._parent._scheduler
   48|      0|        return scheduler.schedule(self._parent._element) { element in
   49|      0|            self.forwardOn(.next(element))
   50|      0|            return scheduler.schedule(()) { _ in
   51|      0|                self.forwardOn(.completed)
   52|      0|                self.dispose()
   53|      0|                return Disposables.create()
   54|      0|            }
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|       |final private class JustScheduled<Element>: Producer<Element> {
   60|       |    fileprivate let _scheduler: ImmediateSchedulerType
   61|       |    fileprivate let _element: Element
   62|       |
   63|      0|    init(element: Element, scheduler: ImmediateSchedulerType) {
   64|      0|        self._scheduler = scheduler
   65|      0|        self._element = element
   66|      0|    }
   67|       |
   68|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   69|      0|        let sink = JustScheduledSink(parent: self, observer: observer, cancel: cancel)
   70|      0|        let subscription = sink.run()
   71|      0|        return (sink: sink, subscription: subscription)
   72|      0|    }
   73|       |}
   74|       |
   75|       |final private class Just<Element>: Producer<Element> {
   76|       |    private let _element: Element
   77|       |    
   78|      0|    init(element: Element) {
   79|      0|        self._element = element
   80|      0|    }
   81|       |    
   82|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   83|      0|        observer.on(.next(self._element))
   84|      0|        observer.on(.completed)
   85|      0|        return Disposables.create()
   86|      0|    }
   87|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Map.swift:
    1|       |//
    2|       |//  Map.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Projects each element of an observable sequence into a new form.
   13|       |
   14|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
   15|       |
   16|       |     - parameter transform: A transform function to apply to each source element.
   17|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
   18|       |
   19|       |     */
   20|       |    public func map<R>(_ transform: @escaping (E) throws -> R)
   21|      0|        -> Observable<R> {
   22|      0|        return self.asObservable().composeMap(transform)
   23|      0|    }
   24|       |}
   25|       |
   26|       |final private class MapSink<SourceType, O: ObserverType>: Sink<O>, ObserverType {
   27|       |    typealias Transform = (SourceType) throws -> ResultType
   28|       |
   29|       |    typealias ResultType = O.E
   30|       |    typealias Element = SourceType
   31|       |
   32|       |    private let _transform: Transform
   33|       |
   34|      0|    init(transform: @escaping Transform, observer: O, cancel: Cancelable) {
   35|      0|        self._transform = transform
   36|      0|        super.init(observer: observer, cancel: cancel)
   37|      0|    }
   38|       |
   39|      0|    func on(_ event: Event<SourceType>) {
   40|      0|        switch event {
   41|      0|        case .next(let element):
   42|      0|            do {
   43|      0|                let mappedElement = try self._transform(element)
   44|      0|                self.forwardOn(.next(mappedElement))
   45|      0|            }
   46|      0|            catch let e {
   47|      0|                self.forwardOn(.error(e))
   48|      0|                self.dispose()
   49|      0|            }
   50|      0|        case .error(let error):
   51|      0|            self.forwardOn(.error(error))
   52|      0|            self.dispose()
   53|      0|        case .completed:
   54|      0|            self.forwardOn(.completed)
   55|      0|            self.dispose()
   56|      0|        }
   57|      0|    }
   58|       |}
   59|       |
   60|       |#if TRACE_RESOURCES
   61|       |    fileprivate let _numberOfMapOperators = AtomicInt(0)
   62|       |    extension Resources {
   63|       |        public static var numberOfMapOperators: Int32 {
   64|       |            return load(_numberOfMapOperators)
   65|       |        }
   66|       |    }
   67|       |#endif
   68|       |
   69|      0|internal func _map<Element, R>(source: Observable<Element>, transform: @escaping (Element) throws -> R) -> Observable<R> {
   70|      0|    return Map(source: source, transform: transform)
   71|      0|}
   72|       |
   73|       |final private class Map<SourceType, ResultType>: Producer<ResultType> {
   74|       |    typealias Transform = (SourceType) throws -> ResultType
   75|       |
   76|       |    private let _source: Observable<SourceType>
   77|       |
   78|       |    private let _transform: Transform
   79|       |
   80|      0|    init(source: Observable<SourceType>, transform: @escaping Transform) {
   81|      0|        self._source = source
   82|      0|        self._transform = transform
   83|      0|
   84|      0|#if TRACE_RESOURCES
   85|      0|        _ = increment(_numberOfMapOperators)
   86|      0|#endif
   87|      0|    }
   88|       |
   89|      0|    override func composeMap<R>(_ selector: @escaping (ResultType) throws -> R) -> Observable<R> {
   90|      0|        let originalSelector = self._transform
   91|      0|        return Map<SourceType, R>(source: self._source, transform: { (s: SourceType) throws -> R in
   92|      0|            let r: ResultType = try originalSelector(s)
   93|      0|            return try selector(r)
   94|      0|        })
   95|      0|    }
   96|       |
   97|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
   98|      0|        let sink = MapSink(transform: self._transform, observer: observer, cancel: cancel)
   99|      0|        let subscription = self._source.subscribe(sink)
  100|      0|        return (sink: sink, subscription: subscription)
  101|      0|    }
  102|       |
  103|       |    #if TRACE_RESOURCES
  104|       |    deinit {
  105|       |        _ = decrement(_numberOfMapOperators)
  106|       |    }
  107|       |    #endif
  108|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Materialize.swift:
    1|       |//
    2|       |//  Materialize.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 08/03/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Convert any Observable into an Observable of its events.
   12|       |     - seealso: [materialize operator on reactivex.io](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
   13|       |     - returns: An observable sequence that wraps events in an Event<E>. The returned Observable never errors, but it does complete after observing all of the events of the underlying Observable.
   14|       |     */
   15|      0|    public func materialize() -> Observable<Event<E>> {
   16|      0|        return Materialize(source: self.asObservable())
   17|      0|    }
   18|       |}
   19|       |
   20|       |fileprivate final class MaterializeSink<Element, O: ObserverType>: Sink<O>, ObserverType where O.E == Event<Element> {
   21|       |    
   22|      0|    func on(_ event: Event<Element>) {
   23|      0|        self.forwardOn(.next(event))
   24|      0|        if event.isStopEvent {
   25|      0|            self.forwardOn(.completed)
   26|      0|            self.dispose()
   27|      0|        }
   28|      0|    }
   29|       |}
   30|       |
   31|       |final private class Materialize<Element>: Producer<Event<Element>> {
   32|       |    private let _source: Observable<Element>
   33|       |    
   34|      0|    init(source: Observable<Element>) {
   35|      0|        self._source = source
   36|      0|    }
   37|       |
   38|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   39|      0|        let sink = MaterializeSink(observer: observer, cancel: cancel)
   40|      0|        let subscription = self._source.subscribe(sink)
   41|      0|
   42|      0|        return (sink: sink, subscription: subscription)
   43|      0|    }
   44|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Merge.swift:
    1|       |//
    2|       |//  Merge.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   13|       |
   14|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
   15|       |
   16|       |     - parameter selector: A transform function to apply to each element.
   17|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
   18|       |     */
   19|       |    public func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
   20|      0|        -> Observable<O.E> {
   21|      0|            return FlatMap(source: self.asObservable(), selector: selector)
   22|      0|    }
   23|       |
   24|       |}
   25|       |
   26|       |extension ObservableType {
   27|       |
   28|       |    /**
   29|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   30|       |     If element is received while there is some projected observable sequence being merged it will simply be ignored.
   31|       |
   32|       |     - seealso: [flatMapFirst operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
   33|       |
   34|       |     - parameter selector: A transform function to apply to element that was observed while no observable is executing in parallel.
   35|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence that was received while no other sequence was being calculated.
   36|       |     */
   37|       |    public func flatMapFirst<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
   38|      0|        -> Observable<O.E> {
   39|      0|            return FlatMapFirst(source: self.asObservable(), selector: selector)
   40|      0|    }
   41|       |}
   42|       |
   43|       |extension ObservableType where E : ObservableConvertibleType {
   44|       |
   45|       |    /**
   46|       |     Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.
   47|       |
   48|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
   49|       |
   50|       |     - returns: The observable sequence that merges the elements of the observable sequences.
   51|       |     */
   52|      0|    public func merge() -> Observable<E.E> {
   53|      0|        return Merge(source: self.asObservable())
   54|      0|    }
   55|       |
   56|       |    /**
   57|       |     Merges elements from all inner observable sequences into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
   58|       |
   59|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
   60|       |
   61|       |     - parameter maxConcurrent: Maximum number of inner observable sequences being subscribed to concurrently.
   62|       |     - returns: The observable sequence that merges the elements of the inner sequences.
   63|       |     */
   64|       |    public func merge(maxConcurrent: Int)
   65|      0|        -> Observable<E.E> {
   66|      0|        return MergeLimited(source: self.asObservable(), maxConcurrent: maxConcurrent)
   67|      0|    }
   68|       |}
   69|       |
   70|       |extension ObservableType where E : ObservableConvertibleType {
   71|       |
   72|       |    /**
   73|       |     Concatenates all inner observable sequences, as long as the previous observable sequence terminated successfully.
   74|       |
   75|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   76|       |
   77|       |     - returns: An observable sequence that contains the elements of each observed inner sequence, in sequential order.
   78|       |     */
   79|      0|    public func concat() -> Observable<E.E> {
   80|      0|        return self.merge(maxConcurrent: 1)
   81|      0|    }
   82|       |}
   83|       |
   84|       |extension ObservableType {
   85|       |    /**
   86|       |     Merges elements from all observable sequences from collection into a single observable sequence.
   87|       |
   88|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
   89|       |
   90|       |     - parameter sources: Collection of observable sequences to merge.
   91|       |     - returns: The observable sequence that merges the elements of the observable sequences.
   92|       |     */
   93|      0|    public static func merge<C: Collection>(_ sources: C) -> Observable<E> where C.Iterator.Element == Observable<E> {
   94|      0|        return MergeArray(sources: Array(sources))
   95|      0|    }
   96|       |
   97|       |    /**
   98|       |     Merges elements from all observable sequences from array into a single observable sequence.
   99|       |
  100|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  101|       |
  102|       |     - parameter sources: Array of observable sequences to merge.
  103|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  104|       |     */
  105|      0|    public static func merge(_ sources: [Observable<E>]) -> Observable<E> {
  106|      0|        return MergeArray(sources: sources)
  107|      0|    }
  108|       |
  109|       |    /**
  110|       |     Merges elements from all observable sequences into a single observable sequence.
  111|       |
  112|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  113|       |
  114|       |     - parameter sources: Collection of observable sequences to merge.
  115|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  116|       |     */
  117|      0|    public static func merge(_ sources: Observable<E>...) -> Observable<E> {
  118|      0|        return MergeArray(sources: sources)
  119|      0|    }
  120|       |}
  121|       |
  122|       |// MARK: concatMap
  123|       |
  124|       |extension ObservableType {
  125|       |    /**
  126|       |     Projects each element of an observable sequence to an observable sequence and concatenates the resulting observable sequences into one observable sequence.
  127|       |     
  128|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  129|       |     
  130|       |     - returns: An observable sequence that contains the elements of each observed inner sequence, in sequential order.
  131|       |     */
  132|       |    
  133|       |    public func concatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
  134|      0|        -> Observable<O.E> {
  135|      0|            return ConcatMap(source: self.asObservable(), selector: selector)
  136|      0|    }
  137|       |}
  138|       |
  139|       |fileprivate final class MergeLimitedSinkIter<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType>
  140|       |    : ObserverType
  141|       |    , LockOwnerType
  142|       |    , SynchronizedOnType where SourceSequence.E == Observer.E {
  143|       |    typealias E = Observer.E
  144|       |    typealias DisposeKey = CompositeDisposable.DisposeKey
  145|       |    typealias Parent = MergeLimitedSink<SourceElement, SourceSequence, Observer>
  146|       |    
  147|       |    private let _parent: Parent
  148|       |    private let _disposeKey: DisposeKey
  149|       |
  150|      0|    var _lock: RecursiveLock {
  151|      0|        return self._parent._lock
  152|      0|    }
  153|       |    
  154|      0|    init(parent: Parent, disposeKey: DisposeKey) {
  155|      0|        self._parent = parent
  156|      0|        self._disposeKey = disposeKey
  157|      0|    }
  158|       |    
  159|      0|    func on(_ event: Event<E>) {
  160|      0|        self.synchronizedOn(event)
  161|      0|    }
  162|       |
  163|      0|    func _synchronized_on(_ event: Event<E>) {
  164|      0|        switch event {
  165|      0|        case .next:
  166|      0|            self._parent.forwardOn(event)
  167|      0|        case .error:
  168|      0|            self._parent.forwardOn(event)
  169|      0|            self._parent.dispose()
  170|      0|        case .completed:
  171|      0|            self._parent._group.remove(for: self._disposeKey)
  172|      0|            if let next = self._parent._queue.dequeue() {
  173|      0|                self._parent.subscribe(next, group: self._parent._group)
  174|      0|            }
  175|      0|            else {
  176|      0|                self._parent._activeCount -= 1
  177|      0|                
  178|      0|                if self._parent._stopped && self._parent._activeCount == 0 {
  179|      0|                    self._parent.forwardOn(.completed)
  180|      0|                    self._parent.dispose()
  181|      0|                }
  182|      0|            }
  183|      0|        }
  184|      0|    }
  185|       |}
  186|       |
  187|       |fileprivate final class ConcatMapSink<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType>: MergeLimitedSink<SourceElement, SourceSequence, Observer> where Observer.E == SourceSequence.E {
  188|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  189|       |    
  190|       |    private let _selector: Selector
  191|       |    
  192|      0|    init(selector: @escaping Selector, observer: Observer, cancel: Cancelable) {
  193|      0|        self._selector = selector
  194|      0|        super.init(maxConcurrent: 1, observer: observer, cancel: cancel)
  195|      0|    }
  196|       |    
  197|      0|    override func performMap(_ element: SourceElement) throws -> SourceSequence {
  198|      0|        return try self._selector(element)
  199|      0|    }
  200|       |}
  201|       |
  202|       |fileprivate final class MergeLimitedBasicSink<SourceSequence: ObservableConvertibleType, Observer: ObserverType>: MergeLimitedSink<SourceSequence, SourceSequence, Observer> where Observer.E == SourceSequence.E {
  203|       |    
  204|      0|    override func performMap(_ element: SourceSequence) throws -> SourceSequence {
  205|      0|        return element
  206|      0|    }
  207|       |}
  208|       |
  209|       |private class MergeLimitedSink<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType>
  210|       |    : Sink<Observer>
  211|       |    , ObserverType where Observer.E == SourceSequence.E {
  212|       |    typealias QueueType = Queue<SourceSequence>
  213|       |
  214|       |    let _maxConcurrent: Int
  215|       |
  216|       |    let _lock = RecursiveLock()
  217|       |
  218|       |    // state
  219|       |    var _stopped = false
  220|       |    var _activeCount = 0
  221|       |    var _queue = QueueType(capacity: 2)
  222|       |    
  223|       |    let _sourceSubscription = SingleAssignmentDisposable()
  224|       |    let _group = CompositeDisposable()
  225|       |    
  226|      0|    init(maxConcurrent: Int, observer: Observer, cancel: Cancelable) {
  227|      0|        self._maxConcurrent = maxConcurrent
  228|      0|        super.init(observer: observer, cancel: cancel)
  229|      0|    }
  230|       |    
  231|       |    func run(_ source: Observable<SourceElement>) -> Disposable {
  232|       |        _ = self._group.insert(self._sourceSubscription)
  233|       |        
  234|       |        let disposable = source.subscribe(self)
  235|       |        self._sourceSubscription.setDisposable(disposable)
  236|       |        return self._group
  237|       |    }
  238|       |    
  239|       |    func subscribe(_ innerSource: SourceSequence, group: CompositeDisposable) {
  240|       |        let subscription = SingleAssignmentDisposable()
  241|       |        
  242|       |        let key = group.insert(subscription)
  243|       |        
  244|       |        if let key = key {
  245|       |            let observer = MergeLimitedSinkIter(parent: self, disposeKey: key)
  246|       |            
  247|       |            let disposable = innerSource.asObservable().subscribe(observer)
  248|       |            subscription.setDisposable(disposable)
  249|       |        }
  250|       |    }
  251|       |    
  252|      0|    func performMap(_ element: SourceElement) throws -> SourceSequence {
  253|      0|        rxAbstractMethod()
  254|      0|    }
  255|       |
  256|       |    @inline(__always)
  257|      0|    final private func nextElementArrived(element: SourceElement) -> SourceSequence? {
  258|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
  259|      0|            let subscribe: Bool
  260|      0|            if self._activeCount < self._maxConcurrent {
  261|      0|                self._activeCount += 1
  262|      0|                subscribe = true
  263|      0|            }
  264|      0|            else {
  265|      0|                do {
  266|      0|                    let value = try self.performMap(element)
  267|      0|                    self._queue.enqueue(value)
  268|      0|                } catch {
  269|      0|                    self.forwardOn(.error(error))
  270|      0|                    self.dispose()
  271|      0|                }
  272|      0|                subscribe = false
  273|      0|            }
  274|      0|
  275|      0|            if subscribe {
  276|      0|                do {
  277|      0|                    return try self.performMap(element)
  278|      0|                } catch {
  279|      0|                    self.forwardOn(.error(error))
  280|      0|                    self.dispose()
  281|      0|                }
  282|      0|            }
  283|      0|
  284|      0|            return nil
  285|      0|        // }
  286|      0|    }
  287|       |
  288|       |    func on(_ event: Event<SourceElement>) {
  289|       |        switch event {
  290|       |        case .next(let element):
  291|       |            if let sequence = self.nextElementArrived(element: element) {
  292|       |                self.subscribe(sequence, group: self._group)
  293|       |            }
  294|       |        case .error(let error):
  295|       |            self._lock.lock(); defer { self._lock.unlock() }
  296|       |
  297|       |            self.forwardOn(.error(error))
  298|       |            self.dispose()
  299|       |        case .completed:
  300|       |            self._lock.lock(); defer { self._lock.unlock() }
  301|       |
  302|       |            if self._activeCount == 0 {
  303|       |                self.forwardOn(.completed)
  304|       |                self.dispose()
  305|       |            }
  306|       |            else {
  307|       |                self._sourceSubscription.dispose()
  308|       |            }
  309|       |
  310|       |            self._stopped = true
  311|       |        }
  312|       |    }
  313|       |}
  314|       |
  315|       |final private class MergeLimited<SourceSequence: ObservableConvertibleType>: Producer<SourceSequence.E> {
  316|       |    private let _source: Observable<SourceSequence>
  317|       |    private let _maxConcurrent: Int
  318|       |    
  319|      0|    init(source: Observable<SourceSequence>, maxConcurrent: Int) {
  320|      0|        self._source = source
  321|      0|        self._maxConcurrent = maxConcurrent
  322|      0|    }
  323|       |    
  324|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceSequence.E {
  325|      0|        let sink = MergeLimitedBasicSink<SourceSequence, O>(maxConcurrent: self._maxConcurrent, observer: observer, cancel: cancel)
  326|      0|        let subscription = sink.run(self._source)
  327|      0|        return (sink: sink, subscription: subscription)
  328|      0|    }
  329|       |}
  330|       |
  331|       |// MARK: Merge
  332|       |
  333|       |fileprivate final class MergeBasicSink<S: ObservableConvertibleType, O: ObserverType> : MergeSink<S, S, O> where O.E == S.E {
  334|      0|    override func performMap(_ element: S) throws -> S {
  335|      0|        return element
  336|      0|    }
  337|       |}
  338|       |
  339|       |// MARK: flatMap
  340|       |
  341|       |fileprivate final class FlatMapSink<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType> : MergeSink<SourceElement, SourceSequence, Observer> where Observer.E == SourceSequence.E {
  342|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  343|       |
  344|       |    private let _selector: Selector
  345|       |
  346|      0|    init(selector: @escaping Selector, observer: Observer, cancel: Cancelable) {
  347|      0|        self._selector = selector
  348|      0|        super.init(observer: observer, cancel: cancel)
  349|      0|    }
  350|       |
  351|      0|    override func performMap(_ element: SourceElement) throws -> SourceSequence {
  352|      0|        return try self._selector(element)
  353|      0|    }
  354|       |}
  355|       |
  356|       |// MARK: FlatMapFirst
  357|       |
  358|       |fileprivate final class FlatMapFirstSink<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType> : MergeSink<SourceElement, SourceSequence, Observer> where Observer.E == SourceSequence.E {
  359|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  360|       |
  361|       |    private let _selector: Selector
  362|       |
  363|      0|    override var subscribeNext: Bool {
  364|      0|        return self._activeCount == 0
  365|      0|    }
  366|       |
  367|      0|    init(selector: @escaping Selector, observer: Observer, cancel: Cancelable) {
  368|      0|        self._selector = selector
  369|      0|        super.init(observer: observer, cancel: cancel)
  370|      0|    }
  371|       |
  372|      0|    override func performMap(_ element: SourceElement) throws -> SourceSequence {
  373|      0|        return try self._selector(element)
  374|      0|    }
  375|       |}
  376|       |
  377|       |fileprivate final class MergeSinkIter<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType> : ObserverType where Observer.E == SourceSequence.E {
  378|       |    typealias Parent = MergeSink<SourceElement, SourceSequence, Observer>
  379|       |    typealias DisposeKey = CompositeDisposable.DisposeKey
  380|       |    typealias E = Observer.E
  381|       |    
  382|       |    private let _parent: Parent
  383|       |    private let _disposeKey: DisposeKey
  384|       |
  385|      0|    init(parent: Parent, disposeKey: DisposeKey) {
  386|      0|        self._parent = parent
  387|      0|        self._disposeKey = disposeKey
  388|      0|    }
  389|       |    
  390|      0|    func on(_ event: Event<E>) {
  391|      0|        self._parent._lock.lock(); defer { self._parent._lock.unlock() } // lock {
  392|      0|            switch event {
  393|      0|            case .next(let value):
  394|      0|                self._parent.forwardOn(.next(value))
  395|      0|            case .error(let error):
  396|      0|                self._parent.forwardOn(.error(error))
  397|      0|                self._parent.dispose()
  398|      0|            case .completed:
  399|      0|                self._parent._group.remove(for: self._disposeKey)
  400|      0|                self._parent._activeCount -= 1
  401|      0|                self._parent.checkCompleted()
  402|      0|            }
  403|      0|        // }
  404|      0|    }
  405|       |}
  406|       |
  407|       |
  408|       |private class MergeSink<SourceElement, SourceSequence: ObservableConvertibleType, Observer: ObserverType>
  409|       |    : Sink<Observer>
  410|       |    , ObserverType where Observer.E == SourceSequence.E {
  411|       |    typealias ResultType = Observer.E
  412|       |    typealias Element = SourceElement
  413|       |
  414|       |    let _lock = RecursiveLock()
  415|       |
  416|       |    var subscribeNext: Bool {
  417|       |        return true
  418|       |    }
  419|       |
  420|       |    // state
  421|       |    let _group = CompositeDisposable()
  422|       |    let _sourceSubscription = SingleAssignmentDisposable()
  423|       |
  424|       |    var _activeCount = 0
  425|       |    var _stopped = false
  426|       |
  427|      0|    override init(observer: Observer, cancel: Cancelable) {
  428|      0|        super.init(observer: observer, cancel: cancel)
  429|      0|    }
  430|       |
  431|      0|    func performMap(_ element: SourceElement) throws -> SourceSequence {
  432|      0|        rxAbstractMethod()
  433|      0|    }
  434|       |
  435|       |    @inline(__always)
  436|      0|    final private func nextElementArrived(element: SourceElement) -> SourceSequence? {
  437|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
  438|      0|            if !self.subscribeNext {
  439|      0|                return nil
  440|      0|            }
  441|      0|
  442|      0|            do {
  443|      0|                let value = try self.performMap(element)
  444|      0|                self._activeCount += 1
  445|      0|                return value
  446|      0|            }
  447|      0|            catch let e {
  448|      0|                self.forwardOn(.error(e))
  449|      0|                self.dispose()
  450|      0|                return nil
  451|      0|            }
  452|      0|        // }
  453|      0|    }
  454|       |    
  455|       |    func on(_ event: Event<SourceElement>) {
  456|       |        switch event {
  457|       |        case .next(let element):
  458|       |            if let value = self.nextElementArrived(element: element) {
  459|       |                self.subscribeInner(value.asObservable())
  460|       |            }
  461|       |        case .error(let error):
  462|       |            self._lock.lock(); defer { self._lock.unlock() }
  463|       |            self.forwardOn(.error(error))
  464|       |            self.dispose()
  465|       |        case .completed:
  466|       |            self._lock.lock(); defer { self._lock.unlock() }
  467|       |            self._stopped = true
  468|       |            self._sourceSubscription.dispose()
  469|       |            self.checkCompleted()
  470|       |        }
  471|       |    }
  472|       |
  473|       |    func subscribeInner(_ source: Observable<Observer.E>) {
  474|       |        let iterDisposable = SingleAssignmentDisposable()
  475|       |        if let disposeKey = self._group.insert(iterDisposable) {
  476|       |            let iter = MergeSinkIter(parent: self, disposeKey: disposeKey)
  477|       |            let subscription = source.subscribe(iter)
  478|       |            iterDisposable.setDisposable(subscription)
  479|       |        }
  480|       |    }
  481|       |
  482|       |    func run(_ sources: [Observable<Observer.E>]) -> Disposable {
  483|       |        self._activeCount += sources.count
  484|       |
  485|       |        for source in sources {
  486|       |            self.subscribeInner(source)
  487|       |        }
  488|       |
  489|       |        self._stopped = true
  490|       |
  491|       |        self.checkCompleted()
  492|       |
  493|       |        return self._group
  494|       |    }
  495|       |
  496|       |    @inline(__always)
  497|       |    func checkCompleted() {
  498|       |        if self._stopped && self._activeCount == 0 {
  499|       |            self.forwardOn(.completed)
  500|       |            self.dispose()
  501|       |        }
  502|       |    }
  503|       |    
  504|       |    func run(_ source: Observable<SourceElement>) -> Disposable {
  505|       |        _ = self._group.insert(self._sourceSubscription)
  506|       |
  507|       |        let subscription = source.subscribe(self)
  508|       |        self._sourceSubscription.setDisposable(subscription)
  509|       |        
  510|       |        return self._group
  511|       |    }
  512|       |}
  513|       |
  514|       |// MARK: Producers
  515|       |
  516|       |final private class FlatMap<SourceElement, SourceSequence: ObservableConvertibleType>: Producer<SourceSequence.E> {
  517|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  518|       |
  519|       |    private let _source: Observable<SourceElement>
  520|       |    
  521|       |    private let _selector: Selector
  522|       |
  523|      0|    init(source: Observable<SourceElement>, selector: @escaping Selector) {
  524|      0|        self._source = source
  525|      0|        self._selector = selector
  526|      0|    }
  527|       |    
  528|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceSequence.E {
  529|      0|        let sink = FlatMapSink(selector: self._selector, observer: observer, cancel: cancel)
  530|      0|        let subscription = sink.run(self._source)
  531|      0|        return (sink: sink, subscription: subscription)
  532|      0|    }
  533|       |}
  534|       |
  535|       |final private class FlatMapFirst<SourceElement, SourceSequence: ObservableConvertibleType>: Producer<SourceSequence.E> {
  536|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  537|       |
  538|       |    private let _source: Observable<SourceElement>
  539|       |
  540|       |    private let _selector: Selector
  541|       |
  542|      0|    init(source: Observable<SourceElement>, selector: @escaping Selector) {
  543|      0|        self._source = source
  544|      0|        self._selector = selector
  545|      0|    }
  546|       |
  547|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceSequence.E {
  548|      0|        let sink = FlatMapFirstSink<SourceElement, SourceSequence, O>(selector: self._selector, observer: observer, cancel: cancel)
  549|      0|        let subscription = sink.run(self._source)
  550|      0|        return (sink: sink, subscription: subscription)
  551|      0|    }
  552|       |}
  553|       |
  554|       |final class ConcatMap<SourceElement, SourceSequence: ObservableConvertibleType>: Producer<SourceSequence.E> {
  555|       |    typealias Selector = (SourceElement) throws -> SourceSequence
  556|       |    
  557|       |    private let _source: Observable<SourceElement>
  558|       |    private let _selector: Selector
  559|       |    
  560|      0|    init(source: Observable<SourceElement>, selector: @escaping Selector) {
  561|      0|        self._source = source
  562|      0|        self._selector = selector
  563|      0|    }
  564|       |    
  565|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceSequence.E {
  566|      0|        let sink = ConcatMapSink<SourceElement, SourceSequence, O>(selector: self._selector, observer: observer, cancel: cancel)
  567|      0|        let subscription = sink.run(self._source)
  568|      0|        return (sink: sink, subscription: subscription)
  569|      0|    }
  570|       |}
  571|       |
  572|       |final class Merge<SourceSequence: ObservableConvertibleType> : Producer<SourceSequence.E> {
  573|       |    private let _source: Observable<SourceSequence>
  574|       |
  575|      0|    init(source: Observable<SourceSequence>) {
  576|      0|        self._source = source
  577|      0|    }
  578|       |    
  579|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceSequence.E {
  580|      0|        let sink = MergeBasicSink<SourceSequence, O>(observer: observer, cancel: cancel)
  581|      0|        let subscription = sink.run(self._source)
  582|      0|        return (sink: sink, subscription: subscription)
  583|      0|    }
  584|       |}
  585|       |
  586|       |final private class MergeArray<Element>: Producer<Element> {
  587|       |    private let _sources: [Observable<Element>]
  588|       |
  589|      0|    init(sources: [Observable<Element>]) {
  590|      0|        self._sources = sources
  591|      0|    }
  592|       |
  593|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
  594|      0|        let sink = MergeBasicSink<Observable<E>, O>(observer: observer, cancel: cancel)
  595|      0|        let subscription = sink.run(self._sources)
  596|      0|        return (sink: sink, subscription: subscription)
  597|      0|    }
  598|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Multicast.swift:
    1|       |//
    2|       |//  Multicast.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       | Represents an observable wrapper that can be connected and disconnected from its underlying observable sequence.
   11|       | */
   12|       |public class ConnectableObservable<Element>
   13|       |    : Observable<Element>
   14|       |    , ConnectableObservableType {
   15|       |
   16|       |    /**
   17|       |     Connects the observable wrapper to its source. All subscribed observers will receive values from the underlying observable sequence as long as the connection is established.
   18|       |
   19|       |     - returns: Disposable used to disconnect the observable wrapper from its source, causing subscribed observer to stop receiving values from the underlying observable sequence.
   20|       |     */
   21|      0|    public func connect() -> Disposable {
   22|      0|        rxAbstractMethod()
   23|      0|    }
   24|       |}
   25|       |
   26|       |extension ObservableType {
   27|       |
   28|       |    /**
   29|       |    Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function.
   30|       |
   31|       |    Each subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's invocation.
   32|       |
   33|       |    For specializations with fixed subject types, see `publish` and `replay`.
   34|       |
   35|       |    - seealso: [multicast operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
   36|       |
   37|       |    - parameter subjectSelector: Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
   38|       |    - parameter selector: Selector function which can use the multicasted source sequence subject to the policies enforced by the created subject.
   39|       |    - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   40|       |    */
   41|       |    public func multicast<S: SubjectType, R>(_ subjectSelector: @escaping () throws -> S, selector: @escaping (Observable<S.E>) throws -> Observable<R>)
   42|      0|        -> Observable<R> where S.SubjectObserverType.E == E {
   43|      0|        return Multicast(
   44|      0|            source: self.asObservable(),
   45|      0|            subjectSelector: subjectSelector,
   46|      0|            selector: selector
   47|      0|        )
   48|      0|    }
   49|       |}
   50|       |
   51|       |extension ObservableType {
   52|       |
   53|       |    /**
   54|       |    Returns a connectable observable sequence that shares a single subscription to the underlying sequence.
   55|       |
   56|       |    This operator is a specialization of `multicast` using a `PublishSubject`.
   57|       |
   58|       |    - seealso: [publish operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
   59|       |
   60|       |    - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   61|       |    */
   62|      0|    public func publish() -> ConnectableObservable<E> {
   63|      0|        return self.multicast { PublishSubject() }
   64|      0|    }
   65|       |}
   66|       |
   67|       |extension ObservableType {
   68|       |
   69|       |    /**
   70|       |     Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying bufferSize elements.
   71|       |
   72|       |     This operator is a specialization of `multicast` using a `ReplaySubject`.
   73|       |
   74|       |     - seealso: [replay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
   75|       |
   76|       |     - parameter bufferSize: Maximum element count of the replay buffer.
   77|       |     - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   78|       |     */
   79|       |    public func replay(_ bufferSize: Int)
   80|      0|        -> ConnectableObservable<E> {
   81|      0|        return self.multicast { ReplaySubject.create(bufferSize: bufferSize) }
   82|      0|    }
   83|       |
   84|       |    /**
   85|       |     Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all elements.
   86|       |
   87|       |     This operator is a specialization of `multicast` using a `ReplaySubject`.
   88|       |
   89|       |     - seealso: [replay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
   90|       |
   91|       |     - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   92|       |     */
   93|       |    public func replayAll()
   94|      0|        -> ConnectableObservable<E> {
   95|      0|        return self.multicast { ReplaySubject.createUnbounded() }
   96|      0|    }
   97|       |}
   98|       |
   99|       |extension ConnectableObservableType {
  100|       |
  101|       |    /**
  102|       |    Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
  103|       |
  104|       |    - seealso: [refCount operator on reactivex.io](http://reactivex.io/documentation/operators/refcount.html)
  105|       |
  106|       |    - returns: An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
  107|       |    */
  108|      0|    public func refCount() -> Observable<E> {
  109|      0|        return RefCount(source: self)
  110|      0|    }
  111|       |}
  112|       |
  113|       |extension ObservableType {
  114|       |
  115|       |    /**
  116|       |     Multicasts the source sequence notifications through the specified subject to the resulting connectable observable.
  117|       |
  118|       |     Upon connection of the connectable observable, the subject is subscribed to the source exactly one, and messages are forwarded to the observers registered with the connectable observable.
  119|       |
  120|       |     For specializations with fixed subject types, see `publish` and `replay`.
  121|       |
  122|       |     - seealso: [multicast operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
  123|       |
  124|       |     - parameter subject: Subject to push source elements into.
  125|       |     - returns: A connectable observable sequence that upon connection causes the source sequence to push results into the specified subject.
  126|       |     */
  127|       |    public func multicast<S: SubjectType>(_ subject: S)
  128|      0|        -> ConnectableObservable<S.E> where S.SubjectObserverType.E == E {
  129|      0|        return ConnectableObservableAdapter(source: self.asObservable(), makeSubject: { subject })
  130|      0|    }
  131|       |
  132|       |    /**
  133|       |     Multicasts the source sequence notifications through an instantiated subject to the resulting connectable observable.
  134|       |
  135|       |     Upon connection of the connectable observable, the subject is subscribed to the source exactly one, and messages are forwarded to the observers registered with the connectable observable.
  136|       |
  137|       |     Subject is cleared on connection disposal or in case source sequence produces terminal event.
  138|       |
  139|       |     - seealso: [multicast operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
  140|       |
  141|       |     - parameter makeSubject: Factory function used to instantiate a subject for each connection.
  142|       |     - returns: A connectable observable sequence that upon connection causes the source sequence to push results into the specified subject.
  143|       |     */
  144|       |    public func multicast<S: SubjectType>(makeSubject: @escaping () -> S)
  145|       |        -> ConnectableObservable<S.E> where S.SubjectObserverType.E == E {
  146|       |        return ConnectableObservableAdapter(source: self.asObservable(), makeSubject: makeSubject)
  147|       |    }
  148|       |}
  149|       |
  150|       |final private class Connection<S: SubjectType>: ObserverType, Disposable {
  151|       |    typealias E = S.SubjectObserverType.E
  152|       |
  153|       |    private var _lock: RecursiveLock
  154|       |    // state
  155|       |    private var _parent: ConnectableObservableAdapter<S>?
  156|       |    private var _subscription : Disposable?
  157|       |    private var _subjectObserver: S.SubjectObserverType
  158|       |
  159|       |    private let _disposed = AtomicInt(0)
  160|       |
  161|      0|    init(parent: ConnectableObservableAdapter<S>, subjectObserver: S.SubjectObserverType, lock: RecursiveLock, subscription: Disposable) {
  162|      0|        self._parent = parent
  163|      0|        self._subscription = subscription
  164|      0|        self._lock = lock
  165|      0|        self._subjectObserver = subjectObserver
  166|      0|    }
  167|       |
  168|      0|    func on(_ event: Event<S.SubjectObserverType.E>) {
  169|      0|        if isFlagSet(self._disposed, 1) {
  170|      0|            return
  171|      0|        }
  172|      0|        if event.isStopEvent {
  173|      0|            self.dispose()
  174|      0|        }
  175|      0|        self._subjectObserver.on(event)
  176|      0|    }
  177|       |
  178|       |    func dispose() {
  179|       |        _lock.lock(); defer { _lock.unlock() } // {
  180|       |        fetchOr(self._disposed, 1)
  181|       |        guard let parent = _parent else {
  182|       |            return
  183|       |        }
  184|       |
  185|       |        if parent._connection === self {
  186|       |            parent._connection = nil
  187|       |            parent._subject = nil
  188|       |        }
  189|       |        self._parent = nil
  190|       |
  191|       |        self._subscription?.dispose()
  192|       |        self._subscription = nil
  193|       |        // }
  194|       |    }
  195|       |}
  196|       |
  197|       |final private class ConnectableObservableAdapter<S: SubjectType>
  198|       |    : ConnectableObservable<S.E> {
  199|       |    typealias ConnectionType = Connection<S>
  200|       |
  201|       |    fileprivate let _source: Observable<S.SubjectObserverType.E>
  202|       |    fileprivate let _makeSubject: () -> S
  203|       |
  204|       |    fileprivate let _lock = RecursiveLock()
  205|       |    fileprivate var _subject: S?
  206|       |
  207|       |    // state
  208|       |    fileprivate var _connection: ConnectionType?
  209|       |
  210|      0|    init(source: Observable<S.SubjectObserverType.E>, makeSubject: @escaping () -> S) {
  211|      0|        self._source = source
  212|      0|        self._makeSubject = makeSubject
  213|      0|        self._subject = nil
  214|      0|        self._connection = nil
  215|      0|    }
  216|       |
  217|      0|    override func connect() -> Disposable {
  218|      0|        return self._lock.calculateLocked {
  219|      0|            if let connection = self._connection {
  220|      0|                return connection
  221|      0|            }
  222|      0|
  223|      0|            let singleAssignmentDisposable = SingleAssignmentDisposable()
  224|      0|            let connection = Connection(parent: self, subjectObserver: self.lazySubject.asObserver(), lock: self._lock, subscription: singleAssignmentDisposable)
  225|      0|            self._connection = connection
  226|      0|            let subscription = self._source.subscribe(connection)
  227|      0|            singleAssignmentDisposable.setDisposable(subscription)
  228|      0|            return connection
  229|      0|        }
  230|      0|    }
  231|       |
  232|       |    fileprivate var lazySubject: S {
  233|       |        if let subject = self._subject {
  234|       |            return subject
  235|       |        }
  236|       |
  237|       |        let subject = self._makeSubject()
  238|       |        self._subject = subject
  239|       |        return subject
  240|       |    }
  241|       |
  242|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == S.E {
  243|      0|        return self.lazySubject.subscribe(observer)
  244|      0|    }
  245|       |}
  246|       |
  247|       |final private class RefCountSink<CO: ConnectableObservableType, O: ObserverType>
  248|       |    : Sink<O>
  249|       |    , ObserverType where CO.E == O.E {
  250|       |    typealias Element = O.E
  251|       |    typealias Parent = RefCount<CO>
  252|       |
  253|       |    private let _parent: Parent
  254|       |
  255|       |    private var _connectionIdSnapshot: Int64 = -1
  256|       |
  257|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  258|      0|        self._parent = parent
  259|      0|        super.init(observer: observer, cancel: cancel)
  260|      0|    }
  261|       |
  262|      0|    func run() -> Disposable {
  263|      0|        let subscription = self._parent._source.subscribe(self)
  264|      0|        self._parent._lock.lock(); defer { self._parent._lock.unlock() } // {
  265|      0|
  266|      0|        self._connectionIdSnapshot = self._parent._connectionId
  267|      0|
  268|      0|        if self.disposed {
  269|      0|            return Disposables.create()
  270|      0|        }
  271|      0|
  272|      0|        if self._parent._count == 0 {
  273|      0|            self._parent._count = 1
  274|      0|            self._parent._connectableSubscription = self._parent._source.connect()
  275|      0|        }
  276|      0|        else {
  277|      0|            self._parent._count += 1
  278|      0|        }
  279|      0|        // }
  280|      0|
  281|      0|        return Disposables.create {
  282|      0|            subscription.dispose()
  283|      0|            self._parent._lock.lock(); defer { self._parent._lock.unlock() } // {
  284|      0|            if self._parent._connectionId != self._connectionIdSnapshot {
  285|      0|                return
  286|      0|            }
  287|      0|            if self._parent._count == 1 {
  288|      0|                self._parent._count = 0
  289|      0|                guard let connectableSubscription = self._parent._connectableSubscription else {
  290|      0|                    return
  291|      0|                }
  292|      0|
  293|      0|                connectableSubscription.dispose()
  294|      0|                self._parent._connectableSubscription = nil
  295|      0|            }
  296|      0|            else if self._parent._count > 1 {
  297|      0|                self._parent._count -= 1
  298|      0|            }
  299|      0|            else {
  300|      0|                rxFatalError("Something went wrong with RefCount disposing mechanism")
  301|      0|            }
  302|      0|            // }
  303|      0|        }
  304|      0|    }
  305|       |
  306|      0|    func on(_ event: Event<Element>) {
  307|      0|        switch event {
  308|      0|        case .next:
  309|      0|            self.forwardOn(event)
  310|      0|        case .error, .completed:
  311|      0|            self._parent._lock.lock() // {
  312|      0|                if self._parent._connectionId == self._connectionIdSnapshot {
  313|      0|                    let connection = self._parent._connectableSubscription
  314|      0|                    defer { connection?.dispose() }
  315|      0|                    self._parent._count = 0
  316|      0|                    self._parent._connectionId = self._parent._connectionId &+ 1
  317|      0|                    self._parent._connectableSubscription = nil
  318|      0|                }
  319|      0|            // }
  320|      0|            self._parent._lock.unlock()
  321|      0|            self.forwardOn(event)
  322|      0|            self.dispose()
  323|      0|        }
  324|      0|    }
  325|       |}
  326|       |
  327|       |final private class RefCount<CO: ConnectableObservableType>: Producer<CO.E> {
  328|       |    fileprivate let _lock = RecursiveLock()
  329|       |
  330|       |    // state
  331|       |    fileprivate var _count = 0
  332|       |    fileprivate var _connectionId: Int64 = 0
  333|       |    fileprivate var _connectableSubscription = nil as Disposable?
  334|       |
  335|       |    fileprivate let _source: CO
  336|       |
  337|      0|    init(source: CO) {
  338|      0|        self._source = source
  339|      0|    }
  340|       |
  341|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == CO.E {
  342|      0|        let sink = RefCountSink(parent: self, observer: observer, cancel: cancel)
  343|      0|        let subscription = sink.run()
  344|      0|        return (sink: sink, subscription: subscription)
  345|      0|    }
  346|       |}
  347|       |
  348|       |final private class MulticastSink<S: SubjectType, O: ObserverType>: Sink<O>, ObserverType {
  349|       |    typealias Element = O.E
  350|       |    typealias ResultType = Element
  351|       |    typealias MutlicastType = Multicast<S, O.E>
  352|       |
  353|       |    private let _parent: MutlicastType
  354|       |
  355|      0|    init(parent: MutlicastType, observer: O, cancel: Cancelable) {
  356|      0|        self._parent = parent
  357|      0|        super.init(observer: observer, cancel: cancel)
  358|      0|    }
  359|       |
  360|      0|    func run() -> Disposable {
  361|      0|        do {
  362|      0|            let subject = try self._parent._subjectSelector()
  363|      0|            let connectable = ConnectableObservableAdapter(source: self._parent._source, makeSubject: { subject })
  364|      0|
  365|      0|            let observable = try self._parent._selector(connectable)
  366|      0|
  367|      0|            let subscription = observable.subscribe(self)
  368|      0|            let connection = connectable.connect()
  369|      0|
  370|      0|            return Disposables.create(subscription, connection)
  371|      0|        }
  372|      0|        catch let e {
  373|      0|            self.forwardOn(.error(e))
  374|      0|            self.dispose()
  375|      0|            return Disposables.create()
  376|      0|        }
  377|      0|    }
  378|       |
  379|      0|    func on(_ event: Event<ResultType>) {
  380|      0|        self.forwardOn(event)
  381|      0|        switch event {
  382|      0|        case .next: break
  383|      0|        case .error, .completed:
  384|      0|            self.dispose()
  385|      0|        }
  386|      0|    }
  387|       |}
  388|       |
  389|       |final private class Multicast<S: SubjectType, R>: Producer<R> {
  390|       |    typealias SubjectSelectorType = () throws -> S
  391|       |    typealias SelectorType = (Observable<S.E>) throws -> Observable<R>
  392|       |
  393|       |    fileprivate let _source: Observable<S.SubjectObserverType.E>
  394|       |    fileprivate let _subjectSelector: SubjectSelectorType
  395|       |    fileprivate let _selector: SelectorType
  396|       |
  397|      0|    init(source: Observable<S.SubjectObserverType.E>, subjectSelector: @escaping SubjectSelectorType, selector: @escaping SelectorType) {
  398|      0|        self._source = source
  399|      0|        self._subjectSelector = subjectSelector
  400|      0|        self._selector = selector
  401|      0|    }
  402|       |
  403|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  404|      0|        let sink = MulticastSink(parent: self, observer: observer, cancel: cancel)
  405|      0|        let subscription = sink.run()
  406|      0|        return (sink: sink, subscription: subscription)
  407|      0|    }
  408|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Never.swift:
    1|       |//
    2|       |//  Never.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
   13|       |
   14|       |     - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   15|       |
   16|       |     - returns: An observable sequence whose observers will never get called.
   17|       |     */
   18|      0|    public static func never() -> Observable<E> {
   19|      0|        return NeverProducer()
   20|      0|    }
   21|       |}
   22|       |
   23|       |final private class NeverProducer<Element>: Producer<Element> {
   24|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   25|      0|        return Disposables.create()
   26|      0|    }
   27|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/ObserveOn.swift:
    1|       |//
    2|       |//  ObserveOn.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
   13|       |
   14|       |     This only invokes observer callbacks on a `scheduler`. In case the subscription and/or unsubscription
   15|       |     actions have side-effects that require to be run on a scheduler, use `subscribeOn`.
   16|       |
   17|       |     - seealso: [observeOn operator on reactivex.io](http://reactivex.io/documentation/operators/observeon.html)
   18|       |
   19|       |     - parameter scheduler: Scheduler to notify observers on.
   20|       |     - returns: The source sequence whose observations happen on the specified scheduler.
   21|       |     */
   22|       |    public func observeOn(_ scheduler: ImmediateSchedulerType)
   23|      0|        -> Observable<E> {
   24|      0|            if let scheduler = scheduler as? SerialDispatchQueueScheduler {
   25|      0|                return ObserveOnSerialDispatchQueue(source: self.asObservable(), scheduler: scheduler)
   26|      0|            }
   27|      0|            else {
   28|      0|                return ObserveOn(source: self.asObservable(), scheduler: scheduler)
   29|      0|            }
   30|      0|    }
   31|       |}
   32|       |
   33|       |final private class ObserveOn<E>: Producer<E> {
   34|       |    let scheduler: ImmediateSchedulerType
   35|       |    let source: Observable<E>
   36|       |
   37|      0|    init(source: Observable<E>, scheduler: ImmediateSchedulerType) {
   38|      0|        self.scheduler = scheduler
   39|      0|        self.source = source
   40|      0|
   41|      0|#if TRACE_RESOURCES
   42|      0|        _ = Resources.incrementTotal()
   43|      0|#endif
   44|      0|    }
   45|       |
   46|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   47|      0|        let sink = ObserveOnSink(scheduler: self.scheduler, observer: observer, cancel: cancel)
   48|      0|        let subscription = self.source.subscribe(sink)
   49|      0|        return (sink: sink, subscription: subscription)
   50|      0|    }
   51|       |
   52|       |#if TRACE_RESOURCES
   53|       |    deinit {
   54|       |        _ = Resources.decrementTotal()
   55|       |    }
   56|       |#endif
   57|       |}
   58|       |
   59|       |enum ObserveOnState : Int32 {
   60|       |    // pump is not running
   61|       |    case stopped = 0
   62|       |    // pump is running
   63|       |    case running = 1
   64|       |}
   65|       |
   66|       |final private class ObserveOnSink<O: ObserverType>: ObserverBase<O.E> {
   67|       |    typealias E = O.E
   68|       |
   69|       |    let _scheduler: ImmediateSchedulerType
   70|       |
   71|       |    var _lock = SpinLock()
   72|       |    let _observer: O
   73|       |
   74|       |    // state
   75|       |    var _state = ObserveOnState.stopped
   76|       |    var _queue = Queue<Event<E>>(capacity: 10)
   77|       |
   78|       |    let _scheduleDisposable = SerialDisposable()
   79|       |    let _cancel: Cancelable
   80|       |
   81|      0|    init(scheduler: ImmediateSchedulerType, observer: O, cancel: Cancelable) {
   82|      0|        self._scheduler = scheduler
   83|      0|        self._observer = observer
   84|      0|        self._cancel = cancel
   85|      0|    }
   86|       |
   87|      0|    override func onCore(_ event: Event<E>) {
   88|      0|        let shouldStart = self._lock.calculateLocked { () -> Bool in
   89|      0|            self._queue.enqueue(event)
   90|      0|
   91|      0|            switch self._state {
   92|      0|            case .stopped:
   93|      0|                self._state = .running
   94|      0|                return true
   95|      0|            case .running:
   96|      0|                return false
   97|      0|            }
   98|      0|        }
   99|      0|
  100|      0|        if shouldStart {
  101|      0|            self._scheduleDisposable.disposable = self._scheduler.scheduleRecursive((), action: self.run)
  102|      0|        }
  103|      0|    }
  104|       |
  105|       |    func run(_ state: (), _ recurse: (()) -> Void) {
  106|      0|        let (nextEvent, observer) = self._lock.calculateLocked { () -> (Event<E>?, O) in
  107|      0|            if !self._queue.isEmpty {
  108|      0|                return (self._queue.dequeue(), self._observer)
  109|      0|            }
  110|      0|            else {
  111|      0|                self._state = .stopped
  112|      0|                return (nil, self._observer)
  113|      0|            }
  114|      0|        }
  115|       |
  116|       |        if let nextEvent = nextEvent, !self._cancel.isDisposed {
  117|       |            observer.on(nextEvent)
  118|       |            if nextEvent.isStopEvent {
  119|       |                self.dispose()
  120|       |            }
  121|       |        }
  122|       |        else {
  123|       |            return
  124|       |        }
  125|       |
  126|       |        let shouldContinue = self._shouldContinue_synchronized()
  127|       |
  128|       |        if shouldContinue {
  129|       |            recurse(())
  130|       |        }
  131|       |    }
  132|       |
  133|       |    func _shouldContinue_synchronized() -> Bool {
  134|       |        self._lock.lock(); defer { self._lock.unlock() } // {
  135|       |            if !self._queue.isEmpty {
  136|       |                return true
  137|       |            }
  138|       |            else {
  139|       |                self._state = .stopped
  140|       |                return false
  141|       |            }
  142|       |        // }
  143|       |    }
  144|       |
  145|       |    override func dispose() {
  146|       |        super.dispose()
  147|       |
  148|       |        self._cancel.dispose()
  149|       |        self._scheduleDisposable.dispose()
  150|       |    }
  151|       |}
  152|       |
  153|       |#if TRACE_RESOURCES
  154|       |    fileprivate let _numberOfSerialDispatchQueueObservables = AtomicInt(0)
  155|       |    extension Resources {
  156|       |        /**
  157|       |         Counts number of `SerialDispatchQueueObservables`.
  158|       |
  159|       |         Purposed for unit tests.
  160|       |         */
  161|       |        public static var numberOfSerialDispatchQueueObservables: Int32 {
  162|       |            return load(_numberOfSerialDispatchQueueObservables)
  163|       |        }
  164|       |    }
  165|       |#endif
  166|       |
  167|       |final private class ObserveOnSerialDispatchQueueSink<O: ObserverType>: ObserverBase<O.E> {
  168|       |    let scheduler: SerialDispatchQueueScheduler
  169|       |    let observer: O
  170|       |
  171|       |    let cancel: Cancelable
  172|       |
  173|       |    var cachedScheduleLambda: (((sink: ObserveOnSerialDispatchQueueSink<O>, event: Event<E>)) -> Disposable)!
  174|       |
  175|      0|    init(scheduler: SerialDispatchQueueScheduler, observer: O, cancel: Cancelable) {
  176|      0|        self.scheduler = scheduler
  177|      0|        self.observer = observer
  178|      0|        self.cancel = cancel
  179|      0|        super.init()
  180|      0|
  181|      0|        self.cachedScheduleLambda = { pair in
  182|      0|            guard !cancel.isDisposed else { return Disposables.create() }
  183|      0|
  184|      0|            pair.sink.observer.on(pair.event)
  185|      0|
  186|      0|            if pair.event.isStopEvent {
  187|      0|                pair.sink.dispose()
  188|      0|            }
  189|      0|
  190|      0|            return Disposables.create()
  191|      0|        }
  192|      0|    }
  193|       |
  194|      0|    override func onCore(_ event: Event<E>) {
  195|      0|        _ = self.scheduler.schedule((self, event), action: self.cachedScheduleLambda!)
  196|      0|    }
  197|       |
  198|       |    override func dispose() {
  199|       |        super.dispose()
  200|       |
  201|       |        self.cancel.dispose()
  202|       |    }
  203|       |}
  204|       |
  205|       |final private class ObserveOnSerialDispatchQueue<E>: Producer<E> {
  206|       |    let scheduler: SerialDispatchQueueScheduler
  207|       |    let source: Observable<E>
  208|       |
  209|      0|    init(source: Observable<E>, scheduler: SerialDispatchQueueScheduler) {
  210|      0|        self.scheduler = scheduler
  211|      0|        self.source = source
  212|      0|
  213|      0|        #if TRACE_RESOURCES
  214|      0|            _ = Resources.incrementTotal()
  215|      0|            _ = increment(_numberOfSerialDispatchQueueObservables)
  216|      0|        #endif
  217|      0|    }
  218|       |
  219|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
  220|      0|        let sink = ObserveOnSerialDispatchQueueSink(scheduler: self.scheduler, observer: observer, cancel: cancel)
  221|      0|        let subscription = self.source.subscribe(sink)
  222|      0|        return (sink: sink, subscription: subscription)
  223|      0|    }
  224|       |
  225|       |    #if TRACE_RESOURCES
  226|       |    deinit {
  227|       |        _ = Resources.decrementTotal()
  228|       |        _ = decrement(_numberOfSerialDispatchQueueObservables)
  229|       |    }
  230|       |    #endif
  231|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Optional.swift:
    1|       |//
    2|       |//  Optional.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by tarunon on 2016/12/13.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Converts a optional to an observable sequence.
   12|       |
   13|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   14|       |
   15|       |     - parameter optional: Optional element in the resulting observable sequence.
   16|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   17|       |     */
   18|      0|    public static func from(optional: E?) -> Observable<E> {
   19|      0|        return ObservableOptional(optional: optional)
   20|      0|    }
   21|       |
   22|       |    /**
   23|       |     Converts a optional to an observable sequence.
   24|       |
   25|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   26|       |
   27|       |     - parameter optional: Optional element in the resulting observable sequence.
   28|       |     - parameter scheduler: Scheduler to send the optional element on.
   29|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   30|       |     */
   31|      0|    public static func from(optional: E?, scheduler: ImmediateSchedulerType) -> Observable<E> {
   32|      0|        return ObservableOptionalScheduled(optional: optional, scheduler: scheduler)
   33|      0|    }
   34|       |}
   35|       |
   36|       |final private class ObservableOptionalScheduledSink<O: ObserverType>: Sink<O> {
   37|       |    typealias E = O.E
   38|       |    typealias Parent = ObservableOptionalScheduled<E>
   39|       |
   40|       |    private let _parent: Parent
   41|       |
   42|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   43|      0|        self._parent = parent
   44|      0|        super.init(observer: observer, cancel: cancel)
   45|      0|    }
   46|       |
   47|      0|    func run() -> Disposable {
   48|      0|        return self._parent._scheduler.schedule(self._parent._optional) { (optional: E?) -> Disposable in
   49|      0|            if let next = optional {
   50|      0|                self.forwardOn(.next(next))
   51|      0|                return self._parent._scheduler.schedule(()) { _ in
   52|      0|                    self.forwardOn(.completed)
   53|      0|                    self.dispose()
   54|      0|                    return Disposables.create()
   55|      0|                }
   56|      0|            } else {
   57|      0|                self.forwardOn(.completed)
   58|      0|                self.dispose()
   59|      0|                return Disposables.create()
   60|      0|            }
   61|      0|        }
   62|      0|    }
   63|       |}
   64|       |
   65|       |final private class ObservableOptionalScheduled<E>: Producer<E> {
   66|       |    fileprivate let _optional: E?
   67|       |    fileprivate let _scheduler: ImmediateSchedulerType
   68|       |
   69|      0|    init(optional: E?, scheduler: ImmediateSchedulerType) {
   70|      0|        self._optional = optional
   71|      0|        self._scheduler = scheduler
   72|      0|    }
   73|       |
   74|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   75|      0|        let sink = ObservableOptionalScheduledSink(parent: self, observer: observer, cancel: cancel)
   76|      0|        let subscription = sink.run()
   77|      0|        return (sink: sink, subscription: subscription)
   78|      0|    }
   79|       |}
   80|       |
   81|       |final private class ObservableOptional<E>: Producer<E> {
   82|       |    private let _optional: E?
   83|       |    
   84|      0|    init(optional: E?) {
   85|      0|        self._optional = optional
   86|      0|    }
   87|       |    
   88|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   89|      0|        if let element = self._optional {
   90|      0|            observer.on(.next(element))
   91|      0|        }
   92|      0|        observer.on(.completed)
   93|      0|        return Disposables.create()
   94|      0|    }
   95|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Producer.swift:
    1|       |//
    2|       |//  Producer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/20/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class Producer<Element> : Observable<Element> {
   10|      0|    override init() {
   11|      0|        super.init()
   12|      0|    }
   13|       |
   14|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   15|      0|        if !CurrentThreadScheduler.isScheduleRequired {
   16|      0|            // The returned disposable needs to release all references once it was disposed.
   17|      0|            let disposer = SinkDisposer()
   18|      0|            let sinkAndSubscription = self.run(observer, cancel: disposer)
   19|      0|            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)
   20|      0|
   21|      0|            return disposer
   22|      0|        }
   23|      0|        else {
   24|      0|            return CurrentThreadScheduler.instance.schedule(()) { _ in
   25|      0|                let disposer = SinkDisposer()
   26|      0|                let sinkAndSubscription = self.run(observer, cancel: disposer)
   27|      0|                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)
   28|      0|
   29|      0|                return disposer
   30|      0|            }
   31|      0|        }
   32|      0|    }
   33|       |
   34|      0|    func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   35|      0|        rxAbstractMethod()
   36|      0|    }
   37|       |}
   38|       |
   39|       |fileprivate final class SinkDisposer: Cancelable {
   40|       |    fileprivate enum DisposeState: Int32 {
   41|       |        case disposed = 1
   42|       |        case sinkAndSubscriptionSet = 2
   43|       |    }
   44|       |
   45|       |    private let _state = AtomicInt(0)
   46|       |    private var _sink: Disposable?
   47|       |    private var _subscription: Disposable?
   48|       |
   49|      0|    var isDisposed: Bool {
   50|      0|        return isFlagSet(self._state, DisposeState.disposed.rawValue)
   51|      0|    }
   52|       |
   53|       |    func setSinkAndSubscription(sink: Disposable, subscription: Disposable) {
   54|       |        self._sink = sink
   55|       |        self._subscription = subscription
   56|       |
   57|       |        let previousState = fetchOr(self._state, DisposeState.sinkAndSubscriptionSet.rawValue)
   58|       |        if (previousState & DisposeState.sinkAndSubscriptionSet.rawValue) != 0 {
   59|      0|            rxFatalError("Sink and subscription were already set")
   60|       |        }
   61|       |
   62|       |        if (previousState & DisposeState.disposed.rawValue) != 0 {
   63|       |            sink.dispose()
   64|       |            subscription.dispose()
   65|       |            self._sink = nil
   66|       |            self._subscription = nil
   67|       |        }
   68|       |    }
   69|       |
   70|      0|    func dispose() {
   71|      0|        let previousState = fetchOr(self._state, DisposeState.disposed.rawValue)
   72|      0|
   73|      0|        if (previousState & DisposeState.disposed.rawValue) != 0 {
   74|      0|            return
   75|      0|        }
   76|      0|
   77|      0|        if (previousState & DisposeState.sinkAndSubscriptionSet.rawValue) != 0 {
   78|      0|            guard let sink = self._sink else {
   79|      0|                rxFatalError("Sink not set")
   80|      0|            }
   81|      0|            guard let subscription = self._subscription else {
   82|      0|                rxFatalError("Subscription not set")
   83|      0|            }
   84|      0|
   85|      0|            sink.dispose()
   86|      0|            subscription.dispose()
   87|      0|
   88|      0|            self._sink = nil
   89|      0|            self._subscription = nil
   90|      0|        }
   91|      0|    }
   92|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Range.swift:
    1|       |//
    2|       |//  Range.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType where E : RxAbstractInteger {
   10|       |    /**
   11|       |     Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to generate and send out observer messages.
   12|       |
   13|       |     - seealso: [range operator on reactivex.io](http://reactivex.io/documentation/operators/range.html)
   14|       |
   15|       |     - parameter start: The value of the first integer in the sequence.
   16|       |     - parameter count: The number of sequential integers to generate.
   17|       |     - parameter scheduler: Scheduler to run the generator loop on.
   18|       |     - returns: An observable sequence that contains a range of sequential integral numbers.
   19|       |     */
   20|      0|    public static func range(start: E, count: E, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
   21|      0|        return RangeProducer<E>(start: start, count: count, scheduler: scheduler)
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class RangeProducer<E: RxAbstractInteger>: Producer<E> {
   26|       |    fileprivate let _start: E
   27|       |    fileprivate let _count: E
   28|       |    fileprivate let _scheduler: ImmediateSchedulerType
   29|       |
   30|      0|    init(start: E, count: E, scheduler: ImmediateSchedulerType) {
   31|      0|        guard count >= 0 else {
   32|      0|            rxFatalError("count can't be negative")
   33|      0|        }
   34|      0|
   35|      0|        guard start &+ (count - 1) >= start || count == 0 else {
   36|      0|            rxFatalError("overflow of count")
   37|      0|        }
   38|      0|
   39|      0|        self._start = start
   40|      0|        self._count = count
   41|      0|        self._scheduler = scheduler
   42|      0|    }
   43|       |    
   44|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   45|      0|        let sink = RangeSink(parent: self, observer: observer, cancel: cancel)
   46|      0|        let subscription = sink.run()
   47|      0|        return (sink: sink, subscription: subscription)
   48|      0|    }
   49|       |}
   50|       |
   51|       |final private class RangeSink<O: ObserverType>: Sink<O> where O.E: RxAbstractInteger {
   52|       |    typealias Parent = RangeProducer<O.E>
   53|       |    
   54|       |    private let _parent: Parent
   55|       |    
   56|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   57|      0|        self._parent = parent
   58|      0|        super.init(observer: observer, cancel: cancel)
   59|      0|    }
   60|       |    
   61|       |    func run() -> Disposable {
   62|      0|        return self._parent._scheduler.scheduleRecursive(0 as O.E) { i, recurse in
   63|      0|            if i < self._parent._count {
   64|      0|                self.forwardOn(.next(self._parent._start + i))
   65|      0|                recurse(i + 1)
   66|      0|            }
   67|      0|            else {
   68|      0|                self.forwardOn(.completed)
   69|      0|                self.dispose()
   70|      0|            }
   71|      0|        }
   72|       |    }
   73|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Reduce.swift:
    1|       |//
    2|       |//  Reduce.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |extension ObservableType {
   11|       |    /**
   12|       |    Applies an `accumulator` function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified `seed` value is used as the initial accumulator value.
   13|       |
   14|       |    For aggregation behavior with incremental intermediate results, see `scan`.
   15|       |
   16|       |    - seealso: [reduce operator on reactivex.io](http://reactivex.io/documentation/operators/reduce.html)
   17|       |
   18|       |    - parameter seed: The initial accumulator value.
   19|       |    - parameter accumulator: A accumulator function to be invoked on each element.
   20|       |    - parameter mapResult: A function to transform the final accumulator value into the result value.
   21|       |    - returns: An observable sequence containing a single element with the final accumulator value.
   22|       |    */
   23|       |    public func reduce<A, R>(_ seed: A, accumulator: @escaping (A, E) throws -> A, mapResult: @escaping (A) throws -> R)
   24|      0|        -> Observable<R> {
   25|      0|        return Reduce(source: self.asObservable(), seed: seed, accumulator: accumulator, mapResult: mapResult)
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |    Applies an `accumulator` function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified `seed` value is used as the initial accumulator value.
   30|       |    
   31|       |    For aggregation behavior with incremental intermediate results, see `scan`.
   32|       |
   33|       |    - seealso: [reduce operator on reactivex.io](http://reactivex.io/documentation/operators/reduce.html)
   34|       |    
   35|       |    - parameter seed: The initial accumulator value.
   36|       |    - parameter accumulator: A accumulator function to be invoked on each element.
   37|       |    - returns: An observable sequence containing a single element with the final accumulator value.
   38|       |    */
   39|       |    public func reduce<A>(_ seed: A, accumulator: @escaping (A, E) throws -> A)
   40|      0|        -> Observable<A> {
   41|      0|        return Reduce(source: self.asObservable(), seed: seed, accumulator: accumulator, mapResult: { $0 })
   42|      0|    }
   43|       |}
   44|       |
   45|       |final private class ReduceSink<SourceType, AccumulateType, O: ObserverType>: Sink<O>, ObserverType {
   46|       |    typealias ResultType = O.E
   47|       |    typealias Parent = Reduce<SourceType, AccumulateType, ResultType>
   48|       |    
   49|       |    private let _parent: Parent
   50|       |    private var _accumulation: AccumulateType
   51|       |    
   52|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   53|      0|        self._parent = parent
   54|      0|        self._accumulation = parent._seed
   55|      0|        
   56|      0|        super.init(observer: observer, cancel: cancel)
   57|      0|    }
   58|       |    
   59|      0|    func on(_ event: Event<SourceType>) {
   60|      0|        switch event {
   61|      0|        case .next(let value):
   62|      0|            do {
   63|      0|                self._accumulation = try self._parent._accumulator(self._accumulation, value)
   64|      0|            }
   65|      0|            catch let e {
   66|      0|                self.forwardOn(.error(e))
   67|      0|                self.dispose()
   68|      0|            }
   69|      0|        case .error(let e):
   70|      0|            self.forwardOn(.error(e))
   71|      0|            self.dispose()
   72|      0|        case .completed:
   73|      0|            do {
   74|      0|                let result = try self._parent._mapResult(self._accumulation)
   75|      0|                self.forwardOn(.next(result))
   76|      0|                self.forwardOn(.completed)
   77|      0|                self.dispose()
   78|      0|            }
   79|      0|            catch let e {
   80|      0|                self.forwardOn(.error(e))
   81|      0|                self.dispose()
   82|      0|            }
   83|      0|        }
   84|      0|    }
   85|       |}
   86|       |
   87|       |final private class Reduce<SourceType, AccumulateType, ResultType>: Producer<ResultType> {
   88|       |    typealias AccumulatorType = (AccumulateType, SourceType) throws -> AccumulateType
   89|       |    typealias ResultSelectorType = (AccumulateType) throws -> ResultType
   90|       |    
   91|       |    fileprivate let _source: Observable<SourceType>
   92|       |    fileprivate let _seed: AccumulateType
   93|       |    fileprivate let _accumulator: AccumulatorType
   94|       |    fileprivate let _mapResult: ResultSelectorType
   95|       |    
   96|      0|    init(source: Observable<SourceType>, seed: AccumulateType, accumulator: @escaping AccumulatorType, mapResult: @escaping ResultSelectorType) {
   97|      0|        self._source = source
   98|      0|        self._seed = seed
   99|      0|        self._accumulator = accumulator
  100|      0|        self._mapResult = mapResult
  101|      0|    }
  102|       |
  103|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
  104|      0|        let sink = ReduceSink(parent: self, observer: observer, cancel: cancel)
  105|      0|        let subscription = self._source.subscribe(sink)
  106|      0|        return (sink: sink, subscription: subscription)
  107|      0|    }
  108|       |}
  109|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Repeat.swift:
    1|       |//
    2|       |//  Repeat.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Generates an observable sequence that repeats the given element infinitely, using the specified scheduler to send out observer messages.
   12|       |
   13|       |     - seealso: [repeat operator on reactivex.io](http://reactivex.io/documentation/operators/repeat.html)
   14|       |
   15|       |     - parameter element: Element to repeat.
   16|       |     - parameter scheduler: Scheduler to run the producer loop on.
   17|       |     - returns: An observable sequence that repeats the given element infinitely.
   18|       |     */
   19|      0|    public static func repeatElement(_ element: E, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
   20|      0|        return RepeatElement(element: element, scheduler: scheduler)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class RepeatElement<Element>: Producer<Element> {
   25|       |    fileprivate let _element: Element
   26|       |    fileprivate let _scheduler: ImmediateSchedulerType
   27|       |    
   28|      0|    init(element: Element, scheduler: ImmediateSchedulerType) {
   29|      0|        self._element = element
   30|      0|        self._scheduler = scheduler
   31|      0|    }
   32|       |    
   33|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   34|      0|        let sink = RepeatElementSink(parent: self, observer: observer, cancel: cancel)
   35|      0|        let subscription = sink.run()
   36|      0|
   37|      0|        return (sink: sink, subscription: subscription)
   38|      0|    }
   39|       |}
   40|       |
   41|       |final private class RepeatElementSink<O: ObserverType>: Sink<O> {
   42|       |    typealias Parent = RepeatElement<O.E>
   43|       |    
   44|       |    private let _parent: Parent
   45|       |    
   46|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   47|      0|        self._parent = parent
   48|      0|        super.init(observer: observer, cancel: cancel)
   49|      0|    }
   50|       |    
   51|       |    func run() -> Disposable {
   52|      0|        return self._parent._scheduler.scheduleRecursive(self._parent._element) { e, recurse in
   53|      0|            self.forwardOn(.next(e))
   54|      0|            recurse(e)
   55|      0|        }
   56|       |    }
   57|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/RetryWhen.swift:
    1|       |//
    2|       |//  RetryWhen.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 06/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Repeats the source observable sequence on error when the notifier emits a next value.
   13|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
   14|       |
   15|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
   16|       |
   17|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
   18|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
   19|       |     */
   20|       |    public func retryWhen<TriggerObservable: ObservableType, Error: Swift.Error>(_ notificationHandler: @escaping (Observable<Error>) -> TriggerObservable)
   21|      0|        -> Observable<E> {
   22|      0|        return RetryWhenSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()), notificationHandler: notificationHandler)
   23|      0|    }
   24|       |
   25|       |    /**
   26|       |     Repeats the source observable sequence on error when the notifier emits a next value.
   27|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
   28|       |
   29|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
   30|       |
   31|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
   32|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
   33|       |     */
   34|       |    public func retryWhen<TriggerObservable: ObservableType>(_ notificationHandler: @escaping (Observable<Swift.Error>) -> TriggerObservable)
   35|      0|        -> Observable<E> {
   36|      0|        return RetryWhenSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()), notificationHandler: notificationHandler)
   37|      0|    }
   38|       |}
   39|       |
   40|       |final private class RetryTriggerSink<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
   41|       |    : ObserverType where S.Iterator.Element: ObservableType, S.Iterator.Element.E == O.E {
   42|       |    typealias E = TriggerObservable.E
   43|       |    
   44|       |    typealias Parent = RetryWhenSequenceSinkIter<S, O, TriggerObservable, Error>
   45|       |    
   46|       |    fileprivate let _parent: Parent
   47|       |
   48|      0|    init(parent: Parent) {
   49|      0|        self._parent = parent
   50|      0|    }
   51|       |
   52|      0|    func on(_ event: Event<E>) {
   53|      0|        switch event {
   54|      0|        case .next:
   55|      0|            self._parent._parent._lastError = nil
   56|      0|            self._parent._parent.schedule(.moveNext)
   57|      0|        case .error(let e):
   58|      0|            self._parent._parent.forwardOn(.error(e))
   59|      0|            self._parent._parent.dispose()
   60|      0|        case .completed:
   61|      0|            self._parent._parent.forwardOn(.completed)
   62|      0|            self._parent._parent.dispose()
   63|      0|        }
   64|      0|    }
   65|       |}
   66|       |
   67|       |final private class RetryWhenSequenceSinkIter<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
   68|       |    : ObserverType
   69|       |    , Disposable where S.Iterator.Element: ObservableType, S.Iterator.Element.E == O.E {
   70|       |    typealias E = O.E
   71|       |    typealias Parent = RetryWhenSequenceSink<S, O, TriggerObservable, Error>
   72|       |
   73|       |    fileprivate let _parent: Parent
   74|       |    fileprivate let _errorHandlerSubscription = SingleAssignmentDisposable()
   75|       |    fileprivate let _subscription: Disposable
   76|       |
   77|      0|    init(parent: Parent, subscription: Disposable) {
   78|      0|        self._parent = parent
   79|      0|        self._subscription = subscription
   80|      0|    }
   81|       |
   82|      0|    func on(_ event: Event<E>) {
   83|      0|        switch event {
   84|      0|        case .next:
   85|      0|            self._parent.forwardOn(event)
   86|      0|        case .error(let error):
   87|      0|            self._parent._lastError = error
   88|      0|
   89|      0|            if let failedWith = error as? Error {
   90|      0|                // dispose current subscription
   91|      0|                self._subscription.dispose()
   92|      0|
   93|      0|                let errorHandlerSubscription = self._parent._notifier.subscribe(RetryTriggerSink(parent: self))
   94|      0|                self._errorHandlerSubscription.setDisposable(errorHandlerSubscription)
   95|      0|                self._parent._errorSubject.on(.next(failedWith))
   96|      0|            }
   97|      0|            else {
   98|      0|                self._parent.forwardOn(.error(error))
   99|      0|                self._parent.dispose()
  100|      0|            }
  101|      0|        case .completed:
  102|      0|            self._parent.forwardOn(event)
  103|      0|            self._parent.dispose()
  104|      0|        }
  105|      0|    }
  106|       |
  107|      0|    final func dispose() {
  108|      0|        self._subscription.dispose()
  109|      0|        self._errorHandlerSubscription.dispose()
  110|      0|    }
  111|       |}
  112|       |
  113|       |final private class RetryWhenSequenceSink<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
  114|       |    : TailRecursiveSink<S, O> where S.Iterator.Element: ObservableType, S.Iterator.Element.E == O.E {
  115|       |    typealias Element = O.E
  116|       |    typealias Parent = RetryWhenSequence<S, TriggerObservable, Error>
  117|       |    
  118|       |    let _lock = RecursiveLock()
  119|       |    
  120|       |    fileprivate let _parent: Parent
  121|       |    
  122|       |    fileprivate var _lastError: Swift.Error?
  123|       |    fileprivate let _errorSubject = PublishSubject<Error>()
  124|       |    fileprivate let _handler: Observable<TriggerObservable.E>
  125|       |    fileprivate let _notifier = PublishSubject<TriggerObservable.E>()
  126|       |
  127|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  128|      0|        self._parent = parent
  129|      0|        self._handler = parent._notificationHandler(self._errorSubject).asObservable()
  130|      0|        super.init(observer: observer, cancel: cancel)
  131|      0|    }
  132|       |    
  133|      0|    override func done() {
  134|      0|        if let lastError = self._lastError {
  135|      0|            self.forwardOn(.error(lastError))
  136|      0|            self._lastError = nil
  137|      0|        }
  138|      0|        else {
  139|      0|            self.forwardOn(.completed)
  140|      0|        }
  141|      0|
  142|      0|        self.dispose()
  143|      0|    }
  144|       |    
  145|      0|    override func extract(_ observable: Observable<E>) -> SequenceGenerator? {
  146|      0|        // It is important to always return `nil` here because there are sideffects in the `run` method
  147|      0|        // that are dependant on particular `retryWhen` operator so single operator stack can't be reused in this
  148|      0|        // case.
  149|      0|        return nil
  150|      0|    }
  151|       |
  152|      0|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
  153|      0|        let subscription = SingleAssignmentDisposable()
  154|      0|        let iter = RetryWhenSequenceSinkIter(parent: self, subscription: subscription)
  155|      0|        subscription.setDisposable(source.subscribe(iter))
  156|      0|        return iter
  157|      0|    }
  158|       |
  159|      0|    override func run(_ sources: SequenceGenerator) -> Disposable {
  160|      0|        let triggerSubscription = self._handler.subscribe(self._notifier.asObserver())
  161|      0|        let superSubscription = super.run(sources)
  162|      0|        return Disposables.create(superSubscription, triggerSubscription)
  163|      0|    }
  164|       |}
  165|       |
  166|       |final private class RetryWhenSequence<S: Sequence, TriggerObservable: ObservableType, Error>: Producer<S.Iterator.Element.E> where S.Iterator.Element: ObservableType {
  167|       |    typealias Element = S.Iterator.Element.E
  168|       |    
  169|       |    fileprivate let _sources: S
  170|       |    fileprivate let _notificationHandler: (Observable<Error>) -> TriggerObservable
  171|       |    
  172|      0|    init(sources: S, notificationHandler: @escaping (Observable<Error>) -> TriggerObservable) {
  173|      0|        self._sources = sources
  174|      0|        self._notificationHandler = notificationHandler
  175|      0|    }
  176|       |    
  177|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  178|      0|        let sink = RetryWhenSequenceSink<S, O, TriggerObservable, Error>(parent: self, observer: observer, cancel: cancel)
  179|      0|        let subscription = sink.run((self._sources.makeIterator(), nil))
  180|      0|        return (sink: sink, subscription: subscription)
  181|      0|    }
  182|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Sample.swift:
    1|       |//
    2|       |//  Sample.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Samples the source observable sequence using a sampler observable sequence producing sampling ticks.
   13|       |
   14|       |     Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.
   15|       |
   16|       |     **In case there were no new elements between sampler ticks, no element is sent to the resulting sequence.**
   17|       |
   18|       |     - seealso: [sample operator on reactivex.io](http://reactivex.io/documentation/operators/sample.html)
   19|       |
   20|       |     - parameter sampler: Sampling tick sequence.
   21|       |     - returns: Sampled observable sequence.
   22|       |     */
   23|       |    public func sample<O: ObservableType>(_ sampler: O)
   24|      0|        -> Observable<E> {
   25|      0|            return Sample(source: self.asObservable(), sampler: sampler.asObservable())
   26|      0|    }
   27|       |}
   28|       |
   29|       |final private class SamplerSink<O: ObserverType, SampleType>
   30|       |    : ObserverType
   31|       |    , LockOwnerType
   32|       |    , SynchronizedOnType {
   33|       |    typealias E = SampleType
   34|       |    
   35|       |    typealias Parent = SampleSequenceSink<O, SampleType>
   36|       |    
   37|       |    fileprivate let _parent: Parent
   38|       |
   39|      0|    var _lock: RecursiveLock {
   40|      0|        return self._parent._lock
   41|      0|    }
   42|       |    
   43|      0|    init(parent: Parent) {
   44|      0|        self._parent = parent
   45|      0|    }
   46|       |    
   47|      0|    func on(_ event: Event<E>) {
   48|      0|        self.synchronizedOn(event)
   49|      0|    }
   50|       |
   51|      0|    func _synchronized_on(_ event: Event<E>) {
   52|      0|        switch event {
   53|      0|        case .next, .completed:
   54|      0|            if let element = _parent._element {
   55|      0|                self._parent._element = nil
   56|      0|                self._parent.forwardOn(.next(element))
   57|      0|            }
   58|      0|
   59|      0|            if self._parent._atEnd {
   60|      0|                self._parent.forwardOn(.completed)
   61|      0|                self._parent.dispose()
   62|      0|            }
   63|      0|        case .error(let e):
   64|      0|            self._parent.forwardOn(.error(e))
   65|      0|            self._parent.dispose()
   66|      0|        }
   67|      0|    }
   68|       |}
   69|       |
   70|       |final private class SampleSequenceSink<O: ObserverType, SampleType>
   71|       |    : Sink<O>
   72|       |    , ObserverType
   73|       |    , LockOwnerType
   74|       |    , SynchronizedOnType {
   75|       |    typealias Element = O.E
   76|       |    typealias Parent = Sample<Element, SampleType>
   77|       |    
   78|       |    fileprivate let _parent: Parent
   79|       |
   80|       |    let _lock = RecursiveLock()
   81|       |    
   82|       |    // state
   83|       |    fileprivate var _element = nil as Element?
   84|       |    fileprivate var _atEnd = false
   85|       |    
   86|       |    fileprivate let _sourceSubscription = SingleAssignmentDisposable()
   87|       |    
   88|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   89|      0|        self._parent = parent
   90|      0|        super.init(observer: observer, cancel: cancel)
   91|      0|    }
   92|       |    
   93|      0|    func run() -> Disposable {
   94|      0|        self._sourceSubscription.setDisposable(self._parent._source.subscribe(self))
   95|      0|        let samplerSubscription = self._parent._sampler.subscribe(SamplerSink(parent: self))
   96|      0|        
   97|      0|        return Disposables.create(_sourceSubscription, samplerSubscription)
   98|      0|    }
   99|       |    
  100|      0|    func on(_ event: Event<Element>) {
  101|      0|        self.synchronizedOn(event)
  102|      0|    }
  103|       |
  104|      0|    func _synchronized_on(_ event: Event<Element>) {
  105|      0|        switch event {
  106|      0|        case .next(let element):
  107|      0|            self._element = element
  108|      0|        case .error:
  109|      0|            self.forwardOn(event)
  110|      0|            self.dispose()
  111|      0|        case .completed:
  112|      0|            self._atEnd = true
  113|      0|            self._sourceSubscription.dispose()
  114|      0|        }
  115|      0|    }
  116|       |    
  117|       |}
  118|       |
  119|       |final private class Sample<Element, SampleType>: Producer<Element> {
  120|       |    fileprivate let _source: Observable<Element>
  121|       |    fileprivate let _sampler: Observable<SampleType>
  122|       |
  123|      0|    init(source: Observable<Element>, sampler: Observable<SampleType>) {
  124|      0|        self._source = source
  125|      0|        self._sampler = sampler
  126|      0|    }
  127|       |    
  128|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  129|      0|        let sink = SampleSequenceSink(parent: self, observer: observer, cancel: cancel)
  130|      0|        let subscription = sink.run()
  131|      0|        return (sink: sink, subscription: subscription)
  132|      0|    }
  133|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Scan.swift:
    1|       |//
    2|       |//  Scan.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
   13|       |
   14|       |     For aggregation behavior with no intermediate results, see `reduce`.
   15|       |
   16|       |     - seealso: [scan operator on reactivex.io](http://reactivex.io/documentation/operators/scan.html)
   17|       |
   18|       |     - parameter seed: The initial accumulator value.
   19|       |     - parameter accumulator: An accumulator function to be invoked on each element.
   20|       |     - returns: An observable sequence containing the accumulated values.
   21|       |     */
   22|       |    public func scan<A>(into seed: A, accumulator: @escaping (inout A, E) throws -> Void)
   23|      0|        -> Observable<A> {
   24|      0|        return Scan(source: self.asObservable(), seed: seed, accumulator: accumulator)
   25|      0|    }
   26|       |
   27|       |    /**
   28|       |     Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
   29|       |
   30|       |     For aggregation behavior with no intermediate results, see `reduce`.
   31|       |
   32|       |     - seealso: [scan operator on reactivex.io](http://reactivex.io/documentation/operators/scan.html)
   33|       |
   34|       |     - parameter seed: The initial accumulator value.
   35|       |     - parameter accumulator: An accumulator function to be invoked on each element.
   36|       |     - returns: An observable sequence containing the accumulated values.
   37|       |     */
   38|       |    public func scan<A>(_ seed: A, accumulator: @escaping (A, E) throws -> A)
   39|      0|        -> Observable<A> {
   40|      0|        return Scan(source: self.asObservable(), seed: seed) { acc, element in
   41|      0|            let currentAcc = acc
   42|      0|            acc = try accumulator(currentAcc, element)
   43|      0|        }
   44|      0|    }
   45|       |}
   46|       |
   47|       |final private class ScanSink<ElementType, O: ObserverType>: Sink<O>, ObserverType {
   48|       |    typealias Accumulate = O.E
   49|       |    typealias Parent = Scan<ElementType, Accumulate>
   50|       |    typealias E = ElementType
   51|       |    
   52|       |    fileprivate let _parent: Parent
   53|       |    fileprivate var _accumulate: Accumulate
   54|       |    
   55|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   56|      0|        self._parent = parent
   57|      0|        self._accumulate = parent._seed
   58|      0|        super.init(observer: observer, cancel: cancel)
   59|      0|    }
   60|       |    
   61|      0|    func on(_ event: Event<ElementType>) {
   62|      0|        switch event {
   63|      0|        case .next(let element):
   64|      0|            do {
   65|      0|                try self._parent._accumulator(&self._accumulate, element)
   66|      0|                self.forwardOn(.next(self._accumulate))
   67|      0|            }
   68|      0|            catch let error {
   69|      0|                self.forwardOn(.error(error))
   70|      0|                self.dispose()
   71|      0|            }
   72|      0|        case .error(let error):
   73|      0|            self.forwardOn(.error(error))
   74|      0|            self.dispose()
   75|      0|        case .completed:
   76|      0|            self.forwardOn(.completed)
   77|      0|            self.dispose()
   78|      0|        }
   79|      0|    }
   80|       |    
   81|       |}
   82|       |
   83|       |final private class Scan<Element, Accumulate>: Producer<Accumulate> {
   84|       |    typealias Accumulator = (inout Accumulate, Element) throws -> Void
   85|       |    
   86|       |    fileprivate let _source: Observable<Element>
   87|       |    fileprivate let _seed: Accumulate
   88|       |    fileprivate let _accumulator: Accumulator
   89|       |    
   90|      0|    init(source: Observable<Element>, seed: Accumulate, accumulator: @escaping Accumulator) {
   91|      0|        self._source = source
   92|      0|        self._seed = seed
   93|      0|        self._accumulator = accumulator
   94|      0|    }
   95|       |    
   96|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Accumulate {
   97|      0|        let sink = ScanSink(parent: self, observer: observer, cancel: cancel)
   98|      0|        let subscription = self._source.subscribe(sink)
   99|      0|        return (sink: sink, subscription: subscription)
  100|      0|    }
  101|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Sequence.swift:
    1|       |//
    2|       |//  Sequence.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    // MARK: of
   11|       |
   12|       |    /**
   13|       |     This method creates a new Observable instance with a variable number of elements.
   14|       |
   15|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   16|       |
   17|       |     - parameter elements: Elements to generate.
   18|       |     - parameter scheduler: Scheduler to send elements on. If `nil`, elements are sent immediately on subscription.
   19|       |     - returns: The observable sequence whose elements are pulled from the given arguments.
   20|       |     */
   21|      0|    public static func of(_ elements: E ..., scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
   22|      0|        return ObservableSequence(elements: elements, scheduler: scheduler)
   23|      0|    }
   24|       |}
   25|       |
   26|       |extension ObservableType {
   27|       |    /**
   28|       |     Converts an array to an observable sequence.
   29|       |
   30|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   31|       |
   32|       |     - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
   33|       |     */
   34|      0|    public static func from(_ array: [E], scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
   35|      0|        return ObservableSequence(elements: array, scheduler: scheduler)
   36|      0|    }
   37|       |
   38|       |    /**
   39|       |     Converts a sequence to an observable sequence.
   40|       |
   41|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   42|       |
   43|       |     - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
   44|       |     */
   45|      0|    public static func from<S: Sequence>(_ sequence: S, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> where S.Iterator.Element == E {
   46|      0|        return ObservableSequence(elements: sequence, scheduler: scheduler)
   47|      0|    }
   48|       |}
   49|       |
   50|       |final private class ObservableSequenceSink<S: Sequence, O: ObserverType>: Sink<O> where S.Iterator.Element == O.E {
   51|       |    typealias Parent = ObservableSequence<S>
   52|       |
   53|       |    private let _parent: Parent
   54|       |
   55|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   56|      0|        self._parent = parent
   57|      0|        super.init(observer: observer, cancel: cancel)
   58|      0|    }
   59|       |
   60|      0|    func run() -> Disposable {
   61|      0|        return self._parent._scheduler.scheduleRecursive(self._parent._elements.makeIterator()) { iterator, recurse in
   62|      0|            var mutableIterator = iterator
   63|      0|            if let next = mutableIterator.next() {
   64|      0|                self.forwardOn(.next(next))
   65|      0|                recurse(mutableIterator)
   66|      0|            }
   67|      0|            else {
   68|      0|                self.forwardOn(.completed)
   69|      0|                self.dispose()
   70|      0|            }
   71|      0|        }
   72|      0|    }
   73|       |}
   74|       |
   75|       |final private class ObservableSequence<S: Sequence>: Producer<S.Iterator.Element> {
   76|       |    fileprivate let _elements: S
   77|       |    fileprivate let _scheduler: ImmediateSchedulerType
   78|       |
   79|      0|    init(elements: S, scheduler: ImmediateSchedulerType) {
   80|      0|        self._elements = elements
   81|      0|        self._scheduler = scheduler
   82|      0|    }
   83|       |
   84|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   85|      0|        let sink = ObservableSequenceSink(parent: self, observer: observer, cancel: cancel)
   86|      0|        let subscription = sink.run()
   87|      0|        return (sink: sink, subscription: subscription)
   88|      0|    }
   89|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/ShareReplayScope.swift:
    1|       |//
    2|       |//  ShareReplayScope.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/28/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Subject lifetime scope
   10|       |public enum SubjectLifetimeScope {
   11|       |    /**
   12|       |     **Each connection will have it's own subject instance to store replay events.**
   13|       |     **Connections will be isolated from each another.**
   14|       |
   15|       |     Configures the underlying implementation to behave equivalent to.
   16|       |     
   17|       |     ```
   18|       |     source.multicast(makeSubject: { MySubject() }).refCount()
   19|       |     ```
   20|       |
   21|       |     **This is the recommended default.**
   22|       |
   23|       |     This has the following consequences:
   24|       |     * `retry` or `concat` operators will function as expected because terminating the sequence will clear internal state.
   25|       |     * Each connection to source observable sequence will use it's own subject.
   26|       |     * When the number of subscribers drops from 1 to 0 and connection to source sequence is disposed, subject will be cleared.
   27|       |
   28|       |     
   29|       |     ```
   30|       |     let xs = Observable.deferred { () -> Observable<TimeInterval> in
   31|       |             print("Performing work ...")
   32|       |             return Observable.just(Date().timeIntervalSince1970)
   33|       |         }
   34|       |         .share(replay: 1, scope: .whileConnected)
   35|       |
   36|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   37|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   38|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   39|       |
   40|       |     ```
   41|       |
   42|       |     Notice how time interval is different and `Performing work ...` is printed each time)
   43|       |     
   44|       |     ```
   45|       |     Performing work ...
   46|       |     next 1495998900.82141
   47|       |     completed
   48|       |
   49|       |     Performing work ...
   50|       |     next 1495998900.82359
   51|       |     completed
   52|       |
   53|       |     Performing work ...
   54|       |     next 1495998900.82444
   55|       |     completed
   56|       |
   57|       |
   58|       |     ```
   59|       |     
   60|       |     */
   61|       |    case whileConnected
   62|       |
   63|       |    /**
   64|       |     **One subject will store replay events for all connections to source.**
   65|       |     **Connections won't be isolated from each another.**
   66|       |
   67|       |     Configures the underlying implementation behave equivalent to.
   68|       |
   69|       |     ```
   70|       |     source.multicast(MySubject()).refCount()
   71|       |     ```
   72|       |     
   73|       |     This has the following consequences:
   74|       |     * Using `retry` or `concat` operators after this operator usually isn't advised.
   75|       |     * Each connection to source observable sequence will share the same subject.
   76|       |     * After number of subscribers drops from 1 to 0 and connection to source observable sequence is dispose, this operator will 
   77|       |       continue holding a reference to the same subject.
   78|       |       If at some later moment a new observer initiates a new connection to source it can potentially receive
   79|       |       some of the stale events received during previous connection.
   80|       |     * After source sequence terminates any new observer will always immediately receive replayed elements and terminal event.
   81|       |       No new subscriptions to source observable sequence will be attempted.
   82|       |
   83|       |     ```
   84|       |     let xs = Observable.deferred { () -> Observable<TimeInterval> in
   85|       |             print("Performing work ...")
   86|       |             return Observable.just(Date().timeIntervalSince1970)
   87|       |         }
   88|       |         .share(replay: 1, scope: .forever)
   89|       |
   90|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   91|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   92|       |     _ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
   93|       |     ```
   94|       |     
   95|       |     Notice how time interval is the same, replayed, and `Performing work ...` is printed only once
   96|       |     
   97|       |     ```
   98|       |     Performing work ...
   99|       |     next 1495999013.76356
  100|       |     completed
  101|       |
  102|       |     next 1495999013.76356
  103|       |     completed
  104|       |
  105|       |     next 1495999013.76356
  106|       |     completed
  107|       |     ```
  108|       |     
  109|       |    */
  110|       |    case forever
  111|       |}
  112|       |
  113|       |extension ObservableType {
  114|       |
  115|       |    /**
  116|       |     Returns an observable sequence that **shares a single subscription to the underlying sequence**, and immediately upon subscription replays  elements in buffer.
  117|       |     
  118|       |     This operator is equivalent to:
  119|       |     * `.whileConnected`
  120|       |     ```
  121|       |     // Each connection will have it's own subject instance to store replay events.
  122|       |     // Connections will be isolated from each another.
  123|       |     source.multicast(makeSubject: { Replay.create(bufferSize: replay) }).refCount()
  124|       |     ```
  125|       |     * `.forever`
  126|       |     ```
  127|       |     // One subject will store replay events for all connections to source.
  128|       |     // Connections won't be isolated from each another.
  129|       |     source.multicast(Replay.create(bufferSize: replay)).refCount()
  130|       |     ```
  131|       |     
  132|       |     It uses optimized versions of the operators for most common operations.
  133|       |
  134|       |     - parameter replay: Maximum element count of the replay buffer.
  135|       |     - parameter scope: Lifetime scope of sharing subject. For more information see `SubjectLifetimeScope` enum.
  136|       |
  137|       |     - seealso: [shareReplay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
  138|       |
  139|       |     - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  140|       |     */
  141|       |    public func share(replay: Int = 0, scope: SubjectLifetimeScope = .whileConnected)
  142|      0|        -> Observable<E> {
  143|      0|        switch scope {
  144|      0|        case .forever:
  145|      0|            switch replay {
  146|      0|            case 0: return self.multicast(PublishSubject()).refCount()
  147|      0|            default: return self.multicast(ReplaySubject.create(bufferSize: replay)).refCount()
  148|      0|            }
  149|      0|        case .whileConnected:
  150|      0|            switch replay {
  151|      0|            case 0: return ShareWhileConnected(source: self.asObservable())
  152|      0|            case 1: return ShareReplay1WhileConnected(source: self.asObservable())
  153|      0|            default: return self.multicast(makeSubject: { ReplaySubject.create(bufferSize: replay) }).refCount()
  154|      0|            }
  155|      0|        }
  156|      0|    }
  157|       |}
  158|       |
  159|       |fileprivate final class ShareReplay1WhileConnectedConnection<Element>
  160|       |    : ObserverType
  161|       |    , SynchronizedUnsubscribeType {
  162|       |    typealias E = Element
  163|       |    typealias Observers = AnyObserver<Element>.s
  164|       |    typealias DisposeKey = Observers.KeyType
  165|       |
  166|       |    typealias Parent = ShareReplay1WhileConnected<Element>
  167|       |    private let _parent: Parent
  168|       |    private let _subscription = SingleAssignmentDisposable()
  169|       |
  170|       |    private let _lock: RecursiveLock
  171|       |    private var _disposed: Bool = false
  172|       |    fileprivate var _observers = Observers()
  173|       |    fileprivate var _element: Element?
  174|       |
  175|      0|    init(parent: Parent, lock: RecursiveLock) {
  176|      0|        self._parent = parent
  177|      0|        self._lock = lock
  178|      0|
  179|      0|        #if TRACE_RESOURCES
  180|      0|            _ = Resources.incrementTotal()
  181|      0|        #endif
  182|      0|    }
  183|       |
  184|      0|    final func on(_ event: Event<E>) {
  185|      0|        self._lock.lock()
  186|      0|        let observers = self._synchronized_on(event)
  187|      0|        self._lock.unlock()
  188|      0|        dispatch(observers, event)
  189|      0|    }
  190|       |
  191|       |    final private func _synchronized_on(_ event: Event<E>) -> Observers {
  192|       |        if self._disposed {
  193|       |            return Observers()
  194|       |        }
  195|       |
  196|       |        switch event {
  197|       |        case .next(let element):
  198|       |            self._element = element
  199|       |            return self._observers
  200|       |        case .error, .completed:
  201|       |            let observers = self._observers
  202|       |            self._synchronized_dispose()
  203|       |            return observers
  204|       |        }
  205|       |    }
  206|       |
  207|      0|    final func connect() {
  208|      0|        self._subscription.setDisposable(self._parent._source.subscribe(self))
  209|      0|    }
  210|       |
  211|      0|    final func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  212|      0|        self._lock.lock(); defer { self._lock.unlock() }
  213|      0|        if let element = self._element {
  214|      0|            observer.on(.next(element))
  215|      0|        }
  216|      0|
  217|      0|        let disposeKey = self._observers.insert(observer.on)
  218|      0|
  219|      0|        return SubscriptionDisposable(owner: self, key: disposeKey)
  220|      0|    }
  221|       |
  222|       |    final private func _synchronized_dispose() {
  223|       |        self._disposed = true
  224|       |        if self._parent._connection === self {
  225|       |            self._parent._connection = nil
  226|       |        }
  227|       |        self._observers = Observers()
  228|       |    }
  229|       |
  230|      0|    final func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  231|      0|        self._lock.lock()
  232|      0|        let shouldDisconnect = self._synchronized_unsubscribe(disposeKey)
  233|      0|        self._lock.unlock()
  234|      0|        if shouldDisconnect {
  235|      0|            self._subscription.dispose()
  236|      0|        }
  237|      0|    }
  238|       |
  239|       |    @inline(__always)
  240|       |    final private func _synchronized_unsubscribe(_ disposeKey: DisposeKey) -> Bool {
  241|       |        // if already unsubscribed, just return
  242|       |        if self._observers.removeKey(disposeKey) == nil {
  243|       |            return false
  244|       |        }
  245|       |
  246|       |        if self._observers.count == 0 {
  247|       |            self._synchronized_dispose()
  248|       |            return true
  249|       |        }
  250|       |
  251|       |        return false
  252|       |    }
  253|       |
  254|       |    #if TRACE_RESOURCES
  255|       |        deinit {
  256|       |            _ = Resources.decrementTotal()
  257|       |        }
  258|       |    #endif
  259|       |}
  260|       |
  261|       |// optimized version of share replay for most common case
  262|       |final private class ShareReplay1WhileConnected<Element>
  263|       |    : Observable<Element> {
  264|       |
  265|       |    fileprivate typealias Connection = ShareReplay1WhileConnectedConnection<Element>
  266|       |
  267|       |    fileprivate let _source: Observable<Element>
  268|       |
  269|       |    fileprivate let _lock = RecursiveLock()
  270|       |
  271|       |    fileprivate var _connection: Connection?
  272|       |
  273|      0|    init(source: Observable<Element>) {
  274|      0|        self._source = source
  275|      0|    }
  276|       |
  277|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  278|      0|        self._lock.lock()
  279|      0|
  280|      0|        let connection = self._synchronized_subscribe(observer)
  281|      0|        let count = connection._observers.count
  282|      0|
  283|      0|        let disposable = connection._synchronized_subscribe(observer)
  284|      0|
  285|      0|        self._lock.unlock()
  286|      0|        
  287|      0|        if count == 0 {
  288|      0|            connection.connect()
  289|      0|        }
  290|      0|
  291|      0|        return disposable
  292|      0|    }
  293|       |
  294|       |    @inline(__always)
  295|       |    private func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Connection where O.E == E {
  296|       |        let connection: Connection
  297|       |
  298|       |        if let existingConnection = self._connection {
  299|       |            connection = existingConnection
  300|       |        }
  301|       |        else {
  302|       |            connection = ShareReplay1WhileConnectedConnection<Element>(
  303|       |                parent: self,
  304|       |                lock: self._lock)
  305|       |            self._connection = connection
  306|       |        }
  307|       |
  308|       |        return connection
  309|       |    }
  310|       |}
  311|       |
  312|       |fileprivate final class ShareWhileConnectedConnection<Element>
  313|       |    : ObserverType
  314|       |    , SynchronizedUnsubscribeType {
  315|       |    typealias E = Element
  316|       |    typealias Observers = AnyObserver<Element>.s
  317|       |    typealias DisposeKey = Observers.KeyType
  318|       |
  319|       |    typealias Parent = ShareWhileConnected<Element>
  320|       |    private let _parent: Parent
  321|       |    private let _subscription = SingleAssignmentDisposable()
  322|       |
  323|       |    private let _lock: RecursiveLock
  324|       |    private var _disposed: Bool = false
  325|       |    fileprivate var _observers = Observers()
  326|       |
  327|      0|    init(parent: Parent, lock: RecursiveLock) {
  328|      0|        self._parent = parent
  329|      0|        self._lock = lock
  330|      0|
  331|      0|        #if TRACE_RESOURCES
  332|      0|            _ = Resources.incrementTotal()
  333|      0|        #endif
  334|      0|    }
  335|       |
  336|      0|    final func on(_ event: Event<E>) {
  337|      0|        self._lock.lock()
  338|      0|        let observers = self._synchronized_on(event)
  339|      0|        self._lock.unlock()
  340|      0|        dispatch(observers, event)
  341|      0|    }
  342|       |
  343|       |    final private func _synchronized_on(_ event: Event<E>) -> Observers {
  344|       |        if self._disposed {
  345|       |            return Observers()
  346|       |        }
  347|       |
  348|       |        switch event {
  349|       |        case .next:
  350|       |            return self._observers
  351|       |        case .error, .completed:
  352|       |            let observers = self._observers
  353|       |            self._synchronized_dispose()
  354|       |            return observers
  355|       |        }
  356|       |    }
  357|       |
  358|      0|    final func connect() {
  359|      0|        self._subscription.setDisposable(self._parent._source.subscribe(self))
  360|      0|    }
  361|       |
  362|      0|    final func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  363|      0|        self._lock.lock(); defer { self._lock.unlock() }
  364|      0|
  365|      0|        let disposeKey = self._observers.insert(observer.on)
  366|      0|
  367|      0|        return SubscriptionDisposable(owner: self, key: disposeKey)
  368|      0|    }
  369|       |
  370|       |    final private func _synchronized_dispose() {
  371|       |        self._disposed = true
  372|       |        if self._parent._connection === self {
  373|       |            self._parent._connection = nil
  374|       |        }
  375|       |        self._observers = Observers()
  376|       |    }
  377|       |
  378|      0|    final func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  379|      0|        self._lock.lock()
  380|      0|        let shouldDisconnect = self._synchronized_unsubscribe(disposeKey)
  381|      0|        self._lock.unlock()
  382|      0|        if shouldDisconnect {
  383|      0|            self._subscription.dispose()
  384|      0|        }
  385|      0|    }
  386|       |
  387|       |    @inline(__always)
  388|       |    final private func _synchronized_unsubscribe(_ disposeKey: DisposeKey) -> Bool {
  389|       |        // if already unsubscribed, just return
  390|       |        if self._observers.removeKey(disposeKey) == nil {
  391|       |            return false
  392|       |        }
  393|       |
  394|       |        if self._observers.count == 0 {
  395|       |            self._synchronized_dispose()
  396|       |            return true
  397|       |        }
  398|       |
  399|       |        return false
  400|       |    }
  401|       |
  402|       |    #if TRACE_RESOURCES
  403|       |    deinit {
  404|       |        _ = Resources.decrementTotal()
  405|       |    }
  406|       |    #endif
  407|       |}
  408|       |
  409|       |// optimized version of share replay for most common case
  410|       |final private class ShareWhileConnected<Element>
  411|       |    : Observable<Element> {
  412|       |
  413|       |    fileprivate typealias Connection = ShareWhileConnectedConnection<Element>
  414|       |
  415|       |    fileprivate let _source: Observable<Element>
  416|       |
  417|       |    fileprivate let _lock = RecursiveLock()
  418|       |
  419|       |    fileprivate var _connection: Connection?
  420|       |
  421|      0|    init(source: Observable<Element>) {
  422|      0|        self._source = source
  423|      0|    }
  424|       |
  425|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  426|      0|        self._lock.lock()
  427|      0|
  428|      0|        let connection = self._synchronized_subscribe(observer)
  429|      0|        let count = connection._observers.count
  430|      0|
  431|      0|        let disposable = connection._synchronized_subscribe(observer)
  432|      0|
  433|      0|        self._lock.unlock()
  434|      0|
  435|      0|        if count == 0 {
  436|      0|            connection.connect()
  437|      0|        }
  438|      0|
  439|      0|        return disposable
  440|      0|    }
  441|       |
  442|       |    @inline(__always)
  443|       |    private func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Connection where O.E == E {
  444|       |        let connection: Connection
  445|       |
  446|       |        if let existingConnection = self._connection {
  447|       |            connection = existingConnection
  448|       |        }
  449|       |        else {
  450|       |            connection = ShareWhileConnectedConnection<Element>(
  451|       |                parent: self,
  452|       |                lock: self._lock)
  453|       |            self._connection = connection
  454|       |        }
  455|       |        
  456|       |        return connection
  457|       |    }
  458|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/SingleAsync.swift:
    1|       |//
    2|       |//  SingleAsync.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 09/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     The single operator is similar to first, but throws a `RxError.noElements` or `RxError.moreThanOneElement`
   13|       |     if the source Observable does not emit exactly one element before successfully completing.
   14|       |
   15|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
   16|       |
   17|       |     - returns: An observable sequence that emits a single element or throws an exception if more (or none) of them are emitted.
   18|       |     */
   19|       |    public func single()
   20|      0|        -> Observable<E> {
   21|      0|        return SingleAsync(source: self.asObservable())
   22|      0|    }
   23|       |
   24|       |    /**
   25|       |     The single operator is similar to first, but throws a `RxError.NoElements` or `RxError.MoreThanOneElement`
   26|       |     if the source Observable does not emit exactly one element before successfully completing.
   27|       |
   28|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
   29|       |
   30|       |     - parameter predicate: A function to test each source element for a condition.
   31|       |     - returns: An observable sequence that emits a single element or throws an exception if more (or none) of them are emitted.
   32|       |     */
   33|       |    public func single(_ predicate: @escaping (E) throws -> Bool)
   34|      0|        -> Observable<E> {
   35|      0|        return SingleAsync(source: self.asObservable(), predicate: predicate)
   36|      0|    }
   37|       |}
   38|       |
   39|       |fileprivate final class SingleAsyncSink<O: ObserverType> : Sink<O>, ObserverType {
   40|       |    typealias ElementType = O.E
   41|       |    typealias Parent = SingleAsync<ElementType>
   42|       |    typealias E = ElementType
   43|       |    
   44|       |    private let _parent: Parent
   45|       |    private var _seenValue: Bool = false
   46|       |    
   47|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   48|      0|        self._parent = parent
   49|      0|        super.init(observer: observer, cancel: cancel)
   50|      0|    }
   51|       |    
   52|      0|    func on(_ event: Event<E>) {
   53|      0|        switch event {
   54|      0|        case .next(let value):
   55|      0|            do {
   56|      0|                let forward = try self._parent._predicate?(value) ?? true
   57|      0|                if !forward {
   58|      0|                    return
   59|      0|                }
   60|      0|            }
   61|      0|            catch let error {
   62|      0|                self.forwardOn(.error(error as Swift.Error))
   63|      0|                self.dispose()
   64|      0|                return
   65|      0|            }
   66|      0|
   67|      0|            if self._seenValue {
   68|      0|                self.forwardOn(.error(RxError.moreThanOneElement))
   69|      0|                self.dispose()
   70|      0|                return
   71|      0|            }
   72|      0|
   73|      0|            self._seenValue = true
   74|      0|            self.forwardOn(.next(value))
   75|      0|        case .error:
   76|      0|            self.forwardOn(event)
   77|      0|            self.dispose()
   78|      0|        case .completed:
   79|      0|            if self._seenValue {
   80|      0|                self.forwardOn(.completed)
   81|      0|            } else {
   82|      0|                self.forwardOn(.error(RxError.noElements))
   83|      0|            }
   84|      0|            self.dispose()
   85|      0|        }
   86|      0|    }
   87|       |}
   88|       |
   89|       |final class SingleAsync<Element>: Producer<Element> {
   90|       |    typealias Predicate = (Element) throws -> Bool
   91|       |    
   92|       |    fileprivate let _source: Observable<Element>
   93|       |    fileprivate let _predicate: Predicate?
   94|       |    
   95|      0|    init(source: Observable<Element>, predicate: Predicate? = nil) {
   96|      0|        self._source = source
   97|      0|        self._predicate = predicate
   98|      0|    }
   99|       |    
  100|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  101|      0|        let sink = SingleAsyncSink(parent: self, observer: observer, cancel: cancel)
  102|      0|        let subscription = self._source.subscribe(sink)
  103|      0|        return (sink: sink, subscription: subscription)
  104|      0|    }
  105|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Sink.swift:
    1|       |//
    2|       |//  Sink.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class Sink<O : ObserverType> : Disposable {
   10|       |    fileprivate let _observer: O
   11|       |    fileprivate let _cancel: Cancelable
   12|       |    fileprivate let _disposed = AtomicInt(0)
   13|       |
   14|       |    #if DEBUG
   15|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   16|       |    #endif
   17|       |
   18|      0|    init(observer: O, cancel: Cancelable) {
   19|      0|#if TRACE_RESOURCES
   20|      0|        _ = Resources.incrementTotal()
   21|      0|#endif
   22|      0|        self._observer = observer
   23|      0|        self._cancel = cancel
   24|      0|    }
   25|       |
   26|      0|    final func forwardOn(_ event: Event<O.E>) {
   27|      0|        #if DEBUG
   28|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
   29|      0|            defer { self._synchronizationTracker.unregister() }
   30|      0|        #endif
   31|      0|        if isFlagSet(self._disposed, 1) {
   32|      0|            return
   33|      0|        }
   34|      0|        self._observer.on(event)
   35|      0|    }
   36|       |
   37|      0|    final func forwarder() -> SinkForward<O> {
   38|      0|        return SinkForward(forward: self)
   39|      0|    }
   40|       |
   41|      0|    final var disposed: Bool {
   42|      0|        return isFlagSet(self._disposed, 1)
   43|      0|    }
   44|       |
   45|      0|    func dispose() {
   46|      0|        fetchOr(self._disposed, 1)
   47|      0|        self._cancel.dispose()
   48|      0|    }
   49|       |
   50|      0|    deinit {
   51|      0|#if TRACE_RESOURCES
   52|      0|       _ =  Resources.decrementTotal()
   53|      0|#endif
   54|      0|    }
   55|       |}
   56|       |
   57|       |final class SinkForward<O: ObserverType>: ObserverType {
   58|       |    typealias E = O.E
   59|       |
   60|       |    private let _forward: Sink<O>
   61|       |
   62|      0|    init(forward: Sink<O>) {
   63|      0|        self._forward = forward
   64|      0|    }
   65|       |
   66|      0|    final func on(_ event: Event<E>) {
   67|      0|        switch event {
   68|      0|        case .next:
   69|      0|            self._forward._observer.on(event)
   70|      0|        case .error, .completed:
   71|      0|            self._forward._observer.on(event)
   72|      0|            self._forward._cancel.dispose()
   73|      0|        }
   74|      0|    }
   75|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Skip.swift:
    1|       |//
    2|       |//  Skip.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
   13|       |
   14|       |     - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
   15|       |
   16|       |     - parameter count: The number of elements to skip before returning the remaining elements.
   17|       |     - returns: An observable sequence that contains the elements that occur after the specified index in the input sequence.
   18|       |     */
   19|       |    public func skip(_ count: Int)
   20|      0|        -> Observable<E> {
   21|      0|        return SkipCount(source: self.asObservable(), count: count)
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension ObservableType {
   26|       |
   27|       |    /**
   28|       |     Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   29|       |
   30|       |     - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
   31|       |
   32|       |     - parameter duration: Duration for skipping elements from the start of the sequence.
   33|       |     - parameter scheduler: Scheduler to run the timer on.
   34|       |     - returns: An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
   35|       |     */
   36|       |    public func skip(_ duration: RxTimeInterval, scheduler: SchedulerType)
   37|      0|        -> Observable<E> {
   38|      0|        return SkipTime(source: self.asObservable(), duration: duration, scheduler: scheduler)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// count version
   43|       |
   44|       |final private class SkipCountSink<O: ObserverType>: Sink<O>, ObserverType {
   45|       |    typealias Element = O.E
   46|       |    typealias Parent = SkipCount<Element>
   47|       |    
   48|       |    let parent: Parent
   49|       |    
   50|       |    var remaining: Int
   51|       |    
   52|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   53|      0|        self.parent = parent
   54|      0|        self.remaining = parent.count
   55|      0|        super.init(observer: observer, cancel: cancel)
   56|      0|    }
   57|       |    
   58|      0|    func on(_ event: Event<Element>) {
   59|      0|        switch event {
   60|      0|        case .next(let value):
   61|      0|            
   62|      0|            if self.remaining <= 0 {
   63|      0|                self.forwardOn(.next(value))
   64|      0|            }
   65|      0|            else {
   66|      0|                self.remaining -= 1
   67|      0|            }
   68|      0|        case .error:
   69|      0|            self.forwardOn(event)
   70|      0|            self.dispose()
   71|      0|        case .completed:
   72|      0|            self.forwardOn(event)
   73|      0|            self.dispose()
   74|      0|        }
   75|      0|    }
   76|       |    
   77|       |}
   78|       |
   79|       |final private class SkipCount<Element>: Producer<Element> {
   80|       |    let source: Observable<Element>
   81|       |    let count: Int
   82|       |    
   83|      0|    init(source: Observable<Element>, count: Int) {
   84|      0|        self.source = source
   85|      0|        self.count = count
   86|      0|    }
   87|       |    
   88|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   89|      0|        let sink = SkipCountSink(parent: self, observer: observer, cancel: cancel)
   90|      0|        let subscription = self.source.subscribe(sink)
   91|      0|
   92|      0|        return (sink: sink, subscription: subscription)
   93|      0|    }
   94|       |}
   95|       |
   96|       |// time version
   97|       |
   98|       |final private class SkipTimeSink<ElementType, O: ObserverType>: Sink<O>, ObserverType where O.E == ElementType {
   99|       |    typealias Parent = SkipTime<ElementType>
  100|       |    typealias Element = ElementType
  101|       |
  102|       |    let parent: Parent
  103|       |    
  104|       |    // state
  105|       |    var open = false
  106|       |    
  107|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  108|      0|        self.parent = parent
  109|      0|        super.init(observer: observer, cancel: cancel)
  110|      0|    }
  111|       |    
  112|      0|    func on(_ event: Event<Element>) {
  113|      0|        switch event {
  114|      0|        case .next(let value):
  115|      0|            if self.open {
  116|      0|                self.forwardOn(.next(value))
  117|      0|            }
  118|      0|        case .error:
  119|      0|            self.forwardOn(event)
  120|      0|            self.dispose()
  121|      0|        case .completed:
  122|      0|            self.forwardOn(event)
  123|      0|            self.dispose()
  124|      0|        }
  125|      0|    }
  126|       |    
  127|      0|    func tick() {
  128|      0|        self.open = true
  129|      0|    }
  130|       |    
  131|      0|    func run() -> Disposable {
  132|      0|        let disposeTimer = self.parent.scheduler.scheduleRelative((), dueTime: self.parent.duration) { _ in 
  133|      0|            self.tick()
  134|      0|            return Disposables.create()
  135|      0|        }
  136|      0|        
  137|      0|        let disposeSubscription = self.parent.source.subscribe(self)
  138|      0|        
  139|      0|        return Disposables.create(disposeTimer, disposeSubscription)
  140|      0|    }
  141|       |}
  142|       |
  143|       |final private class SkipTime<Element>: Producer<Element> {
  144|       |    let source: Observable<Element>
  145|       |    let duration: RxTimeInterval
  146|       |    let scheduler: SchedulerType
  147|       |    
  148|      0|    init(source: Observable<Element>, duration: RxTimeInterval, scheduler: SchedulerType) {
  149|      0|        self.source = source
  150|      0|        self.scheduler = scheduler
  151|      0|        self.duration = duration
  152|      0|    }
  153|       |    
  154|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  155|      0|        let sink = SkipTimeSink(parent: self, observer: observer, cancel: cancel)
  156|      0|        let subscription = sink.run()
  157|      0|        return (sink: sink, subscription: subscription)
  158|      0|    }
  159|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/SkipUntil.swift:
    1|       |//
    2|       |//  SkipUntil.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/3/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns the elements from the source observable sequence that are emitted after the other observable sequence produces an element.
   13|       |
   14|       |     - seealso: [skipUntil operator on reactivex.io](http://reactivex.io/documentation/operators/skipuntil.html)
   15|       |
   16|       |     - parameter other: Observable sequence that starts propagation of elements of the source sequence.
   17|       |     - returns: An observable sequence containing the elements of the source sequence that are emitted after the other sequence emits an item.
   18|       |     */
   19|       |    public func skipUntil<O: ObservableType>(_ other: O)
   20|      0|        -> Observable<E> {
   21|      0|        return SkipUntil(source: self.asObservable(), other: other.asObservable())
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class SkipUntilSinkOther<Other, O: ObserverType>
   26|       |    : ObserverType
   27|       |    , LockOwnerType
   28|       |    , SynchronizedOnType {
   29|       |    typealias Parent = SkipUntilSink<Other, O>
   30|       |    typealias E = Other
   31|       |    
   32|       |    fileprivate let _parent: Parent
   33|       |
   34|      0|    var _lock: RecursiveLock {
   35|      0|        return self._parent._lock
   36|      0|    }
   37|       |    
   38|       |    let _subscription = SingleAssignmentDisposable()
   39|       |
   40|      0|    init(parent: Parent) {
   41|      0|        self._parent = parent
   42|      0|        #if TRACE_RESOURCES
   43|      0|            _ = Resources.incrementTotal()
   44|      0|        #endif
   45|      0|    }
   46|       |
   47|      0|    func on(_ event: Event<E>) {
   48|      0|        self.synchronizedOn(event)
   49|      0|    }
   50|       |
   51|      0|    func _synchronized_on(_ event: Event<E>) {
   52|      0|        switch event {
   53|      0|        case .next:
   54|      0|            self._parent._forwardElements = true
   55|      0|            self._subscription.dispose()
   56|      0|        case .error(let e):
   57|      0|            self._parent.forwardOn(.error(e))
   58|      0|            self._parent.dispose()
   59|      0|        case .completed:
   60|      0|            self._subscription.dispose()
   61|      0|        }
   62|      0|    }
   63|       |    
   64|       |    #if TRACE_RESOURCES
   65|       |    deinit {
   66|       |        _ = Resources.decrementTotal()
   67|       |    }
   68|       |    #endif
   69|       |
   70|       |}
   71|       |
   72|       |
   73|       |final private class SkipUntilSink<Other, O: ObserverType>
   74|       |    : Sink<O>
   75|       |    , ObserverType
   76|       |    , LockOwnerType
   77|       |    , SynchronizedOnType {
   78|       |    typealias E = O.E
   79|       |    typealias Parent = SkipUntil<E, Other>
   80|       |    
   81|       |    let _lock = RecursiveLock()
   82|       |    fileprivate let _parent: Parent
   83|       |    fileprivate var _forwardElements = false
   84|       |    
   85|       |    fileprivate let _sourceSubscription = SingleAssignmentDisposable()
   86|       |
   87|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   88|      0|        self._parent = parent
   89|      0|        super.init(observer: observer, cancel: cancel)
   90|      0|    }
   91|       |    
   92|      0|    func on(_ event: Event<E>) {
   93|      0|        self.synchronizedOn(event)
   94|      0|    }
   95|       |
   96|      0|    func _synchronized_on(_ event: Event<E>) {
   97|      0|        switch event {
   98|      0|        case .next:
   99|      0|            if self._forwardElements {
  100|      0|                self.forwardOn(event)
  101|      0|            }
  102|      0|        case .error:
  103|      0|            self.forwardOn(event)
  104|      0|            self.dispose()
  105|      0|        case .completed:
  106|      0|            if self._forwardElements {
  107|      0|                self.forwardOn(event)
  108|      0|            }
  109|      0|            self.dispose()
  110|      0|        }
  111|      0|    }
  112|       |    
  113|      0|    func run() -> Disposable {
  114|      0|        let sourceSubscription = self._parent._source.subscribe(self)
  115|      0|        let otherObserver = SkipUntilSinkOther(parent: self)
  116|      0|        let otherSubscription = self._parent._other.subscribe(otherObserver)
  117|      0|        self._sourceSubscription.setDisposable(sourceSubscription)
  118|      0|        otherObserver._subscription.setDisposable(otherSubscription)
  119|      0|        
  120|      0|        return Disposables.create(_sourceSubscription, otherObserver._subscription)
  121|      0|    }
  122|       |}
  123|       |
  124|       |final private class SkipUntil<Element, Other>: Producer<Element> {
  125|       |    
  126|       |    fileprivate let _source: Observable<Element>
  127|       |    fileprivate let _other: Observable<Other>
  128|       |    
  129|      0|    init(source: Observable<Element>, other: Observable<Other>) {
  130|      0|        self._source = source
  131|      0|        self._other = other
  132|      0|    }
  133|       |    
  134|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  135|      0|        let sink = SkipUntilSink(parent: self, observer: observer, cancel: cancel)
  136|      0|        let subscription = sink.run()
  137|      0|        return (sink: sink, subscription: subscription)
  138|      0|    }
  139|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/SkipWhile.swift:
    1|       |//
    2|       |//  SkipWhile.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/9/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
   13|       |
   14|       |     - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html)
   15|       |
   16|       |     - parameter predicate: A function to test each element for a condition.
   17|       |     - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
   18|       |     */
   19|      0|    public func skipWhile(_ predicate: @escaping (E) throws -> Bool) -> Observable<E> {
   20|      0|        return SkipWhile(source: self.asObservable(), predicate: predicate)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class SkipWhileSink<O: ObserverType>: Sink<O>, ObserverType {
   25|       |    typealias Element = O.E
   26|       |    typealias Parent = SkipWhile<Element>
   27|       |
   28|       |    fileprivate let _parent: Parent
   29|       |    fileprivate var _running = false
   30|       |
   31|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   32|      0|        self._parent = parent
   33|      0|        super.init(observer: observer, cancel: cancel)
   34|      0|    }
   35|       |
   36|      0|    func on(_ event: Event<Element>) {
   37|      0|        switch event {
   38|      0|        case .next(let value):
   39|      0|            if !self._running {
   40|      0|                do {
   41|      0|                    self._running = try !self._parent._predicate(value)
   42|      0|                } catch let e {
   43|      0|                    self.forwardOn(.error(e))
   44|      0|                    self.dispose()
   45|      0|                    return
   46|      0|                }
   47|      0|            }
   48|      0|
   49|      0|            if self._running {
   50|      0|                self.forwardOn(.next(value))
   51|      0|            }
   52|      0|        case .error, .completed:
   53|      0|            self.forwardOn(event)
   54|      0|            self.dispose()
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|       |final private class SkipWhile<Element>: Producer<Element> {
   60|       |    typealias Predicate = (Element) throws -> Bool
   61|       |
   62|       |    fileprivate let _source: Observable<Element>
   63|       |    fileprivate let _predicate: Predicate
   64|       |
   65|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
   66|      0|        self._source = source
   67|      0|        self._predicate = predicate
   68|      0|    }
   69|       |
   70|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   71|      0|        let sink = SkipWhileSink(parent: self, observer: observer, cancel: cancel)
   72|      0|        let subscription = self._source.subscribe(sink)
   73|      0|        return (sink: sink, subscription: subscription)
   74|      0|    }
   75|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/StartWith.swift:
    1|       |//
    2|       |//  StartWith.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Prepends a sequence of values to an observable sequence.
   13|       |
   14|       |     - seealso: [startWith operator on reactivex.io](http://reactivex.io/documentation/operators/startwith.html)
   15|       |
   16|       |     - parameter elements: Elements to prepend to the specified sequence.
   17|       |     - returns: The source sequence prepended with the specified values.
   18|       |     */
   19|       |    public func startWith(_ elements: E ...)
   20|      0|        -> Observable<E> {
   21|      0|            return StartWith(source: self.asObservable(), elements: elements)
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class StartWith<Element>: Producer<Element> {
   26|       |    let elements: [Element]
   27|       |    let source: Observable<Element>
   28|       |
   29|      0|    init(source: Observable<Element>, elements: [Element]) {
   30|      0|        self.source = source
   31|      0|        self.elements = elements
   32|      0|        super.init()
   33|      0|    }
   34|       |
   35|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   36|      0|        for e in self.elements {
   37|      0|            observer.on(.next(e))
   38|      0|        }
   39|      0|
   40|      0|        return (sink: Disposables.create(), subscription: self.source.subscribe(observer))
   41|      0|    }
   42|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/SubscribeOn.swift:
    1|       |//
    2|       |//  SubscribeOn.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Wraps the source sequence in order to run its subscription and unsubscription logic on the specified
   13|       |     scheduler.
   14|       |
   15|       |     This operation is not commonly used.
   16|       |
   17|       |     This only performs the side-effects of subscription and unsubscription on the specified scheduler.
   18|       |
   19|       |     In order to invoke observer callbacks on a `scheduler`, use `observeOn`.
   20|       |
   21|       |     - seealso: [subscribeOn operator on reactivex.io](http://reactivex.io/documentation/operators/subscribeon.html)
   22|       |
   23|       |     - parameter scheduler: Scheduler to perform subscription and unsubscription actions on.
   24|       |     - returns: The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
   25|       |     */
   26|       |    public func subscribeOn(_ scheduler: ImmediateSchedulerType)
   27|      0|        -> Observable<E> {
   28|      0|        return SubscribeOn(source: self, scheduler: scheduler)
   29|      0|    }
   30|       |}
   31|       |
   32|       |final private class SubscribeOnSink<Ob: ObservableType, O: ObserverType>: Sink<O>, ObserverType where Ob.E == O.E {
   33|       |    typealias Element = O.E
   34|       |    typealias Parent = SubscribeOn<Ob>
   35|       |    
   36|       |    let parent: Parent
   37|       |    
   38|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   39|      0|        self.parent = parent
   40|      0|        super.init(observer: observer, cancel: cancel)
   41|      0|    }
   42|       |    
   43|      0|    func on(_ event: Event<Element>) {
   44|      0|        self.forwardOn(event)
   45|      0|        
   46|      0|        if event.isStopEvent {
   47|      0|            self.dispose()
   48|      0|        }
   49|      0|    }
   50|       |    
   51|      0|    func run() -> Disposable {
   52|      0|        let disposeEverything = SerialDisposable()
   53|      0|        let cancelSchedule = SingleAssignmentDisposable()
   54|      0|        
   55|      0|        disposeEverything.disposable = cancelSchedule
   56|      0|        
   57|      0|        let disposeSchedule = self.parent.scheduler.schedule(()) { _ -> Disposable in
   58|      0|            let subscription = self.parent.source.subscribe(self)
   59|      0|            disposeEverything.disposable = ScheduledDisposable(scheduler: self.parent.scheduler, disposable: subscription)
   60|      0|            return Disposables.create()
   61|      0|        }
   62|      0|
   63|      0|        cancelSchedule.setDisposable(disposeSchedule)
   64|      0|    
   65|      0|        return disposeEverything
   66|      0|    }
   67|       |}
   68|       |
   69|       |final private class SubscribeOn<Ob: ObservableType>: Producer<Ob.E> {
   70|       |    let source: Ob
   71|       |    let scheduler: ImmediateSchedulerType
   72|       |    
   73|      0|    init(source: Ob, scheduler: ImmediateSchedulerType) {
   74|      0|        self.source = source
   75|      0|        self.scheduler = scheduler
   76|      0|    }
   77|       |    
   78|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Ob.E {
   79|      0|        let sink = SubscribeOnSink(parent: self, observer: observer, cancel: cancel)
   80|      0|        let subscription = sink.run()
   81|      0|        return (sink: sink, subscription: subscription)
   82|      0|    }
   83|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Switch.swift:
    1|       |//
    2|       |//  Switch.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Projects each element of an observable sequence into a new sequence of observable sequences and then
   12|       |     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
   13|       |
   14|       |     It is a combination of `map` + `switchLatest` operator
   15|       |
   16|       |     - seealso: [flatMapLatest operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
   17|       |
   18|       |     - parameter selector: A transform function to apply to each element.
   19|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an
   20|       |     Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   21|       |     */
   22|       |    public func flatMapLatest<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
   23|      0|        -> Observable<O.E> {
   24|      0|            return FlatMapLatest(source: self.asObservable(), selector: selector)
   25|      0|    }
   26|       |}
   27|       |
   28|       |extension ObservableType where E : ObservableConvertibleType {
   29|       |
   30|       |    /**
   31|       |     Transforms an observable sequence of observable sequences into an observable sequence
   32|       |     producing values only from the most recent observable sequence.
   33|       |
   34|       |     Each time a new inner observable sequence is received, unsubscribe from the
   35|       |     previous inner observable sequence.
   36|       |
   37|       |     - seealso: [switch operator on reactivex.io](http://reactivex.io/documentation/operators/switch.html)
   38|       |
   39|       |     - returns: The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   40|       |     */
   41|      0|    public func switchLatest() -> Observable<E.E> {
   42|      0|        return Switch(source: self.asObservable())
   43|      0|    }
   44|       |}
   45|       |
   46|       |private class SwitchSink<SourceType, S: ObservableConvertibleType, O: ObserverType>
   47|       |    : Sink<O>
   48|       |    , ObserverType where S.E == O.E {
   49|       |    typealias E = SourceType
   50|       |
   51|       |    fileprivate let _subscriptions: SingleAssignmentDisposable = SingleAssignmentDisposable()
   52|       |    fileprivate let _innerSubscription: SerialDisposable = SerialDisposable()
   53|       |
   54|       |    let _lock = RecursiveLock()
   55|       |    
   56|       |    // state
   57|       |    fileprivate var _stopped = false
   58|       |    fileprivate var _latest = 0
   59|       |    fileprivate var _hasLatest = false
   60|       |    
   61|      0|    override init(observer: O, cancel: Cancelable) {
   62|      0|        super.init(observer: observer, cancel: cancel)
   63|      0|    }
   64|       |    
   65|      0|    func run(_ source: Observable<SourceType>) -> Disposable {
   66|      0|        let subscription = source.subscribe(self)
   67|      0|        self._subscriptions.setDisposable(subscription)
   68|      0|        return Disposables.create(_subscriptions, _innerSubscription)
   69|      0|    }
   70|       |
   71|      0|    func performMap(_ element: SourceType) throws -> S {
   72|      0|        rxAbstractMethod()
   73|      0|    }
   74|       |
   75|       |    @inline(__always)
   76|      0|    final private func nextElementArrived(element: E) -> (Int, Observable<S.E>)? {
   77|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   78|      0|            do {
   79|      0|                let observable = try self.performMap(element).asObservable()
   80|      0|                self._hasLatest = true
   81|      0|                self._latest = self._latest &+ 1
   82|      0|                return (self._latest, observable)
   83|      0|            }
   84|      0|            catch let error {
   85|      0|                self.forwardOn(.error(error))
   86|      0|                self.dispose()
   87|      0|            }
   88|      0|
   89|      0|            return nil
   90|      0|        // }
   91|      0|    }
   92|       |
   93|      0|    func on(_ event: Event<E>) {
   94|      0|        switch event {
   95|      0|        case .next(let element):
   96|      0|            if let (latest, observable) = self.nextElementArrived(element: element) {
   97|      0|                let d = SingleAssignmentDisposable()
   98|      0|                self._innerSubscription.disposable = d
   99|      0|                   
  100|      0|                let observer = SwitchSinkIter(parent: self, id: latest, _self: d)
  101|      0|                let disposable = observable.subscribe(observer)
  102|      0|                d.setDisposable(disposable)
  103|      0|            }
  104|      0|        case .error(let error):
  105|      0|            self._lock.lock(); defer { self._lock.unlock() }
  106|      0|            self.forwardOn(.error(error))
  107|      0|            self.dispose()
  108|      0|        case .completed:
  109|      0|            self._lock.lock(); defer { self._lock.unlock() }
  110|      0|            self._stopped = true
  111|      0|            
  112|      0|            self._subscriptions.dispose()
  113|      0|            
  114|      0|            if !self._hasLatest {
  115|      0|                self.forwardOn(.completed)
  116|      0|                self.dispose()
  117|      0|            }
  118|      0|        }
  119|      0|    }
  120|       |}
  121|       |
  122|       |final private class SwitchSinkIter<SourceType, S: ObservableConvertibleType, O: ObserverType>
  123|       |    : ObserverType
  124|       |    , LockOwnerType
  125|       |    , SynchronizedOnType where S.E == O.E {
  126|       |    typealias E = S.E
  127|       |    typealias Parent = SwitchSink<SourceType, S, O>
  128|       |    
  129|       |    fileprivate let _parent: Parent
  130|       |    fileprivate let _id: Int
  131|       |    fileprivate let _self: Disposable
  132|       |
  133|      0|    var _lock: RecursiveLock {
  134|      0|        return self._parent._lock
  135|      0|    }
  136|       |
  137|      0|    init(parent: Parent, id: Int, _self: Disposable) {
  138|      0|        self._parent = parent
  139|      0|        self._id = id
  140|      0|        self._self = _self
  141|      0|    }
  142|       |    
  143|      0|    func on(_ event: Event<E>) {
  144|      0|        self.synchronizedOn(event)
  145|      0|    }
  146|       |
  147|      0|    func _synchronized_on(_ event: Event<E>) {
  148|      0|        switch event {
  149|      0|        case .next: break
  150|      0|        case .error, .completed:
  151|      0|            self._self.dispose()
  152|      0|        }
  153|      0|        
  154|      0|        if self._parent._latest != self._id {
  155|      0|            return
  156|      0|        }
  157|      0|       
  158|      0|        switch event {
  159|      0|        case .next:
  160|      0|            self._parent.forwardOn(event)
  161|      0|        case .error:
  162|      0|            self._parent.forwardOn(event)
  163|      0|            self._parent.dispose()
  164|      0|        case .completed:
  165|      0|            self._parent._hasLatest = false
  166|      0|            if self._parent._stopped {
  167|      0|                self._parent.forwardOn(event)
  168|      0|                self._parent.dispose()
  169|      0|            }
  170|      0|        }
  171|      0|    }
  172|       |}
  173|       |
  174|       |// MARK: Specializations
  175|       |
  176|       |final private class SwitchIdentitySink<S: ObservableConvertibleType, O: ObserverType>: SwitchSink<S, S, O> where O.E == S.E {
  177|      0|    override init(observer: O, cancel: Cancelable) {
  178|      0|        super.init(observer: observer, cancel: cancel)
  179|      0|    }
  180|       |
  181|      0|    override func performMap(_ element: S) throws -> S {
  182|      0|        return element
  183|      0|    }
  184|       |}
  185|       |
  186|       |final private class MapSwitchSink<SourceType, S: ObservableConvertibleType, O: ObserverType>: SwitchSink<SourceType, S, O> where O.E == S.E {
  187|       |    typealias Selector = (SourceType) throws -> S
  188|       |
  189|       |    fileprivate let _selector: Selector
  190|       |
  191|      0|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
  192|      0|        self._selector = selector
  193|      0|        super.init(observer: observer, cancel: cancel)
  194|      0|    }
  195|       |
  196|      0|    override func performMap(_ element: SourceType) throws -> S {
  197|      0|        return try self._selector(element)
  198|      0|    }
  199|       |}
  200|       |
  201|       |// MARK: Producers
  202|       |
  203|       |final private class Switch<S: ObservableConvertibleType>: Producer<S.E> {
  204|       |    fileprivate let _source: Observable<S>
  205|       |    
  206|      0|    init(source: Observable<S>) {
  207|      0|        self._source = source
  208|      0|    }
  209|       |    
  210|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  211|      0|        let sink = SwitchIdentitySink<S, O>(observer: observer, cancel: cancel)
  212|      0|        let subscription = sink.run(self._source)
  213|      0|        return (sink: sink, subscription: subscription)
  214|      0|    }
  215|       |}
  216|       |
  217|       |final private class FlatMapLatest<SourceType, S: ObservableConvertibleType>: Producer<S.E> {
  218|       |    typealias Selector = (SourceType) throws -> S
  219|       |
  220|       |    fileprivate let _source: Observable<SourceType>
  221|       |    fileprivate let _selector: Selector
  222|       |
  223|      0|    init(source: Observable<SourceType>, selector: @escaping Selector) {
  224|      0|        self._source = source
  225|      0|        self._selector = selector
  226|      0|    }
  227|       |
  228|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  229|      0|        let sink = MapSwitchSink<SourceType, S, O>(selector: self._selector, observer: observer, cancel: cancel)
  230|      0|        let subscription = sink.run(self._source)
  231|      0|        return (sink: sink, subscription: subscription)
  232|      0|    }
  233|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/SwitchIfEmpty.swift:
    1|       |//
    2|       |//  SwitchIfEmpty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 23/12/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Returns the elements of the specified sequence or `switchTo` sequence if the sequence is empty.
   12|       |
   13|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
   14|       |
   15|       |     - parameter switchTo: Observable sequence being returned when source sequence is empty.
   16|       |     - returns: Observable sequence that contains elements from switchTo sequence if source is empty, otherwise returns source sequence elements.
   17|       |     */
   18|      0|    public func ifEmpty(switchTo other: Observable<E>) -> Observable<E> {
   19|      0|        return SwitchIfEmpty(source: self.asObservable(), ifEmpty: other)
   20|      0|    }
   21|       |}
   22|       |
   23|       |final private class SwitchIfEmpty<Element>: Producer<Element> {
   24|       |    
   25|       |    private let _source: Observable<E>
   26|       |    private let _ifEmpty: Observable<E>
   27|       |    
   28|      0|    init(source: Observable<E>, ifEmpty: Observable<E>) {
   29|      0|        self._source = source
   30|      0|        self._ifEmpty = ifEmpty
   31|      0|    }
   32|       |    
   33|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   34|      0|        let sink = SwitchIfEmptySink(ifEmpty: self._ifEmpty,
   35|      0|                                     observer: observer,
   36|      0|                                     cancel: cancel)
   37|      0|        let subscription = sink.run(self._source.asObservable())
   38|      0|        
   39|      0|        return (sink: sink, subscription: subscription)
   40|      0|    }
   41|       |}
   42|       |
   43|       |final private class SwitchIfEmptySink<O: ObserverType>: Sink<O>
   44|       |    , ObserverType {
   45|       |    typealias E = O.E
   46|       |    
   47|       |    private let _ifEmpty: Observable<E>
   48|       |    private var _isEmpty = true
   49|       |    private let _ifEmptySubscription = SingleAssignmentDisposable()
   50|       |    
   51|      0|    init(ifEmpty: Observable<E>, observer: O, cancel: Cancelable) {
   52|      0|        self._ifEmpty = ifEmpty
   53|      0|        super.init(observer: observer, cancel: cancel)
   54|      0|    }
   55|       |    
   56|       |    func run(_ source: Observable<O.E>) -> Disposable {
   57|       |        let subscription = source.subscribe(self)
   58|       |        return Disposables.create(subscription, _ifEmptySubscription)
   59|       |    }
   60|       |    
   61|      0|    func on(_ event: Event<E>) {
   62|      0|        switch event {
   63|      0|        case .next:
   64|      0|            self._isEmpty = false
   65|      0|            self.forwardOn(event)
   66|      0|        case .error:
   67|      0|            self.forwardOn(event)
   68|      0|            self.dispose()
   69|      0|        case .completed:
   70|      0|            guard self._isEmpty else {
   71|      0|                self.forwardOn(.completed)
   72|      0|                self.dispose()
   73|      0|                return
   74|      0|            }
   75|      0|            let ifEmptySink = SwitchIfEmptySinkIter(parent: self)
   76|      0|            self._ifEmptySubscription.setDisposable(self._ifEmpty.subscribe(ifEmptySink))
   77|      0|        }
   78|      0|    }
   79|       |}
   80|       |
   81|       |final private class SwitchIfEmptySinkIter<O: ObserverType>
   82|       |    : ObserverType {
   83|       |    typealias E = O.E
   84|       |    typealias Parent = SwitchIfEmptySink<O>
   85|       |    
   86|       |    private let _parent: Parent
   87|       |
   88|      0|    init(parent: Parent) {
   89|      0|        self._parent = parent
   90|      0|    }
   91|       |    
   92|      0|    func on(_ event: Event<E>) {
   93|      0|        switch event {
   94|      0|        case .next:
   95|      0|            self._parent.forwardOn(event)
   96|      0|        case .error:
   97|      0|            self._parent.forwardOn(event)
   98|      0|            self._parent.dispose()
   99|      0|        case .completed:
  100|      0|            self._parent.forwardOn(event)
  101|      0|            self._parent.dispose()
  102|      0|        }
  103|      0|    }
  104|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Take.swift:
    1|       |//
    2|       |//  Take.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns a specified number of contiguous elements from the start of an observable sequence.
   13|       |
   14|       |     - seealso: [take operator on reactivex.io](http://reactivex.io/documentation/operators/take.html)
   15|       |
   16|       |     - parameter count: The number of elements to return.
   17|       |     - returns: An observable sequence that contains the specified number of elements from the start of the input sequence.
   18|       |     */
   19|       |    public func take(_ count: Int)
   20|      0|        -> Observable<E> {
   21|      0|        if count == 0 {
   22|      0|            return Observable.empty()
   23|      0|        }
   24|      0|        else {
   25|      0|            return TakeCount(source: self.asObservable(), count: count)
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |extension ObservableType {
   31|       |
   32|       |    /**
   33|       |     Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
   34|       |
   35|       |     - seealso: [take operator on reactivex.io](http://reactivex.io/documentation/operators/take.html)
   36|       |
   37|       |     - parameter duration: Duration for taking elements from the start of the sequence.
   38|       |     - parameter scheduler: Scheduler to run the timer on.
   39|       |     - returns: An observable sequence with the elements taken during the specified duration from the start of the source sequence.
   40|       |     */
   41|       |    public func take(_ duration: RxTimeInterval, scheduler: SchedulerType)
   42|      0|        -> Observable<E> {
   43|      0|        return TakeTime(source: self.asObservable(), duration: duration, scheduler: scheduler)
   44|      0|    }
   45|       |}
   46|       |
   47|       |// count version
   48|       |
   49|       |final private class TakeCountSink<O: ObserverType>: Sink<O>, ObserverType {
   50|       |    typealias E = O.E
   51|       |    typealias Parent = TakeCount<E>
   52|       |    
   53|       |    private let _parent: Parent
   54|       |    
   55|       |    private var _remaining: Int
   56|       |    
   57|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   58|      0|        self._parent = parent
   59|      0|        self._remaining = parent._count
   60|      0|        super.init(observer: observer, cancel: cancel)
   61|      0|    }
   62|       |    
   63|      0|    func on(_ event: Event<E>) {
   64|      0|        switch event {
   65|      0|        case .next(let value):
   66|      0|            
   67|      0|            if self._remaining > 0 {
   68|      0|                self._remaining -= 1
   69|      0|                
   70|      0|                self.forwardOn(.next(value))
   71|      0|            
   72|      0|                if self._remaining == 0 {
   73|      0|                    self.forwardOn(.completed)
   74|      0|                    self.dispose()
   75|      0|                }
   76|      0|            }
   77|      0|        case .error:
   78|      0|            self.forwardOn(event)
   79|      0|            self.dispose()
   80|      0|        case .completed:
   81|      0|            self.forwardOn(event)
   82|      0|            self.dispose()
   83|      0|        }
   84|      0|    }
   85|       |    
   86|       |}
   87|       |
   88|       |final private class TakeCount<Element>: Producer<Element> {
   89|       |    fileprivate let _source: Observable<Element>
   90|       |    fileprivate let _count: Int
   91|       |    
   92|      0|    init(source: Observable<Element>, count: Int) {
   93|      0|        if count < 0 {
   94|      0|            rxFatalError("count can't be negative")
   95|      0|        }
   96|      0|        self._source = source
   97|      0|        self._count = count
   98|      0|    }
   99|       |    
  100|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  101|      0|        let sink = TakeCountSink(parent: self, observer: observer, cancel: cancel)
  102|      0|        let subscription = self._source.subscribe(sink)
  103|      0|        return (sink: sink, subscription: subscription)
  104|      0|    }
  105|       |}
  106|       |
  107|       |// time version
  108|       |
  109|       |final private class TakeTimeSink<ElementType, O: ObserverType>
  110|       |    : Sink<O>
  111|       |    , LockOwnerType
  112|       |    , ObserverType
  113|       |    , SynchronizedOnType where O.E == ElementType {
  114|       |    typealias Parent = TakeTime<ElementType>
  115|       |    typealias E = ElementType
  116|       |
  117|       |    fileprivate let _parent: Parent
  118|       |    
  119|       |    let _lock = RecursiveLock()
  120|       |    
  121|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  122|      0|        self._parent = parent
  123|      0|        super.init(observer: observer, cancel: cancel)
  124|      0|    }
  125|       |    
  126|      0|    func on(_ event: Event<E>) {
  127|      0|        self.synchronizedOn(event)
  128|      0|    }
  129|       |
  130|      0|    func _synchronized_on(_ event: Event<E>) {
  131|      0|        switch event {
  132|      0|        case .next(let value):
  133|      0|            self.forwardOn(.next(value))
  134|      0|        case .error:
  135|      0|            self.forwardOn(event)
  136|      0|            self.dispose()
  137|      0|        case .completed:
  138|      0|            self.forwardOn(event)
  139|      0|            self.dispose()
  140|      0|        }
  141|      0|    }
  142|       |    
  143|      0|    func tick() {
  144|      0|        self._lock.lock(); defer { self._lock.unlock() }
  145|      0|
  146|      0|        self.forwardOn(.completed)
  147|      0|        self.dispose()
  148|      0|    }
  149|       |    
  150|      0|    func run() -> Disposable {
  151|      0|        let disposeTimer = self._parent._scheduler.scheduleRelative((), dueTime: self._parent._duration) { _ in
  152|      0|            self.tick()
  153|      0|            return Disposables.create()
  154|      0|        }
  155|      0|        
  156|      0|        let disposeSubscription = self._parent._source.subscribe(self)
  157|      0|        
  158|      0|        return Disposables.create(disposeTimer, disposeSubscription)
  159|      0|    }
  160|       |}
  161|       |
  162|       |final private class TakeTime<Element>: Producer<Element> {
  163|       |    typealias TimeInterval = RxTimeInterval
  164|       |    
  165|       |    fileprivate let _source: Observable<Element>
  166|       |    fileprivate let _duration: TimeInterval
  167|       |    fileprivate let _scheduler: SchedulerType
  168|       |    
  169|      0|    init(source: Observable<Element>, duration: TimeInterval, scheduler: SchedulerType) {
  170|      0|        self._source = source
  171|      0|        self._scheduler = scheduler
  172|      0|        self._duration = duration
  173|      0|    }
  174|       |    
  175|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  176|      0|        let sink = TakeTimeSink(parent: self, observer: observer, cancel: cancel)
  177|      0|        let subscription = sink.run()
  178|      0|        return (sink: sink, subscription: subscription)
  179|      0|    }
  180|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/TakeLast.swift:
    1|       |//
    2|       |//  TakeLast.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 25/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns a specified number of contiguous elements from the end of an observable sequence.
   13|       |
   14|       |     This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
   15|       |
   16|       |     - seealso: [takeLast operator on reactivex.io](http://reactivex.io/documentation/operators/takelast.html)
   17|       |
   18|       |     - parameter count: Number of elements to take from the end of the source sequence.
   19|       |     - returns: An observable sequence containing the specified number of elements from the end of the source sequence.
   20|       |     */
   21|       |    public func takeLast(_ count: Int)
   22|      0|        -> Observable<E> {
   23|      0|        return TakeLast(source: self.asObservable(), count: count)
   24|      0|    }
   25|       |}
   26|       |
   27|       |final private class TakeLastSink<O: ObserverType>: Sink<O>, ObserverType {
   28|       |    typealias E = O.E
   29|       |    typealias Parent = TakeLast<E>
   30|       |    
   31|       |    private let _parent: Parent
   32|       |    
   33|       |    private var _elements: Queue<E>
   34|       |    
   35|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   36|      0|        self._parent = parent
   37|      0|        self._elements = Queue<E>(capacity: parent._count + 1)
   38|      0|        super.init(observer: observer, cancel: cancel)
   39|      0|    }
   40|       |    
   41|      0|    func on(_ event: Event<E>) {
   42|      0|        switch event {
   43|      0|        case .next(let value):
   44|      0|            self._elements.enqueue(value)
   45|      0|            if self._elements.count > self._parent._count {
   46|      0|                _ = self._elements.dequeue()
   47|      0|            }
   48|      0|        case .error:
   49|      0|            self.forwardOn(event)
   50|      0|            self.dispose()
   51|      0|        case .completed:
   52|      0|            for e in self._elements {
   53|      0|                self.forwardOn(.next(e))
   54|      0|            }
   55|      0|            self.forwardOn(.completed)
   56|      0|            self.dispose()
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|       |final private class TakeLast<Element>: Producer<Element> {
   62|       |    fileprivate let _source: Observable<Element>
   63|       |    fileprivate let _count: Int
   64|       |    
   65|      0|    init(source: Observable<Element>, count: Int) {
   66|      0|        if count < 0 {
   67|      0|            rxFatalError("count can't be negative")
   68|      0|        }
   69|      0|        self._source = source
   70|      0|        self._count = count
   71|      0|    }
   72|       |    
   73|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   74|      0|        let sink = TakeLastSink(parent: self, observer: observer, cancel: cancel)
   75|      0|        let subscription = self._source.subscribe(sink)
   76|      0|        return (sink: sink, subscription: subscription)
   77|      0|    }
   78|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/TakeUntil.swift:
    1|       |//
    2|       |//  TakeUntil.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns the elements from the source observable sequence until the other observable sequence produces an element.
   13|       |
   14|       |     - seealso: [takeUntil operator on reactivex.io](http://reactivex.io/documentation/operators/takeuntil.html)
   15|       |
   16|       |     - parameter other: Observable sequence that terminates propagation of elements of the source sequence.
   17|       |     - returns: An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
   18|       |     */
   19|       |    public func takeUntil<O: ObservableType>(_ other: O)
   20|      0|        -> Observable<E> {
   21|      0|        return TakeUntil(source: self.asObservable(), other: other.asObservable())
   22|      0|    }
   23|       |
   24|       |    /**
   25|       |     Returns elements from an observable sequence until the specified condition is true.
   26|       |
   27|       |     - seealso: [takeUntil operator on reactivex.io](http://reactivex.io/documentation/operators/takeuntil.html)
   28|       |
   29|       |     - parameter behavior: Whether or not to include the last element matching the predicate.
   30|       |     - parameter predicate: A function to test each element for a condition.
   31|       |     - returns: An observable sequence that contains the elements from the input sequence that occur before the element at which the test passes.
   32|       |     */
   33|       |    public func takeUntil(_ behavior: TakeUntilBehavior,
   34|       |                          predicate: @escaping (E) throws -> Bool)
   35|      0|        -> Observable<E> {
   36|      0|        return TakeUntilPredicate(source: self.asObservable(),
   37|      0|                                  behavior: behavior,
   38|      0|                                  predicate: predicate)
   39|      0|    }
   40|       |}
   41|       |
   42|       |/// Behaviors for the `takeUntil(_ behavior:predicate:)` operator.
   43|       |public enum TakeUntilBehavior {
   44|       |    /// Include the last element matching the predicate.
   45|       |    case inclusive
   46|       |
   47|       |    /// Exclude the last element matching the predicate.
   48|       |    case exclusive
   49|       |}
   50|       |
   51|       |// MARK: - TakeUntil Observable
   52|       |final private class TakeUntilSinkOther<Other, O: ObserverType>
   53|       |    : ObserverType
   54|       |    , LockOwnerType
   55|       |    , SynchronizedOnType {
   56|       |    typealias Parent = TakeUntilSink<Other, O>
   57|       |    typealias E = Other
   58|       |    
   59|       |    fileprivate let _parent: Parent
   60|       |
   61|      0|    var _lock: RecursiveLock {
   62|      0|        return self._parent._lock
   63|      0|    }
   64|       |    
   65|       |    fileprivate let _subscription = SingleAssignmentDisposable()
   66|       |    
   67|      0|    init(parent: Parent) {
   68|      0|        self._parent = parent
   69|      0|#if TRACE_RESOURCES
   70|      0|        _ = Resources.incrementTotal()
   71|      0|#endif
   72|      0|    }
   73|       |    
   74|      0|    func on(_ event: Event<E>) {
   75|      0|        self.synchronizedOn(event)
   76|      0|    }
   77|       |
   78|      0|    func _synchronized_on(_ event: Event<E>) {
   79|      0|        switch event {
   80|      0|        case .next:
   81|      0|            self._parent.forwardOn(.completed)
   82|      0|            self._parent.dispose()
   83|      0|        case .error(let e):
   84|      0|            self._parent.forwardOn(.error(e))
   85|      0|            self._parent.dispose()
   86|      0|        case .completed:
   87|      0|            self._subscription.dispose()
   88|      0|        }
   89|      0|    }
   90|       |    
   91|       |#if TRACE_RESOURCES
   92|       |    deinit {
   93|       |        _ = Resources.decrementTotal()
   94|       |    }
   95|       |#endif
   96|       |}
   97|       |
   98|       |final private class TakeUntilSink<Other, O: ObserverType>
   99|       |    : Sink<O>
  100|       |    , LockOwnerType
  101|       |    , ObserverType
  102|       |    , SynchronizedOnType {
  103|       |    typealias E = O.E
  104|       |    typealias Parent = TakeUntil<E, Other>
  105|       |    
  106|       |    fileprivate let _parent: Parent
  107|       | 
  108|       |    let _lock = RecursiveLock()
  109|       |    
  110|       |    
  111|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  112|      0|        self._parent = parent
  113|      0|        super.init(observer: observer, cancel: cancel)
  114|      0|    }
  115|       |    
  116|      0|    func on(_ event: Event<E>) {
  117|      0|        self.synchronizedOn(event)
  118|      0|    }
  119|       |
  120|      0|    func _synchronized_on(_ event: Event<E>) {
  121|      0|        switch event {
  122|      0|        case .next:
  123|      0|            self.forwardOn(event)
  124|      0|        case .error:
  125|      0|            self.forwardOn(event)
  126|      0|            self.dispose()
  127|      0|        case .completed:
  128|      0|            self.forwardOn(event)
  129|      0|            self.dispose()
  130|      0|        }
  131|      0|    }
  132|       |    
  133|      0|    func run() -> Disposable {
  134|      0|        let otherObserver = TakeUntilSinkOther(parent: self)
  135|      0|        let otherSubscription = self._parent._other.subscribe(otherObserver)
  136|      0|        otherObserver._subscription.setDisposable(otherSubscription)
  137|      0|        let sourceSubscription = self._parent._source.subscribe(self)
  138|      0|        
  139|      0|        return Disposables.create(sourceSubscription, otherObserver._subscription)
  140|      0|    }
  141|       |}
  142|       |
  143|       |final private class TakeUntil<Element, Other>: Producer<Element> {
  144|       |    
  145|       |    fileprivate let _source: Observable<Element>
  146|       |    fileprivate let _other: Observable<Other>
  147|       |    
  148|      0|    init(source: Observable<Element>, other: Observable<Other>) {
  149|      0|        self._source = source
  150|      0|        self._other = other
  151|      0|    }
  152|       |    
  153|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  154|      0|        let sink = TakeUntilSink(parent: self, observer: observer, cancel: cancel)
  155|      0|        let subscription = sink.run()
  156|      0|        return (sink: sink, subscription: subscription)
  157|      0|    }
  158|       |}
  159|       |
  160|       |// MARK: - TakeUntil Predicate
  161|       |final private class TakeUntilPredicateSink<O: ObserverType>
  162|       |    : Sink<O>, ObserverType {
  163|       |    typealias Element = O.E
  164|       |    typealias Parent = TakeUntilPredicate<Element>
  165|       |
  166|       |    fileprivate let _parent: Parent
  167|       |    fileprivate var _running = true
  168|       |
  169|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  170|      0|        self._parent = parent
  171|      0|        super.init(observer: observer, cancel: cancel)
  172|      0|    }
  173|       |
  174|      0|    func on(_ event: Event<Element>) {
  175|      0|        switch event {
  176|      0|        case .next(let value):
  177|      0|            if !self._running {
  178|      0|                return
  179|      0|            }
  180|      0|
  181|      0|            do {
  182|      0|                self._running = try !self._parent._predicate(value)
  183|      0|            } catch let e {
  184|      0|                self.forwardOn(.error(e))
  185|      0|                self.dispose()
  186|      0|                return
  187|      0|            }
  188|      0|
  189|      0|            if self._running {
  190|      0|                self.forwardOn(.next(value))
  191|      0|            } else {
  192|      0|                if self._parent._behavior == .inclusive {
  193|      0|                    self.forwardOn(.next(value))
  194|      0|                }
  195|      0|
  196|      0|                self.forwardOn(.completed)
  197|      0|                self.dispose()
  198|      0|            }
  199|      0|        case .error, .completed:
  200|      0|            self.forwardOn(event)
  201|      0|            self.dispose()
  202|      0|        }
  203|      0|    }
  204|       |
  205|       |}
  206|       |
  207|       |final private class TakeUntilPredicate<Element>: Producer<Element> {
  208|       |    typealias Predicate = (Element) throws -> Bool
  209|       |
  210|       |    fileprivate let _source: Observable<Element>
  211|       |    fileprivate let _predicate: Predicate
  212|       |    fileprivate let _behavior: TakeUntilBehavior
  213|       |
  214|       |    init(source: Observable<Element>,
  215|       |         behavior: TakeUntilBehavior,
  216|      0|         predicate: @escaping Predicate) {
  217|      0|        self._source = source
  218|      0|        self._behavior = behavior
  219|      0|        self._predicate = predicate
  220|      0|    }
  221|       |
  222|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  223|      0|        let sink = TakeUntilPredicateSink(parent: self, observer: observer, cancel: cancel)
  224|      0|        let subscription = self._source.subscribe(sink)
  225|      0|        return (sink: sink, subscription: subscription)
  226|      0|    }
  227|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/TakeWhile.swift:
    1|       |//
    2|       |//  TakeWhile.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Returns elements from an observable sequence as long as a specified condition is true.
   13|       |
   14|       |     - seealso: [takeWhile operator on reactivex.io](http://reactivex.io/documentation/operators/takewhile.html)
   15|       |
   16|       |     - parameter predicate: A function to test each element for a condition.
   17|       |     - returns: An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   18|       |     */
   19|       |    public func takeWhile(_ predicate: @escaping (E) throws -> Bool)
   20|      0|        -> Observable<E> {
   21|      0|        return TakeWhile(source: self.asObservable(), predicate: predicate)
   22|      0|    }
   23|       |}
   24|       |
   25|       |final private class TakeWhileSink<O: ObserverType>
   26|       |    : Sink<O>
   27|       |    , ObserverType {
   28|       |    typealias Element = O.E
   29|       |    typealias Parent = TakeWhile<Element>
   30|       |
   31|       |    fileprivate let _parent: Parent
   32|       |
   33|       |    fileprivate var _running = true
   34|       |
   35|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   36|      0|        self._parent = parent
   37|      0|        super.init(observer: observer, cancel: cancel)
   38|      0|    }
   39|       |    
   40|      0|    func on(_ event: Event<Element>) {
   41|      0|        switch event {
   42|      0|        case .next(let value):
   43|      0|            if !self._running {
   44|      0|                return
   45|      0|            }
   46|      0|            
   47|      0|            do {
   48|      0|                self._running = try self._parent._predicate(value)
   49|      0|            } catch let e {
   50|      0|                self.forwardOn(.error(e))
   51|      0|                self.dispose()
   52|      0|                return
   53|      0|            }
   54|      0|            
   55|      0|            if self._running {
   56|      0|                self.forwardOn(.next(value))
   57|      0|            } else {
   58|      0|                self.forwardOn(.completed)
   59|      0|                self.dispose()
   60|      0|            }
   61|      0|        case .error, .completed:
   62|      0|            self.forwardOn(event)
   63|      0|            self.dispose()
   64|      0|        }
   65|      0|    }
   66|       |    
   67|       |}
   68|       |
   69|       |final private class TakeWhile<Element>: Producer<Element> {
   70|       |    typealias Predicate = (Element) throws -> Bool
   71|       |
   72|       |    fileprivate let _source: Observable<Element>
   73|       |    fileprivate let _predicate: Predicate
   74|       |
   75|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
   76|      0|        self._source = source
   77|      0|        self._predicate = predicate
   78|      0|    }
   79|       |
   80|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   81|      0|        let sink = TakeWhileSink(parent: self, observer: observer, cancel: cancel)
   82|      0|        let subscription = self._source.subscribe(sink)
   83|      0|        return (sink: sink, subscription: subscription)
   84|      0|    }
   85|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Throttle.swift:
    1|       |//
    2|       |//  Throttle.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |extension ObservableType {
   12|       |
   13|       |    /**
   14|       |     Returns an Observable that emits the first and the latest item emitted by the source Observable during sequential time windows of a specified duration.
   15|       |
   16|       |     This operator makes sure that no two elements are emitted in less then dueTime.
   17|       |
   18|       |     - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
   19|       |
   20|       |     - parameter dueTime: Throttling duration for each element.
   21|       |     - parameter latest: Should latest element received in a dueTime wide time window since last element emission be emitted.
   22|       |     - parameter scheduler: Scheduler to run the throttle timers on.
   23|       |     - returns: The throttled sequence.
   24|       |     */
   25|       |    public func throttle(_ dueTime: RxTimeInterval, latest: Bool = true, scheduler: SchedulerType)
   26|      0|        -> Observable<E> {
   27|      0|        return Throttle(source: self.asObservable(), dueTime: dueTime, latest: latest, scheduler: scheduler)
   28|      0|    }
   29|       |}
   30|       |
   31|       |final private class ThrottleSink<O: ObserverType>
   32|       |    : Sink<O>
   33|       |    , ObserverType
   34|       |    , LockOwnerType
   35|       |    , SynchronizedOnType {
   36|       |    typealias Element = O.E
   37|       |    typealias ParentType = Throttle<Element>
   38|       |    
   39|       |    private let _parent: ParentType
   40|       |    
   41|       |    let _lock = RecursiveLock()
   42|       |    
   43|       |    // state
   44|       |    private var _lastUnsentElement: Element?
   45|       |    private var _lastSentTime: Date?
   46|       |    private var _completed: Bool = false
   47|       |
   48|       |    let cancellable = SerialDisposable()
   49|       |    
   50|      0|    init(parent: ParentType, observer: O, cancel: Cancelable) {
   51|      0|        self._parent = parent
   52|      0|        
   53|      0|        super.init(observer: observer, cancel: cancel)
   54|      0|    }
   55|       |    
   56|      0|    func run() -> Disposable {
   57|      0|        let subscription = self._parent._source.subscribe(self)
   58|      0|        
   59|      0|        return Disposables.create(subscription, cancellable)
   60|      0|    }
   61|       |
   62|      0|    func on(_ event: Event<Element>) {
   63|      0|        self.synchronizedOn(event)
   64|      0|    }
   65|       |
   66|      0|    func _synchronized_on(_ event: Event<Element>) {
   67|      0|        switch event {
   68|      0|        case .next(let element):
   69|      0|            let now = self._parent._scheduler.now
   70|      0|
   71|      0|            let timeIntervalSinceLast: RxTimeInterval
   72|      0|
   73|      0|            if let lastSendingTime = self._lastSentTime {
   74|      0|                timeIntervalSinceLast = now.timeIntervalSince(lastSendingTime)
   75|      0|            }
   76|      0|            else {
   77|      0|                timeIntervalSinceLast = self._parent._dueTime
   78|      0|            }
   79|      0|
   80|      0|            let couldSendNow = timeIntervalSinceLast >= self._parent._dueTime
   81|      0|
   82|      0|            if couldSendNow {
   83|      0|                self.sendNow(element: element)
   84|      0|                return
   85|      0|            }
   86|      0|
   87|      0|            if !self._parent._latest {
   88|      0|                return
   89|      0|            }
   90|      0|
   91|      0|            let isThereAlreadyInFlightRequest = self._lastUnsentElement != nil
   92|      0|            
   93|      0|            self._lastUnsentElement = element
   94|      0|
   95|      0|            if isThereAlreadyInFlightRequest {
   96|      0|                return
   97|      0|            }
   98|      0|
   99|      0|            let scheduler = self._parent._scheduler
  100|      0|            let dueTime = self._parent._dueTime
  101|      0|
  102|      0|            let d = SingleAssignmentDisposable()
  103|      0|            self.cancellable.disposable = d
  104|      0|
  105|      0|            d.setDisposable(scheduler.scheduleRelative(0, dueTime: dueTime - timeIntervalSinceLast, action: self.propagate))
  106|      0|        case .error:
  107|      0|            self._lastUnsentElement = nil
  108|      0|            self.forwardOn(event)
  109|      0|            self.dispose()
  110|      0|        case .completed:
  111|      0|            if self._lastUnsentElement != nil {
  112|      0|                self._completed = true
  113|      0|            }
  114|      0|            else {
  115|      0|                self.forwardOn(.completed)
  116|      0|                self.dispose()
  117|      0|            }
  118|      0|        }
  119|      0|    }
  120|       |
  121|       |    private func sendNow(element: Element) {
  122|       |        self._lastUnsentElement = nil
  123|       |        self.forwardOn(.next(element))
  124|       |        // in case element processing takes a while, this should give some more room
  125|       |        self._lastSentTime = self._parent._scheduler.now
  126|       |    }
  127|       |    
  128|       |    func propagate(_: Int) -> Disposable {
  129|       |        self._lock.lock(); defer { self._lock.unlock() } // {
  130|       |            if let lastUnsentElement = self._lastUnsentElement {
  131|       |                self.sendNow(element: lastUnsentElement)
  132|       |            }
  133|       |
  134|       |            if self._completed {
  135|       |                self.forwardOn(.completed)
  136|       |                self.dispose()
  137|       |            }
  138|       |        // }
  139|       |        return Disposables.create()
  140|       |    }
  141|       |}
  142|       |
  143|       |final private class Throttle<Element>: Producer<Element> {
  144|       |    fileprivate let _source: Observable<Element>
  145|       |    fileprivate let _dueTime: RxTimeInterval
  146|       |    fileprivate let _latest: Bool
  147|       |    fileprivate let _scheduler: SchedulerType
  148|       |
  149|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, latest: Bool, scheduler: SchedulerType) {
  150|      0|        self._source = source
  151|      0|        self._dueTime = dueTime
  152|      0|        self._latest = latest
  153|      0|        self._scheduler = scheduler
  154|      0|    }
  155|       |    
  156|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  157|      0|        let sink = ThrottleSink(parent: self, observer: observer, cancel: cancel)
  158|      0|        let subscription = sink.run()
  159|      0|        return (sink: sink, subscription: subscription)
  160|      0|    }
  161|       |    
  162|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Timeout.swift:
    1|       |//
    2|       |//  Timeout.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 13/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Applies a timeout policy for each element in the observable sequence. If the next element isn't received within the specified timeout duration starting from its predecessor, a TimeoutError is propagated to the observer.
   13|       |
   14|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
   15|       |
   16|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
   17|       |     - parameter scheduler: Scheduler to run the timeout timer on.
   18|       |     - returns: An observable sequence with a `RxError.timeout` in case of a timeout.
   19|       |     */
   20|       |    public func timeout(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   21|      0|        -> Observable<E> {
   22|      0|            return Timeout(source: self.asObservable(), dueTime: dueTime, other: Observable.error(RxError.timeout), scheduler: scheduler)
   23|      0|    }
   24|       |
   25|       |    /**
   26|       |     Applies a timeout policy for each element in the observable sequence, using the specified scheduler to run timeout timers. If the next element isn't received within the specified timeout duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
   27|       |
   28|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
   29|       |
   30|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
   31|       |     - parameter other: Sequence to return in case of a timeout.
   32|       |     - parameter scheduler: Scheduler to run the timeout timer on.
   33|       |     - returns: The source sequence switching to the other sequence in case of a timeout.
   34|       |     */
   35|       |    public func timeout<O: ObservableConvertibleType>(_ dueTime: RxTimeInterval, other: O, scheduler: SchedulerType)
   36|      0|        -> Observable<E> where E == O.E {
   37|      0|            return Timeout(source: self.asObservable(), dueTime: dueTime, other: other.asObservable(), scheduler: scheduler)
   38|      0|    }
   39|       |}
   40|       |
   41|       |final private class TimeoutSink<O: ObserverType>: Sink<O>, LockOwnerType, ObserverType {
   42|       |    typealias E = O.E
   43|       |    typealias Parent = Timeout<E>
   44|       |    
   45|       |    private let _parent: Parent
   46|       |    
   47|       |    let _lock = RecursiveLock()
   48|       |
   49|       |    private let _timerD = SerialDisposable()
   50|       |    private let _subscription = SerialDisposable()
   51|       |    
   52|       |    private var _id = 0
   53|       |    private var _switched = false
   54|       |    
   55|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   56|      0|        self._parent = parent
   57|      0|        super.init(observer: observer, cancel: cancel)
   58|      0|    }
   59|       |    
   60|      0|    func run() -> Disposable {
   61|      0|        let original = SingleAssignmentDisposable()
   62|      0|        self._subscription.disposable = original
   63|      0|        
   64|      0|        self._createTimeoutTimer()
   65|      0|        
   66|      0|        original.setDisposable(self._parent._source.subscribe(self))
   67|      0|        
   68|      0|        return Disposables.create(_subscription, _timerD)
   69|      0|    }
   70|       |
   71|      0|    func on(_ event: Event<E>) {
   72|      0|        switch event {
   73|      0|        case .next:
   74|      0|            var onNextWins = false
   75|      0|            
   76|      0|            self._lock.performLocked {
   77|      0|                onNextWins = !self._switched
   78|      0|                if onNextWins {
   79|      0|                    self._id = self._id &+ 1
   80|      0|                }
   81|      0|            }
   82|      0|            
   83|      0|            if onNextWins {
   84|      0|                self.forwardOn(event)
   85|      0|                self._createTimeoutTimer()
   86|      0|            }
   87|      0|        case .error, .completed:
   88|      0|            var onEventWins = false
   89|      0|            
   90|      0|            self._lock.performLocked {
   91|      0|                onEventWins = !self._switched
   92|      0|                if onEventWins {
   93|      0|                    self._id = self._id &+ 1
   94|      0|                }
   95|      0|            }
   96|      0|            
   97|      0|            if onEventWins {
   98|      0|                self.forwardOn(event)
   99|      0|                self.dispose()
  100|      0|            }
  101|      0|        }
  102|      0|    }
  103|       |    
  104|       |    private func _createTimeoutTimer() {
  105|       |        if self._timerD.isDisposed {
  106|       |            return
  107|       |        }
  108|       |        
  109|       |        let nextTimer = SingleAssignmentDisposable()
  110|       |        self._timerD.disposable = nextTimer
  111|       |        
  112|      0|        let disposeSchedule = self._parent._scheduler.scheduleRelative(self._id, dueTime: self._parent._dueTime) { state in
  113|      0|            
  114|      0|            var timerWins = false
  115|      0|            
  116|      0|            self._lock.performLocked {
  117|      0|                self._switched = (state == self._id)
  118|      0|                timerWins = self._switched
  119|      0|            }
  120|      0|            
  121|      0|            if timerWins {
  122|      0|                self._subscription.disposable = self._parent._other.subscribe(self.forwarder())
  123|      0|            }
  124|      0|            
  125|      0|            return Disposables.create()
  126|      0|        }
  127|       |
  128|       |        nextTimer.setDisposable(disposeSchedule)
  129|       |    }
  130|       |}
  131|       |
  132|       |
  133|       |final private class Timeout<Element>: Producer<Element> {
  134|       |    fileprivate let _source: Observable<Element>
  135|       |    fileprivate let _dueTime: RxTimeInterval
  136|       |    fileprivate let _other: Observable<Element>
  137|       |    fileprivate let _scheduler: SchedulerType
  138|       |    
  139|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, other: Observable<Element>, scheduler: SchedulerType) {
  140|      0|        self._source = source
  141|      0|        self._dueTime = dueTime
  142|      0|        self._other = other
  143|      0|        self._scheduler = scheduler
  144|      0|    }
  145|       |    
  146|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  147|      0|        let sink = TimeoutSink(parent: self, observer: observer, cancel: cancel)
  148|      0|        let subscription = sink.run()
  149|      0|        return (sink: sink, subscription: subscription)
  150|      0|    }
  151|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Timer.swift:
    1|       |//
    2|       |//  Timer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType where E : RxAbstractInteger {
   10|       |    /**
   11|       |     Returns an observable sequence that produces a value after each period, using the specified scheduler to run timers and to send out observer messages.
   12|       |
   13|       |     - seealso: [interval operator on reactivex.io](http://reactivex.io/documentation/operators/interval.html)
   14|       |
   15|       |     - parameter period: Period for producing the values in the resulting sequence.
   16|       |     - parameter scheduler: Scheduler to run the timer on.
   17|       |     - returns: An observable sequence that produces a value after each period.
   18|       |     */
   19|       |    public static func interval(_ period: RxTimeInterval, scheduler: SchedulerType)
   20|      0|        -> Observable<E> {
   21|      0|        return Timer(
   22|      0|            dueTime: period,
   23|      0|            period: period,
   24|      0|            scheduler: scheduler
   25|      0|        )
   26|      0|    }
   27|       |}
   28|       |
   29|       |extension ObservableType where E: RxAbstractInteger {
   30|       |    /**
   31|       |     Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
   32|       |
   33|       |     - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
   34|       |
   35|       |     - parameter dueTime: Relative time at which to produce the first value.
   36|       |     - parameter period: Period to produce subsequent values.
   37|       |     - parameter scheduler: Scheduler to run timers on.
   38|       |     - returns: An observable sequence that produces a value after due time has elapsed and then each period.
   39|       |     */
   40|       |    public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval? = nil, scheduler: SchedulerType)
   41|      0|        -> Observable<E> {
   42|      0|        return Timer(
   43|      0|            dueTime: dueTime,
   44|      0|            period: period,
   45|      0|            scheduler: scheduler
   46|      0|        )
   47|      0|    }
   48|       |}
   49|       |
   50|       |import Foundation
   51|       |
   52|       |final private class TimerSink<O: ObserverType> : Sink<O> where O.E : RxAbstractInteger  {
   53|       |    typealias Parent = Timer<O.E>
   54|       |
   55|       |    private let _parent: Parent
   56|       |    private let _lock = RecursiveLock()
   57|       |
   58|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   59|      0|        self._parent = parent
   60|      0|        super.init(observer: observer, cancel: cancel)
   61|      0|    }
   62|       |
   63|      0|    func run() -> Disposable {
   64|      0|        return self._parent._scheduler.schedulePeriodic(0 as O.E, startAfter: self._parent._dueTime, period: self._parent._period!) { state in
   65|      0|            self._lock.lock(); defer { self._lock.unlock() }
   66|      0|            self.forwardOn(.next(state))
   67|      0|            return state &+ 1
   68|      0|        }
   69|      0|    }
   70|       |}
   71|       |
   72|       |final private class TimerOneOffSink<O: ObserverType>: Sink<O> where O.E: RxAbstractInteger {
   73|       |    typealias Parent = Timer<O.E>
   74|       |
   75|       |    private let _parent: Parent
   76|       |
   77|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   78|      0|        self._parent = parent
   79|      0|        super.init(observer: observer, cancel: cancel)
   80|      0|    }
   81|       |
   82|      0|    func run() -> Disposable {
   83|      0|        return self._parent._scheduler.scheduleRelative(self, dueTime: self._parent._dueTime) { [unowned self] _ -> Disposable in
   84|      0|            self.forwardOn(.next(0))
   85|      0|            self.forwardOn(.completed)
   86|      0|            self.dispose()
   87|      0|
   88|      0|            return Disposables.create()
   89|      0|        }
   90|      0|    }
   91|       |}
   92|       |
   93|       |final private class Timer<E: RxAbstractInteger>: Producer<E> {
   94|       |    fileprivate let _scheduler: SchedulerType
   95|       |    fileprivate let _dueTime: RxTimeInterval
   96|       |    fileprivate let _period: RxTimeInterval?
   97|       |
   98|      0|    init(dueTime: RxTimeInterval, period: RxTimeInterval?, scheduler: SchedulerType) {
   99|      0|        self._scheduler = scheduler
  100|      0|        self._dueTime = dueTime
  101|      0|        self._period = period
  102|      0|    }
  103|       |
  104|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
  105|      0|        if self._period != nil {
  106|      0|            let sink = TimerSink(parent: self, observer: observer, cancel: cancel)
  107|      0|            let subscription = sink.run()
  108|      0|            return (sink: sink, subscription: subscription)
  109|      0|        }
  110|      0|        else {
  111|      0|            let sink = TimerOneOffSink(parent: self, observer: observer, cancel: cancel)
  112|      0|            let subscription = sink.run()
  113|      0|            return (sink: sink, subscription: subscription)
  114|      0|        }
  115|      0|    }
  116|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/ToArray.swift:
    1|       |//
    2|       |//  ToArray.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 20/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |extension ObservableType {
   11|       |
   12|       |    /**
   13|       |    Converts an Observable into another Observable that emits the whole sequence as a single array and then terminates.
   14|       |    
   15|       |    For aggregation behavior see `reduce`.
   16|       |
   17|       |    - seealso: [toArray operator on reactivex.io](http://reactivex.io/documentation/operators/to.html)
   18|       |    
   19|       |    - returns: An observable sequence containing all the emitted elements as array.
   20|       |    */
   21|       |    public func toArray()
   22|      0|        -> Observable<[E]> {
   23|      0|        return ToArray(source: self.asObservable())
   24|      0|    }
   25|       |}
   26|       |
   27|       |final private class ToArraySink<SourceType, O: ObserverType>: Sink<O>, ObserverType where O.E == [SourceType] {
   28|       |    typealias Parent = ToArray<SourceType>
   29|       |    
   30|       |    let _parent: Parent
   31|       |    var _list = [SourceType]()
   32|       |    
   33|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   34|      0|        self._parent = parent
   35|      0|        
   36|      0|        super.init(observer: observer, cancel: cancel)
   37|      0|    }
   38|       |    
   39|      0|    func on(_ event: Event<SourceType>) {
   40|      0|        switch event {
   41|      0|        case .next(let value):
   42|      0|            self._list.append(value)
   43|      0|        case .error(let e):
   44|      0|            self.forwardOn(.error(e))
   45|      0|            self.dispose()
   46|      0|        case .completed:
   47|      0|            self.forwardOn(.next(self._list))
   48|      0|            self.forwardOn(.completed)
   49|      0|            self.dispose()
   50|      0|        }
   51|      0|    }
   52|       |}
   53|       |
   54|       |final private class ToArray<SourceType>: Producer<[SourceType]> {
   55|       |    let _source: Observable<SourceType>
   56|       |
   57|      0|    init(source: Observable<SourceType>) {
   58|      0|        self._source = source
   59|      0|    }
   60|       |    
   61|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == [SourceType] {
   62|      0|        let sink = ToArraySink(parent: self, observer: observer, cancel: cancel)
   63|      0|        let subscription = self._source.subscribe(sink)
   64|      0|        return (sink: sink, subscription: subscription)
   65|      0|    }
   66|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Using.swift:
    1|       |//
    2|       |//  Using.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
   12|       |
   13|       |     - seealso: [using operator on reactivex.io](http://reactivex.io/documentation/operators/using.html)
   14|       |
   15|       |     - parameter resourceFactory: Factory function to obtain a resource object.
   16|       |     - parameter observableFactory: Factory function to obtain an observable sequence that depends on the obtained resource.
   17|       |     - returns: An observable sequence whose lifetime controls the lifetime of the dependent resource object.
   18|       |     */
   19|      0|    public static func using<Resource: Disposable>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> Observable<E>) -> Observable<E> {
   20|      0|        return Using(resourceFactory: resourceFactory, observableFactory: observableFactory)
   21|      0|    }
   22|       |}
   23|       |
   24|       |final private class UsingSink<ResourceType: Disposable, O: ObserverType>: Sink<O>, ObserverType {
   25|       |    typealias SourceType = O.E
   26|       |    typealias Parent = Using<SourceType, ResourceType>
   27|       |
   28|       |    private let _parent: Parent
   29|       |    
   30|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   31|      0|        self._parent = parent
   32|      0|        super.init(observer: observer, cancel: cancel)
   33|      0|    }
   34|       |    
   35|      0|    func run() -> Disposable {
   36|      0|        var disposable = Disposables.create()
   37|      0|        
   38|      0|        do {
   39|      0|            let resource = try self._parent._resourceFactory()
   40|      0|            disposable = resource
   41|      0|            let source = try self._parent._observableFactory(resource)
   42|      0|            
   43|      0|            return Disposables.create(
   44|      0|                source.subscribe(self),
   45|      0|                disposable
   46|      0|            )
   47|      0|        } catch let error {
   48|      0|            return Disposables.create(
   49|      0|                Observable.error(error).subscribe(self),
   50|      0|                disposable
   51|      0|            )
   52|      0|        }
   53|      0|    }
   54|       |    
   55|      0|    func on(_ event: Event<SourceType>) {
   56|      0|        switch event {
   57|      0|        case let .next(value):
   58|      0|            self.forwardOn(.next(value))
   59|      0|        case let .error(error):
   60|      0|            self.forwardOn(.error(error))
   61|      0|            self.dispose()
   62|      0|        case .completed:
   63|      0|            self.forwardOn(.completed)
   64|      0|            self.dispose()
   65|      0|        }
   66|      0|    }
   67|       |}
   68|       |
   69|       |final private class Using<SourceType, ResourceType: Disposable>: Producer<SourceType> {
   70|       |    
   71|       |    typealias E = SourceType
   72|       |    
   73|       |    typealias ResourceFactory = () throws -> ResourceType
   74|       |    typealias ObservableFactory = (ResourceType) throws -> Observable<SourceType>
   75|       |    
   76|       |    fileprivate let _resourceFactory: ResourceFactory
   77|       |    fileprivate let _observableFactory: ObservableFactory
   78|       |    
   79|       |    
   80|      0|    init(resourceFactory: @escaping ResourceFactory, observableFactory: @escaping ObservableFactory) {
   81|      0|        self._resourceFactory = resourceFactory
   82|      0|        self._observableFactory = observableFactory
   83|      0|    }
   84|       |    
   85|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   86|      0|        let sink = UsingSink(parent: self, observer: observer, cancel: cancel)
   87|      0|        let subscription = sink.run()
   88|      0|        return (sink: sink, subscription: subscription)
   89|      0|    }
   90|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Window.swift:
    1|       |//
    2|       |//  Window.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 29/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Projects each element of an observable sequence into a window that is completed when either it’s full or a given amount of time has elapsed.
   13|       |
   14|       |     - seealso: [window operator on reactivex.io](http://reactivex.io/documentation/operators/window.html)
   15|       |
   16|       |     - parameter timeSpan: Maximum time length of a window.
   17|       |     - parameter count: Maximum element count of a window.
   18|       |     - parameter scheduler: Scheduler to run windowing timers on.
   19|       |     - returns: An observable sequence of windows (instances of `Observable`).
   20|       |     */
   21|       |    public func window(timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType)
   22|      0|        -> Observable<Observable<E>> {
   23|      0|            return WindowTimeCount(source: self.asObservable(), timeSpan: timeSpan, count: count, scheduler: scheduler)
   24|      0|    }
   25|       |}
   26|       |
   27|       |final private class WindowTimeCountSink<Element, O: ObserverType>
   28|       |    : Sink<O>
   29|       |    , ObserverType
   30|       |    , LockOwnerType
   31|       |    , SynchronizedOnType where O.E == Observable<Element> {
   32|       |    typealias Parent = WindowTimeCount<Element>
   33|       |    typealias E = Element
   34|       |    
   35|       |    private let _parent: Parent
   36|       |    
   37|       |    let _lock = RecursiveLock()
   38|       |    
   39|       |    private var _subject = PublishSubject<Element>()
   40|       |    private var _count = 0
   41|       |    private var _windowId = 0
   42|       |    
   43|       |    private let _timerD = SerialDisposable()
   44|       |    private let _refCountDisposable: RefCountDisposable
   45|       |    private let _groupDisposable = CompositeDisposable()
   46|       |    
   47|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   48|      0|        self._parent = parent
   49|      0|        
   50|      0|        _ = self._groupDisposable.insert(self._timerD)
   51|      0|        
   52|      0|        self._refCountDisposable = RefCountDisposable(disposable: self._groupDisposable)
   53|      0|        super.init(observer: observer, cancel: cancel)
   54|      0|    }
   55|       |    
   56|      0|    func run() -> Disposable {
   57|      0|        
   58|      0|        self.forwardOn(.next(AddRef(source: self._subject, refCount: self._refCountDisposable).asObservable()))
   59|      0|        self.createTimer(self._windowId)
   60|      0|        
   61|      0|        _ = self._groupDisposable.insert(self._parent._source.subscribe(self))
   62|      0|        return self._refCountDisposable
   63|      0|    }
   64|       |    
   65|      0|    func startNewWindowAndCompleteCurrentOne() {
   66|      0|        self._subject.on(.completed)
   67|      0|        self._subject = PublishSubject<Element>()
   68|      0|        
   69|      0|        self.forwardOn(.next(AddRef(source: self._subject, refCount: self._refCountDisposable).asObservable()))
   70|      0|    }
   71|       |
   72|      0|    func on(_ event: Event<E>) {
   73|      0|        self.synchronizedOn(event)
   74|      0|    }
   75|       |
   76|      0|    func _synchronized_on(_ event: Event<E>) {
   77|      0|        var newWindow = false
   78|      0|        var newId = 0
   79|      0|        
   80|      0|        switch event {
   81|      0|        case .next(let element):
   82|      0|            self._subject.on(.next(element))
   83|      0|            
   84|      0|            do {
   85|      0|                _ = try incrementChecked(&self._count)
   86|      0|            } catch let e {
   87|      0|                self._subject.on(.error(e as Swift.Error))
   88|      0|                self.dispose()
   89|      0|            }
   90|      0|            
   91|      0|            if self._count == self._parent._count {
   92|      0|                newWindow = true
   93|      0|                self._count = 0
   94|      0|                self._windowId += 1
   95|      0|                newId = self._windowId
   96|      0|                self.startNewWindowAndCompleteCurrentOne()
   97|      0|            }
   98|      0|            
   99|      0|        case .error(let error):
  100|      0|            self._subject.on(.error(error))
  101|      0|            self.forwardOn(.error(error))
  102|      0|            self.dispose()
  103|      0|        case .completed:
  104|      0|            self._subject.on(.completed)
  105|      0|            self.forwardOn(.completed)
  106|      0|            self.dispose()
  107|      0|        }
  108|      0|
  109|      0|        if newWindow {
  110|      0|            self.createTimer(newId)
  111|      0|        }
  112|      0|    }
  113|       |    
  114|       |    func createTimer(_ windowId: Int) {
  115|       |        if self._timerD.isDisposed {
  116|       |            return
  117|       |        }
  118|       |        
  119|       |        if self._windowId != windowId {
  120|       |            return
  121|       |        }
  122|       |
  123|       |        let nextTimer = SingleAssignmentDisposable()
  124|       |
  125|       |        self._timerD.disposable = nextTimer
  126|       |
  127|      0|        let scheduledRelative = self._parent._scheduler.scheduleRelative(windowId, dueTime: self._parent._timeSpan) { previousWindowId in
  128|      0|            
  129|      0|            var newId = 0
  130|      0|            
  131|      0|            self._lock.performLocked {
  132|      0|                if previousWindowId != self._windowId {
  133|      0|                    return
  134|      0|                }
  135|      0|                
  136|      0|                self._count = 0
  137|      0|                self._windowId = self._windowId &+ 1
  138|      0|                newId = self._windowId
  139|      0|                self.startNewWindowAndCompleteCurrentOne()
  140|      0|            }
  141|      0|            
  142|      0|            self.createTimer(newId)
  143|      0|            
  144|      0|            return Disposables.create()
  145|      0|        }
  146|       |
  147|       |        nextTimer.setDisposable(scheduledRelative)
  148|       |    }
  149|       |}
  150|       |
  151|       |final private class WindowTimeCount<Element>: Producer<Observable<Element>> {
  152|       |    fileprivate let _timeSpan: RxTimeInterval
  153|       |    fileprivate let _count: Int
  154|       |    fileprivate let _scheduler: SchedulerType
  155|       |    fileprivate let _source: Observable<Element>
  156|       |    
  157|      0|    init(source: Observable<Element>, timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType) {
  158|      0|        self._source = source
  159|      0|        self._timeSpan = timeSpan
  160|      0|        self._count = count
  161|      0|        self._scheduler = scheduler
  162|      0|    }
  163|       |    
  164|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Observable<Element> {
  165|      0|        let sink = WindowTimeCountSink(parent: self, observer: observer, cancel: cancel)
  166|      0|        let subscription = sink.run()
  167|      0|        return (sink: sink, subscription: subscription)
  168|      0|    }
  169|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/WithLatestFrom.swift:
    1|       |//
    2|       |//  WithLatestFrom.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |
   11|       |    /**
   12|       |     Merges two observable sequences into one observable sequence by combining each element from self with the latest element from the second source, if any.
   13|       |
   14|       |     - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   15|       |
   16|       |     - parameter second: Second observable source.
   17|       |     - parameter resultSelector: Function to invoke for each element from the self combined with the latest element from the second source, if any.
   18|       |     - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
   19|       |     */
   20|      0|    public func withLatestFrom<SecondO: ObservableConvertibleType, ResultType>(_ second: SecondO, resultSelector: @escaping (E, SecondO.E) throws -> ResultType) -> Observable<ResultType> {
   21|      0|        return WithLatestFrom(first: self.asObservable(), second: second.asObservable(), resultSelector: resultSelector)
   22|      0|    }
   23|       |
   24|       |    /**
   25|       |     Merges two observable sequences into one observable sequence by using latest element from the second sequence every time when `self` emits an element.
   26|       |
   27|       |     - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   28|       |
   29|       |     - parameter second: Second observable source.
   30|       |     - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
   31|       |     */
   32|      0|    public func withLatestFrom<SecondO: ObservableConvertibleType>(_ second: SecondO) -> Observable<SecondO.E> {
   33|      0|        return WithLatestFrom(first: self.asObservable(), second: second.asObservable(), resultSelector: { $1 })
   34|      0|    }
   35|       |}
   36|       |
   37|       |final private class WithLatestFromSink<FirstType, SecondType, O: ObserverType>
   38|       |    : Sink<O>
   39|       |    , ObserverType
   40|       |    , LockOwnerType
   41|       |    , SynchronizedOnType {
   42|       |    typealias ResultType = O.E
   43|       |    typealias Parent = WithLatestFrom<FirstType, SecondType, ResultType>
   44|       |    typealias E = FirstType
   45|       |    
   46|       |    fileprivate let _parent: Parent
   47|       |    
   48|       |    var _lock = RecursiveLock()
   49|       |    fileprivate var _latest: SecondType?
   50|       |
   51|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   52|      0|        self._parent = parent
   53|      0|        
   54|      0|        super.init(observer: observer, cancel: cancel)
   55|      0|    }
   56|       |    
   57|      0|    func run() -> Disposable {
   58|      0|        let sndSubscription = SingleAssignmentDisposable()
   59|      0|        let sndO = WithLatestFromSecond(parent: self, disposable: sndSubscription)
   60|      0|        
   61|      0|        sndSubscription.setDisposable(self._parent._second.subscribe(sndO))
   62|      0|        let fstSubscription = self._parent._first.subscribe(self)
   63|      0|
   64|      0|        return Disposables.create(fstSubscription, sndSubscription)
   65|      0|    }
   66|       |
   67|      0|    func on(_ event: Event<E>) {
   68|      0|        self.synchronizedOn(event)
   69|      0|    }
   70|       |
   71|      0|    func _synchronized_on(_ event: Event<E>) {
   72|      0|        switch event {
   73|      0|        case let .next(value):
   74|      0|            guard let latest = self._latest else { return }
   75|      0|            do {
   76|      0|                let res = try self._parent._resultSelector(value, latest)
   77|      0|                
   78|      0|                self.forwardOn(.next(res))
   79|      0|            } catch let e {
   80|      0|                self.forwardOn(.error(e))
   81|      0|                self.dispose()
   82|      0|            }
   83|      0|        case .completed:
   84|      0|            self.forwardOn(.completed)
   85|      0|            self.dispose()
   86|      0|        case let .error(error):
   87|      0|            self.forwardOn(.error(error))
   88|      0|            self.dispose()
   89|      0|        }
   90|      0|    }
   91|       |}
   92|       |
   93|       |final private class WithLatestFromSecond<FirstType, SecondType, O: ObserverType>
   94|       |    : ObserverType
   95|       |    , LockOwnerType
   96|       |    , SynchronizedOnType {
   97|       |    
   98|       |    typealias ResultType = O.E
   99|       |    typealias Parent = WithLatestFromSink<FirstType, SecondType, O>
  100|       |    typealias E = SecondType
  101|       |    
  102|       |    private let _parent: Parent
  103|       |    private let _disposable: Disposable
  104|       |
  105|      0|    var _lock: RecursiveLock {
  106|      0|        return self._parent._lock
  107|      0|    }
  108|       |
  109|      0|    init(parent: Parent, disposable: Disposable) {
  110|      0|        self._parent = parent
  111|      0|        self._disposable = disposable
  112|      0|    }
  113|       |    
  114|      0|    func on(_ event: Event<E>) {
  115|      0|        self.synchronizedOn(event)
  116|      0|    }
  117|       |
  118|      0|    func _synchronized_on(_ event: Event<E>) {
  119|      0|        switch event {
  120|      0|        case let .next(value):
  121|      0|            self._parent._latest = value
  122|      0|        case .completed:
  123|      0|            self._disposable.dispose()
  124|      0|        case let .error(error):
  125|      0|            self._parent.forwardOn(.error(error))
  126|      0|            self._parent.dispose()
  127|      0|        }
  128|      0|    }
  129|       |}
  130|       |
  131|       |final private class WithLatestFrom<FirstType, SecondType, ResultType>: Producer<ResultType> {
  132|       |    typealias ResultSelector = (FirstType, SecondType) throws -> ResultType
  133|       |    
  134|       |    fileprivate let _first: Observable<FirstType>
  135|       |    fileprivate let _second: Observable<SecondType>
  136|       |    fileprivate let _resultSelector: ResultSelector
  137|       |
  138|      0|    init(first: Observable<FirstType>, second: Observable<SecondType>, resultSelector: @escaping ResultSelector) {
  139|      0|        self._first = first
  140|      0|        self._second = second
  141|      0|        self._resultSelector = resultSelector
  142|      0|    }
  143|       |    
  144|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
  145|      0|        let sink = WithLatestFromSink(parent: self, observer: observer, cancel: cancel)
  146|      0|        let subscription = sink.run()
  147|      0|        return (sink: sink, subscription: subscription)
  148|      0|    }
  149|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Zip+Collection.swift:
    1|       |//
    2|       |//  Zip+Collection.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   12|       |
   13|       |     - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   14|       |
   15|       |     - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   16|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   17|       |     */
   18|       |    public static func zip<C: Collection>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> E) -> Observable<E>
   19|      0|        where C.Iterator.Element: ObservableType {
   20|      0|        return ZipCollectionType(sources: collection, resultSelector: resultSelector)
   21|      0|    }
   22|       |
   23|       |    /**
   24|       |     Merges the specified observable sequences into one observable sequence whenever all of the observable sequences have produced an element at a corresponding index.
   25|       |
   26|       |     - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   27|       |
   28|       |     - returns: An observable sequence containing the result of combining elements of the sources.
   29|       |     */
   30|       |    public static func zip<C: Collection>(_ collection: C) -> Observable<[E]>
   31|      0|        where C.Iterator.Element: ObservableType, C.Iterator.Element.E == E {
   32|      0|        return ZipCollectionType(sources: collection, resultSelector: { $0 })
   33|      0|    }
   34|       |    
   35|       |}
   36|       |
   37|       |final private class ZipCollectionTypeSink<C: Collection, O: ObserverType>
   38|       |    : Sink<O> where C.Iterator.Element: ObservableConvertibleType {
   39|       |    typealias R = O.E
   40|       |    typealias Parent = ZipCollectionType<C, R>
   41|       |    typealias SourceElement = C.Iterator.Element.E
   42|       |    
   43|       |    private let _parent: Parent
   44|       |    
   45|       |    private let _lock = RecursiveLock()
   46|       |    
   47|       |    // state
   48|       |    private var _numberOfValues = 0
   49|       |    private var _values: [Queue<SourceElement>]
   50|       |    private var _isDone: [Bool]
   51|       |    private var _numberOfDone = 0
   52|       |    private var _subscriptions: [SingleAssignmentDisposable]
   53|       |    
   54|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   55|      0|        self._parent = parent
   56|      0|        self._values = [Queue<SourceElement>](repeating: Queue(capacity: 4), count: parent.count)
   57|      0|        self._isDone = [Bool](repeating: false, count: parent.count)
   58|      0|        self._subscriptions = [SingleAssignmentDisposable]()
   59|      0|        self._subscriptions.reserveCapacity(parent.count)
   60|      0|        
   61|      0|        for _ in 0 ..< parent.count {
   62|      0|            self._subscriptions.append(SingleAssignmentDisposable())
   63|      0|        }
   64|      0|        
   65|      0|        super.init(observer: observer, cancel: cancel)
   66|      0|    }
   67|       |    
   68|      0|    func on(_ event: Event<SourceElement>, atIndex: Int) {
   69|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   70|      0|            switch event {
   71|      0|            case .next(let element):
   72|      0|                self._values[atIndex].enqueue(element)
   73|      0|                
   74|      0|                if self._values[atIndex].count == 1 {
   75|      0|                    self._numberOfValues += 1
   76|      0|                }
   77|      0|                
   78|      0|                if self._numberOfValues < self._parent.count {
   79|      0|                    if self._numberOfDone == self._parent.count - 1 {
   80|      0|                        self.forwardOn(.completed)
   81|      0|                        self.dispose()
   82|      0|                    }
   83|      0|                    return
   84|      0|                }
   85|      0|                
   86|      0|                do {
   87|      0|                    var arguments = [SourceElement]()
   88|      0|                    arguments.reserveCapacity(self._parent.count)
   89|      0|                    
   90|      0|                    // recalculate number of values
   91|      0|                    self._numberOfValues = 0
   92|      0|                    
   93|      0|                    for i in 0 ..< self._values.count {
   94|      0|                        arguments.append(self._values[i].dequeue()!)
   95|      0|                        if !self._values[i].isEmpty {
   96|      0|                            self._numberOfValues += 1
   97|      0|                        }
   98|      0|                    }
   99|      0|                    
  100|      0|                    let result = try self._parent.resultSelector(arguments)
  101|      0|                    self.forwardOn(.next(result))
  102|      0|                }
  103|      0|                catch let error {
  104|      0|                    self.forwardOn(.error(error))
  105|      0|                    self.dispose()
  106|      0|                }
  107|      0|                
  108|      0|            case .error(let error):
  109|      0|                self.forwardOn(.error(error))
  110|      0|                self.dispose()
  111|      0|            case .completed:
  112|      0|                if self._isDone[atIndex] {
  113|      0|                    return
  114|      0|                }
  115|      0|                
  116|      0|                self._isDone[atIndex] = true
  117|      0|                self._numberOfDone += 1
  118|      0|                
  119|      0|                if self._numberOfDone == self._parent.count {
  120|      0|                    self.forwardOn(.completed)
  121|      0|                    self.dispose()
  122|      0|                }
  123|      0|                else {
  124|      0|                    self._subscriptions[atIndex].dispose()
  125|      0|                }
  126|      0|            }
  127|      0|        // }
  128|      0|    }
  129|       |    
  130|      0|    func run() -> Disposable {
  131|      0|        var j = 0
  132|      0|        for i in self._parent.sources {
  133|      0|            let index = j
  134|      0|            let source = i.asObservable()
  135|      0|
  136|      0|            let disposable = source.subscribe(AnyObserver { event in
  137|      0|                self.on(event, atIndex: index)
  138|      0|                })
  139|      0|            self._subscriptions[j].setDisposable(disposable)
  140|      0|            j += 1
  141|      0|        }
  142|      0|
  143|      0|        if self._parent.sources.isEmpty {
  144|      0|            self.forwardOn(.completed)
  145|      0|        }
  146|      0|        
  147|      0|        return Disposables.create(_subscriptions)
  148|      0|    }
  149|       |}
  150|       |
  151|       |final private class ZipCollectionType<C: Collection, R>: Producer<R> where C.Iterator.Element: ObservableConvertibleType {
  152|       |    typealias ResultSelector = ([C.Iterator.Element.E]) throws -> R
  153|       |    
  154|       |    let sources: C
  155|       |    let resultSelector: ResultSelector
  156|       |    let count: Int
  157|       |    
  158|      0|    init(sources: C, resultSelector: @escaping ResultSelector) {
  159|      0|        self.sources = sources
  160|      0|        self.resultSelector = resultSelector
  161|      0|        self.count = Int(Int64(self.sources.count))
  162|      0|    }
  163|       |    
  164|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  165|      0|        let sink = ZipCollectionTypeSink(parent: self, observer: observer, cancel: cancel)
  166|      0|        let subscription = sink.run()
  167|      0|        return (sink: sink, subscription: subscription)
  168|      0|    }
  169|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Zip+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  Zip+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 5/23/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension ObservableType {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   17|       |
   18|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func zip<O1: ObservableType, O2: ObservableType>
   24|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   25|      0|        -> Observable<E> {
   26|      0|        return Zip2(
   27|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   28|      0|            resultSelector: resultSelector
   29|      0|        )
   30|      0|    }
   31|       |}
   32|       |
   33|       |extension ObservableType where E == Any {
   34|       |    /**
   35|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   36|       |
   37|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   38|       |
   39|       |    - returns: An observable sequence containing the result of combining elements of the sources.
   40|       |    */
   41|       |    public static func zip<O1: ObservableType, O2: ObservableType>
   42|       |        (_ source1: O1, _ source2: O2)
   43|      0|        -> Observable<(O1.E, O2.E)> {
   44|      0|        return Zip2(
   45|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   46|      0|            resultSelector: { ($0, $1) }
   47|      0|        )
   48|      0|    }
   49|       |}
   50|       |
   51|       |final class ZipSink2_<E1, E2, O: ObserverType> : ZipSink<O> {
   52|       |    typealias R = O.E
   53|       |    typealias Parent = Zip2<E1, E2, R>
   54|       |
   55|       |    let _parent: Parent
   56|       |
   57|       |    var _values1: Queue<E1> = Queue(capacity: 2)
   58|       |    var _values2: Queue<E2> = Queue(capacity: 2)
   59|       |
   60|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   61|      0|        self._parent = parent
   62|      0|        super.init(arity: 2, observer: observer, cancel: cancel)
   63|      0|    }
   64|       |
   65|      0|    override func hasElements(_ index: Int) -> Bool {
   66|      0|        switch index {
   67|      0|        case 0: return !self._values1.isEmpty
   68|      0|        case 1: return !self._values2.isEmpty
   69|      0|
   70|      0|        default:
   71|      0|            rxFatalError("Unhandled case (Function)")
   72|      0|        }
   73|      0|
   74|      0|    #if swift(>=4.2)
   75|      0|        #if !compiler(>=5.0)
   76|      0|        return false
   77|      0|        #endif
   78|      0|    #else
   79|      0|    return false
   80|      0|    #endif
   81|      0|    }
   82|       |
   83|      0|    func run() -> Disposable {
   84|      0|        let subscription1 = SingleAssignmentDisposable()
   85|      0|        let subscription2 = SingleAssignmentDisposable()
   86|      0|
   87|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
   88|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
   89|      0|
   90|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
   91|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
   92|      0|
   93|      0|        return Disposables.create([
   94|      0|           subscription1,
   95|      0|           subscription2
   96|      0|        ])
   97|      0|    }
   98|       |
   99|      0|    override func getResult() throws -> R {
  100|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!)
  101|      0|    }
  102|       |}
  103|       |
  104|       |final class Zip2<E1, E2, R> : Producer<R> {
  105|       |    typealias ResultSelector = (E1, E2) throws -> R
  106|       |
  107|       |    let source1: Observable<E1>
  108|       |    let source2: Observable<E2>
  109|       |
  110|       |    let _resultSelector: ResultSelector
  111|       |
  112|      0|    init(source1: Observable<E1>, source2: Observable<E2>, resultSelector: @escaping ResultSelector) {
  113|      0|        self.source1 = source1
  114|      0|        self.source2 = source2
  115|      0|
  116|      0|        self._resultSelector = resultSelector
  117|      0|    }
  118|       |
  119|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  120|      0|        let sink = ZipSink2_(parent: self, observer: observer, cancel: cancel)
  121|      0|        let subscription = sink.run()
  122|      0|        return (sink: sink, subscription: subscription)
  123|      0|    }
  124|       |}
  125|       |
  126|       |
  127|       |
  128|       |// 3
  129|       |
  130|       |extension ObservableType {
  131|       |    /**
  132|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  133|       |
  134|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  135|       |
  136|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  137|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  138|       |    */
  139|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  140|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  141|      0|        -> Observable<E> {
  142|      0|        return Zip3(
  143|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  144|      0|            resultSelector: resultSelector
  145|      0|        )
  146|      0|    }
  147|       |}
  148|       |
  149|       |extension ObservableType where E == Any {
  150|       |    /**
  151|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  152|       |
  153|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  154|       |
  155|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  156|       |    */
  157|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  158|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  159|      0|        -> Observable<(O1.E, O2.E, O3.E)> {
  160|      0|        return Zip3(
  161|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  162|      0|            resultSelector: { ($0, $1, $2) }
  163|      0|        )
  164|      0|    }
  165|       |}
  166|       |
  167|       |final class ZipSink3_<E1, E2, E3, O: ObserverType> : ZipSink<O> {
  168|       |    typealias R = O.E
  169|       |    typealias Parent = Zip3<E1, E2, E3, R>
  170|       |
  171|       |    let _parent: Parent
  172|       |
  173|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  174|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  175|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  176|       |
  177|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  178|      0|        self._parent = parent
  179|      0|        super.init(arity: 3, observer: observer, cancel: cancel)
  180|      0|    }
  181|       |
  182|      0|    override func hasElements(_ index: Int) -> Bool {
  183|      0|        switch index {
  184|      0|        case 0: return !self._values1.isEmpty
  185|      0|        case 1: return !self._values2.isEmpty
  186|      0|        case 2: return !self._values3.isEmpty
  187|      0|
  188|      0|        default:
  189|      0|            rxFatalError("Unhandled case (Function)")
  190|      0|        }
  191|      0|
  192|      0|    #if swift(>=4.2)
  193|      0|        #if !compiler(>=5.0)
  194|      0|        return false
  195|      0|        #endif
  196|      0|    #else
  197|      0|    return false
  198|      0|    #endif
  199|      0|    }
  200|       |
  201|      0|    func run() -> Disposable {
  202|      0|        let subscription1 = SingleAssignmentDisposable()
  203|      0|        let subscription2 = SingleAssignmentDisposable()
  204|      0|        let subscription3 = SingleAssignmentDisposable()
  205|      0|
  206|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  207|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  208|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  209|      0|
  210|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  211|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  212|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  213|      0|
  214|      0|        return Disposables.create([
  215|      0|           subscription1,
  216|      0|           subscription2,
  217|      0|           subscription3
  218|      0|        ])
  219|      0|    }
  220|       |
  221|      0|    override func getResult() throws -> R {
  222|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!)
  223|      0|    }
  224|       |}
  225|       |
  226|       |final class Zip3<E1, E2, E3, R> : Producer<R> {
  227|       |    typealias ResultSelector = (E1, E2, E3) throws -> R
  228|       |
  229|       |    let source1: Observable<E1>
  230|       |    let source2: Observable<E2>
  231|       |    let source3: Observable<E3>
  232|       |
  233|       |    let _resultSelector: ResultSelector
  234|       |
  235|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, resultSelector: @escaping ResultSelector) {
  236|      0|        self.source1 = source1
  237|      0|        self.source2 = source2
  238|      0|        self.source3 = source3
  239|      0|
  240|      0|        self._resultSelector = resultSelector
  241|      0|    }
  242|       |
  243|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  244|      0|        let sink = ZipSink3_(parent: self, observer: observer, cancel: cancel)
  245|      0|        let subscription = sink.run()
  246|      0|        return (sink: sink, subscription: subscription)
  247|      0|    }
  248|       |}
  249|       |
  250|       |
  251|       |
  252|       |// 4
  253|       |
  254|       |extension ObservableType {
  255|       |    /**
  256|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  257|       |
  258|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  259|       |
  260|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  261|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  262|       |    */
  263|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  264|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  265|      0|        -> Observable<E> {
  266|      0|        return Zip4(
  267|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  268|      0|            resultSelector: resultSelector
  269|      0|        )
  270|      0|    }
  271|       |}
  272|       |
  273|       |extension ObservableType where E == Any {
  274|       |    /**
  275|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  276|       |
  277|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  278|       |
  279|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  280|       |    */
  281|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  282|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  283|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E)> {
  284|      0|        return Zip4(
  285|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  286|      0|            resultSelector: { ($0, $1, $2, $3) }
  287|      0|        )
  288|      0|    }
  289|       |}
  290|       |
  291|       |final class ZipSink4_<E1, E2, E3, E4, O: ObserverType> : ZipSink<O> {
  292|       |    typealias R = O.E
  293|       |    typealias Parent = Zip4<E1, E2, E3, E4, R>
  294|       |
  295|       |    let _parent: Parent
  296|       |
  297|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  298|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  299|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  300|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  301|       |
  302|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  303|      0|        self._parent = parent
  304|      0|        super.init(arity: 4, observer: observer, cancel: cancel)
  305|      0|    }
  306|       |
  307|      0|    override func hasElements(_ index: Int) -> Bool {
  308|      0|        switch index {
  309|      0|        case 0: return !self._values1.isEmpty
  310|      0|        case 1: return !self._values2.isEmpty
  311|      0|        case 2: return !self._values3.isEmpty
  312|      0|        case 3: return !self._values4.isEmpty
  313|      0|
  314|      0|        default:
  315|      0|            rxFatalError("Unhandled case (Function)")
  316|      0|        }
  317|      0|
  318|      0|    #if swift(>=4.2)
  319|      0|        #if !compiler(>=5.0)
  320|      0|        return false
  321|      0|        #endif
  322|      0|    #else
  323|      0|    return false
  324|      0|    #endif
  325|      0|    }
  326|       |
  327|      0|    func run() -> Disposable {
  328|      0|        let subscription1 = SingleAssignmentDisposable()
  329|      0|        let subscription2 = SingleAssignmentDisposable()
  330|      0|        let subscription3 = SingleAssignmentDisposable()
  331|      0|        let subscription4 = SingleAssignmentDisposable()
  332|      0|
  333|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  334|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  335|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  336|      0|        let observer4 = ZipObserver(lock: self._lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  337|      0|
  338|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  339|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  340|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  341|      0|        subscription4.setDisposable(self._parent.source4.subscribe(observer4))
  342|      0|
  343|      0|        return Disposables.create([
  344|      0|           subscription1,
  345|      0|           subscription2,
  346|      0|           subscription3,
  347|      0|           subscription4
  348|      0|        ])
  349|      0|    }
  350|       |
  351|      0|    override func getResult() throws -> R {
  352|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!, self._values4.dequeue()!)
  353|      0|    }
  354|       |}
  355|       |
  356|       |final class Zip4<E1, E2, E3, E4, R> : Producer<R> {
  357|       |    typealias ResultSelector = (E1, E2, E3, E4) throws -> R
  358|       |
  359|       |    let source1: Observable<E1>
  360|       |    let source2: Observable<E2>
  361|       |    let source3: Observable<E3>
  362|       |    let source4: Observable<E4>
  363|       |
  364|       |    let _resultSelector: ResultSelector
  365|       |
  366|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, resultSelector: @escaping ResultSelector) {
  367|      0|        self.source1 = source1
  368|      0|        self.source2 = source2
  369|      0|        self.source3 = source3
  370|      0|        self.source4 = source4
  371|      0|
  372|      0|        self._resultSelector = resultSelector
  373|      0|    }
  374|       |
  375|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  376|      0|        let sink = ZipSink4_(parent: self, observer: observer, cancel: cancel)
  377|      0|        let subscription = sink.run()
  378|      0|        return (sink: sink, subscription: subscription)
  379|      0|    }
  380|       |}
  381|       |
  382|       |
  383|       |
  384|       |// 5
  385|       |
  386|       |extension ObservableType {
  387|       |    /**
  388|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  389|       |
  390|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  391|       |
  392|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  393|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  394|       |    */
  395|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  396|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  397|      0|        -> Observable<E> {
  398|      0|        return Zip5(
  399|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  400|      0|            resultSelector: resultSelector
  401|      0|        )
  402|      0|    }
  403|       |}
  404|       |
  405|       |extension ObservableType where E == Any {
  406|       |    /**
  407|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  408|       |
  409|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  410|       |
  411|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  412|       |    */
  413|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  414|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  415|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> {
  416|      0|        return Zip5(
  417|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  418|      0|            resultSelector: { ($0, $1, $2, $3, $4) }
  419|      0|        )
  420|      0|    }
  421|       |}
  422|       |
  423|       |final class ZipSink5_<E1, E2, E3, E4, E5, O: ObserverType> : ZipSink<O> {
  424|       |    typealias R = O.E
  425|       |    typealias Parent = Zip5<E1, E2, E3, E4, E5, R>
  426|       |
  427|       |    let _parent: Parent
  428|       |
  429|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  430|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  431|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  432|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  433|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  434|       |
  435|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  436|      0|        self._parent = parent
  437|      0|        super.init(arity: 5, observer: observer, cancel: cancel)
  438|      0|    }
  439|       |
  440|      0|    override func hasElements(_ index: Int) -> Bool {
  441|      0|        switch index {
  442|      0|        case 0: return !self._values1.isEmpty
  443|      0|        case 1: return !self._values2.isEmpty
  444|      0|        case 2: return !self._values3.isEmpty
  445|      0|        case 3: return !self._values4.isEmpty
  446|      0|        case 4: return !self._values5.isEmpty
  447|      0|
  448|      0|        default:
  449|      0|            rxFatalError("Unhandled case (Function)")
  450|      0|        }
  451|      0|
  452|      0|    #if swift(>=4.2)
  453|      0|        #if !compiler(>=5.0)
  454|      0|        return false
  455|      0|        #endif
  456|      0|    #else
  457|      0|    return false
  458|      0|    #endif
  459|      0|    }
  460|       |
  461|      0|    func run() -> Disposable {
  462|      0|        let subscription1 = SingleAssignmentDisposable()
  463|      0|        let subscription2 = SingleAssignmentDisposable()
  464|      0|        let subscription3 = SingleAssignmentDisposable()
  465|      0|        let subscription4 = SingleAssignmentDisposable()
  466|      0|        let subscription5 = SingleAssignmentDisposable()
  467|      0|
  468|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  469|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  470|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  471|      0|        let observer4 = ZipObserver(lock: self._lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  472|      0|        let observer5 = ZipObserver(lock: self._lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  473|      0|
  474|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  475|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  476|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  477|      0|        subscription4.setDisposable(self._parent.source4.subscribe(observer4))
  478|      0|        subscription5.setDisposable(self._parent.source5.subscribe(observer5))
  479|      0|
  480|      0|        return Disposables.create([
  481|      0|           subscription1,
  482|      0|           subscription2,
  483|      0|           subscription3,
  484|      0|           subscription4,
  485|      0|           subscription5
  486|      0|        ])
  487|      0|    }
  488|       |
  489|      0|    override func getResult() throws -> R {
  490|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!, self._values4.dequeue()!, self._values5.dequeue()!)
  491|      0|    }
  492|       |}
  493|       |
  494|       |final class Zip5<E1, E2, E3, E4, E5, R> : Producer<R> {
  495|       |    typealias ResultSelector = (E1, E2, E3, E4, E5) throws -> R
  496|       |
  497|       |    let source1: Observable<E1>
  498|       |    let source2: Observable<E2>
  499|       |    let source3: Observable<E3>
  500|       |    let source4: Observable<E4>
  501|       |    let source5: Observable<E5>
  502|       |
  503|       |    let _resultSelector: ResultSelector
  504|       |
  505|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, resultSelector: @escaping ResultSelector) {
  506|      0|        self.source1 = source1
  507|      0|        self.source2 = source2
  508|      0|        self.source3 = source3
  509|      0|        self.source4 = source4
  510|      0|        self.source5 = source5
  511|      0|
  512|      0|        self._resultSelector = resultSelector
  513|      0|    }
  514|       |
  515|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  516|      0|        let sink = ZipSink5_(parent: self, observer: observer, cancel: cancel)
  517|      0|        let subscription = sink.run()
  518|      0|        return (sink: sink, subscription: subscription)
  519|      0|    }
  520|       |}
  521|       |
  522|       |
  523|       |
  524|       |// 6
  525|       |
  526|       |extension ObservableType {
  527|       |    /**
  528|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  529|       |
  530|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  531|       |
  532|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  533|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  534|       |    */
  535|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  536|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  537|      0|        -> Observable<E> {
  538|      0|        return Zip6(
  539|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  540|      0|            resultSelector: resultSelector
  541|      0|        )
  542|      0|    }
  543|       |}
  544|       |
  545|       |extension ObservableType where E == Any {
  546|       |    /**
  547|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  548|       |
  549|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  550|       |
  551|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  552|       |    */
  553|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  554|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  555|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> {
  556|      0|        return Zip6(
  557|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  558|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5) }
  559|      0|        )
  560|      0|    }
  561|       |}
  562|       |
  563|       |final class ZipSink6_<E1, E2, E3, E4, E5, E6, O: ObserverType> : ZipSink<O> {
  564|       |    typealias R = O.E
  565|       |    typealias Parent = Zip6<E1, E2, E3, E4, E5, E6, R>
  566|       |
  567|       |    let _parent: Parent
  568|       |
  569|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  570|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  571|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  572|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  573|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  574|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  575|       |
  576|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  577|      0|        self._parent = parent
  578|      0|        super.init(arity: 6, observer: observer, cancel: cancel)
  579|      0|    }
  580|       |
  581|      0|    override func hasElements(_ index: Int) -> Bool {
  582|      0|        switch index {
  583|      0|        case 0: return !self._values1.isEmpty
  584|      0|        case 1: return !self._values2.isEmpty
  585|      0|        case 2: return !self._values3.isEmpty
  586|      0|        case 3: return !self._values4.isEmpty
  587|      0|        case 4: return !self._values5.isEmpty
  588|      0|        case 5: return !self._values6.isEmpty
  589|      0|
  590|      0|        default:
  591|      0|            rxFatalError("Unhandled case (Function)")
  592|      0|        }
  593|      0|
  594|      0|    #if swift(>=4.2)
  595|      0|        #if !compiler(>=5.0)
  596|      0|        return false
  597|      0|        #endif
  598|      0|    #else
  599|      0|    return false
  600|      0|    #endif
  601|      0|    }
  602|       |
  603|      0|    func run() -> Disposable {
  604|      0|        let subscription1 = SingleAssignmentDisposable()
  605|      0|        let subscription2 = SingleAssignmentDisposable()
  606|      0|        let subscription3 = SingleAssignmentDisposable()
  607|      0|        let subscription4 = SingleAssignmentDisposable()
  608|      0|        let subscription5 = SingleAssignmentDisposable()
  609|      0|        let subscription6 = SingleAssignmentDisposable()
  610|      0|
  611|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  612|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  613|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  614|      0|        let observer4 = ZipObserver(lock: self._lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  615|      0|        let observer5 = ZipObserver(lock: self._lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  616|      0|        let observer6 = ZipObserver(lock: self._lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  617|      0|
  618|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  619|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  620|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  621|      0|        subscription4.setDisposable(self._parent.source4.subscribe(observer4))
  622|      0|        subscription5.setDisposable(self._parent.source5.subscribe(observer5))
  623|      0|        subscription6.setDisposable(self._parent.source6.subscribe(observer6))
  624|      0|
  625|      0|        return Disposables.create([
  626|      0|           subscription1,
  627|      0|           subscription2,
  628|      0|           subscription3,
  629|      0|           subscription4,
  630|      0|           subscription5,
  631|      0|           subscription6
  632|      0|        ])
  633|      0|    }
  634|       |
  635|      0|    override func getResult() throws -> R {
  636|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!, self._values4.dequeue()!, self._values5.dequeue()!, self._values6.dequeue()!)
  637|      0|    }
  638|       |}
  639|       |
  640|       |final class Zip6<E1, E2, E3, E4, E5, E6, R> : Producer<R> {
  641|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6) throws -> R
  642|       |
  643|       |    let source1: Observable<E1>
  644|       |    let source2: Observable<E2>
  645|       |    let source3: Observable<E3>
  646|       |    let source4: Observable<E4>
  647|       |    let source5: Observable<E5>
  648|       |    let source6: Observable<E6>
  649|       |
  650|       |    let _resultSelector: ResultSelector
  651|       |
  652|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, resultSelector: @escaping ResultSelector) {
  653|      0|        self.source1 = source1
  654|      0|        self.source2 = source2
  655|      0|        self.source3 = source3
  656|      0|        self.source4 = source4
  657|      0|        self.source5 = source5
  658|      0|        self.source6 = source6
  659|      0|
  660|      0|        self._resultSelector = resultSelector
  661|      0|    }
  662|       |
  663|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  664|      0|        let sink = ZipSink6_(parent: self, observer: observer, cancel: cancel)
  665|      0|        let subscription = sink.run()
  666|      0|        return (sink: sink, subscription: subscription)
  667|      0|    }
  668|       |}
  669|       |
  670|       |
  671|       |
  672|       |// 7
  673|       |
  674|       |extension ObservableType {
  675|       |    /**
  676|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  677|       |
  678|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  679|       |
  680|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  681|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  682|       |    */
  683|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  684|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  685|      0|        -> Observable<E> {
  686|      0|        return Zip7(
  687|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  688|      0|            resultSelector: resultSelector
  689|      0|        )
  690|      0|    }
  691|       |}
  692|       |
  693|       |extension ObservableType where E == Any {
  694|       |    /**
  695|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  696|       |
  697|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  698|       |
  699|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  700|       |    */
  701|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  702|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  703|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> {
  704|      0|        return Zip7(
  705|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  706|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
  707|      0|        )
  708|      0|    }
  709|       |}
  710|       |
  711|       |final class ZipSink7_<E1, E2, E3, E4, E5, E6, E7, O: ObserverType> : ZipSink<O> {
  712|       |    typealias R = O.E
  713|       |    typealias Parent = Zip7<E1, E2, E3, E4, E5, E6, E7, R>
  714|       |
  715|       |    let _parent: Parent
  716|       |
  717|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  718|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  719|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  720|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  721|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  722|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  723|       |    var _values7: Queue<E7> = Queue(capacity: 2)
  724|       |
  725|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  726|      0|        self._parent = parent
  727|      0|        super.init(arity: 7, observer: observer, cancel: cancel)
  728|      0|    }
  729|       |
  730|      0|    override func hasElements(_ index: Int) -> Bool {
  731|      0|        switch index {
  732|      0|        case 0: return !self._values1.isEmpty
  733|      0|        case 1: return !self._values2.isEmpty
  734|      0|        case 2: return !self._values3.isEmpty
  735|      0|        case 3: return !self._values4.isEmpty
  736|      0|        case 4: return !self._values5.isEmpty
  737|      0|        case 5: return !self._values6.isEmpty
  738|      0|        case 6: return !self._values7.isEmpty
  739|      0|
  740|      0|        default:
  741|      0|            rxFatalError("Unhandled case (Function)")
  742|      0|        }
  743|      0|
  744|      0|    #if swift(>=4.2)
  745|      0|        #if !compiler(>=5.0)
  746|      0|        return false
  747|      0|        #endif
  748|      0|    #else
  749|      0|    return false
  750|      0|    #endif
  751|      0|    }
  752|       |
  753|      0|    func run() -> Disposable {
  754|      0|        let subscription1 = SingleAssignmentDisposable()
  755|      0|        let subscription2 = SingleAssignmentDisposable()
  756|      0|        let subscription3 = SingleAssignmentDisposable()
  757|      0|        let subscription4 = SingleAssignmentDisposable()
  758|      0|        let subscription5 = SingleAssignmentDisposable()
  759|      0|        let subscription6 = SingleAssignmentDisposable()
  760|      0|        let subscription7 = SingleAssignmentDisposable()
  761|      0|
  762|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  763|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  764|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  765|      0|        let observer4 = ZipObserver(lock: self._lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  766|      0|        let observer5 = ZipObserver(lock: self._lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  767|      0|        let observer6 = ZipObserver(lock: self._lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  768|      0|        let observer7 = ZipObserver(lock: self._lock, parent: self, index: 6, setNextValue: { self._values7.enqueue($0) }, this: subscription7)
  769|      0|
  770|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  771|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  772|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  773|      0|        subscription4.setDisposable(self._parent.source4.subscribe(observer4))
  774|      0|        subscription5.setDisposable(self._parent.source5.subscribe(observer5))
  775|      0|        subscription6.setDisposable(self._parent.source6.subscribe(observer6))
  776|      0|        subscription7.setDisposable(self._parent.source7.subscribe(observer7))
  777|      0|
  778|      0|        return Disposables.create([
  779|      0|           subscription1,
  780|      0|           subscription2,
  781|      0|           subscription3,
  782|      0|           subscription4,
  783|      0|           subscription5,
  784|      0|           subscription6,
  785|      0|           subscription7
  786|      0|        ])
  787|      0|    }
  788|       |
  789|      0|    override func getResult() throws -> R {
  790|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!, self._values4.dequeue()!, self._values5.dequeue()!, self._values6.dequeue()!, self._values7.dequeue()!)
  791|      0|    }
  792|       |}
  793|       |
  794|       |final class Zip7<E1, E2, E3, E4, E5, E6, E7, R> : Producer<R> {
  795|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7) throws -> R
  796|       |
  797|       |    let source1: Observable<E1>
  798|       |    let source2: Observable<E2>
  799|       |    let source3: Observable<E3>
  800|       |    let source4: Observable<E4>
  801|       |    let source5: Observable<E5>
  802|       |    let source6: Observable<E6>
  803|       |    let source7: Observable<E7>
  804|       |
  805|       |    let _resultSelector: ResultSelector
  806|       |
  807|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, resultSelector: @escaping ResultSelector) {
  808|      0|        self.source1 = source1
  809|      0|        self.source2 = source2
  810|      0|        self.source3 = source3
  811|      0|        self.source4 = source4
  812|      0|        self.source5 = source5
  813|      0|        self.source6 = source6
  814|      0|        self.source7 = source7
  815|      0|
  816|      0|        self._resultSelector = resultSelector
  817|      0|    }
  818|       |
  819|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  820|      0|        let sink = ZipSink7_(parent: self, observer: observer, cancel: cancel)
  821|      0|        let subscription = sink.run()
  822|      0|        return (sink: sink, subscription: subscription)
  823|      0|    }
  824|       |}
  825|       |
  826|       |
  827|       |
  828|       |// 8
  829|       |
  830|       |extension ObservableType {
  831|       |    /**
  832|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  833|       |
  834|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  835|       |
  836|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  837|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  838|       |    */
  839|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  840|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  841|      0|        -> Observable<E> {
  842|      0|        return Zip8(
  843|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  844|      0|            resultSelector: resultSelector
  845|      0|        )
  846|      0|    }
  847|       |}
  848|       |
  849|       |extension ObservableType where E == Any {
  850|       |    /**
  851|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  852|       |
  853|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  854|       |
  855|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  856|       |    */
  857|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  858|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  859|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> {
  860|      0|        return Zip8(
  861|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  862|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
  863|      0|        )
  864|      0|    }
  865|       |}
  866|       |
  867|       |final class ZipSink8_<E1, E2, E3, E4, E5, E6, E7, E8, O: ObserverType> : ZipSink<O> {
  868|       |    typealias R = O.E
  869|       |    typealias Parent = Zip8<E1, E2, E3, E4, E5, E6, E7, E8, R>
  870|       |
  871|       |    let _parent: Parent
  872|       |
  873|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  874|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  875|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  876|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  877|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  878|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  879|       |    var _values7: Queue<E7> = Queue(capacity: 2)
  880|       |    var _values8: Queue<E8> = Queue(capacity: 2)
  881|       |
  882|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  883|      0|        self._parent = parent
  884|      0|        super.init(arity: 8, observer: observer, cancel: cancel)
  885|      0|    }
  886|       |
  887|      0|    override func hasElements(_ index: Int) -> Bool {
  888|      0|        switch index {
  889|      0|        case 0: return !self._values1.isEmpty
  890|      0|        case 1: return !self._values2.isEmpty
  891|      0|        case 2: return !self._values3.isEmpty
  892|      0|        case 3: return !self._values4.isEmpty
  893|      0|        case 4: return !self._values5.isEmpty
  894|      0|        case 5: return !self._values6.isEmpty
  895|      0|        case 6: return !self._values7.isEmpty
  896|      0|        case 7: return !self._values8.isEmpty
  897|      0|
  898|      0|        default:
  899|      0|            rxFatalError("Unhandled case (Function)")
  900|      0|        }
  901|      0|
  902|      0|    #if swift(>=4.2)
  903|      0|        #if !compiler(>=5.0)
  904|      0|        return false
  905|      0|        #endif
  906|      0|    #else
  907|      0|    return false
  908|      0|    #endif
  909|      0|    }
  910|       |
  911|      0|    func run() -> Disposable {
  912|      0|        let subscription1 = SingleAssignmentDisposable()
  913|      0|        let subscription2 = SingleAssignmentDisposable()
  914|      0|        let subscription3 = SingleAssignmentDisposable()
  915|      0|        let subscription4 = SingleAssignmentDisposable()
  916|      0|        let subscription5 = SingleAssignmentDisposable()
  917|      0|        let subscription6 = SingleAssignmentDisposable()
  918|      0|        let subscription7 = SingleAssignmentDisposable()
  919|      0|        let subscription8 = SingleAssignmentDisposable()
  920|      0|
  921|      0|        let observer1 = ZipObserver(lock: self._lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  922|      0|        let observer2 = ZipObserver(lock: self._lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  923|      0|        let observer3 = ZipObserver(lock: self._lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  924|      0|        let observer4 = ZipObserver(lock: self._lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  925|      0|        let observer5 = ZipObserver(lock: self._lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  926|      0|        let observer6 = ZipObserver(lock: self._lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  927|      0|        let observer7 = ZipObserver(lock: self._lock, parent: self, index: 6, setNextValue: { self._values7.enqueue($0) }, this: subscription7)
  928|      0|        let observer8 = ZipObserver(lock: self._lock, parent: self, index: 7, setNextValue: { self._values8.enqueue($0) }, this: subscription8)
  929|      0|
  930|      0|        subscription1.setDisposable(self._parent.source1.subscribe(observer1))
  931|      0|        subscription2.setDisposable(self._parent.source2.subscribe(observer2))
  932|      0|        subscription3.setDisposable(self._parent.source3.subscribe(observer3))
  933|      0|        subscription4.setDisposable(self._parent.source4.subscribe(observer4))
  934|      0|        subscription5.setDisposable(self._parent.source5.subscribe(observer5))
  935|      0|        subscription6.setDisposable(self._parent.source6.subscribe(observer6))
  936|      0|        subscription7.setDisposable(self._parent.source7.subscribe(observer7))
  937|      0|        subscription8.setDisposable(self._parent.source8.subscribe(observer8))
  938|      0|
  939|      0|        return Disposables.create([
  940|      0|           subscription1,
  941|      0|           subscription2,
  942|      0|           subscription3,
  943|      0|           subscription4,
  944|      0|           subscription5,
  945|      0|           subscription6,
  946|      0|           subscription7,
  947|      0|           subscription8
  948|      0|        ])
  949|      0|    }
  950|       |
  951|      0|    override func getResult() throws -> R {
  952|      0|        return try self._parent._resultSelector(self._values1.dequeue()!, self._values2.dequeue()!, self._values3.dequeue()!, self._values4.dequeue()!, self._values5.dequeue()!, self._values6.dequeue()!, self._values7.dequeue()!, self._values8.dequeue()!)
  953|      0|    }
  954|       |}
  955|       |
  956|       |final class Zip8<E1, E2, E3, E4, E5, E6, E7, E8, R> : Producer<R> {
  957|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7, E8) throws -> R
  958|       |
  959|       |    let source1: Observable<E1>
  960|       |    let source2: Observable<E2>
  961|       |    let source3: Observable<E3>
  962|       |    let source4: Observable<E4>
  963|       |    let source5: Observable<E5>
  964|       |    let source6: Observable<E6>
  965|       |    let source7: Observable<E7>
  966|       |    let source8: Observable<E8>
  967|       |
  968|       |    let _resultSelector: ResultSelector
  969|       |
  970|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, source8: Observable<E8>, resultSelector: @escaping ResultSelector) {
  971|      0|        self.source1 = source1
  972|      0|        self.source2 = source2
  973|      0|        self.source3 = source3
  974|      0|        self.source4 = source4
  975|      0|        self.source5 = source5
  976|      0|        self.source6 = source6
  977|      0|        self.source7 = source7
  978|      0|        self.source8 = source8
  979|      0|
  980|      0|        self._resultSelector = resultSelector
  981|      0|    }
  982|       |
  983|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  984|      0|        let sink = ZipSink8_(parent: self, observer: observer, cancel: cancel)
  985|      0|        let subscription = sink.run()
  986|      0|        return (sink: sink, subscription: subscription)
  987|      0|    }
  988|       |}
  989|       |
  990|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observables/Zip.swift:
    1|       |//
    2|       |//  Zip.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol ZipSinkProtocol : class
   10|       |{
   11|       |    func next(_ index: Int)
   12|       |    func fail(_ error: Swift.Error)
   13|       |    func done(_ index: Int)
   14|       |}
   15|       |
   16|       |class ZipSink<O: ObserverType> : Sink<O>, ZipSinkProtocol {
   17|       |    typealias Element = O.E
   18|       |    
   19|       |    let _arity: Int
   20|       |
   21|       |    let _lock = RecursiveLock()
   22|       |
   23|       |    // state
   24|       |    private var _isDone: [Bool]
   25|       |    
   26|      0|    init(arity: Int, observer: O, cancel: Cancelable) {
   27|      0|        self._isDone = [Bool](repeating: false, count: arity)
   28|      0|        self._arity = arity
   29|      0|        
   30|      0|        super.init(observer: observer, cancel: cancel)
   31|      0|    }
   32|       |
   33|      0|    func getResult() throws -> Element {
   34|      0|        rxAbstractMethod()
   35|      0|    }
   36|       |    
   37|      0|    func hasElements(_ index: Int) -> Bool {
   38|      0|        rxAbstractMethod()
   39|      0|    }
   40|       |    
   41|      0|    func next(_ index: Int) {
   42|      0|        var hasValueAll = true
   43|      0|        
   44|      0|        for i in 0 ..< self._arity {
   45|      0|            if !self.hasElements(i) {
   46|      0|                hasValueAll = false
   47|      0|                break
   48|      0|            }
   49|      0|        }
   50|      0|        
   51|      0|        if hasValueAll {
   52|      0|            do {
   53|      0|                let result = try self.getResult()
   54|      0|                self.forwardOn(.next(result))
   55|      0|            }
   56|      0|            catch let e {
   57|      0|                self.forwardOn(.error(e))
   58|      0|                self.dispose()
   59|      0|            }
   60|      0|        }
   61|      0|        else {
   62|      0|            var allOthersDone = true
   63|      0|            
   64|      0|            let arity = self._isDone.count
   65|      0|            for i in 0 ..< arity {
   66|      0|                if i != index && !self._isDone[i] {
   67|      0|                    allOthersDone = false
   68|      0|                    break
   69|      0|                }
   70|      0|            }
   71|      0|            
   72|      0|            if allOthersDone {
   73|      0|                self.forwardOn(.completed)
   74|      0|                self.dispose()
   75|      0|            }
   76|      0|        }
   77|      0|    }
   78|       |    
   79|      0|    func fail(_ error: Swift.Error) {
   80|      0|        self.forwardOn(.error(error))
   81|      0|        self.dispose()
   82|      0|    }
   83|       |    
   84|      0|    func done(_ index: Int) {
   85|      0|        self._isDone[index] = true
   86|      0|        
   87|      0|        var allDone = true
   88|      0|        
   89|      0|        for done in self._isDone where !done {
   90|      0|            allDone = false
   91|      0|            break
   92|      0|        }
   93|      0|        
   94|      0|        if allDone {
   95|      0|            self.forwardOn(.completed)
   96|      0|            self.dispose()
   97|      0|        }
   98|      0|    }
   99|       |}
  100|       |
  101|       |final class ZipObserver<ElementType>
  102|       |    : ObserverType
  103|       |    , LockOwnerType
  104|       |    , SynchronizedOnType {
  105|       |    typealias E = ElementType
  106|       |    typealias ValueSetter = (ElementType) -> Void
  107|       |
  108|       |    private var _parent: ZipSinkProtocol?
  109|       |    
  110|       |    let _lock: RecursiveLock
  111|       |    
  112|       |    // state
  113|       |    private let _index: Int
  114|       |    private let _this: Disposable
  115|       |    private let _setNextValue: ValueSetter
  116|       |    
  117|      0|    init(lock: RecursiveLock, parent: ZipSinkProtocol, index: Int, setNextValue: @escaping ValueSetter, this: Disposable) {
  118|      0|        self._lock = lock
  119|      0|        self._parent = parent
  120|      0|        self._index = index
  121|      0|        self._this = this
  122|      0|        self._setNextValue = setNextValue
  123|      0|    }
  124|       |    
  125|      0|    func on(_ event: Event<E>) {
  126|      0|        self.synchronizedOn(event)
  127|      0|    }
  128|       |
  129|      0|    func _synchronized_on(_ event: Event<E>) {
  130|      0|        if self._parent != nil {
  131|      0|            switch event {
  132|      0|            case .next:
  133|      0|                break
  134|      0|            case .error:
  135|      0|                self._this.dispose()
  136|      0|            case .completed:
  137|      0|                self._this.dispose()
  138|      0|            }
  139|      0|        }
  140|      0|        
  141|      0|        if let parent = self._parent {
  142|      0|            switch event {
  143|      0|            case .next(let value):
  144|      0|                self._setNextValue(value)
  145|      0|                parent.next(self._index)
  146|      0|            case .error(let error):
  147|      0|                parent.fail(error)
  148|      0|            case .completed:
  149|      0|                parent.done(self._index)
  150|      0|            }
  151|      0|        }
  152|      0|    }
  153|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/ObserverType.swift:
    1|       |//
    2|       |//  ObserverType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Supports push-style iteration over an observable sequence.
   10|       |public protocol ObserverType {
   11|       |    /// The type of elements in sequence that observer can observe.
   12|       |    associatedtype E
   13|       |
   14|       |    /// Notify observer about sequence event.
   15|       |    ///
   16|       |    /// - parameter event: Event that occurred.
   17|       |    func on(_ event: Event<E>)
   18|       |}
   19|       |
   20|       |/// Convenience API extensions to provide alternate next, error, completed events
   21|       |extension ObserverType {
   22|       |    
   23|       |    /// Convenience method equivalent to `on(.next(element: E))`
   24|       |    ///
   25|       |    /// - parameter element: Next element to send to observer(s)
   26|      0|    public func onNext(_ element: E) {
   27|      0|        self.on(.next(element))
   28|      0|    }
   29|       |    
   30|       |    /// Convenience method equivalent to `on(.completed)`
   31|      0|    public func onCompleted() {
   32|      0|        self.on(.completed)
   33|      0|    }
   34|       |    
   35|       |    /// Convenience method equivalent to `on(.error(Swift.Error))`
   36|       |    /// - parameter error: Swift.Error to send to observer(s)
   37|      0|    public func onError(_ error: Swift.Error) {
   38|      0|        self.on(.error(error))
   39|      0|    }
   40|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observers/AnonymousObserver.swift:
    1|       |//
    2|       |//  AnonymousObserver.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class AnonymousObserver<ElementType> : ObserverBase<ElementType> {
   10|       |    typealias Element = ElementType
   11|       |    
   12|       |    typealias EventHandler = (Event<Element>) -> Void
   13|       |    
   14|       |    private let _eventHandler : EventHandler
   15|       |    
   16|      0|    init(_ eventHandler: @escaping EventHandler) {
   17|      0|#if TRACE_RESOURCES
   18|      0|        _ = Resources.incrementTotal()
   19|      0|#endif
   20|      0|        self._eventHandler = eventHandler
   21|      0|    }
   22|       |
   23|      0|    override func onCore(_ event: Event<Element>) {
   24|      0|        return self._eventHandler(event)
   25|      0|    }
   26|       |    
   27|       |#if TRACE_RESOURCES
   28|       |    deinit {
   29|       |        _ = Resources.decrementTotal()
   30|       |    }
   31|       |#endif
   32|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observers/ObserverBase.swift:
    1|       |//
    2|       |//  ObserverBase.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class ObserverBase<ElementType> : Disposable, ObserverType {
   10|       |    typealias E = ElementType
   11|       |
   12|       |    private let _isStopped = AtomicInt(0)
   13|       |
   14|      0|    func on(_ event: Event<E>) {
   15|      0|        switch event {
   16|      0|        case .next:
   17|      0|            if load(self._isStopped) == 0 {
   18|      0|                self.onCore(event)
   19|      0|            }
   20|      0|        case .error, .completed:
   21|      0|            if fetchOr(self._isStopped, 1) == 0 {
   22|      0|                self.onCore(event)
   23|      0|            }
   24|      0|        }
   25|      0|    }
   26|       |
   27|      0|    func onCore(_ event: Event<E>) {
   28|      0|        rxAbstractMethod()
   29|      0|    }
   30|       |
   31|      0|    func dispose() {
   32|      0|        fetchOr(self._isStopped, 1)
   33|      0|    }
   34|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Observers/TailRecursiveSink.swift:
    1|       |//
    2|       |//  TailRecursiveSink.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |enum TailRecursiveSinkCommand {
   10|       |    case moveNext
   11|       |    case dispose
   12|       |}
   13|       |
   14|       |#if DEBUG || TRACE_RESOURCES
   15|       |    public var maxTailRecursiveSinkStackSize = 0
   16|       |#endif
   17|       |
   18|       |/// This class is usually used with `Generator` version of the operators.
   19|       |class TailRecursiveSink<S: Sequence, O: ObserverType>
   20|       |    : Sink<O>
   21|       |    , InvocableWithValueType where S.Iterator.Element: ObservableConvertibleType, S.Iterator.Element.E == O.E {
   22|       |    typealias Value = TailRecursiveSinkCommand
   23|       |    typealias E = O.E
   24|       |    typealias SequenceGenerator = (generator: S.Iterator, remaining: IntMax?)
   25|       |
   26|       |    var _generators: [SequenceGenerator] = []
   27|       |    var _isDisposed = false
   28|       |    var _subscription = SerialDisposable()
   29|       |
   30|       |    // this is thread safe object
   31|       |    var _gate = AsyncLock<InvocableScheduledItem<TailRecursiveSink<S, O>>>()
   32|       |
   33|      0|    override init(observer: O, cancel: Cancelable) {
   34|      0|        super.init(observer: observer, cancel: cancel)
   35|      0|    }
   36|       |
   37|      0|    func run(_ sources: SequenceGenerator) -> Disposable {
   38|      0|        self._generators.append(sources)
   39|      0|
   40|      0|        self.schedule(.moveNext)
   41|      0|
   42|      0|        return self._subscription
   43|      0|    }
   44|       |
   45|      0|    func invoke(_ command: TailRecursiveSinkCommand) {
   46|      0|        switch command {
   47|      0|        case .dispose:
   48|      0|            self.disposeCommand()
   49|      0|        case .moveNext:
   50|      0|            self.moveNextCommand()
   51|      0|        }
   52|      0|    }
   53|       |
   54|       |    // simple implementation for now
   55|      0|    func schedule(_ command: TailRecursiveSinkCommand) {
   56|      0|        self._gate.invoke(InvocableScheduledItem(invocable: self, state: command))
   57|      0|    }
   58|       |
   59|      0|    func done() {
   60|      0|        self.forwardOn(.completed)
   61|      0|        self.dispose()
   62|      0|    }
   63|       |
   64|      0|    func extract(_ observable: Observable<E>) -> SequenceGenerator? {
   65|      0|        rxAbstractMethod()
   66|      0|    }
   67|       |
   68|       |    // should be done on gate locked
   69|       |
   70|      0|    private func moveNextCommand() {
   71|      0|        var next: Observable<E>?
   72|      0|
   73|      0|        repeat {
   74|      0|            guard let (g, left) = self._generators.last else {
   75|      0|                break
   76|      0|            }
   77|      0|            
   78|      0|            if self._isDisposed {
   79|      0|                return
   80|      0|            }
   81|      0|
   82|      0|            self._generators.removeLast()
   83|      0|            
   84|      0|            var e = g
   85|      0|
   86|      0|            guard let nextCandidate = e.next()?.asObservable() else {
   87|      0|                continue
   88|      0|            }
   89|      0|
   90|      0|            // `left` is a hint of how many elements are left in generator.
   91|      0|            // In case this is the last element, then there is no need to push
   92|      0|            // that generator on stack.
   93|      0|            //
   94|      0|            // This is an optimization used to make sure in tail recursive case
   95|      0|            // there is no memory leak in case this operator is used to generate non terminating
   96|      0|            // sequence.
   97|      0|
   98|      0|            if let knownOriginalLeft = left {
   99|      0|                // `- 1` because generator.next() has just been called
  100|      0|                if knownOriginalLeft - 1 >= 1 {
  101|      0|                    self._generators.append((e, knownOriginalLeft - 1))
  102|      0|                }
  103|      0|            }
  104|      0|            else {
  105|      0|                self._generators.append((e, nil))
  106|      0|            }
  107|      0|
  108|      0|            let nextGenerator = self.extract(nextCandidate)
  109|      0|
  110|      0|            if let nextGenerator = nextGenerator {
  111|      0|                self._generators.append(nextGenerator)
  112|      0|                #if DEBUG || TRACE_RESOURCES
  113|      0|                    if maxTailRecursiveSinkStackSize < self._generators.count {
  114|      0|                        maxTailRecursiveSinkStackSize = self._generators.count
  115|      0|                    }
  116|      0|                #endif
  117|      0|            }
  118|      0|            else {
  119|      0|                next = nextCandidate
  120|      0|            }
  121|      0|        } while next == nil
  122|      0|
  123|      0|        guard let existingNext = next else {
  124|      0|            self.done()
  125|      0|            return
  126|      0|        }
  127|      0|
  128|      0|        let disposable = SingleAssignmentDisposable()
  129|      0|        self._subscription.disposable = disposable
  130|      0|        disposable.setDisposable(self.subscribeToNext(existingNext))
  131|      0|    }
  132|       |
  133|      0|    func subscribeToNext(_ source: Observable<E>) -> Disposable {
  134|      0|        rxAbstractMethod()
  135|      0|    }
  136|       |
  137|      0|    func disposeCommand() {
  138|      0|        self._isDisposed = true
  139|      0|        self._generators.removeAll(keepingCapacity: false)
  140|      0|    }
  141|       |
  142|      0|    override func dispose() {
  143|      0|        super.dispose()
  144|      0|        
  145|      0|        self._subscription.dispose()
  146|      0|        self._gate.dispose()
  147|      0|        
  148|      0|        self.schedule(.dispose)
  149|      0|    }
  150|       |}
  151|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Reactive.swift:
    1|       |//
    2|       |//  Reactive.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 5/2/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       | Use `Reactive` proxy as customization point for constrained protocol extensions.
   11|       |
   12|       | General pattern would be:
   13|       |
   14|       | // 1. Extend Reactive protocol with constrain on Base
   15|       | // Read as: Reactive Extension where Base is a SomeType
   16|       | extension Reactive where Base: SomeType {
   17|       | // 2. Put any specific reactive extension for SomeType here
   18|       | }
   19|       |
   20|       | With this approach we can have more specialized methods and properties using
   21|       | `Base` and not just specialized on common base type.
   22|       |
   23|       | */
   24|       |
   25|       |public struct Reactive<Base> {
   26|       |    /// Base object to extend.
   27|       |    public let base: Base
   28|       |
   29|       |    /// Creates extensions with base object.
   30|       |    ///
   31|       |    /// - parameter base: Base object.
   32|      0|    public init(_ base: Base) {
   33|      0|        self.base = base
   34|      0|    }
   35|       |}
   36|       |
   37|       |/// A type that has reactive extensions.
   38|       |public protocol ReactiveCompatible {
   39|       |    /// Extended type
   40|       |    associatedtype CompatibleType
   41|       |
   42|       |    /// Reactive extensions.
   43|       |    static var rx: Reactive<CompatibleType>.Type { get set }
   44|       |
   45|       |    /// Reactive extensions.
   46|       |    var rx: Reactive<CompatibleType> { get set }
   47|       |}
   48|       |
   49|       |extension ReactiveCompatible {
   50|       |    /// Reactive extensions.
   51|       |    public static var rx: Reactive<Self>.Type {
   52|      0|        get {
   53|      0|            return Reactive<Self>.self
   54|      0|        }
   55|      0|        set {
   56|      0|            // this enables using Reactive to "mutate" base type
   57|      0|        }
   58|       |    }
   59|       |
   60|       |    /// Reactive extensions.
   61|       |    public var rx: Reactive<Self> {
   62|      0|        get {
   63|      0|            return Reactive(self)
   64|      0|        }
   65|      0|        set {
   66|      0|            // this enables using Reactive to "mutate" base object
   67|      0|        }
   68|       |    }
   69|       |}
   70|       |
   71|       |import class Foundation.NSObject
   72|       |
   73|       |/// Extend NSObject with `rx` proxy.
   74|       |extension NSObject: ReactiveCompatible { }

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Rx.swift:
    1|       |//
    2|       |//  Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if TRACE_RESOURCES
   10|       |    fileprivate let resourceCount = AtomicInt(0)
   11|       |
   12|       |    /// Resource utilization information
   13|       |    public struct Resources {
   14|       |        /// Counts internal Rx resource allocations (Observables, Observers, Disposables, etc.). This provides a simple way to detect leaks during development.
   15|       |        public static var total: Int32 {
   16|       |            return load(resourceCount)
   17|       |        }
   18|       |
   19|       |        /// Increments `Resources.total` resource count.
   20|       |        ///
   21|       |        /// - returns: New resource count
   22|       |        public static func incrementTotal() -> Int32 {
   23|       |            return increment(resourceCount)
   24|       |        }
   25|       |
   26|       |        /// Decrements `Resources.total` resource count
   27|       |        ///
   28|       |        /// - returns: New resource count
   29|       |        public static func decrementTotal() -> Int32 {
   30|       |            return decrement(resourceCount)
   31|       |        }
   32|       |    }
   33|       |#endif
   34|       |
   35|       |/// Swift does not implement abstract methods. This method is used as a runtime check to ensure that methods which intended to be abstract (i.e., they should be implemented in subclasses) are not called directly on the superclass.
   36|      0|func rxAbstractMethod(file: StaticString = #file, line: UInt = #line) -> Swift.Never {
   37|      0|    rxFatalError("Abstract method", file: file, line: line)
   38|      0|}
   39|       |
   40|       |func rxFatalError(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) -> Swift.Never  {
   41|      0|    fatalError(lastMessage(), file: file, line: line)
   42|       |}
   43|       |
   44|      0|func rxFatalErrorInDebug(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) {
   45|      0|    #if DEBUG
   46|      0|        fatalError(lastMessage(), file: file, line: line)
   47|      0|    #else
   48|      0|        print("\(file):\(line): \(lastMessage())")
   49|      0|    #endif
   50|      0|}
   51|       |
   52|      0|func incrementChecked(_ i: inout Int) throws -> Int {
   53|      0|    if i == Int.max {
   54|      0|        throw RxError.overflow
   55|      0|    }
   56|      0|    defer { i += 1 }
   57|      0|    return i
   58|      0|}
   59|       |
   60|      0|func decrementChecked(_ i: inout Int) throws -> Int {
   61|      0|    if i == Int.min {
   62|      0|        throw RxError.overflow
   63|      0|    }
   64|      0|    defer { i -= 1 }
   65|      0|    return i
   66|      0|}
   67|       |
   68|       |#if DEBUG
   69|       |    import class Foundation.Thread
   70|       |    final class SynchronizationTracker {
   71|       |        private let _lock = RecursiveLock()
   72|       |
   73|       |        public enum SynchronizationErrorMessages: String {
   74|       |            case variable = "Two different threads are trying to assign the same `Variable.value` unsynchronized.\n    This is undefined behavior because the end result (variable value) is nondeterministic and depends on the \n    operating system thread scheduler. This will cause random behavior of your program.\n"
   75|       |            case `default` = "Two different unsynchronized threads are trying to send some event simultaneously.\n    This is undefined behavior because the ordering of the effects caused by these events is nondeterministic and depends on the \n    operating system thread scheduler. This will result in a random behavior of your program.\n"
   76|       |        }
   77|       |
   78|       |        private var _threads = [UnsafeMutableRawPointer: Int]()
   79|       |
   80|      0|        private func synchronizationError(_ message: String) {
   81|      0|            #if FATAL_SYNCHRONIZATION
   82|      0|                rxFatalError(message)
   83|      0|            #else
   84|      0|                print(message)
   85|      0|            #endif
   86|      0|        }
   87|       |        
   88|      0|        func register(synchronizationErrorMessage: SynchronizationErrorMessages) {
   89|      0|            self._lock.lock(); defer { self._lock.unlock() }
   90|      0|            let pointer = Unmanaged.passUnretained(Thread.current).toOpaque()
   91|      0|            let count = (self._threads[pointer] ?? 0) + 1
   92|      0|
   93|      0|            if count > 1 {
   94|      0|                self.synchronizationError(
   95|      0|                    "⚠️ Reentrancy anomaly was detected.\n" +
   96|      0|                    "  > Debugging: To debug this issue you can set a breakpoint in \(#file):\(#line) and observe the call stack.\n" +
   97|      0|                    "  > Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`\n" +
   98|      0|                    "    This behavior breaks the grammar because there is overlapping between sequence events.\n" +
   99|      0|                    "    Observable sequence is trying to send an event before sending of previous event has finished.\n" +
  100|      0|                    "  > Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,\n" +
  101|      0|                    "    or that the system is not behaving in the expected way.\n" +
  102|      0|                    "  > Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`\n" +
  103|      0|                    "    or by enqueuing sequence events in some other way.\n"
  104|      0|                )
  105|      0|            }
  106|      0|            
  107|      0|            self._threads[pointer] = count
  108|      0|
  109|      0|            if self._threads.count > 1 {
  110|      0|                self.synchronizationError(
  111|      0|                    "⚠️ Synchronization anomaly was detected.\n" +
  112|      0|                    "  > Debugging: To debug this issue you can set a breakpoint in \(#file):\(#line) and observe the call stack.\n" +
  113|      0|                    "  > Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`\n" +
  114|      0|                    "    This behavior breaks the grammar because there is overlapping between sequence events.\n" +
  115|      0|                    "    Observable sequence is trying to send an event before sending of previous event has finished.\n" +
  116|      0|                    "  > Interpretation: " + synchronizationErrorMessage.rawValue +
  117|      0|                    "  > Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`\n" +
  118|      0|                    "    or by synchronizing sequence events in some other way.\n"
  119|      0|                )
  120|      0|            }
  121|      0|        }
  122|       |
  123|      0|        func unregister() {
  124|      0|            self._lock.lock(); defer { self._lock.unlock() }
  125|      0|            let pointer = Unmanaged.passUnretained(Thread.current).toOpaque()
  126|      0|            self._threads[pointer] = (self._threads[pointer] ?? 1) - 1
  127|      0|            if self._threads[pointer] == 0 {
  128|      0|                self._threads[pointer] = nil
  129|      0|            }
  130|      0|        }
  131|       |    }
  132|       |
  133|       |#endif
  134|       |
  135|       |/// RxSwift global hooks
  136|       |public enum Hooks {
  137|       |    
  138|       |    // Should capture call stack
  139|       |    public static var recordCallStackOnError: Bool = false
  140|       |
  141|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/RxMutableBox.swift:
    1|       |//
    2|       |//  RxMutableBox.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Creates mutable reference wrapper for any type.
   10|       |final class RxMutableBox<T> : CustomDebugStringConvertible {
   11|       |    /// Wrapped value
   12|       |    var value : T
   13|       |    
   14|       |    /// Creates reference wrapper for `value`.
   15|       |    ///
   16|       |    /// - parameter value: Value to wrap.
   17|      0|    init (_ value: T) {
   18|      0|        self.value = value
   19|      0|    }
   20|       |}
   21|       |
   22|       |extension RxMutableBox {
   23|       |    /// - returns: Box description.
   24|       |    var debugDescription: String {
   25|       |        return "MutatingBox(\(self.value))"
   26|       |    }
   27|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/SchedulerType.swift:
    1|       |//
    2|       |//  SchedulerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.TimeInterval
   10|       |import struct Foundation.Date
   11|       |
   12|       |// Type that represents time interval in the context of RxSwift.
   13|       |public typealias RxTimeInterval = TimeInterval
   14|       |
   15|       |/// Type that represents absolute time in the context of RxSwift.
   16|       |public typealias RxTime = Date
   17|       |
   18|       |/// Represents an object that schedules units of work.
   19|       |public protocol SchedulerType: ImmediateSchedulerType {
   20|       |
   21|       |    /// - returns: Current time.
   22|       |    var now : RxTime {
   23|       |        get
   24|       |    }
   25|       |
   26|       |    /**
   27|       |    Schedules an action to be executed.
   28|       |    
   29|       |    - parameter state: State passed to the action to be executed.
   30|       |    - parameter dueTime: Relative time after which to execute the action.
   31|       |    - parameter action: Action to be executed.
   32|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   33|       |    */
   34|       |    func scheduleRelative<StateType>(_ state: StateType, dueTime: RxTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable
   35|       | 
   36|       |    /**
   37|       |    Schedules a periodic piece of work.
   38|       |    
   39|       |    - parameter state: State passed to the action to be executed.
   40|       |    - parameter startAfter: Period after which initial work should be run.
   41|       |    - parameter period: Period for running the work periodically.
   42|       |    - parameter action: Action to be executed.
   43|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   44|       |    */
   45|       |    func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping (StateType) -> StateType) -> Disposable
   46|       |}
   47|       |
   48|       |extension SchedulerType {
   49|       |
   50|       |    /**
   51|       |    Periodic task will be emulated using recursive scheduling.
   52|       |
   53|       |    - parameter state: Initial state passed to the action upon the first iteration.
   54|       |    - parameter startAfter: Period after which initial work should be run.
   55|       |    - parameter period: Period for running the work periodically.
   56|       |    - returns: The disposable object used to cancel the scheduled recurring action (best effort).
   57|       |    */
   58|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   59|      0|        let schedule = SchedulePeriodicRecursive(scheduler: self, startAfter: startAfter, period: period, action: action, state: state)
   60|      0|            
   61|      0|        return schedule.start()
   62|      0|    }
   63|       |
   64|      0|    func scheduleRecursive<State>(_ state: State, dueTime: RxTimeInterval, action: @escaping (State, AnyRecursiveScheduler<State>) -> Void) -> Disposable {
   65|      0|        let scheduler = AnyRecursiveScheduler(scheduler: self, action: action)
   66|      0|         
   67|      0|        scheduler.schedule(state, dueTime: dueTime)
   68|      0|            
   69|      0|        return Disposables.create(with: scheduler.dispose)
   70|      0|    }
   71|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/ConcurrentDispatchQueueScheduler.swift:
    1|       |//
    2|       |//  ConcurrentDispatchQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/5/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import struct Foundation.TimeInterval
   11|       |import Dispatch
   12|       |
   13|       |/// Abstracts the work that needs to be performed on a specific `dispatch_queue_t`. You can also pass a serial dispatch queue, it shouldn't cause any problems.
   14|       |///
   15|       |/// This scheduler is suitable when some work needs to be performed in background.
   16|       |public class ConcurrentDispatchQueueScheduler: SchedulerType {
   17|       |    public typealias TimeInterval = Foundation.TimeInterval
   18|       |    public typealias Time = Date
   19|       |    
   20|      0|    public var now : Date {
   21|      0|        return Date()
   22|      0|    }
   23|       |
   24|       |    let configuration: DispatchQueueConfiguration
   25|       |    
   26|       |    /// Constructs new `ConcurrentDispatchQueueScheduler` that wraps `queue`.
   27|       |    ///
   28|       |    /// - parameter queue: Target dispatch queue.
   29|       |    /// - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   30|      0|    public init(queue: DispatchQueue, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   31|      0|        self.configuration = DispatchQueueConfiguration(queue: queue, leeway: leeway)
   32|      0|    }
   33|       |    
   34|       |    /// Convenience init for scheduler that wraps one of the global concurrent dispatch queues.
   35|       |    ///
   36|       |    /// - parameter qos: Target global dispatch queue, by quality of service class.
   37|       |    /// - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   38|       |    @available(iOS 8, OSX 10.10, *)
   39|      0|    public convenience init(qos: DispatchQoS, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   40|      0|        self.init(queue: DispatchQueue(
   41|      0|            label: "rxswift.queue.\(qos)",
   42|      0|            qos: qos,
   43|      0|            attributes: [DispatchQueue.Attributes.concurrent],
   44|      0|            target: nil),
   45|      0|            leeway: leeway
   46|      0|        )
   47|      0|    }
   48|       |
   49|       |    /**
   50|       |    Schedules an action to be executed immediately.
   51|       |    
   52|       |    - parameter state: State passed to the action to be executed.
   53|       |    - parameter action: Action to be executed.
   54|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   55|       |    */
   56|      0|    public final func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   57|      0|        return self.configuration.schedule(state, action: action)
   58|      0|    }
   59|       |    
   60|       |    /**
   61|       |    Schedules an action to be executed.
   62|       |    
   63|       |    - parameter state: State passed to the action to be executed.
   64|       |    - parameter dueTime: Relative time after which to execute the action.
   65|       |    - parameter action: Action to be executed.
   66|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   67|       |    */
   68|      0|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   69|      0|        return self.configuration.scheduleRelative(state, dueTime: dueTime, action: action)
   70|      0|    }
   71|       |    
   72|       |    /**
   73|       |    Schedules a periodic piece of work.
   74|       |    
   75|       |    - parameter state: State passed to the action to be executed.
   76|       |    - parameter startAfter: Period after which initial work should be run.
   77|       |    - parameter period: Period for running the work periodically.
   78|       |    - parameter action: Action to be executed.
   79|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   80|       |    */
   81|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   82|      0|        return self.configuration.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
   83|      0|    }
   84|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/ConcurrentMainScheduler.swift:
    1|       |//
    2|       |//  ConcurrentMainScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import struct Foundation.TimeInterval
   11|       |import Dispatch
   12|       |
   13|       |/**
   14|       |Abstracts work that needs to be performed on `MainThread`. In case `schedule` methods are called from main thread, it will perform action immediately without scheduling.
   15|       |
   16|       |This scheduler is optimized for `subscribeOn` operator. If you want to observe observable sequence elements on main thread using `observeOn` operator,
   17|       |`MainScheduler` is more suitable for that purpose.
   18|       |*/
   19|       |public final class ConcurrentMainScheduler : SchedulerType {
   20|       |    public typealias TimeInterval = Foundation.TimeInterval
   21|       |    public typealias Time = Date
   22|       |
   23|       |    private let _mainScheduler: MainScheduler
   24|       |    private let _mainQueue: DispatchQueue
   25|       |
   26|       |    /// - returns: Current time.
   27|      0|    public var now: Date {
   28|      0|        return self._mainScheduler.now as Date
   29|      0|    }
   30|       |
   31|      0|    private init(mainScheduler: MainScheduler) {
   32|      0|        self._mainQueue = DispatchQueue.main
   33|      0|        self._mainScheduler = mainScheduler
   34|      0|    }
   35|       |
   36|       |    /// Singleton instance of `ConcurrentMainScheduler`
   37|       |    public static let instance = ConcurrentMainScheduler(mainScheduler: MainScheduler.instance)
   38|       |
   39|       |    /**
   40|       |    Schedules an action to be executed immediately.
   41|       |
   42|       |    - parameter state: State passed to the action to be executed.
   43|       |    - parameter action: Action to be executed.
   44|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   45|       |    */
   46|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   47|      0|        if DispatchQueue.isMain {
   48|      0|            return action(state)
   49|      0|        }
   50|      0|
   51|      0|        let cancel = SingleAssignmentDisposable()
   52|      0|
   53|      0|        self._mainQueue.async {
   54|      0|            if cancel.isDisposed {
   55|      0|                return
   56|      0|            }
   57|      0|
   58|      0|            cancel.setDisposable(action(state))
   59|      0|        }
   60|      0|
   61|      0|        return cancel
   62|      0|    }
   63|       |
   64|       |    /**
   65|       |    Schedules an action to be executed.
   66|       |
   67|       |    - parameter state: State passed to the action to be executed.
   68|       |    - parameter dueTime: Relative time after which to execute the action.
   69|       |    - parameter action: Action to be executed.
   70|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   71|       |    */
   72|      0|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   73|      0|        return self._mainScheduler.scheduleRelative(state, dueTime: dueTime, action: action)
   74|      0|    }
   75|       |
   76|       |    /**
   77|       |    Schedules a periodic piece of work.
   78|       |
   79|       |    - parameter state: State passed to the action to be executed.
   80|       |    - parameter startAfter: Period after which initial work should be run.
   81|       |    - parameter period: Period for running the work periodically.
   82|       |    - parameter action: Action to be executed.
   83|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   84|       |    */
   85|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   86|      0|        return self._mainScheduler.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
   87|      0|    }
   88|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/CurrentThreadScheduler.swift:
    1|       |//
    2|       |//  CurrentThreadScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSObject
   10|       |import protocol Foundation.NSCopying
   11|       |import class Foundation.Thread
   12|       |import Dispatch
   13|       |
   14|       |#if os(Linux)
   15|       |    import struct Foundation.pthread_key_t
   16|       |    import func Foundation.pthread_setspecific
   17|       |    import func Foundation.pthread_getspecific
   18|       |    import func Foundation.pthread_key_create
   19|       |    
   20|       |    fileprivate enum CurrentThreadSchedulerQueueKey {
   21|       |        fileprivate static let instance = "RxSwift.CurrentThreadScheduler.Queue"
   22|       |    }
   23|       |#else
   24|       |    private class CurrentThreadSchedulerQueueKey: NSObject, NSCopying {
   25|       |        static let instance = CurrentThreadSchedulerQueueKey()
   26|      0|        private override init() {
   27|      0|            super.init()
   28|      0|        }
   29|       |
   30|       |        override var hash: Int {
   31|       |            return 0
   32|       |        }
   33|       |
   34|      0|        public func copy(with zone: NSZone? = nil) -> Any {
   35|      0|            return self
   36|      0|        }
   37|       |    }
   38|       |#endif
   39|       |
   40|       |/// Represents an object that schedules units of work on the current thread.
   41|       |///
   42|       |/// This is the default scheduler for operators that generate elements.
   43|       |///
   44|       |/// This scheduler is also sometimes called `trampoline scheduler`.
   45|       |public class CurrentThreadScheduler : ImmediateSchedulerType {
   46|       |    typealias ScheduleQueue = RxMutableBox<Queue<ScheduledItemType>>
   47|       |
   48|       |    /// The singleton instance of the current thread scheduler.
   49|       |    public static let instance = CurrentThreadScheduler()
   50|       |
   51|      0|    private static var isScheduleRequiredKey: pthread_key_t = { () -> pthread_key_t in
   52|      0|        let key = UnsafeMutablePointer<pthread_key_t>.allocate(capacity: 1)
   53|      0|        defer {
   54|      0|#if swift(>=4.1)
   55|      0|            key.deallocate()
   56|      0|#else
   57|      0|            key.deallocate(capacity: 1)
   58|      0|#endif
   59|      0|        }
   60|      0|                                                               
   61|      0|        guard pthread_key_create(key, nil) == 0 else {
   62|      0|            rxFatalError("isScheduleRequired key creation failed")
   63|      0|        }
   64|      0|
   65|      0|        return key.pointee
   66|      0|    }()
   67|       |
   68|      0|    private static var scheduleInProgressSentinel: UnsafeRawPointer = { () -> UnsafeRawPointer in
   69|      0|        return UnsafeRawPointer(UnsafeMutablePointer<Int>.allocate(capacity: 1))
   70|      0|    }()
   71|       |
   72|       |    static var queue : ScheduleQueue? {
   73|      0|        get {
   74|      0|            return Thread.getThreadLocalStorageValueForKey(CurrentThreadSchedulerQueueKey.instance)
   75|      0|        }
   76|      0|        set {
   77|      0|            Thread.setThreadLocalStorageValue(newValue, forKey: CurrentThreadSchedulerQueueKey.instance)
   78|      0|        }
   79|       |    }
   80|       |
   81|       |    /// Gets a value that indicates whether the caller must call a `schedule` method.
   82|       |    public static fileprivate(set) var isScheduleRequired: Bool {
   83|      0|        get {
   84|      0|            return pthread_getspecific(CurrentThreadScheduler.isScheduleRequiredKey) == nil
   85|      0|        }
   86|      0|        set(isScheduleRequired) {
   87|      0|            if pthread_setspecific(CurrentThreadScheduler.isScheduleRequiredKey, isScheduleRequired ? nil : scheduleInProgressSentinel) != 0 {
   88|      0|                rxFatalError("pthread_setspecific failed")
   89|      0|            }
   90|      0|        }
   91|       |    }
   92|       |
   93|       |    /**
   94|       |    Schedules an action to be executed as soon as possible on current thread.
   95|       |
   96|       |    If this method is called on some thread that doesn't have `CurrentThreadScheduler` installed, scheduler will be
   97|       |    automatically installed and uninstalled after all work is performed.
   98|       |
   99|       |    - parameter state: State passed to the action to be executed.
  100|       |    - parameter action: Action to be executed.
  101|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
  102|       |    */
  103|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
  104|      0|        if CurrentThreadScheduler.isScheduleRequired {
  105|      0|            CurrentThreadScheduler.isScheduleRequired = false
  106|      0|
  107|      0|            let disposable = action(state)
  108|      0|
  109|      0|            defer {
  110|      0|                CurrentThreadScheduler.isScheduleRequired = true
  111|      0|                CurrentThreadScheduler.queue = nil
  112|      0|            }
  113|      0|
  114|      0|            guard let queue = CurrentThreadScheduler.queue else {
  115|      0|                return disposable
  116|      0|            }
  117|      0|
  118|      0|            while let latest = queue.value.dequeue() {
  119|      0|                if latest.isDisposed {
  120|      0|                    continue
  121|      0|                }
  122|      0|                latest.invoke()
  123|      0|            }
  124|      0|
  125|      0|            return disposable
  126|      0|        }
  127|      0|
  128|      0|        let existingQueue = CurrentThreadScheduler.queue
  129|      0|
  130|      0|        let queue: RxMutableBox<Queue<ScheduledItemType>>
  131|      0|        if let existingQueue = existingQueue {
  132|      0|            queue = existingQueue
  133|      0|        }
  134|      0|        else {
  135|      0|            queue = RxMutableBox(Queue<ScheduledItemType>(capacity: 1))
  136|      0|            CurrentThreadScheduler.queue = queue
  137|      0|        }
  138|      0|
  139|      0|        let scheduledItem = ScheduledItem(action: action, state: state)
  140|      0|        queue.value.enqueue(scheduledItem)
  141|      0|
  142|      0|        return scheduledItem
  143|      0|    }
  144|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/HistoricalScheduler.swift:
    1|       |//
    2|       |//  HistoricalScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |/// Provides a virtual time scheduler that uses `Date` for absolute time and `NSTimeInterval` for relative time.
   12|       |public class HistoricalScheduler : VirtualTimeScheduler<HistoricalSchedulerTimeConverter> {
   13|       |
   14|       |    /**
   15|       |      Creates a new historical scheduler with initial clock value.
   16|       |     
   17|       |     - parameter initialClock: Initial value for virtual clock.
   18|       |    */
   19|      0|    public init(initialClock: RxTime = Date(timeIntervalSince1970: 0)) {
   20|      0|        super.init(initialClock: initialClock, converter: HistoricalSchedulerTimeConverter())
   21|      0|    }
   22|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/HistoricalSchedulerTimeConverter.swift:
    1|       |//
    2|       |//  HistoricalSchedulerTimeConverter.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |/// Converts historical virtual time into real time.
   12|       |///
   13|       |/// Since historical virtual time is also measured in `Date`, this converter is identity function.
   14|       |public struct HistoricalSchedulerTimeConverter : VirtualTimeConverterType {
   15|       |    /// Virtual time unit used that represents ticks of virtual clock.
   16|       |    public typealias VirtualTimeUnit = RxTime
   17|       |
   18|       |    /// Virtual time unit used to represent differences of virtual times.
   19|       |    public typealias VirtualTimeIntervalUnit = RxTimeInterval
   20|       |
   21|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   22|       |    /// decoupled from local machine clock.
   23|      0|    public func convertFromVirtualTime(_ virtualTime: VirtualTimeUnit) -> RxTime {
   24|      0|        return virtualTime
   25|      0|    }
   26|       |
   27|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   28|       |    /// decoupled from local machine clock.
   29|      0|    public func convertToVirtualTime(_ time: RxTime) -> VirtualTimeUnit {
   30|      0|        return time
   31|      0|    }
   32|       |
   33|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   34|       |    /// decoupled from local machine clock.
   35|      0|    public func convertFromVirtualTimeInterval(_ virtualTimeInterval: VirtualTimeIntervalUnit) -> RxTimeInterval {
   36|      0|        return virtualTimeInterval
   37|      0|    }
   38|       |
   39|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   40|       |    /// decoupled from local machine clock.
   41|      0|    public func convertToVirtualTimeInterval(_ timeInterval: RxTimeInterval) -> VirtualTimeIntervalUnit {
   42|      0|        return timeInterval
   43|      0|    }
   44|       |
   45|       |    /**
   46|       |     Offsets `Date` by time interval.
   47|       |     
   48|       |     - parameter time: Time.
   49|       |     - parameter timeInterval: Time interval offset.
   50|       |     - returns: Time offsetted by time interval.
   51|       |    */
   52|      0|    public func offsetVirtualTime(_ time: VirtualTimeUnit, offset: VirtualTimeIntervalUnit) -> VirtualTimeUnit {
   53|      0|        return time.addingTimeInterval(offset)
   54|      0|    }
   55|       |
   56|       |    /// Compares two `Date`s.
   57|      0|    public func compareVirtualTime(_ lhs: VirtualTimeUnit, _ rhs: VirtualTimeUnit) -> VirtualTimeComparison {
   58|      0|        switch lhs.compare(rhs as Date) {
   59|      0|        case .orderedAscending:
   60|      0|            return .lessThan
   61|      0|        case .orderedSame:
   62|      0|            return .equal
   63|      0|        case .orderedDescending:
   64|      0|            return .greaterThan
   65|      0|        }
   66|      0|    }
   67|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/DispatchQueueConfiguration.swift:
    1|       |//
    2|       |//  DispatchQueueConfiguration.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/23/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |import struct Foundation.TimeInterval
   11|       |
   12|       |struct DispatchQueueConfiguration {
   13|       |    let queue: DispatchQueue
   14|       |    let leeway: DispatchTimeInterval
   15|       |}
   16|       |
   17|      0|private func dispatchInterval(_ interval: Foundation.TimeInterval) -> DispatchTimeInterval {
   18|      0|    precondition(interval >= 0.0)
   19|      0|    // TODO: Replace 1000 with something that actually works 
   20|      0|    // NSEC_PER_MSEC returns 1000000
   21|      0|    return DispatchTimeInterval.milliseconds(Int(interval * 1000.0))
   22|      0|}
   23|       |
   24|       |extension DispatchQueueConfiguration {
   25|      0|    func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   26|      0|        let cancel = SingleAssignmentDisposable()
   27|      0|
   28|      0|        self.queue.async {
   29|      0|            if cancel.isDisposed {
   30|      0|                return
   31|      0|            }
   32|      0|
   33|      0|
   34|      0|            cancel.setDisposable(action(state))
   35|      0|        }
   36|      0|
   37|      0|        return cancel
   38|      0|    }
   39|       |
   40|      0|    func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   41|      0|        let deadline = DispatchTime.now() + dispatchInterval(dueTime)
   42|      0|
   43|      0|        let compositeDisposable = CompositeDisposable()
   44|      0|
   45|      0|        let timer = DispatchSource.makeTimerSource(queue: self.queue)
   46|      0|        timer.schedule(deadline: deadline, leeway: self.leeway)
   47|      0|
   48|      0|        // TODO:
   49|      0|        // This looks horrible, and yes, it is.
   50|      0|        // It looks like Apple has made a conceputal change here, and I'm unsure why.
   51|      0|        // Need more info on this.
   52|      0|        // It looks like just setting timer to fire and not holding a reference to it
   53|      0|        // until deadline causes timer cancellation.
   54|      0|        var timerReference: DispatchSourceTimer? = timer
   55|      0|        let cancelTimer = Disposables.create {
   56|      0|            timerReference?.cancel()
   57|      0|            timerReference = nil
   58|      0|        }
   59|      0|
   60|      0|        timer.setEventHandler(handler: {
   61|      0|            if compositeDisposable.isDisposed {
   62|      0|                return
   63|      0|            }
   64|      0|            _ = compositeDisposable.insert(action(state))
   65|      0|            cancelTimer.dispose()
   66|      0|        })
   67|      0|        timer.resume()
   68|      0|
   69|      0|        _ = compositeDisposable.insert(cancelTimer)
   70|      0|
   71|      0|        return compositeDisposable
   72|      0|    }
   73|       |
   74|      0|    func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   75|      0|        let initial = DispatchTime.now() + dispatchInterval(startAfter)
   76|      0|
   77|      0|        var timerState = state
   78|      0|
   79|      0|        let timer = DispatchSource.makeTimerSource(queue: self.queue)
   80|      0|        timer.schedule(deadline: initial, repeating: dispatchInterval(period), leeway: self.leeway)
   81|      0|        
   82|      0|        // TODO:
   83|      0|        // This looks horrible, and yes, it is.
   84|      0|        // It looks like Apple has made a conceputal change here, and I'm unsure why.
   85|      0|        // Need more info on this.
   86|      0|        // It looks like just setting timer to fire and not holding a reference to it
   87|      0|        // until deadline causes timer cancellation.
   88|      0|        var timerReference: DispatchSourceTimer? = timer
   89|      0|        let cancelTimer = Disposables.create {
   90|      0|            timerReference?.cancel()
   91|      0|            timerReference = nil
   92|      0|        }
   93|      0|
   94|      0|        timer.setEventHandler(handler: {
   95|      0|            if cancelTimer.isDisposed {
   96|      0|                return
   97|      0|            }
   98|      0|            timerState = action(timerState)
   99|      0|        })
  100|      0|        timer.resume()
  101|      0|        
  102|      0|        return cancelTimer
  103|      0|    }
  104|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/InvocableScheduledItem.swift:
    1|       |//
    2|       |//  InvocableScheduledItem.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct InvocableScheduledItem<I: InvocableWithValueType> : InvocableType {
   10|       |
   11|       |    let _invocable: I
   12|       |    let _state: I.Value
   13|       |
   14|      0|    init(invocable: I, state: I.Value) {
   15|      0|        self._invocable = invocable
   16|      0|        self._state = state
   17|      0|    }
   18|       |
   19|      0|    func invoke() {
   20|      0|        self._invocable.invoke(self._state)
   21|      0|    }
   22|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/ScheduledItem.swift:
    1|       |//
    2|       |//  ScheduledItem.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct ScheduledItem<T>
   10|       |    : ScheduledItemType
   11|       |    , InvocableType {
   12|       |    typealias Action = (T) -> Disposable
   13|       |    
   14|       |    private let _action: Action
   15|       |    private let _state: T
   16|       |
   17|       |    private let _disposable = SingleAssignmentDisposable()
   18|       |
   19|      0|    var isDisposed: Bool {
   20|      0|        return self._disposable.isDisposed
   21|      0|    }
   22|       |    
   23|      0|    init(action: @escaping Action, state: T) {
   24|      0|        self._action = action
   25|      0|        self._state = state
   26|      0|    }
   27|       |    
   28|      0|    func invoke() {
   29|      0|         self._disposable.setDisposable(self._action(self._state))
   30|      0|    }
   31|       |    
   32|      0|    func dispose() {
   33|      0|        self._disposable.dispose()
   34|      0|    }
   35|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/MainScheduler.swift:
    1|       |//
    2|       |//  MainScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |#if !os(Linux)
   11|       |    import Foundation
   12|       |#endif
   13|       |
   14|       |/**
   15|       |Abstracts work that needs to be performed on `DispatchQueue.main`. In case `schedule` methods are called from `DispatchQueue.main`, it will perform action immediately without scheduling.
   16|       |
   17|       |This scheduler is usually used to perform UI work.
   18|       |
   19|       |Main scheduler is a specialization of `SerialDispatchQueueScheduler`.
   20|       |
   21|       |This scheduler is optimized for `observeOn` operator. To ensure observable sequence is subscribed on main thread using `subscribeOn`
   22|       |operator please use `ConcurrentMainScheduler` because it is more optimized for that purpose.
   23|       |*/
   24|       |public final class MainScheduler : SerialDispatchQueueScheduler {
   25|       |
   26|       |    private let _mainQueue: DispatchQueue
   27|       |
   28|       |    let numberEnqueued = AtomicInt(0)
   29|       |
   30|       |    /// Initializes new instance of `MainScheduler`.
   31|      0|    public init() {
   32|      0|        self._mainQueue = DispatchQueue.main
   33|      0|        super.init(serialQueue: self._mainQueue)
   34|      0|    }
   35|       |
   36|       |    /// Singleton instance of `MainScheduler`
   37|       |    public static let instance = MainScheduler()
   38|       |
   39|       |    /// Singleton instance of `MainScheduler` that always schedules work asynchronously
   40|       |    /// and doesn't perform optimizations for calls scheduled from main queue.
   41|       |    public static let asyncInstance = SerialDispatchQueueScheduler(serialQueue: DispatchQueue.main)
   42|       |
   43|       |    /// In case this method is called on a background thread it will throw an exception.
   44|      0|    public class func ensureExecutingOnScheduler(errorMessage: String? = nil) {
   45|      0|        if !DispatchQueue.isMain {
   46|      0|            rxFatalError(errorMessage ?? "Executing on background thread. Please use `MainScheduler.instance.schedule` to schedule work on main thread.")
   47|      0|        }
   48|      0|    }
   49|       |
   50|       |    /// In case this method is running on a background thread it will throw an exception.
   51|      0|    public class func ensureRunningOnMainThread(errorMessage: String? = nil) {
   52|      0|        #if !os(Linux) // isMainThread is not implemented in Linux Foundation
   53|      0|            guard Thread.isMainThread else {
   54|      0|                rxFatalError(errorMessage ?? "Running on background thread.")
   55|      0|            }
   56|      0|        #endif
   57|      0|    }
   58|       |
   59|      0|    override func scheduleInternal<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   60|      0|        let previousNumberEnqueued = increment(self.numberEnqueued)
   61|      0|
   62|      0|        if DispatchQueue.isMain && previousNumberEnqueued == 0 {
   63|      0|            let disposable = action(state)
   64|      0|            decrement(self.numberEnqueued)
   65|      0|            return disposable
   66|      0|        }
   67|      0|
   68|      0|        let cancel = SingleAssignmentDisposable()
   69|      0|
   70|      0|        self._mainQueue.async {
   71|      0|            if !cancel.isDisposed {
   72|      0|                _ = action(state)
   73|      0|            }
   74|      0|
   75|      0|            decrement(self.numberEnqueued)
   76|      0|        }
   77|      0|
   78|      0|        return cancel
   79|      0|    }
   80|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/OperationQueueScheduler.swift:
    1|       |//
    2|       |//  OperationQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.Operation
   10|       |import class Foundation.OperationQueue
   11|       |import class Foundation.BlockOperation
   12|       |import Dispatch
   13|       |
   14|       |/// Abstracts the work that needs to be performed on a specific `NSOperationQueue`.
   15|       |///
   16|       |/// This scheduler is suitable for cases when there is some bigger chunk of work that needs to be performed in background and you want to fine tune concurrent processing using `maxConcurrentOperationCount`.
   17|       |public class OperationQueueScheduler: ImmediateSchedulerType {
   18|       |    public let operationQueue: OperationQueue
   19|       |    public let queuePriority: Operation.QueuePriority
   20|       |    
   21|       |    /// Constructs new instance of `OperationQueueScheduler` that performs work on `operationQueue`.
   22|       |    ///
   23|       |    /// - parameter operationQueue: Operation queue targeted to perform work on.
   24|       |    /// - parameter queuePriority: Queue priority which will be assigned to new operations.
   25|      0|    public init(operationQueue: OperationQueue, queuePriority: Operation.QueuePriority = .normal) {
   26|      0|        self.operationQueue = operationQueue
   27|      0|        self.queuePriority = queuePriority
   28|      0|    }
   29|       |    
   30|       |    /**
   31|       |    Schedules an action to be executed recursively.
   32|       |    
   33|       |    - parameter state: State passed to the action to be executed.
   34|       |    - parameter action: Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
   35|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   36|       |    */
   37|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   38|      0|        let cancel = SingleAssignmentDisposable()
   39|      0|
   40|      0|        let operation = BlockOperation {
   41|      0|            if cancel.isDisposed {
   42|      0|                return
   43|      0|            }
   44|      0|
   45|      0|
   46|      0|            cancel.setDisposable(action(state))
   47|      0|        }
   48|      0|
   49|      0|        operation.queuePriority = self.queuePriority
   50|      0|
   51|      0|        self.operationQueue.addOperation(operation)
   52|      0|        
   53|      0|        return cancel
   54|      0|    }
   55|       |
   56|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/RecursiveScheduler.swift:
    1|       |//
    2|       |//  RecursiveScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |private enum ScheduleState {
   10|       |    case initial
   11|       |    case added(CompositeDisposable.DisposeKey)
   12|       |    case done
   13|       |}
   14|       |
   15|       |/// Type erased recursive scheduler.
   16|       |final class AnyRecursiveScheduler<State> {
   17|       |    
   18|       |    typealias Action =  (State, AnyRecursiveScheduler<State>) -> Void
   19|       |
   20|       |    private let _lock = RecursiveLock()
   21|       |    
   22|       |    // state
   23|       |    private let _group = CompositeDisposable()
   24|       |
   25|       |    private var _scheduler: SchedulerType
   26|       |    private var _action: Action?
   27|       |    
   28|      0|    init(scheduler: SchedulerType, action: @escaping Action) {
   29|      0|        self._action = action
   30|      0|        self._scheduler = scheduler
   31|      0|    }
   32|       |
   33|       |    /**
   34|       |    Schedules an action to be executed recursively.
   35|       |    
   36|       |    - parameter state: State passed to the action to be executed.
   37|       |    - parameter dueTime: Relative time after which to execute the recursive action.
   38|       |    */
   39|      0|    func schedule(_ state: State, dueTime: RxTimeInterval) {
   40|      0|        var scheduleState: ScheduleState = .initial
   41|      0|
   42|      0|        let d = self._scheduler.scheduleRelative(state, dueTime: dueTime) { state -> Disposable in
   43|      0|            // best effort
   44|      0|            if self._group.isDisposed {
   45|      0|                return Disposables.create()
   46|      0|            }
   47|      0|            
   48|      0|            let action = self._lock.calculateLocked { () -> Action? in
   49|      0|                switch scheduleState {
   50|      0|                case let .added(removeKey):
   51|      0|                    self._group.remove(for: removeKey)
   52|      0|                case .initial:
   53|      0|                    break
   54|      0|                case .done:
   55|      0|                    break
   56|      0|                }
   57|      0|
   58|      0|                scheduleState = .done
   59|      0|
   60|      0|                return self._action
   61|      0|            }
   62|      0|            
   63|      0|            if let action = action {
   64|      0|                action(state, self)
   65|      0|            }
   66|      0|            
   67|      0|            return Disposables.create()
   68|      0|        }
   69|      0|            
   70|      0|        self._lock.performLocked {
   71|      0|            switch scheduleState {
   72|      0|            case .added:
   73|      0|                rxFatalError("Invalid state")
   74|      0|            case .initial:
   75|      0|                if let removeKey = self._group.insert(d) {
   76|      0|                    scheduleState = .added(removeKey)
   77|      0|                }
   78|      0|                else {
   79|      0|                    scheduleState = .done
   80|      0|                }
   81|      0|            case .done:
   82|      0|                break
   83|      0|            }
   84|      0|        }
   85|      0|    }
   86|       |
   87|       |    /// Schedules an action to be executed recursively.
   88|       |    ///
   89|       |    /// - parameter state: State passed to the action to be executed.
   90|      0|    func schedule(_ state: State) {
   91|      0|        var scheduleState: ScheduleState = .initial
   92|      0|
   93|      0|        let d = self._scheduler.schedule(state) { state -> Disposable in
   94|      0|            // best effort
   95|      0|            if self._group.isDisposed {
   96|      0|                return Disposables.create()
   97|      0|            }
   98|      0|            
   99|      0|            let action = self._lock.calculateLocked { () -> Action? in
  100|      0|                switch scheduleState {
  101|      0|                case let .added(removeKey):
  102|      0|                    self._group.remove(for: removeKey)
  103|      0|                case .initial:
  104|      0|                    break
  105|      0|                case .done:
  106|      0|                    break
  107|      0|                }
  108|      0|
  109|      0|                scheduleState = .done
  110|      0|                
  111|      0|                return self._action
  112|      0|            }
  113|      0|           
  114|      0|            if let action = action {
  115|      0|                action(state, self)
  116|      0|            }
  117|      0|            
  118|      0|            return Disposables.create()
  119|      0|        }
  120|      0|        
  121|      0|        self._lock.performLocked {
  122|      0|            switch scheduleState {
  123|      0|            case .added:
  124|      0|                rxFatalError("Invalid state")
  125|      0|            case .initial:
  126|      0|                if let removeKey = self._group.insert(d) {
  127|      0|                    scheduleState = .added(removeKey)
  128|      0|                }
  129|      0|                else {
  130|      0|                    scheduleState = .done
  131|      0|                }
  132|      0|            case .done:
  133|      0|                break
  134|      0|            }
  135|      0|        }
  136|      0|    }
  137|       |    
  138|      0|    func dispose() {
  139|      0|        self._lock.performLocked {
  140|      0|            self._action = nil
  141|      0|        }
  142|      0|        self._group.dispose()
  143|      0|    }
  144|       |}
  145|       |
  146|       |/// Type erased recursive scheduler.
  147|       |final class RecursiveImmediateScheduler<State> {
  148|       |    typealias Action =  (_ state: State, _ recurse: (State) -> Void) -> Void
  149|       |    
  150|       |    private var _lock = SpinLock()
  151|       |    private let _group = CompositeDisposable()
  152|       |    
  153|       |    private var _action: Action?
  154|       |    private let _scheduler: ImmediateSchedulerType
  155|       |    
  156|      0|    init(action: @escaping Action, scheduler: ImmediateSchedulerType) {
  157|      0|        self._action = action
  158|      0|        self._scheduler = scheduler
  159|      0|    }
  160|       |    
  161|       |    // immediate scheduling
  162|       |    
  163|       |    /// Schedules an action to be executed recursively.
  164|       |    ///
  165|       |    /// - parameter state: State passed to the action to be executed.
  166|      0|    func schedule(_ state: State) {
  167|      0|        var scheduleState: ScheduleState = .initial
  168|      0|
  169|      0|        let d = self._scheduler.schedule(state) { state -> Disposable in
  170|      0|            // best effort
  171|      0|            if self._group.isDisposed {
  172|      0|                return Disposables.create()
  173|      0|            }
  174|      0|            
  175|      0|            let action = self._lock.calculateLocked { () -> Action? in
  176|      0|                switch scheduleState {
  177|      0|                case let .added(removeKey):
  178|      0|                    self._group.remove(for: removeKey)
  179|      0|                case .initial:
  180|      0|                    break
  181|      0|                case .done:
  182|      0|                    break
  183|      0|                }
  184|      0|
  185|      0|                scheduleState = .done
  186|      0|
  187|      0|                return self._action
  188|      0|            }
  189|      0|            
  190|      0|            if let action = action {
  191|      0|                action(state, self.schedule)
  192|      0|            }
  193|      0|            
  194|      0|            return Disposables.create()
  195|      0|        }
  196|      0|        
  197|      0|        self._lock.performLocked {
  198|      0|            switch scheduleState {
  199|      0|            case .added:
  200|      0|                rxFatalError("Invalid state")
  201|      0|            case .initial:
  202|      0|                if let removeKey = self._group.insert(d) {
  203|      0|                    scheduleState = .added(removeKey)
  204|      0|                }
  205|      0|                else {
  206|      0|                    scheduleState = .done
  207|      0|                }
  208|      0|            case .done:
  209|      0|                break
  210|      0|            }
  211|      0|        }
  212|      0|    }
  213|       |    
  214|      0|    func dispose() {
  215|      0|        self._lock.performLocked {
  216|      0|            self._action = nil
  217|      0|        }
  218|      0|        self._group.dispose()
  219|      0|    }
  220|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/SchedulerServices+Emulation.swift:
    1|       |//
    2|       |//  SchedulerServices+Emulation.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |enum SchedulePeriodicRecursiveCommand {
   10|       |    case tick
   11|       |    case dispatchStart
   12|       |}
   13|       |
   14|       |final class SchedulePeriodicRecursive<State> {
   15|       |    typealias RecursiveAction = (State) -> State
   16|       |    typealias RecursiveScheduler = AnyRecursiveScheduler<SchedulePeriodicRecursiveCommand>
   17|       |
   18|       |    private let _scheduler: SchedulerType
   19|       |    private let _startAfter: RxTimeInterval
   20|       |    private let _period: RxTimeInterval
   21|       |    private let _action: RecursiveAction
   22|       |
   23|       |    private var _state: State
   24|       |    private let _pendingTickCount = AtomicInt(0)
   25|       |
   26|      0|    init(scheduler: SchedulerType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping RecursiveAction, state: State) {
   27|      0|        self._scheduler = scheduler
   28|      0|        self._startAfter = startAfter
   29|      0|        self._period = period
   30|      0|        self._action = action
   31|      0|        self._state = state
   32|      0|    }
   33|       |
   34|      0|    func start() -> Disposable {
   35|      0|        return self._scheduler.scheduleRecursive(SchedulePeriodicRecursiveCommand.tick, dueTime: self._startAfter, action: self.tick)
   36|      0|    }
   37|       |
   38|       |    func tick(_ command: SchedulePeriodicRecursiveCommand, scheduler: RecursiveScheduler) {
   39|       |        // Tries to emulate periodic scheduling as best as possible.
   40|       |        // The problem that could arise is if handling periodic ticks take too long, or
   41|       |        // tick interval is short.
   42|       |        switch command {
   43|       |        case .tick:
   44|       |            scheduler.schedule(.tick, dueTime: self._period)
   45|       |
   46|       |            // The idea is that if on tick there wasn't any item enqueued, schedule to perform work immediately.
   47|       |            // Else work will be scheduled after previous enqueued work completes.
   48|       |            if increment(self._pendingTickCount) == 0 {
   49|       |                self.tick(.dispatchStart, scheduler: scheduler)
   50|       |            }
   51|       |
   52|       |        case .dispatchStart:
   53|       |            self._state = self._action(self._state)
   54|       |            // Start work and schedule check is this last batch of work
   55|       |            if decrement(self._pendingTickCount) > 1 {
   56|       |                // This gives priority to scheduler emulation, it's not perfect, but helps
   57|       |                scheduler.schedule(SchedulePeriodicRecursiveCommand.dispatchStart)
   58|       |            }
   59|       |        }
   60|       |    }
   61|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/SerialDispatchQueueScheduler.swift:
    1|       |//
    2|       |//  SerialDispatchQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.TimeInterval
   10|       |import struct Foundation.Date
   11|       |import Dispatch
   12|       |
   13|       |/**
   14|       |Abstracts the work that needs to be performed on a specific `dispatch_queue_t`. It will make sure 
   15|       |that even if concurrent dispatch queue is passed, it's transformed into a serial one.
   16|       |
   17|       |It is extremely important that this scheduler is serial, because
   18|       |certain operator perform optimizations that rely on that property.
   19|       |
   20|       |Because there is no way of detecting is passed dispatch queue serial or
   21|       |concurrent, for every queue that is being passed, worst case (concurrent)
   22|       |will be assumed, and internal serial proxy dispatch queue will be created.
   23|       |
   24|       |This scheduler can also be used with internal serial queue alone.
   25|       |
   26|       |In case some customization need to be made on it before usage,
   27|       |internal serial queue can be customized using `serialQueueConfiguration`
   28|       |callback.
   29|       |*/
   30|       |public class SerialDispatchQueueScheduler : SchedulerType {
   31|       |    public typealias TimeInterval = Foundation.TimeInterval
   32|       |    public typealias Time = Date
   33|       |    
   34|       |    /// - returns: Current time.
   35|      0|    public var now : Date {
   36|      0|        return Date()
   37|      0|    }
   38|       |
   39|       |    let configuration: DispatchQueueConfiguration
   40|       |    
   41|       |    /**
   42|       |    Constructs new `SerialDispatchQueueScheduler` that wraps `serialQueue`.
   43|       |
   44|       |    - parameter serialQueue: Target dispatch queue.
   45|       |    - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   46|       |    */
   47|      0|    init(serialQueue: DispatchQueue, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   48|      0|        self.configuration = DispatchQueueConfiguration(queue: serialQueue, leeway: leeway)
   49|      0|    }
   50|       |
   51|       |    /**
   52|       |    Constructs new `SerialDispatchQueueScheduler` with internal serial queue named `internalSerialQueueName`.
   53|       |    
   54|       |    Additional dispatch queue properties can be set after dispatch queue is created using `serialQueueConfiguration`.
   55|       |    
   56|       |    - parameter internalSerialQueueName: Name of internal serial dispatch queue.
   57|       |    - parameter serialQueueConfiguration: Additional configuration of internal serial dispatch queue.
   58|       |    - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   59|       |    */
   60|      0|    public convenience init(internalSerialQueueName: String, serialQueueConfiguration: ((DispatchQueue) -> Void)? = nil, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   61|      0|        let queue = DispatchQueue(label: internalSerialQueueName, attributes: [])
   62|      0|        serialQueueConfiguration?(queue)
   63|      0|        self.init(serialQueue: queue, leeway: leeway)
   64|      0|    }
   65|       |    
   66|       |    /**
   67|       |    Constructs new `SerialDispatchQueueScheduler` named `internalSerialQueueName` that wraps `queue`.
   68|       |    
   69|       |    - parameter queue: Possibly concurrent dispatch queue used to perform work.
   70|       |    - parameter internalSerialQueueName: Name of internal serial dispatch queue proxy.
   71|       |    - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   72|       |    */
   73|      0|    public convenience init(queue: DispatchQueue, internalSerialQueueName: String, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   74|      0|        // Swift 3.0 IUO
   75|      0|        let serialQueue = DispatchQueue(label: internalSerialQueueName,
   76|      0|                                        attributes: [],
   77|      0|                                        target: queue)
   78|      0|        self.init(serialQueue: serialQueue, leeway: leeway)
   79|      0|    }
   80|       |
   81|       |    /**
   82|       |     Constructs new `SerialDispatchQueueScheduler` that wraps on of the global concurrent dispatch queues.
   83|       |     
   84|       |     - parameter qos: Identifier for global dispatch queue with specified quality of service class.
   85|       |     - parameter internalSerialQueueName: Custom name for internal serial dispatch queue proxy.
   86|       |     - parameter leeway: The amount of time, in nanoseconds, that the system will defer the timer.
   87|       |     */
   88|       |    @available(iOS 8, OSX 10.10, *)
   89|      0|    public convenience init(qos: DispatchQoS, internalSerialQueueName: String = "rx.global_dispatch_queue.serial", leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   90|      0|        self.init(queue: DispatchQueue.global(qos: qos.qosClass), internalSerialQueueName: internalSerialQueueName, leeway: leeway)
   91|      0|    }
   92|       |    
   93|       |    /**
   94|       |    Schedules an action to be executed immediately.
   95|       |    
   96|       |    - parameter state: State passed to the action to be executed.
   97|       |    - parameter action: Action to be executed.
   98|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   99|       |    */
  100|      0|    public final func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
  101|      0|        return self.scheduleInternal(state, action: action)
  102|      0|    }
  103|       |
  104|      0|    func scheduleInternal<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
  105|      0|        return self.configuration.schedule(state, action: action)
  106|      0|    }
  107|       |
  108|       |    /**
  109|       |    Schedules an action to be executed.
  110|       |    
  111|       |    - parameter state: State passed to the action to be executed.
  112|       |    - parameter dueTime: Relative time after which to execute the action.
  113|       |    - parameter action: Action to be executed.
  114|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
  115|       |    */
  116|      0|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
  117|      0|        return self.configuration.scheduleRelative(state, dueTime: dueTime, action: action)
  118|      0|    }
  119|       |    
  120|       |    /**
  121|       |    Schedules a periodic piece of work.
  122|       |    
  123|       |    - parameter state: State passed to the action to be executed.
  124|       |    - parameter startAfter: Period after which initial work should be run.
  125|       |    - parameter period: Period for running the work periodically.
  126|       |    - parameter action: Action to be executed.
  127|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
  128|       |    */
  129|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
  130|      0|        return self.configuration.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
  131|      0|    }
  132|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/VirtualTimeConverterType.swift:
    1|       |//
    2|       |//  VirtualTimeConverterType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Parametrization for virtual time used by `VirtualTimeScheduler`s.
   10|       |public protocol VirtualTimeConverterType {
   11|       |    /// Virtual time unit used that represents ticks of virtual clock.
   12|       |    associatedtype VirtualTimeUnit
   13|       |
   14|       |    /// Virtual time unit used to represent differences of virtual times.
   15|       |    associatedtype VirtualTimeIntervalUnit
   16|       |
   17|       |    /**
   18|       |     Converts virtual time to real time.
   19|       |     
   20|       |     - parameter virtualTime: Virtual time to convert to `Date`.
   21|       |     - returns: `Date` corresponding to virtual time.
   22|       |    */
   23|       |    func convertFromVirtualTime(_ virtualTime: VirtualTimeUnit) -> RxTime
   24|       |
   25|       |    /**
   26|       |     Converts real time to virtual time.
   27|       |     
   28|       |     - parameter time: `Date` to convert to virtual time.
   29|       |     - returns: Virtual time corresponding to `Date`.
   30|       |    */
   31|       |    func convertToVirtualTime(_ time: RxTime) -> VirtualTimeUnit
   32|       |
   33|       |    /**
   34|       |     Converts from virtual time interval to `NSTimeInterval`.
   35|       |     
   36|       |     - parameter virtualTimeInterval: Virtual time interval to convert to `NSTimeInterval`.
   37|       |     - returns: `NSTimeInterval` corresponding to virtual time interval.
   38|       |    */
   39|       |    func convertFromVirtualTimeInterval(_ virtualTimeInterval: VirtualTimeIntervalUnit) -> RxTimeInterval
   40|       |
   41|       |    /**
   42|       |     Converts from `NSTimeInterval` to virtual time interval.
   43|       |     
   44|       |     - parameter timeInterval: `NSTimeInterval` to convert to virtual time interval.
   45|       |     - returns: Virtual time interval corresponding to time interval.
   46|       |    */
   47|       |    func convertToVirtualTimeInterval(_ timeInterval: RxTimeInterval) -> VirtualTimeIntervalUnit
   48|       |
   49|       |    /**
   50|       |     Offsets virtual time by virtual time interval.
   51|       |     
   52|       |     - parameter time: Virtual time.
   53|       |     - parameter offset: Virtual time interval.
   54|       |     - returns: Time corresponding to time offsetted by virtual time interval.
   55|       |    */
   56|       |    func offsetVirtualTime(_ time: VirtualTimeUnit, offset: VirtualTimeIntervalUnit) -> VirtualTimeUnit
   57|       |
   58|       |    /**
   59|       |     This is additional abstraction because `Date` is unfortunately not comparable.
   60|       |     Extending `Date` with `Comparable` would be too risky because of possible collisions with other libraries.
   61|       |    */
   62|       |    func compareVirtualTime(_ lhs: VirtualTimeUnit, _ rhs: VirtualTimeUnit) -> VirtualTimeComparison
   63|       |}
   64|       |
   65|       |/**
   66|       | Virtual time comparison result.
   67|       |
   68|       | This is additional abstraction because `Date` is unfortunately not comparable.
   69|       | Extending `Date` with `Comparable` would be too risky because of possible collisions with other libraries.
   70|       |*/
   71|       |public enum VirtualTimeComparison {
   72|       |    /// lhs < rhs.
   73|       |    case lessThan
   74|       |    /// lhs == rhs.
   75|       |    case equal
   76|       |    /// lhs > rhs.
   77|       |    case greaterThan
   78|       |}
   79|       |
   80|       |extension VirtualTimeComparison {
   81|       |    /// lhs < rhs.
   82|      0|    var lessThen: Bool {
   83|      0|        return self == .lessThan
   84|      0|    }
   85|       |
   86|       |    /// lhs > rhs
   87|      0|    var greaterThan: Bool {
   88|      0|        return self == .greaterThan
   89|      0|    }
   90|       |
   91|       |    /// lhs == rhs
   92|      0|    var equal: Bool {
   93|      0|        return self == .equal
   94|      0|    }
   95|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Schedulers/VirtualTimeScheduler.swift:
    1|       |//
    2|       |//  VirtualTimeScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Base class for virtual time schedulers using a priority queue for scheduled items.
   10|       |open class VirtualTimeScheduler<Converter: VirtualTimeConverterType>
   11|       |    : SchedulerType {
   12|       |
   13|       |    public typealias VirtualTime = Converter.VirtualTimeUnit
   14|       |    public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
   15|       |
   16|       |    private var _running : Bool
   17|       |
   18|       |    private var _clock: VirtualTime
   19|       |
   20|       |    fileprivate var _schedulerQueue : PriorityQueue<VirtualSchedulerItem<VirtualTime>>
   21|       |    private var _converter: Converter
   22|       |
   23|       |    private var _nextId = 0
   24|       |
   25|       |    /// - returns: Current time.
   26|      0|    public var now: RxTime {
   27|      0|        return self._converter.convertFromVirtualTime(self.clock)
   28|      0|    }
   29|       |
   30|       |    /// - returns: Scheduler's absolute time clock value.
   31|      0|    public var clock: VirtualTime {
   32|      0|        return self._clock
   33|      0|    }
   34|       |
   35|       |    /// Creates a new virtual time scheduler.
   36|       |    ///
   37|       |    /// - parameter initialClock: Initial value for the clock.
   38|      0|    public init(initialClock: VirtualTime, converter: Converter) {
   39|      0|        self._clock = initialClock
   40|      0|        self._running = false
   41|      0|        self._converter = converter
   42|      0|        self._schedulerQueue = PriorityQueue(hasHigherPriority: {
   43|      0|            switch converter.compareVirtualTime($0.time, $1.time) {
   44|      0|            case .lessThan:
   45|      0|                return true
   46|      0|            case .equal:
   47|      0|                return $0.id < $1.id
   48|      0|            case .greaterThan:
   49|      0|                return false
   50|      0|            }
   51|      0|        }, isEqual: { $0 === $1 })
   52|      0|        #if TRACE_RESOURCES
   53|      0|            _ = Resources.incrementTotal()
   54|      0|        #endif
   55|      0|    }
   56|       |
   57|       |    /**
   58|       |    Schedules an action to be executed immediately.
   59|       |
   60|       |    - parameter state: State passed to the action to be executed.
   61|       |    - parameter action: Action to be executed.
   62|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   63|       |    */
   64|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   65|      0|        return self.scheduleRelative(state, dueTime: 0.0) { a in
   66|      0|            return action(a)
   67|      0|        }
   68|      0|    }
   69|       |
   70|       |    /**
   71|       |     Schedules an action to be executed.
   72|       |
   73|       |     - parameter state: State passed to the action to be executed.
   74|       |     - parameter dueTime: Relative time after which to execute the action.
   75|       |     - parameter action: Action to be executed.
   76|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
   77|       |     */
   78|      0|    public func scheduleRelative<StateType>(_ state: StateType, dueTime: RxTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   79|      0|        let time = self.now.addingTimeInterval(dueTime)
   80|      0|        let absoluteTime = self._converter.convertToVirtualTime(time)
   81|      0|        let adjustedTime = self.adjustScheduledTime(absoluteTime)
   82|      0|        return self.scheduleAbsoluteVirtual(state, time: adjustedTime, action: action)
   83|      0|    }
   84|       |
   85|       |    /**
   86|       |     Schedules an action to be executed after relative time has passed.
   87|       |
   88|       |     - parameter state: State passed to the action to be executed.
   89|       |     - parameter time: Absolute time when to execute the action. If this is less or equal then `now`, `now + 1`  will be used.
   90|       |     - parameter action: Action to be executed.
   91|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
   92|       |     */
   93|      0|    public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: VirtualTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   94|      0|        let time = self._converter.offsetVirtualTime(self.clock, offset: dueTime)
   95|      0|        return self.scheduleAbsoluteVirtual(state, time: time, action: action)
   96|      0|    }
   97|       |
   98|       |    /**
   99|       |     Schedules an action to be executed at absolute virtual time.
  100|       |
  101|       |     - parameter state: State passed to the action to be executed.
  102|       |     - parameter time: Absolute time when to execute the action.
  103|       |     - parameter action: Action to be executed.
  104|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
  105|       |     */
  106|      0|    public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: Converter.VirtualTimeUnit, action: @escaping (StateType) -> Disposable) -> Disposable {
  107|      0|        MainScheduler.ensureExecutingOnScheduler()
  108|      0|
  109|      0|        let compositeDisposable = CompositeDisposable()
  110|      0|
  111|      0|        let item = VirtualSchedulerItem(action: {
  112|      0|            let dispose = action(state)
  113|      0|            return dispose
  114|      0|        }, time: time, id: self._nextId)
  115|      0|
  116|      0|        self._nextId += 1
  117|      0|
  118|      0|        self._schedulerQueue.enqueue(item)
  119|      0|        
  120|      0|        _ = compositeDisposable.insert(item)
  121|      0|        
  122|      0|        return compositeDisposable
  123|      0|    }
  124|       |
  125|       |    /// Adjusts time of scheduling before adding item to schedule queue.
  126|      0|    open func adjustScheduledTime(_ time: Converter.VirtualTimeUnit) -> Converter.VirtualTimeUnit {
  127|      0|        return time
  128|      0|    }
  129|       |
  130|       |    /// Starts the virtual time scheduler.
  131|      0|    public func start() {
  132|      0|        MainScheduler.ensureExecutingOnScheduler()
  133|      0|
  134|      0|        if self._running {
  135|      0|            return
  136|      0|        }
  137|      0|
  138|      0|        self._running = true
  139|      0|        repeat {
  140|      0|            guard let next = self.findNext() else {
  141|      0|                break
  142|      0|            }
  143|      0|
  144|      0|            if self._converter.compareVirtualTime(next.time, self.clock).greaterThan {
  145|      0|                self._clock = next.time
  146|      0|            }
  147|      0|
  148|      0|            next.invoke()
  149|      0|            self._schedulerQueue.remove(next)
  150|      0|        } while self._running
  151|      0|
  152|      0|        self._running = false
  153|      0|    }
  154|       |
  155|      0|    func findNext() -> VirtualSchedulerItem<VirtualTime>? {
  156|      0|        while let front = self._schedulerQueue.peek() {
  157|      0|            if front.isDisposed {
  158|      0|                self._schedulerQueue.remove(front)
  159|      0|                continue
  160|      0|            }
  161|      0|
  162|      0|            return front
  163|      0|        }
  164|      0|
  165|      0|        return nil
  166|      0|    }
  167|       |
  168|       |    /// Advances the scheduler's clock to the specified time, running all work till that point.
  169|       |    ///
  170|       |    /// - parameter virtualTime: Absolute time to advance the scheduler's clock to.
  171|      0|    public func advanceTo(_ virtualTime: VirtualTime) {
  172|      0|        MainScheduler.ensureExecutingOnScheduler()
  173|      0|
  174|      0|        if self._running {
  175|      0|            fatalError("Scheduler is already running")
  176|      0|        }
  177|      0|
  178|      0|        self._running = true
  179|      0|        repeat {
  180|      0|            guard let next = self.findNext() else {
  181|      0|                break
  182|      0|            }
  183|      0|
  184|      0|            if self._converter.compareVirtualTime(next.time, virtualTime).greaterThan {
  185|      0|                break
  186|      0|            }
  187|      0|
  188|      0|            if self._converter.compareVirtualTime(next.time, self.clock).greaterThan {
  189|      0|                self._clock = next.time
  190|      0|            }
  191|      0|
  192|      0|            next.invoke()
  193|      0|            self._schedulerQueue.remove(next)
  194|      0|        } while self._running
  195|      0|
  196|      0|        self._clock = virtualTime
  197|      0|        self._running = false
  198|      0|    }
  199|       |
  200|       |    /// Advances the scheduler's clock by the specified relative time.
  201|      0|    public func sleep(_ virtualInterval: VirtualTimeInterval) {
  202|      0|        MainScheduler.ensureExecutingOnScheduler()
  203|      0|
  204|      0|        let sleepTo = self._converter.offsetVirtualTime(self.clock, offset: virtualInterval)
  205|      0|        if self._converter.compareVirtualTime(sleepTo, self.clock).lessThen {
  206|      0|            fatalError("Can't sleep to past.")
  207|      0|        }
  208|      0|
  209|      0|        self._clock = sleepTo
  210|      0|    }
  211|       |
  212|       |    /// Stops the virtual time scheduler.
  213|      0|    public func stop() {
  214|      0|        MainScheduler.ensureExecutingOnScheduler()
  215|      0|
  216|      0|        self._running = false
  217|      0|    }
  218|       |
  219|       |    #if TRACE_RESOURCES
  220|       |        deinit {
  221|       |            _ = Resources.decrementTotal()
  222|       |        }
  223|       |    #endif
  224|       |}
  225|       |
  226|       |// MARK: description
  227|       |
  228|       |extension VirtualTimeScheduler: CustomDebugStringConvertible {
  229|       |    /// A textual representation of `self`, suitable for debugging.
  230|      0|    public var debugDescription: String {
  231|      0|        return self._schedulerQueue.debugDescription
  232|      0|    }
  233|       |}
  234|       |
  235|       |final class VirtualSchedulerItem<Time>
  236|       |    : Disposable {
  237|       |    typealias Action = () -> Disposable
  238|       |    
  239|       |    let action: Action
  240|       |    let time: Time
  241|       |    let id: Int
  242|       |
  243|       |    var isDisposed: Bool {
  244|       |        return self.disposable.isDisposed
  245|       |    }
  246|       |    
  247|       |    var disposable = SingleAssignmentDisposable()
  248|       |    
  249|      0|    init(action: @escaping Action, time: Time, id: Int) {
  250|      0|        self.action = action
  251|      0|        self.time = time
  252|      0|        self.id = id
  253|      0|    }
  254|       |
  255|       |    func invoke() {
  256|       |         self.disposable.setDisposable(self.action())
  257|       |    }
  258|       |    
  259|      0|    func dispose() {
  260|      0|        self.disposable.dispose()
  261|      0|    }
  262|       |}
  263|       |
  264|       |extension VirtualSchedulerItem
  265|       |    : CustomDebugStringConvertible {
  266|      0|    var debugDescription: String {
  267|      0|        return "\(self.time)"
  268|      0|    }
  269|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Subjects/AsyncSubject.swift:
    1|       |//
    2|       |//  AsyncSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Victor Galán on 07/01/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// An AsyncSubject emits the last value (and only the last value) emitted by the source Observable,
   10|       |/// and only after that source Observable completes.
   11|       |///
   12|       |/// (If the source Observable does not emit any values, the AsyncSubject also completes without emitting any values.)
   13|       |public final class AsyncSubject<Element>
   14|       |    : Observable<Element>
   15|       |    , SubjectType
   16|       |    , ObserverType
   17|       |    , SynchronizedUnsubscribeType {
   18|       |    public typealias SubjectObserverType = AsyncSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |
   23|       |    /// Indicates whether the subject has any observers
   24|      0|    public var hasObservers: Bool {
   25|      0|        self._lock.lock(); defer { self._lock.unlock() }
   26|      0|        return self._observers.count > 0
   27|      0|    }
   28|       |
   29|       |    let _lock = RecursiveLock()
   30|       |
   31|       |    // state
   32|       |    private var _observers = Observers()
   33|       |    private var _isStopped = false
   34|       |    private var _stoppedEvent = nil as Event<Element>? {
   35|      0|        didSet {
   36|      0|            self._isStopped = self._stoppedEvent != nil
   37|      0|        }
   38|       |    }
   39|       |    private var _lastElement: Element?
   40|       |
   41|       |    #if DEBUG
   42|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   43|       |    #endif
   44|       |
   45|       |
   46|       |    /// Creates a subject.
   47|      0|    public override init() {
   48|      0|        #if TRACE_RESOURCES
   49|      0|            _ = Resources.incrementTotal()
   50|      0|        #endif
   51|      0|        super.init()
   52|      0|    }
   53|       |
   54|       |    /// Notifies all subscribed observers about next event.
   55|       |    ///
   56|       |    /// - parameter event: Event to send to the observers.
   57|      0|    public func on(_ event: Event<E>) {
   58|      0|        #if DEBUG
   59|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
   60|      0|            defer { self._synchronizationTracker.unregister() }
   61|      0|        #endif
   62|      0|        let (observers, event) = self._synchronized_on(event)
   63|      0|        switch event {
   64|      0|        case .next:
   65|      0|            dispatch(observers, event)
   66|      0|            dispatch(observers, .completed)
   67|      0|        case .completed:
   68|      0|            dispatch(observers, event)
   69|      0|        case .error:
   70|      0|            dispatch(observers, event)
   71|      0|        }
   72|      0|    }
   73|       |
   74|       |    func _synchronized_on(_ event: Event<E>) -> (Observers, Event<E>) {
   75|       |        self._lock.lock(); defer { self._lock.unlock() }
   76|       |        if self._isStopped {
   77|       |            return (Observers(), .completed)
   78|       |        }
   79|       |
   80|       |        switch event {
   81|       |        case .next(let element):
   82|       |            self._lastElement = element
   83|       |            return (Observers(), .completed)
   84|       |        case .error:
   85|       |            self._stoppedEvent = event
   86|       |
   87|       |            let observers = self._observers
   88|       |            self._observers.removeAll()
   89|       |
   90|       |            return (observers, event)
   91|       |        case .completed:
   92|       |
   93|       |            let observers = self._observers
   94|       |            self._observers.removeAll()
   95|       |
   96|       |            if let lastElement = self._lastElement {
   97|       |                self._stoppedEvent = .next(lastElement)
   98|       |                return (observers, .next(lastElement))
   99|       |            }
  100|       |            else {
  101|       |                self._stoppedEvent = event
  102|       |                return (observers, .completed)
  103|       |            }
  104|       |        }
  105|       |    }
  106|       |
  107|       |    /// Subscribes an observer to the subject.
  108|       |    ///
  109|       |    /// - parameter observer: Observer to subscribe to the subject.
  110|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from the subject.
  111|      0|    public override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  112|      0|        self._lock.lock(); defer { self._lock.unlock() }
  113|      0|        return self._synchronized_subscribe(observer)
  114|      0|    }
  115|       |
  116|       |    func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  117|       |        if let stoppedEvent = self._stoppedEvent {
  118|       |            switch stoppedEvent {
  119|       |            case .next:
  120|       |                observer.on(stoppedEvent)
  121|       |                observer.on(.completed)
  122|       |            case .completed:
  123|       |                observer.on(stoppedEvent)
  124|       |            case .error:
  125|       |                observer.on(stoppedEvent)
  126|       |            }
  127|       |            return Disposables.create()
  128|       |        }
  129|       |
  130|       |        let key = self._observers.insert(observer.on)
  131|       |
  132|       |        return SubscriptionDisposable(owner: self, key: key)
  133|       |    }
  134|       |
  135|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  136|      0|        self._lock.lock(); defer { self._lock.unlock() }
  137|      0|        self._synchronized_unsubscribe(disposeKey)
  138|      0|    }
  139|       |    
  140|       |    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  141|       |        _ = self._observers.removeKey(disposeKey)
  142|       |    }
  143|       |    
  144|       |    /// Returns observer interface for subject.
  145|      0|    public func asObserver() -> AsyncSubject<Element> {
  146|      0|        return self
  147|      0|    }
  148|       |
  149|       |    #if TRACE_RESOURCES
  150|       |    deinit {
  151|       |        _ = Resources.decrementTotal()
  152|       |    }
  153|       |    #endif
  154|       |}
  155|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Subjects/BehaviorSubject.swift:
    1|       |//
    2|       |//  BehaviorSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a value that changes over time.
   10|       |///
   11|       |/// Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
   12|       |public final class BehaviorSubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , ObserverType
   16|       |    , SynchronizedUnsubscribeType
   17|       |    , Cancelable {
   18|       |    public typealias SubjectObserverType = BehaviorSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |    
   23|       |    /// Indicates whether the subject has any observers
   24|      0|    public var hasObservers: Bool {
   25|      0|        self._lock.lock()
   26|      0|        let value = self._observers.count > 0
   27|      0|        self._lock.unlock()
   28|      0|        return value
   29|      0|    }
   30|       |    
   31|       |    let _lock = RecursiveLock()
   32|       |    
   33|       |    // state
   34|       |    private var _isDisposed = false
   35|       |    private var _element: Element
   36|       |    private var _observers = Observers()
   37|       |    private var _stoppedEvent: Event<Element>?
   38|       |
   39|       |    #if DEBUG
   40|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   41|       |    #endif
   42|       |
   43|       |    /// Indicates whether the subject has been disposed.
   44|      0|    public var isDisposed: Bool {
   45|      0|        return self._isDisposed
   46|      0|    }
   47|       | 
   48|       |    /// Initializes a new instance of the subject that caches its last value and starts with the specified value.
   49|       |    ///
   50|       |    /// - parameter value: Initial value sent to observers when no other value has been received by the subject yet.
   51|      0|    public init(value: Element) {
   52|      0|        self._element = value
   53|      0|
   54|      0|        #if TRACE_RESOURCES
   55|      0|            _ = Resources.incrementTotal()
   56|      0|        #endif
   57|      0|    }
   58|       |    
   59|       |    /// Gets the current value or throws an error.
   60|       |    ///
   61|       |    /// - returns: Latest value.
   62|      0|    public func value() throws -> Element {
   63|      0|        self._lock.lock(); defer { self._lock.unlock() } // {
   64|      0|            if self._isDisposed {
   65|      0|                throw RxError.disposed(object: self)
   66|      0|            }
   67|      0|            
   68|      0|            if let error = self._stoppedEvent?.error {
   69|      0|                // intentionally throw exception
   70|      0|                throw error
   71|      0|            }
   72|      0|            else {
   73|      0|                return self._element
   74|      0|            }
   75|      0|        //}
   76|      0|    }
   77|       |    
   78|       |    /// Notifies all subscribed observers about next event.
   79|       |    ///
   80|       |    /// - parameter event: Event to send to the observers.
   81|      0|    public func on(_ event: Event<E>) {
   82|      0|        #if DEBUG
   83|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
   84|      0|            defer { self._synchronizationTracker.unregister() }
   85|      0|        #endif
   86|      0|        dispatch(self._synchronized_on(event), event)
   87|      0|    }
   88|       |
   89|       |    func _synchronized_on(_ event: Event<E>) -> Observers {
   90|       |        self._lock.lock(); defer { self._lock.unlock() }
   91|      0|        if self._stoppedEvent != nil || self._isDisposed {
   92|       |            return Observers()
   93|       |        }
   94|       |        
   95|       |        switch event {
   96|       |        case .next(let element):
   97|       |            self._element = element
   98|       |        case .error, .completed:
   99|       |            self._stoppedEvent = event
  100|       |        }
  101|       |        
  102|       |        return self._observers
  103|       |    }
  104|       |    
  105|       |    /// Subscribes an observer to the subject.
  106|       |    ///
  107|       |    /// - parameter observer: Observer to subscribe to the subject.
  108|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from the subject.
  109|      0|    public override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  110|      0|        self._lock.lock()
  111|      0|        let subscription = self._synchronized_subscribe(observer)
  112|      0|        self._lock.unlock()
  113|      0|        return subscription
  114|      0|    }
  115|       |
  116|       |    func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  117|       |        if self._isDisposed {
  118|       |            observer.on(.error(RxError.disposed(object: self)))
  119|       |            return Disposables.create()
  120|       |        }
  121|       |        
  122|       |        if let stoppedEvent = self._stoppedEvent {
  123|       |            observer.on(stoppedEvent)
  124|       |            return Disposables.create()
  125|       |        }
  126|       |        
  127|       |        let key = self._observers.insert(observer.on)
  128|       |        observer.on(.next(self._element))
  129|       |    
  130|       |        return SubscriptionDisposable(owner: self, key: key)
  131|       |    }
  132|       |
  133|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  134|      0|        self._lock.lock()
  135|      0|        self._synchronized_unsubscribe(disposeKey)
  136|      0|        self._lock.unlock()
  137|      0|    }
  138|       |
  139|       |    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  140|       |        if self._isDisposed {
  141|       |            return
  142|       |        }
  143|       |
  144|       |        _ = self._observers.removeKey(disposeKey)
  145|       |    }
  146|       |
  147|       |    /// Returns observer interface for subject.
  148|      0|    public func asObserver() -> BehaviorSubject<Element> {
  149|      0|        return self
  150|      0|    }
  151|       |
  152|       |    /// Unsubscribe all observers and release resources.
  153|      0|    public func dispose() {
  154|      0|        self._lock.lock()
  155|      0|        self._isDisposed = true
  156|      0|        self._observers.removeAll()
  157|      0|        self._stoppedEvent = nil
  158|      0|        self._lock.unlock()
  159|      0|    }
  160|       |
  161|       |    #if TRACE_RESOURCES
  162|       |        deinit {
  163|       |        _ = Resources.decrementTotal()
  164|       |        }
  165|       |    #endif
  166|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Subjects/PublishSubject.swift:
    1|       |//
    2|       |//  PublishSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that is both an observable sequence as well as an observer.
   10|       |///
   11|       |/// Each notification is broadcasted to all subscribed observers.
   12|       |public final class PublishSubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , Cancelable
   16|       |    , ObserverType
   17|       |    , SynchronizedUnsubscribeType {
   18|       |    public typealias SubjectObserverType = PublishSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |    
   23|       |    /// Indicates whether the subject has any observers
   24|      0|    public var hasObservers: Bool {
   25|      0|        self._lock.lock()
   26|      0|        let count = self._observers.count > 0
   27|      0|        self._lock.unlock()
   28|      0|        return count
   29|      0|    }
   30|       |    
   31|       |    private let _lock = RecursiveLock()
   32|       |    
   33|       |    // state
   34|       |    private var _isDisposed = false
   35|       |    private var _observers = Observers()
   36|       |    private var _stopped = false
   37|       |    private var _stoppedEvent = nil as Event<Element>?
   38|       |
   39|       |    #if DEBUG
   40|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   41|       |    #endif
   42|       |
   43|       |    /// Indicates whether the subject has been isDisposed.
   44|      0|    public var isDisposed: Bool {
   45|      0|        return self._isDisposed
   46|      0|    }
   47|       |    
   48|       |    /// Creates a subject.
   49|      0|    public override init() {
   50|      0|        super.init()
   51|      0|        #if TRACE_RESOURCES
   52|      0|            _ = Resources.incrementTotal()
   53|      0|        #endif
   54|      0|    }
   55|       |    
   56|       |    /// Notifies all subscribed observers about next event.
   57|       |    ///
   58|       |    /// - parameter event: Event to send to the observers.
   59|      0|    public func on(_ event: Event<Element>) {
   60|      0|        #if DEBUG
   61|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
   62|      0|            defer { self._synchronizationTracker.unregister() }
   63|      0|        #endif
   64|      0|        dispatch(self._synchronized_on(event), event)
   65|      0|    }
   66|       |
   67|       |    func _synchronized_on(_ event: Event<E>) -> Observers {
   68|       |        self._lock.lock(); defer { self._lock.unlock() }
   69|       |        switch event {
   70|       |        case .next:
   71|      0|            if self._isDisposed || self._stopped {
   72|       |                return Observers()
   73|       |            }
   74|       |            
   75|       |            return self._observers
   76|       |        case .completed, .error:
   77|       |            if self._stoppedEvent == nil {
   78|       |                self._stoppedEvent = event
   79|       |                self._stopped = true
   80|       |                let observers = self._observers
   81|       |                self._observers.removeAll()
   82|       |                return observers
   83|       |            }
   84|       |
   85|       |            return Observers()
   86|       |        }
   87|       |    }
   88|       |    
   89|       |    /**
   90|       |    Subscribes an observer to the subject.
   91|       |    
   92|       |    - parameter observer: Observer to subscribe to the subject.
   93|       |    - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   94|       |    */
   95|      0|    public override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   96|      0|        self._lock.lock()
   97|      0|        let subscription = self._synchronized_subscribe(observer)
   98|      0|        self._lock.unlock()
   99|      0|        return subscription
  100|      0|    }
  101|       |
  102|       |    func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  103|       |        if let stoppedEvent = self._stoppedEvent {
  104|       |            observer.on(stoppedEvent)
  105|       |            return Disposables.create()
  106|       |        }
  107|       |        
  108|       |        if self._isDisposed {
  109|       |            observer.on(.error(RxError.disposed(object: self)))
  110|       |            return Disposables.create()
  111|       |        }
  112|       |        
  113|       |        let key = self._observers.insert(observer.on)
  114|       |        return SubscriptionDisposable(owner: self, key: key)
  115|       |    }
  116|       |
  117|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  118|      0|        self._lock.lock()
  119|      0|        self._synchronized_unsubscribe(disposeKey)
  120|      0|        self._lock.unlock()
  121|      0|    }
  122|       |
  123|       |    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  124|       |        _ = self._observers.removeKey(disposeKey)
  125|       |    }
  126|       |    
  127|       |    /// Returns observer interface for subject.
  128|      0|    public func asObserver() -> PublishSubject<Element> {
  129|      0|        return self
  130|      0|    }
  131|       |    
  132|       |    /// Unsubscribe all observers and release resources.
  133|      0|    public func dispose() {
  134|      0|        self._lock.lock()
  135|      0|        self._synchronized_dispose()
  136|      0|        self._lock.unlock()
  137|      0|    }
  138|       |
  139|       |    final func _synchronized_dispose() {
  140|       |        self._isDisposed = true
  141|       |        self._observers.removeAll()
  142|       |        self._stoppedEvent = nil
  143|       |    }
  144|       |
  145|       |    #if TRACE_RESOURCES
  146|       |        deinit {
  147|       |            _ = Resources.decrementTotal()
  148|       |        }
  149|       |    #endif
  150|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Subjects/ReplaySubject.swift:
    1|       |//
    2|       |//  ReplaySubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that is both an observable sequence as well as an observer.
   10|       |///
   11|       |/// Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   12|       |public class ReplaySubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , ObserverType
   16|       |    , Disposable {
   17|       |    public typealias SubjectObserverType = ReplaySubject<Element>
   18|       |
   19|       |    typealias Observers = AnyObserver<Element>.s
   20|       |    typealias DisposeKey = Observers.KeyType
   21|       |
   22|       |    /// Indicates whether the subject has any observers
   23|      0|    public var hasObservers: Bool {
   24|      0|        self._lock.lock()
   25|      0|        let value = self._observers.count > 0
   26|      0|        self._lock.unlock()
   27|      0|        return value
   28|      0|    }
   29|       |    
   30|       |    fileprivate let _lock = RecursiveLock()
   31|       |    
   32|       |    // state
   33|       |    fileprivate var _isDisposed = false
   34|       |    fileprivate var _isStopped = false
   35|       |    fileprivate var _stoppedEvent = nil as Event<Element>? {
   36|      0|        didSet {
   37|      0|            self._isStopped = self._stoppedEvent != nil
   38|      0|        }
   39|       |    }
   40|       |    fileprivate var _observers = Observers()
   41|       |
   42|       |    #if DEBUG
   43|       |        fileprivate let _synchronizationTracker = SynchronizationTracker()
   44|       |    #endif
   45|       |
   46|      0|    func unsubscribe(_ key: DisposeKey) {
   47|      0|        rxAbstractMethod()
   48|      0|    }
   49|       |
   50|      0|    final var isStopped: Bool {
   51|      0|        return self._isStopped
   52|      0|    }
   53|       |    
   54|       |    /// Notifies all subscribed observers about next event.
   55|       |    ///
   56|       |    /// - parameter event: Event to send to the observers.
   57|      0|    public func on(_ event: Event<E>) {
   58|      0|        rxAbstractMethod()
   59|      0|    }
   60|       |    
   61|       |    /// Returns observer interface for subject.
   62|      0|    public func asObserver() -> SubjectObserverType {
   63|      0|        return self
   64|      0|    }
   65|       |    
   66|       |    /// Unsubscribe all observers and release resources.
   67|      0|    public func dispose() {
   68|      0|    }
   69|       |
   70|       |    /// Creates new instance of `ReplaySubject` that replays at most `bufferSize` last elements of sequence.
   71|       |    ///
   72|       |    /// - parameter bufferSize: Maximal number of elements to replay to observer after subscription.
   73|       |    /// - returns: New instance of replay subject.
   74|      0|    public static func create(bufferSize: Int) -> ReplaySubject<Element> {
   75|      0|        if bufferSize == 1 {
   76|      0|            return ReplayOne()
   77|      0|        }
   78|      0|        else {
   79|      0|            return ReplayMany(bufferSize: bufferSize)
   80|      0|        }
   81|      0|    }
   82|       |
   83|       |    /// Creates a new instance of `ReplaySubject` that buffers all the elements of a sequence.
   84|       |    /// To avoid filling up memory, developer needs to make sure that the use case will only ever store a 'reasonable'
   85|       |    /// number of elements.
   86|      0|    public static func createUnbounded() -> ReplaySubject<Element> {
   87|      0|        return ReplayAll()
   88|      0|    }
   89|       |
   90|       |    #if TRACE_RESOURCES
   91|       |        override init() {
   92|       |            _ = Resources.incrementTotal()
   93|       |        }
   94|       |
   95|       |        deinit {
   96|       |            _ = Resources.decrementTotal()
   97|       |        }
   98|       |    #endif
   99|       |}
  100|       |
  101|       |private class ReplayBufferBase<Element>
  102|       |    : ReplaySubject<Element>
  103|       |    , SynchronizedUnsubscribeType {
  104|       |    
  105|      0|    func trim() {
  106|      0|        rxAbstractMethod()
  107|      0|    }
  108|       |    
  109|      0|    func addValueToBuffer(_ value: Element) {
  110|      0|        rxAbstractMethod()
  111|      0|    }
  112|       |    
  113|      0|    func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  114|      0|        rxAbstractMethod()
  115|      0|    }
  116|       |    
  117|      0|    override func on(_ event: Event<Element>) {
  118|      0|        #if DEBUG
  119|      0|            self._synchronizationTracker.register(synchronizationErrorMessage: .default)
  120|      0|            defer { self._synchronizationTracker.unregister() }
  121|      0|        #endif
  122|      0|        dispatch(self._synchronized_on(event), event)
  123|      0|    }
  124|       |
  125|      0|    func _synchronized_on(_ event: Event<E>) -> Observers {
  126|      0|        self._lock.lock(); defer { self._lock.unlock() }
  127|      0|        if self._isDisposed {
  128|      0|            return Observers()
  129|      0|        }
  130|      0|        
  131|      0|        if self._isStopped {
  132|      0|            return Observers()
  133|      0|        }
  134|      0|        
  135|      0|        switch event {
  136|      0|        case .next(let element):
  137|      0|            self.addValueToBuffer(element)
  138|      0|            self.trim()
  139|      0|            return self._observers
  140|      0|        case .error, .completed:
  141|      0|            self._stoppedEvent = event
  142|      0|            self.trim()
  143|      0|            let observers = self._observers
  144|      0|            self._observers.removeAll()
  145|      0|            return observers
  146|      0|        }
  147|      0|    }
  148|       |    
  149|      0|    override func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  150|      0|        self._lock.lock()
  151|      0|        let subscription = self._synchronized_subscribe(observer)
  152|      0|        self._lock.unlock()
  153|      0|        return subscription
  154|      0|    }
  155|       |
  156|      0|    func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  157|      0|        if self._isDisposed {
  158|      0|            observer.on(.error(RxError.disposed(object: self)))
  159|      0|            return Disposables.create()
  160|      0|        }
  161|      0|     
  162|      0|        let anyObserver = observer.asObserver()
  163|      0|        
  164|      0|        self.replayBuffer(anyObserver)
  165|      0|        if let stoppedEvent = self._stoppedEvent {
  166|      0|            observer.on(stoppedEvent)
  167|      0|            return Disposables.create()
  168|      0|        }
  169|      0|        else {
  170|      0|            let key = self._observers.insert(observer.on)
  171|      0|            return SubscriptionDisposable(owner: self, key: key)
  172|      0|        }
  173|      0|    }
  174|       |
  175|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  176|      0|        self._lock.lock()
  177|      0|        self._synchronized_unsubscribe(disposeKey)
  178|      0|        self._lock.unlock()
  179|      0|    }
  180|       |
  181|      0|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  182|      0|        if self._isDisposed {
  183|      0|            return
  184|      0|        }
  185|      0|        
  186|      0|        _ = self._observers.removeKey(disposeKey)
  187|      0|    }
  188|       |    
  189|      0|    override func dispose() {
  190|      0|        super.dispose()
  191|      0|
  192|      0|        self.synchronizedDispose()
  193|      0|    }
  194|       |
  195|      0|    func synchronizedDispose() {
  196|      0|        self._lock.lock()
  197|      0|        self._synchronized_dispose()
  198|      0|        self._lock.unlock()
  199|      0|    }
  200|       |
  201|      0|    func _synchronized_dispose() {
  202|      0|        self._isDisposed = true
  203|      0|        self._observers.removeAll()
  204|      0|    }
  205|       |}
  206|       |
  207|       |fileprivate final class ReplayOne<Element> : ReplayBufferBase<Element> {
  208|       |    private var _value: Element?
  209|       |    
  210|      0|    override init() {
  211|      0|        super.init()
  212|      0|    }
  213|       |    
  214|      0|    override func trim() {
  215|      0|        
  216|      0|    }
  217|       |    
  218|      0|    override func addValueToBuffer(_ value: Element) {
  219|      0|        self._value = value
  220|      0|    }
  221|       |
  222|      0|    override func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  223|      0|        if let value = self._value {
  224|      0|            observer.on(.next(value))
  225|      0|        }
  226|      0|    }
  227|       |
  228|      0|    override func _synchronized_dispose() {
  229|      0|        super._synchronized_dispose()
  230|      0|        self._value = nil
  231|      0|    }
  232|       |}
  233|       |
  234|       |private class ReplayManyBase<Element>: ReplayBufferBase<Element> {
  235|       |    fileprivate var _queue: Queue<Element>
  236|       |    
  237|      0|    init(queueSize: Int) {
  238|      0|        self._queue = Queue(capacity: queueSize + 1)
  239|      0|    }
  240|       |    
  241|      0|    override func addValueToBuffer(_ value: Element) {
  242|      0|        self._queue.enqueue(value)
  243|      0|    }
  244|       |
  245|      0|    override func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  246|      0|        for item in self._queue {
  247|      0|            observer.on(.next(item))
  248|      0|        }
  249|      0|    }
  250|       |
  251|      0|    override func _synchronized_dispose() {
  252|      0|        super._synchronized_dispose()
  253|      0|        self._queue = Queue(capacity: 0)
  254|      0|    }
  255|       |}
  256|       |
  257|       |fileprivate final class ReplayMany<Element> : ReplayManyBase<Element> {
  258|       |    private let _bufferSize: Int
  259|       |    
  260|      0|    init(bufferSize: Int) {
  261|      0|        self._bufferSize = bufferSize
  262|      0|        
  263|      0|        super.init(queueSize: bufferSize)
  264|      0|    }
  265|       |    
  266|      0|    override func trim() {
  267|      0|        while self._queue.count > self._bufferSize {
  268|      0|            _ = self._queue.dequeue()
  269|      0|        }
  270|      0|    }
  271|       |}
  272|       |
  273|       |fileprivate final class ReplayAll<Element> : ReplayManyBase<Element> {
  274|      0|    init() {
  275|      0|        super.init(queueSize: 0)
  276|      0|    }
  277|       |    
  278|      0|    override func trim() {
  279|      0|        
  280|      0|    }
  281|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/SwiftSupport/SwiftSupport.swift:
    1|       |//
    2|       |//  SwiftSupport.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Volodymyr  Gorbenko on 3/6/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |typealias IntMax = Int64
   12|       |public typealias RxAbstractInteger = FixedWidthInteger
   13|       |
   14|       |extension SignedInteger {
   15|      0|    func toIntMax() -> IntMax {
   16|      0|        return IntMax(self)
   17|      0|    }
   18|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/Completable+AndThen.swift:
    1|       |//
    2|       |//  Completable+AndThen.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/2/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Never {
   10|       |    /**
   11|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
   12|       |
   13|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   14|       |
   15|       |     - parameter second: Second observable sequence.
   16|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
   17|       |     */
   18|      0|    public func andThen<E>(_ second: Single<E>) -> Single<E> {
   19|      0|        let completable = self.primitiveSequence.asObservable()
   20|      0|        return Single(raw: ConcatCompletable(completable: completable, second: second.asObservable()))
   21|      0|    }
   22|       |
   23|       |    /**
   24|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
   25|       |
   26|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   27|       |
   28|       |     - parameter second: Second observable sequence.
   29|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
   30|       |     */
   31|      0|    public func andThen<E>(_ second: Maybe<E>) -> Maybe<E> {
   32|      0|        let completable = self.primitiveSequence.asObservable()
   33|      0|        return Maybe(raw: ConcatCompletable(completable: completable, second: second.asObservable()))
   34|      0|    }
   35|       |
   36|       |    /**
   37|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
   38|       |
   39|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   40|       |
   41|       |     - parameter second: Second observable sequence.
   42|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
   43|       |     */
   44|      0|    public func andThen(_ second: Completable) -> Completable {
   45|      0|        let completable = self.primitiveSequence.asObservable()
   46|      0|        return Completable(raw: ConcatCompletable(completable: completable, second: second.asObservable()))
   47|      0|    }
   48|       |
   49|       |    /**
   50|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
   51|       |
   52|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
   53|       |
   54|       |     - parameter second: Second observable sequence.
   55|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
   56|       |     */
   57|      0|    public func andThen<E>(_ second: Observable<E>) -> Observable<E> {
   58|      0|        let completable = self.primitiveSequence.asObservable()
   59|      0|        return ConcatCompletable(completable: completable, second: second.asObservable())
   60|      0|    }
   61|       |}
   62|       |
   63|       |final private class ConcatCompletable<Element>: Producer<Element> {
   64|       |    fileprivate let _completable: Observable<Never>
   65|       |    fileprivate let _second: Observable<Element>
   66|       |
   67|      0|    init(completable: Observable<Never>, second: Observable<Element>) {
   68|      0|        self._completable = completable
   69|      0|        self._second = second
   70|      0|    }
   71|       |
   72|      0|    override func run<O>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O : ObserverType, O.E == Element {
   73|      0|        let sink = ConcatCompletableSink(parent: self, observer: observer, cancel: cancel)
   74|      0|        let subscription = sink.run()
   75|      0|        return (sink: sink, subscription: subscription)
   76|      0|    }
   77|       |}
   78|       |
   79|       |final private class ConcatCompletableSink<O: ObserverType>
   80|       |    : Sink<O>
   81|       |    , ObserverType {
   82|       |    typealias E = Never
   83|       |    typealias Parent = ConcatCompletable<O.E>
   84|       |
   85|       |    private let _parent: Parent
   86|       |    private let _subscription = SerialDisposable()
   87|       |    
   88|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   89|      0|        self._parent = parent
   90|      0|        super.init(observer: observer, cancel: cancel)
   91|      0|    }
   92|       |
   93|      0|    func on(_ event: Event<E>) {
   94|      0|        switch event {
   95|      0|        case .error(let error):
   96|      0|            self.forwardOn(.error(error))
   97|      0|            self.dispose()
   98|      0|        case .next:
   99|      0|            break
  100|      0|        case .completed:
  101|      0|            let otherSink = ConcatCompletableSinkOther(parent: self)
  102|      0|            self._subscription.disposable = self._parent._second.subscribe(otherSink)
  103|      0|        }
  104|      0|    }
  105|       |
  106|       |    func run() -> Disposable {
  107|       |        let subscription = SingleAssignmentDisposable()
  108|       |        self._subscription.disposable = subscription
  109|       |        subscription.setDisposable(self._parent._completable.subscribe(self))
  110|       |        return self._subscription
  111|       |    }
  112|       |}
  113|       |
  114|       |final private class ConcatCompletableSinkOther<O: ObserverType>
  115|       |    : ObserverType {
  116|       |    typealias E = O.E
  117|       |
  118|       |    typealias Parent = ConcatCompletableSink<O>
  119|       |    
  120|       |    private let _parent: Parent
  121|       |
  122|      0|    init(parent: Parent) {
  123|      0|        self._parent = parent
  124|      0|    }
  125|       |
  126|      0|    func on(_ event: Event<O.E>) {
  127|      0|        self._parent.forwardOn(event)
  128|      0|        if event.isStopEvent {
  129|      0|            self._parent.dispose()
  130|      0|        }
  131|      0|    }
  132|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/Completable.swift:
    1|       |//
    2|       |//  Completable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 19/08/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if DEBUG
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |/// Sequence containing 0 elements
   14|       |public enum CompletableTrait { }
   15|       |/// Represents a push style sequence containing 0 elements.
   16|       |public typealias Completable = PrimitiveSequence<CompletableTrait, Swift.Never>
   17|       |
   18|       |public enum CompletableEvent {
   19|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
   20|       |    case error(Swift.Error)
   21|       |    
   22|       |    /// Sequence completed successfully.
   23|       |    case completed
   24|       |}
   25|       |
   26|       |extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Swift.Never {
   27|       |    public typealias CompletableObserver = (CompletableEvent) -> Void
   28|       |    
   29|       |    /**
   30|       |     Creates an observable sequence from a specified subscribe method implementation.
   31|       |     
   32|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   33|       |     
   34|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   35|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
   36|       |     */
   37|      0|    public static func create(subscribe: @escaping (@escaping CompletableObserver) -> Disposable) -> PrimitiveSequence<TraitType, ElementType> {
   38|      0|        let source = Observable<ElementType>.create { observer in
   39|      0|            return subscribe { event in
   40|      0|                switch event {
   41|      0|                case .error(let error):
   42|      0|                    observer.on(.error(error))
   43|      0|                case .completed:
   44|      0|                    observer.on(.completed)
   45|      0|                }
   46|      0|            }
   47|      0|        }
   48|      0|        
   49|      0|        return PrimitiveSequence(raw: source)
   50|      0|    }
   51|       |    
   52|       |    /**
   53|       |     Subscribes `observer` to receive events for this sequence.
   54|       |     
   55|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
   56|       |     */
   57|      0|    public func subscribe(_ observer: @escaping (CompletableEvent) -> Void) -> Disposable {
   58|      0|        var stopped = false
   59|      0|        return self.primitiveSequence.asObservable().subscribe { event in
   60|      0|            if stopped { return }
   61|      0|            stopped = true
   62|      0|            
   63|      0|            switch event {
   64|      0|            case .next:
   65|      0|                rxFatalError("Completables can't emit values")
   66|      0|            case .error(let error):
   67|      0|                observer(.error(error))
   68|      0|            case .completed:
   69|      0|                observer(.completed)
   70|      0|            }
   71|      0|        }
   72|      0|    }
   73|       |    
   74|       |    /**
   75|       |     Subscribes a completion handler and an error handler for this sequence.
   76|       |     
   77|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   78|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   79|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   80|       |     */
   81|      0|    public func subscribe(onCompleted: (() -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil) -> Disposable {
   82|      0|        #if DEBUG
   83|      0|                let callStack = Hooks.recordCallStackOnError ? Thread.callStackSymbols : []
   84|      0|        #else
   85|      0|                let callStack = [String]()
   86|      0|        #endif
   87|      0|
   88|      0|        return self.primitiveSequence.subscribe { event in
   89|      0|            switch event {
   90|      0|            case .error(let error):
   91|      0|                if let onError = onError {
   92|      0|                    onError(error)
   93|      0|                } else {
   94|      0|                    Hooks.defaultErrorHandler(callStack, error)
   95|      0|                }
   96|      0|            case .completed:
   97|      0|                onCompleted?()
   98|      0|            }
   99|      0|        }
  100|      0|    }
  101|       |}
  102|       |
  103|       |extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Swift.Never {
  104|       |    /**
  105|       |     Returns an observable sequence that terminates with an `error`.
  106|       |
  107|       |     - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  108|       |
  109|       |     - returns: The observable sequence that terminates with specified error.
  110|       |     */
  111|      0|    public static func error(_ error: Swift.Error) -> Completable {
  112|      0|        return PrimitiveSequence(raw: Observable.error(error))
  113|      0|    }
  114|       |
  115|       |    /**
  116|       |     Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  117|       |
  118|       |     - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  119|       |
  120|       |     - returns: An observable sequence whose observers will never get called.
  121|       |     */
  122|      0|    public static func never() -> Completable {
  123|      0|        return PrimitiveSequence(raw: Observable.never())
  124|      0|    }
  125|       |
  126|       |    /**
  127|       |     Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  128|       |
  129|       |     - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  130|       |
  131|       |     - returns: An observable sequence with no elements.
  132|       |     */
  133|      0|    public static func empty() -> Completable {
  134|      0|        return Completable(raw: Observable.empty())
  135|      0|    }
  136|       |
  137|       |}
  138|       |
  139|       |extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Swift.Never {
  140|       |    /**
  141|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  142|       |     
  143|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  144|       |     
  145|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  146|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  147|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  148|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  149|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  150|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  151|       |     - returns: The source sequence with the side-effecting behavior applied.
  152|       |     */
  153|       |    public func `do`(onError: ((Swift.Error) throws -> Void)? = nil,
  154|       |                     onCompleted: (() throws -> Void)? = nil,
  155|       |                     onSubscribe: (() -> Void)? = nil,
  156|       |                     onSubscribed: (() -> Void)? = nil,
  157|       |                     onDispose: (() -> Void)? = nil)
  158|      0|        -> Completable {
  159|      0|            return Completable(raw: self.primitiveSequence.source.do(
  160|      0|                onError: onError,
  161|      0|                onCompleted: onCompleted,
  162|      0|                onSubscribe: onSubscribe,
  163|      0|                onSubscribed: onSubscribed,
  164|      0|                onDispose: onDispose)
  165|      0|            )
  166|      0|    }
  167|       |
  168|       |
  169|       |
  170|       |    /**
  171|       |     Concatenates the second observable sequence to `self` upon successful termination of `self`.
  172|       |     
  173|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  174|       |     
  175|       |     - parameter second: Second observable sequence.
  176|       |     - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
  177|       |     */
  178|      0|    public func concat(_ second: Completable) -> Completable {
  179|      0|        return Completable.concat(self.primitiveSequence, second)
  180|      0|    }
  181|       |    
  182|       |    /**
  183|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  184|       |     
  185|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  186|       |     
  187|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  188|       |     */
  189|       |    public static func concat<S: Sequence>(_ sequence: S) -> Completable
  190|      0|        where S.Iterator.Element == Completable {
  191|      0|            let source = Observable.concat(sequence.lazy.map { $0.asObservable() })
  192|      0|            return Completable(raw: source)
  193|      0|    }
  194|       |    
  195|       |    /**
  196|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  197|       |     
  198|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  199|       |     
  200|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  201|       |     */
  202|       |    public static func concat<C: Collection>(_ collection: C) -> Completable
  203|      0|        where C.Iterator.Element == Completable {
  204|      0|            let source = Observable.concat(collection.map { $0.asObservable() })
  205|      0|            return Completable(raw: source)
  206|      0|    }
  207|       |    
  208|       |    /**
  209|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  210|       |     
  211|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  212|       |     
  213|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  214|       |     */
  215|       |    public static func concat(_ sources: Completable ...) -> Completable {
  216|      0|        let source = Observable.concat(sources.map { $0.asObservable() })
  217|       |        return Completable(raw: source)
  218|       |    }
  219|       |    
  220|       |    /**
  221|       |     Merges elements from all observable sequences from collection into a single observable sequence.
  222|       |     
  223|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  224|       |     
  225|       |     - parameter sources: Collection of observable sequences to merge.
  226|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  227|       |     */
  228|       |    public static func merge<C: Collection>(_ sources: C) -> Completable
  229|      0|        where C.Iterator.Element == Completable {
  230|      0|            let source = Observable.merge(sources.map { $0.asObservable() })
  231|      0|            return Completable(raw: source)
  232|      0|    }
  233|       |    
  234|       |    /**
  235|       |     Merges elements from all observable sequences from array into a single observable sequence.
  236|       |     
  237|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  238|       |     
  239|       |     - parameter sources: Array of observable sequences to merge.
  240|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  241|       |     */
  242|      0|    public static func merge(_ sources: [Completable]) -> Completable {
  243|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  244|      0|        return Completable(raw: source)
  245|      0|    }
  246|       |    
  247|       |    /**
  248|       |     Merges elements from all observable sequences into a single observable sequence.
  249|       |     
  250|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  251|       |     
  252|       |     - parameter sources: Collection of observable sequences to merge.
  253|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  254|       |     */
  255|      0|    public static func merge(_ sources: Completable...) -> Completable {
  256|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  257|      0|        return Completable(raw: source)
  258|      0|    }
  259|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/Maybe.swift:
    1|       |//
    2|       |//  Maybe.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 19/08/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if DEBUG
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |/// Sequence containing 0 or 1 elements
   14|       |public enum MaybeTrait { }
   15|       |/// Represents a push style sequence containing 0 or 1 element.
   16|       |public typealias Maybe<Element> = PrimitiveSequence<MaybeTrait, Element>
   17|       |
   18|       |public enum MaybeEvent<Element> {
   19|       |    /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)
   20|       |    case success(Element)
   21|       |    
   22|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
   23|       |    case error(Swift.Error)
   24|       |    
   25|       |    /// Sequence completed successfully.
   26|       |    case completed
   27|       |}
   28|       |
   29|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
   30|       |    public typealias MaybeObserver = (MaybeEvent<ElementType>) -> Void
   31|       |    
   32|       |    /**
   33|       |     Creates an observable sequence from a specified subscribe method implementation.
   34|       |     
   35|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   36|       |     
   37|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   38|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
   39|       |     */
   40|      0|    public static func create(subscribe: @escaping (@escaping MaybeObserver) -> Disposable) -> PrimitiveSequence<TraitType, ElementType> {
   41|      0|        let source = Observable<ElementType>.create { observer in
   42|      0|            return subscribe { event in
   43|      0|                switch event {
   44|      0|                case .success(let element):
   45|      0|                    observer.on(.next(element))
   46|      0|                    observer.on(.completed)
   47|      0|                case .error(let error):
   48|      0|                    observer.on(.error(error))
   49|      0|                case .completed:
   50|      0|                    observer.on(.completed)
   51|      0|                }
   52|      0|            }
   53|      0|        }
   54|      0|        
   55|      0|        return PrimitiveSequence(raw: source)
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |     Subscribes `observer` to receive events for this sequence.
   60|       |     
   61|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
   62|       |     */
   63|      0|    public func subscribe(_ observer: @escaping (MaybeEvent<ElementType>) -> Void) -> Disposable {
   64|      0|        var stopped = false
   65|      0|        return self.primitiveSequence.asObservable().subscribe { event in
   66|      0|            if stopped { return }
   67|      0|            stopped = true
   68|      0|            
   69|      0|            switch event {
   70|      0|            case .next(let element):
   71|      0|                observer(.success(element))
   72|      0|            case .error(let error):
   73|      0|                observer(.error(error))
   74|      0|            case .completed:
   75|      0|                observer(.completed)
   76|      0|            }
   77|      0|        }
   78|      0|    }
   79|       |    
   80|       |    /**
   81|       |     Subscribes a success handler, an error handler, and a completion handler for this sequence.
   82|       |     
   83|       |     - parameter onSuccess: Action to invoke for each element in the observable sequence.
   84|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   85|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   86|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   87|       |     */
   88|       |    public func subscribe(onSuccess: ((ElementType) -> Void)? = nil,
   89|       |                          onError: ((Swift.Error) -> Void)? = nil,
   90|      0|                          onCompleted: (() -> Void)? = nil) -> Disposable {
   91|      0|        #if DEBUG
   92|      0|            let callStack = Hooks.recordCallStackOnError ? Thread.callStackSymbols : []
   93|      0|        #else
   94|      0|            let callStack = [String]()
   95|      0|        #endif
   96|      0|
   97|      0|        return self.primitiveSequence.subscribe { event in
   98|      0|            switch event {
   99|      0|            case .success(let element):
  100|      0|                onSuccess?(element)
  101|      0|            case .error(let error):
  102|      0|                if let onError = onError {
  103|      0|                    onError(error)
  104|      0|                } else {
  105|      0|                    Hooks.defaultErrorHandler(callStack, error)
  106|      0|                }
  107|      0|            case .completed:
  108|      0|                onCompleted?()
  109|      0|            }
  110|      0|        }
  111|      0|    }
  112|       |}
  113|       |
  114|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  115|       |    /**
  116|       |     Returns an observable sequence that contains a single element.
  117|       |     
  118|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  119|       |     
  120|       |     - parameter element: Single element in the resulting observable sequence.
  121|       |     - returns: An observable sequence containing the single specified element.
  122|       |     */
  123|      0|    public static func just(_ element: ElementType) -> Maybe<ElementType> {
  124|      0|        return Maybe(raw: Observable.just(element))
  125|      0|    }
  126|       |    
  127|       |    /**
  128|       |     Returns an observable sequence that contains a single element.
  129|       |     
  130|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  131|       |     
  132|       |     - parameter element: Single element in the resulting observable sequence.
  133|       |     - parameter scheduler: Scheduler to send the single element on.
  134|       |     - returns: An observable sequence containing the single specified element.
  135|       |     */
  136|      0|    public static func just(_ element: ElementType, scheduler: ImmediateSchedulerType) -> Maybe<ElementType> {
  137|      0|        return Maybe(raw: Observable.just(element, scheduler: scheduler))
  138|      0|    }
  139|       |
  140|       |    /**
  141|       |     Returns an observable sequence that terminates with an `error`.
  142|       |
  143|       |     - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  144|       |
  145|       |     - returns: The observable sequence that terminates with specified error.
  146|       |     */
  147|      0|    public static func error(_ error: Swift.Error) -> Maybe<ElementType> {
  148|      0|        return PrimitiveSequence(raw: Observable.error(error))
  149|      0|    }
  150|       |
  151|       |    /**
  152|       |     Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  153|       |
  154|       |     - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  155|       |
  156|       |     - returns: An observable sequence whose observers will never get called.
  157|       |     */
  158|      0|    public static func never() -> Maybe<ElementType> {
  159|      0|        return PrimitiveSequence(raw: Observable.never())
  160|      0|    }
  161|       |
  162|       |    /**
  163|       |     Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  164|       |
  165|       |     - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  166|       |
  167|       |     - returns: An observable sequence with no elements.
  168|       |     */
  169|      0|    public static func empty() -> Maybe<ElementType> {
  170|      0|        return Maybe(raw: Observable.empty())
  171|      0|    }
  172|       |}
  173|       |
  174|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  175|       |    /**
  176|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  177|       |     
  178|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  179|       |     
  180|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  181|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  182|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  183|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  184|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  185|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  186|       |     - returns: The source sequence with the side-effecting behavior applied.
  187|       |     */
  188|       |    public func `do`(onNext: ((ElementType) throws -> Void)? = nil,
  189|       |                     onError: ((Swift.Error) throws -> Void)? = nil,
  190|       |                     onCompleted: (() throws -> Void)? = nil,
  191|       |                     onSubscribe: (() -> Void)? = nil,
  192|       |                     onSubscribed: (() -> Void)? = nil,
  193|       |                     onDispose: (() -> Void)? = nil)
  194|      0|        -> Maybe<ElementType> {
  195|      0|            return Maybe(raw: self.primitiveSequence.source.do(
  196|      0|                onNext: onNext,
  197|      0|                onError: onError,
  198|      0|                onCompleted: onCompleted,
  199|      0|                onSubscribe: onSubscribe,
  200|      0|                onSubscribed: onSubscribed,
  201|      0|                onDispose: onDispose)
  202|      0|            )
  203|      0|    }
  204|       |    
  205|       |    /**
  206|       |     Filters the elements of an observable sequence based on a predicate.
  207|       |     
  208|       |     - seealso: [filter operator on reactivex.io](http://reactivex.io/documentation/operators/filter.html)
  209|       |     
  210|       |     - parameter predicate: A function to test each source element for a condition.
  211|       |     - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
  212|       |     */
  213|       |    public func filter(_ predicate: @escaping (ElementType) throws -> Bool)
  214|      0|        -> Maybe<ElementType> {
  215|      0|            return Maybe(raw: self.primitiveSequence.source.filter(predicate))
  216|      0|    }
  217|       |    
  218|       |    /**
  219|       |     Projects each element of an observable sequence into a new form.
  220|       |     
  221|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
  222|       |     
  223|       |     - parameter transform: A transform function to apply to each source element.
  224|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
  225|       |     
  226|       |     */
  227|       |    public func map<R>(_ transform: @escaping (ElementType) throws -> R)
  228|      0|        -> Maybe<R> {
  229|      0|            return Maybe(raw: self.primitiveSequence.source.map(transform))
  230|      0|    }
  231|       |
  232|       |    /**
  233|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  234|       |
  235|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  236|       |
  237|       |     - parameter selector: A transform function to apply to each element.
  238|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  239|       |     */
  240|       |    public func flatMap<R>(_ selector: @escaping (ElementType) throws -> Maybe<R>)
  241|      0|        -> Maybe<R> {
  242|      0|            return Maybe<R>(raw: self.primitiveSequence.source.flatMap(selector))
  243|      0|    }
  244|       |
  245|       |    /**
  246|       |     Emits elements from the source observable sequence, or a default element if the source observable sequence is empty.
  247|       |
  248|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
  249|       |
  250|       |     - parameter default: Default element to be sent if the source does not emit any elements
  251|       |     - returns: An observable sequence which emits default element end completes in case the original sequence is empty
  252|       |     */
  253|      0|    public func ifEmpty(default: ElementType) -> Single<ElementType> {
  254|      0|        return Single(raw: self.primitiveSequence.source.ifEmpty(default: `default`))
  255|      0|    }
  256|       |
  257|       |    /**
  258|       |     Returns the elements of the specified sequence or `switchTo` sequence if the sequence is empty.
  259|       |
  260|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
  261|       |
  262|       |     - parameter switchTo: Observable sequence being returned when source sequence is empty.
  263|       |     - returns: Observable sequence that contains elements from switchTo sequence if source is empty, otherwise returns source sequence elements.
  264|       |     */
  265|      0|    public func ifEmpty(switchTo other: Maybe<ElementType>) -> Maybe<ElementType> {
  266|      0|        return Maybe(raw: self.primitiveSequence.source.ifEmpty(switchTo: other.primitiveSequence.source))
  267|      0|    }
  268|       |
  269|       |    /**
  270|       |     Returns the elements of the specified sequence or `switchTo` sequence if the sequence is empty.
  271|       |
  272|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
  273|       |
  274|       |     - parameter switchTo: Observable sequence being returned when source sequence is empty.
  275|       |     - returns: Observable sequence that contains elements from switchTo sequence if source is empty, otherwise returns source sequence elements.
  276|       |     */
  277|      0|    public func ifEmpty(switchTo other: Single<ElementType>) -> Single<ElementType> {
  278|      0|        return Single(raw: self.primitiveSequence.source.ifEmpty(switchTo: other.primitiveSequence.source))
  279|      0|    }
  280|       |
  281|       |    /**
  282|       |     Continues an observable sequence that is terminated by an error with a single element.
  283|       |
  284|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  285|       |
  286|       |     - parameter element: Last element in an observable sequence in case error occurs.
  287|       |     - returns: An observable sequence containing the source sequence's elements, followed by the `element` in case an error occurred.
  288|       |     */
  289|       |    public func catchErrorJustReturn(_ element: ElementType)
  290|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  291|      0|        return PrimitiveSequence(raw: self.primitiveSequence.source.catchErrorJustReturn(element))
  292|      0|    }
  293|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/ObservableType+PrimitiveSequence.swift:
    1|       |//
    2|       |//  ObservableType+PrimitiveSequence.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/17/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |     The `asSingle` operator throws a `RxError.noElements` or `RxError.moreThanOneElement`
   12|       |     if the source Observable does not emit exactly one element before successfully completing.
   13|       |
   14|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
   15|       |
   16|       |     - returns: An observable sequence that emits a single element when the source Observable has completed, or throws an exception if more (or none) of them are emitted.
   17|       |     */
   18|      0|    public func asSingle() -> Single<E> {
   19|      0|        return PrimitiveSequence(raw: AsSingle(source: self.asObservable()))
   20|      0|    }
   21|       |    
   22|       |    /**
   23|       |     The `first` operator emits only the very first item emitted by this Observable,
   24|       |     or nil if this Observable completes without emitting anything.
   25|       |     
   26|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
   27|       |     
   28|       |     - returns: An observable sequence that emits a single element or nil if the source observable sequence completes without emitting any items.
   29|       |     */
   30|      0|    public func first() -> Single<E?> {
   31|      0|        return PrimitiveSequence(raw: First(source: self.asObservable()))
   32|      0|    }
   33|       |
   34|       |    /**
   35|       |     The `asMaybe` operator throws a `RxError.moreThanOneElement`
   36|       |     if the source Observable does not emit at most one element before successfully completing.
   37|       |
   38|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
   39|       |
   40|       |     - returns: An observable sequence that emits a single element, completes when the source Observable has completed, or throws an exception if more of them are emitted.
   41|       |     */
   42|      0|    public func asMaybe() -> Maybe<E> {
   43|      0|        return PrimitiveSequence(raw: AsMaybe(source: self.asObservable()))
   44|      0|    }
   45|       |}
   46|       |
   47|       |extension ObservableType where E == Never {
   48|       |    /**
   49|       |     - returns: An observable sequence that completes.
   50|       |     */
   51|       |    public func asCompletable()
   52|      0|        -> Completable {
   53|      0|            return PrimitiveSequence(raw: self.asObservable())
   54|      0|    }
   55|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/PrimitiveSequence+Zip+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  PrimitiveSequence+Zip+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 5/23/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   17|       |
   18|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, resultSelector: @escaping (E1, E2) throws -> ElementType)
   24|      0|        -> PrimitiveSequence<TraitType, ElementType> {
   25|      0|            return PrimitiveSequence(raw: Observable.zip(
   26|      0|            source1.asObservable(), source2.asObservable(),
   27|      0|                resultSelector: resultSelector)
   28|      0|            )
   29|      0|    }
   30|       |}
   31|       |
   32|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
   33|       |    /**
   34|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   35|       |
   36|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   37|       |
   38|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   39|       |    */
   40|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>)
   41|      0|        -> PrimitiveSequence<TraitType, (E1, E2)> {
   42|      0|        return PrimitiveSequence(raw: Observable.zip(
   43|      0|                source1.asObservable(), source2.asObservable())
   44|      0|            )
   45|      0|    }
   46|       |}
   47|       |
   48|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
   49|       |    /**
   50|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   51|       |
   52|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   53|       |
   54|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   55|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   56|       |    */
   57|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, resultSelector: @escaping (E1, E2) throws -> ElementType)
   58|      0|        -> PrimitiveSequence<TraitType, ElementType> {
   59|      0|            return PrimitiveSequence(raw: Observable.zip(
   60|      0|            source1.asObservable(), source2.asObservable(),
   61|      0|                resultSelector: resultSelector)
   62|      0|            )
   63|      0|    }
   64|       |}
   65|       |
   66|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
   67|       |    /**
   68|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   69|       |
   70|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   71|       |
   72|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   73|       |    */
   74|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>)
   75|      0|        -> PrimitiveSequence<TraitType, (E1, E2)> {
   76|      0|        return PrimitiveSequence(raw: Observable.zip(
   77|      0|                source1.asObservable(), source2.asObservable())
   78|      0|            )
   79|      0|    }
   80|       |}
   81|       |
   82|       |
   83|       |
   84|       |
   85|       |// 3
   86|       |
   87|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
   88|       |    /**
   89|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   90|       |
   91|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   92|       |
   93|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   94|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   95|       |    */
   96|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, resultSelector: @escaping (E1, E2, E3) throws -> ElementType)
   97|      0|        -> PrimitiveSequence<TraitType, ElementType> {
   98|      0|            return PrimitiveSequence(raw: Observable.zip(
   99|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(),
  100|      0|                resultSelector: resultSelector)
  101|      0|            )
  102|      0|    }
  103|       |}
  104|       |
  105|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  106|       |    /**
  107|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  108|       |
  109|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  110|       |
  111|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  112|       |    */
  113|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>)
  114|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3)> {
  115|      0|        return PrimitiveSequence(raw: Observable.zip(
  116|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable())
  117|      0|            )
  118|      0|    }
  119|       |}
  120|       |
  121|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  122|       |    /**
  123|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  124|       |
  125|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  126|       |
  127|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  128|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  129|       |    */
  130|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, resultSelector: @escaping (E1, E2, E3) throws -> ElementType)
  131|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  132|      0|            return PrimitiveSequence(raw: Observable.zip(
  133|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(),
  134|      0|                resultSelector: resultSelector)
  135|      0|            )
  136|      0|    }
  137|       |}
  138|       |
  139|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  140|       |    /**
  141|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  142|       |
  143|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  144|       |
  145|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  146|       |    */
  147|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>)
  148|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3)> {
  149|      0|        return PrimitiveSequence(raw: Observable.zip(
  150|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable())
  151|      0|            )
  152|      0|    }
  153|       |}
  154|       |
  155|       |
  156|       |
  157|       |
  158|       |// 4
  159|       |
  160|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  161|       |    /**
  162|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  163|       |
  164|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  165|       |
  166|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  167|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  168|       |    */
  169|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> ElementType)
  170|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  171|      0|            return PrimitiveSequence(raw: Observable.zip(
  172|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(),
  173|      0|                resultSelector: resultSelector)
  174|      0|            )
  175|      0|    }
  176|       |}
  177|       |
  178|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  179|       |    /**
  180|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  181|       |
  182|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  183|       |
  184|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  185|       |    */
  186|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>)
  187|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4)> {
  188|      0|        return PrimitiveSequence(raw: Observable.zip(
  189|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable())
  190|      0|            )
  191|      0|    }
  192|       |}
  193|       |
  194|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  195|       |    /**
  196|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  197|       |
  198|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  199|       |
  200|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  201|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  202|       |    */
  203|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> ElementType)
  204|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  205|      0|            return PrimitiveSequence(raw: Observable.zip(
  206|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(),
  207|      0|                resultSelector: resultSelector)
  208|      0|            )
  209|      0|    }
  210|       |}
  211|       |
  212|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  213|       |    /**
  214|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  215|       |
  216|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  217|       |
  218|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  219|       |    */
  220|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>)
  221|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4)> {
  222|      0|        return PrimitiveSequence(raw: Observable.zip(
  223|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable())
  224|      0|            )
  225|      0|    }
  226|       |}
  227|       |
  228|       |
  229|       |
  230|       |
  231|       |// 5
  232|       |
  233|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  234|       |    /**
  235|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  236|       |
  237|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  238|       |
  239|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  240|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  241|       |    */
  242|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> ElementType)
  243|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  244|      0|            return PrimitiveSequence(raw: Observable.zip(
  245|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(),
  246|      0|                resultSelector: resultSelector)
  247|      0|            )
  248|      0|    }
  249|       |}
  250|       |
  251|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  252|       |    /**
  253|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  254|       |
  255|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  256|       |
  257|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  258|       |    */
  259|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>)
  260|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5)> {
  261|      0|        return PrimitiveSequence(raw: Observable.zip(
  262|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable())
  263|      0|            )
  264|      0|    }
  265|       |}
  266|       |
  267|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  268|       |    /**
  269|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  270|       |
  271|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  272|       |
  273|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  274|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  275|       |    */
  276|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> ElementType)
  277|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  278|      0|            return PrimitiveSequence(raw: Observable.zip(
  279|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(),
  280|      0|                resultSelector: resultSelector)
  281|      0|            )
  282|      0|    }
  283|       |}
  284|       |
  285|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  286|       |    /**
  287|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  288|       |
  289|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  290|       |
  291|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  292|       |    */
  293|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>)
  294|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5)> {
  295|      0|        return PrimitiveSequence(raw: Observable.zip(
  296|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable())
  297|      0|            )
  298|      0|    }
  299|       |}
  300|       |
  301|       |
  302|       |
  303|       |
  304|       |// 6
  305|       |
  306|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  307|       |    /**
  308|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  309|       |
  310|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  311|       |
  312|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  313|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  314|       |    */
  315|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> ElementType)
  316|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  317|      0|            return PrimitiveSequence(raw: Observable.zip(
  318|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(),
  319|      0|                resultSelector: resultSelector)
  320|      0|            )
  321|      0|    }
  322|       |}
  323|       |
  324|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  325|       |    /**
  326|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  327|       |
  328|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  329|       |
  330|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  331|       |    */
  332|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>)
  333|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6)> {
  334|      0|        return PrimitiveSequence(raw: Observable.zip(
  335|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable())
  336|      0|            )
  337|      0|    }
  338|       |}
  339|       |
  340|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  341|       |    /**
  342|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  343|       |
  344|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  345|       |
  346|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  347|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  348|       |    */
  349|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> ElementType)
  350|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  351|      0|            return PrimitiveSequence(raw: Observable.zip(
  352|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(),
  353|      0|                resultSelector: resultSelector)
  354|      0|            )
  355|      0|    }
  356|       |}
  357|       |
  358|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  359|       |    /**
  360|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  361|       |
  362|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  363|       |
  364|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  365|       |    */
  366|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>)
  367|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6)> {
  368|      0|        return PrimitiveSequence(raw: Observable.zip(
  369|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable())
  370|      0|            )
  371|      0|    }
  372|       |}
  373|       |
  374|       |
  375|       |
  376|       |
  377|       |// 7
  378|       |
  379|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  380|       |    /**
  381|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  382|       |
  383|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  384|       |
  385|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  386|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  387|       |    */
  388|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> ElementType)
  389|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  390|      0|            return PrimitiveSequence(raw: Observable.zip(
  391|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(),
  392|      0|                resultSelector: resultSelector)
  393|      0|            )
  394|      0|    }
  395|       |}
  396|       |
  397|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  398|       |    /**
  399|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  400|       |
  401|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  402|       |
  403|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  404|       |    */
  405|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>)
  406|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7)> {
  407|      0|        return PrimitiveSequence(raw: Observable.zip(
  408|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable())
  409|      0|            )
  410|      0|    }
  411|       |}
  412|       |
  413|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  414|       |    /**
  415|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  416|       |
  417|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  418|       |
  419|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  420|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  421|       |    */
  422|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> ElementType)
  423|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  424|      0|            return PrimitiveSequence(raw: Observable.zip(
  425|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(),
  426|      0|                resultSelector: resultSelector)
  427|      0|            )
  428|      0|    }
  429|       |}
  430|       |
  431|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  432|       |    /**
  433|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  434|       |
  435|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  436|       |
  437|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  438|       |    */
  439|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>)
  440|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7)> {
  441|      0|        return PrimitiveSequence(raw: Observable.zip(
  442|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable())
  443|      0|            )
  444|      0|    }
  445|       |}
  446|       |
  447|       |
  448|       |
  449|       |
  450|       |// 8
  451|       |
  452|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  453|       |    /**
  454|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  455|       |
  456|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  457|       |
  458|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  459|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  460|       |    */
  461|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> ElementType)
  462|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  463|      0|            return PrimitiveSequence(raw: Observable.zip(
  464|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable(),
  465|      0|                resultSelector: resultSelector)
  466|      0|            )
  467|      0|    }
  468|       |}
  469|       |
  470|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == SingleTrait {
  471|       |    /**
  472|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  473|       |
  474|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  475|       |
  476|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  477|       |    */
  478|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>)
  479|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7, E8)> {
  480|      0|        return PrimitiveSequence(raw: Observable.zip(
  481|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable())
  482|      0|            )
  483|      0|    }
  484|       |}
  485|       |
  486|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  487|       |    /**
  488|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  489|       |
  490|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  491|       |
  492|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  493|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  494|       |    */
  495|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> ElementType)
  496|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  497|      0|            return PrimitiveSequence(raw: Observable.zip(
  498|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable(),
  499|      0|                resultSelector: resultSelector)
  500|      0|            )
  501|      0|    }
  502|       |}
  503|       |
  504|       |extension PrimitiveSequenceType where ElementType == Any, TraitType == MaybeTrait {
  505|       |    /**
  506|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  507|       |
  508|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  509|       |
  510|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  511|       |    */
  512|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>)
  513|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7, E8)> {
  514|      0|        return PrimitiveSequence(raw: Observable.zip(
  515|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable())
  516|      0|            )
  517|      0|    }
  518|       |}
  519|       |
  520|       |
  521|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/PrimitiveSequence.swift:
    1|       |//
    2|       |//  PrimitiveSequence.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/5/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Observable sequences containing 0 or 1 element.
   10|       |public struct PrimitiveSequence<Trait, Element> {
   11|       |    let source: Observable<Element>
   12|       |
   13|      0|    init(raw: Observable<Element>) {
   14|      0|        self.source = raw
   15|      0|    }
   16|       |}
   17|       |
   18|       |/// Observable sequences containing 0 or 1 element
   19|       |public protocol PrimitiveSequenceType {
   20|       |    /// Additional constraints
   21|       |    associatedtype TraitType
   22|       |    /// Sequence element type
   23|       |    associatedtype ElementType
   24|       |
   25|       |    // Converts `self` to primitive sequence.
   26|       |    ///
   27|       |    /// - returns: Observable sequence that represents `self`.
   28|       |    var primitiveSequence: PrimitiveSequence<TraitType, ElementType> { get }
   29|       |}
   30|       |
   31|       |extension PrimitiveSequence: PrimitiveSequenceType {
   32|       |    /// Additional constraints
   33|       |    public typealias TraitType = Trait
   34|       |    /// Sequence element type
   35|       |    public typealias ElementType = Element
   36|       |
   37|       |    // Converts `self` to primitive sequence.
   38|       |    ///
   39|       |    /// - returns: Observable sequence that represents `self`.
   40|      0|    public var primitiveSequence: PrimitiveSequence<TraitType, ElementType> {
   41|      0|        return self
   42|      0|    }
   43|       |}
   44|       |
   45|       |extension PrimitiveSequence: ObservableConvertibleType {
   46|       |    /// Type of elements in sequence.
   47|       |    public typealias E = Element
   48|       |
   49|       |    /// Converts `self` to `Observable` sequence.
   50|       |    ///
   51|       |    /// - returns: Observable sequence that represents `self`.
   52|      0|    public func asObservable() -> Observable<E> {
   53|      0|        return self.source
   54|      0|    }
   55|       |}
   56|       |
   57|       |extension PrimitiveSequence {
   58|       |    /**
   59|       |     Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
   60|       |
   61|       |     - seealso: [defer operator on reactivex.io](http://reactivex.io/documentation/operators/defer.html)
   62|       |
   63|       |     - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
   64|       |     - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
   65|       |     */
   66|       |    public static func deferred(_ observableFactory: @escaping () throws -> PrimitiveSequence<Trait, Element>)
   67|      0|        -> PrimitiveSequence<Trait, Element> {
   68|      0|        return PrimitiveSequence(raw: Observable.deferred {
   69|      0|            try observableFactory().asObservable()
   70|      0|        })
   71|      0|    }
   72|       |
   73|       |    /**
   74|       |     Returns an observable sequence by the source observable sequence shifted forward in time by a specified delay. Error events from the source observable sequence are not delayed.
   75|       |
   76|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
   77|       |
   78|       |     - parameter dueTime: Relative time shift of the source by.
   79|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
   80|       |     - returns: the source Observable shifted in time by the specified delay.
   81|       |     */
   82|       |    public func delay(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   83|      0|        -> PrimitiveSequence<Trait, Element> {
   84|      0|        return PrimitiveSequence(raw: self.primitiveSequence.source.delay(dueTime, scheduler: scheduler))
   85|      0|    }
   86|       |
   87|       |    /**
   88|       |     Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
   89|       |
   90|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
   91|       |
   92|       |     - parameter dueTime: Relative time shift of the subscription.
   93|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
   94|       |     - returns: Time-shifted sequence.
   95|       |     */
   96|       |    public func delaySubscription(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   97|      0|        -> PrimitiveSequence<Trait, Element> {
   98|      0|        return PrimitiveSequence(raw: self.source.delaySubscription(dueTime, scheduler: scheduler))
   99|      0|    }
  100|       |    
  101|       |    /**
  102|       |     Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
  103|       |
  104|       |     This only invokes observer callbacks on a `scheduler`. In case the subscription and/or unsubscription
  105|       |     actions have side-effects that require to be run on a scheduler, use `subscribeOn`.
  106|       |
  107|       |     - seealso: [observeOn operator on reactivex.io](http://reactivex.io/documentation/operators/observeon.html)
  108|       |
  109|       |     - parameter scheduler: Scheduler to notify observers on.
  110|       |     - returns: The source sequence whose observations happen on the specified scheduler.
  111|       |     */
  112|       |    public func observeOn(_ scheduler: ImmediateSchedulerType)
  113|      0|        -> PrimitiveSequence<Trait, Element> {
  114|      0|        return PrimitiveSequence(raw: self.source.observeOn(scheduler))
  115|      0|    }
  116|       |
  117|       |    /**
  118|       |    Wraps the source sequence in order to run its subscription and unsubscription logic on the specified 
  119|       |    scheduler. 
  120|       |    
  121|       |    This operation is not commonly used.
  122|       |    
  123|       |    This only performs the side-effects of subscription and unsubscription on the specified scheduler. 
  124|       |    
  125|       |    In order to invoke observer callbacks on a `scheduler`, use `observeOn`.
  126|       |
  127|       |    - seealso: [subscribeOn operator on reactivex.io](http://reactivex.io/documentation/operators/subscribeon.html)
  128|       |    
  129|       |    - parameter scheduler: Scheduler to perform subscription and unsubscription actions on.
  130|       |    - returns: The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
  131|       |    */
  132|       |    public func subscribeOn(_ scheduler: ImmediateSchedulerType)
  133|      0|        -> PrimitiveSequence<Trait, Element> {
  134|      0|        return PrimitiveSequence(raw: self.source.subscribeOn(scheduler))
  135|      0|    }
  136|       |
  137|       |    /**
  138|       |     Continues an observable sequence that is terminated by an error with the observable sequence produced by the handler.
  139|       |
  140|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  141|       |
  142|       |     - parameter handler: Error handler function, producing another observable sequence.
  143|       |     - returns: An observable sequence containing the source sequence's elements, followed by the elements produced by the handler's resulting observable sequence in case an error occurred.
  144|       |     */
  145|       |    public func catchError(_ handler: @escaping (Swift.Error) throws -> PrimitiveSequence<Trait, Element>)
  146|      0|        -> PrimitiveSequence<Trait, Element> {
  147|      0|        return PrimitiveSequence(raw: self.source.catchError { try handler($0).asObservable() })
  148|      0|    }
  149|       |
  150|       |    /**
  151|       |     If the initial subscription to the observable sequence emits an error event, try repeating it up to the specified number of attempts (inclusive of the initial attempt) or until is succeeds. For example, if you want to retry a sequence once upon failure, you should use retry(2) (once for the initial attempt, and once for the retry).
  152|       |
  153|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  154|       |
  155|       |     - parameter maxAttemptCount: Maximum number of times to attempt the sequence subscription.
  156|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
  157|       |     */
  158|       |    public func retry(_ maxAttemptCount: Int)
  159|      0|        -> PrimitiveSequence<Trait, Element> {
  160|      0|        return PrimitiveSequence(raw: self.source.retry(maxAttemptCount))
  161|      0|    }
  162|       |
  163|       |    /**
  164|       |     Repeats the source observable sequence on error when the notifier emits a next value.
  165|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
  166|       |
  167|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  168|       |
  169|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  170|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  171|       |     */
  172|       |    public func retryWhen<TriggerObservable: ObservableType, Error: Swift.Error>(_ notificationHandler: @escaping (Observable<Error>) -> TriggerObservable)
  173|      0|        -> PrimitiveSequence<Trait, Element> {
  174|      0|        return PrimitiveSequence(raw: self.source.retryWhen(notificationHandler))
  175|      0|    }
  176|       |
  177|       |    /**
  178|       |     Repeats the source observable sequence on error when the notifier emits a next value.
  179|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
  180|       |
  181|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  182|       |
  183|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  184|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  185|       |     */
  186|       |    public func retryWhen<TriggerObservable: ObservableType>(_ notificationHandler: @escaping (Observable<Swift.Error>) -> TriggerObservable)
  187|      0|        -> PrimitiveSequence<Trait, Element> {
  188|      0|        return PrimitiveSequence(raw: self.source.retryWhen(notificationHandler))
  189|      0|    }
  190|       |
  191|       |    /**
  192|       |     Prints received events for all observers on standard output.
  193|       |
  194|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  195|       |
  196|       |     - parameter identifier: Identifier that is printed together with event description to standard output.
  197|       |     - parameter trimOutput: Should output be trimmed to max 40 characters.
  198|       |     - returns: An observable sequence whose events are printed to standard output.
  199|       |     */
  200|       |    public func debug(_ identifier: String? = nil, trimOutput: Bool = false, file: String = #file, line: UInt = #line, function: String = #function)
  201|      0|        -> PrimitiveSequence<Trait, Element> {
  202|      0|            return PrimitiveSequence(raw: self.source.debug(identifier, trimOutput: trimOutput, file: file, line: line, function: function))
  203|      0|    }
  204|       |    
  205|       |    /**
  206|       |     Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
  207|       |     
  208|       |     - seealso: [using operator on reactivex.io](http://reactivex.io/documentation/operators/using.html)
  209|       |     
  210|       |     - parameter resourceFactory: Factory function to obtain a resource object.
  211|       |     - parameter primitiveSequenceFactory: Factory function to obtain an observable sequence that depends on the obtained resource.
  212|       |     - returns: An observable sequence whose lifetime controls the lifetime of the dependent resource object.
  213|       |     */
  214|       |    public static func using<Resource: Disposable>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> PrimitiveSequence<Trait, Element>)
  215|      0|        -> PrimitiveSequence<Trait, Element> {
  216|      0|            return PrimitiveSequence(raw: Observable.using(resourceFactory, observableFactory: { (resource: Resource) throws -> Observable<E> in
  217|      0|                return try primitiveSequenceFactory(resource).asObservable()
  218|      0|            }))
  219|      0|    }
  220|       |
  221|       |    /**
  222|       |     Applies a timeout policy for each element in the observable sequence. If the next element isn't received within the specified timeout duration starting from its predecessor, a TimeoutError is propagated to the observer.
  223|       |     
  224|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
  225|       |     
  226|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
  227|       |     - parameter scheduler: Scheduler to run the timeout timer on.
  228|       |     - returns: An observable sequence with a `RxError.timeout` in case of a timeout.
  229|       |     */
  230|       |    public func timeout(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  231|      0|        -> PrimitiveSequence<Trait, Element> {
  232|      0|            return PrimitiveSequence<Trait, Element>(raw: self.primitiveSequence.source.timeout(dueTime, scheduler: scheduler))
  233|      0|    }
  234|       |    
  235|       |    /**
  236|       |     Applies a timeout policy for each element in the observable sequence, using the specified scheduler to run timeout timers. If the next element isn't received within the specified timeout duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
  237|       |     
  238|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
  239|       |     
  240|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
  241|       |     - parameter other: Sequence to return in case of a timeout.
  242|       |     - parameter scheduler: Scheduler to run the timeout timer on.
  243|       |     - returns: The source sequence switching to the other sequence in case of a timeout.
  244|       |     */
  245|       |    public func timeout(_ dueTime: RxTimeInterval,
  246|       |                        other: PrimitiveSequence<Trait, Element>,
  247|      0|                        scheduler: SchedulerType) -> PrimitiveSequence<Trait, Element> {
  248|      0|        return PrimitiveSequence<Trait, Element>(raw: self.primitiveSequence.source.timeout(dueTime, other: other.source, scheduler: scheduler))
  249|      0|    }
  250|       |}
  251|       |
  252|       |extension PrimitiveSequenceType where ElementType: RxAbstractInteger
  253|       |{
  254|       |    /**
  255|       |     Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
  256|       |
  257|       |     - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
  258|       |
  259|       |     - parameter dueTime: Relative time at which to produce the first value.
  260|       |     - parameter scheduler: Scheduler to run timers on.
  261|       |     - returns: An observable sequence that produces a value after due time has elapsed and then each period.
  262|       |     */
  263|       |    public static func timer(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  264|      0|        -> PrimitiveSequence<TraitType, ElementType>  {
  265|      0|        return PrimitiveSequence(raw: Observable<ElementType>.timer(dueTime, scheduler: scheduler))
  266|      0|    }
  267|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxSwift/RxSwift/Traits/Single.swift:
    1|       |//
    2|       |//  Single.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 19/08/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if DEBUG
   10|       |import Foundation
   11|       |#endif
   12|       |
   13|       |/// Sequence containing exactly 1 element
   14|       |public enum SingleTrait { }
   15|       |/// Represents a push style sequence containing 1 element.
   16|       |public typealias Single<Element> = PrimitiveSequence<SingleTrait, Element>
   17|       |
   18|       |public enum SingleEvent<Element> {
   19|       |    /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)
   20|       |    case success(Element)
   21|       |    
   22|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
   23|       |    case error(Swift.Error)
   24|       |}
   25|       |
   26|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
   27|       |    public typealias SingleObserver = (SingleEvent<ElementType>) -> Void
   28|       |    
   29|       |    /**
   30|       |     Creates an observable sequence from a specified subscribe method implementation.
   31|       |     
   32|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   33|       |     
   34|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   35|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
   36|       |     */
   37|      0|    public static func create(subscribe: @escaping (@escaping SingleObserver) -> Disposable) -> Single<ElementType> {
   38|      0|        let source = Observable<ElementType>.create { observer in
   39|      0|            return subscribe { event in
   40|      0|                switch event {
   41|      0|                case .success(let element):
   42|      0|                    observer.on(.next(element))
   43|      0|                    observer.on(.completed)
   44|      0|                case .error(let error):
   45|      0|                    observer.on(.error(error))
   46|      0|                }
   47|      0|            }
   48|      0|        }
   49|      0|        
   50|      0|        return PrimitiveSequence(raw: source)
   51|      0|    }
   52|       |    
   53|       |    
   54|       |    /**
   55|       |     Subscribes `observer` to receive events for this sequence.
   56|       |     
   57|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
   58|       |     */
   59|      0|    public func subscribe(_ observer: @escaping (SingleEvent<ElementType>) -> Void) -> Disposable {
   60|      0|        var stopped = false
   61|      0|        return self.primitiveSequence.asObservable().subscribe { event in
   62|      0|            if stopped { return }
   63|      0|            stopped = true
   64|      0|            
   65|      0|            switch event {
   66|      0|            case .next(let element):
   67|      0|                observer(.success(element))
   68|      0|            case .error(let error):
   69|      0|                observer(.error(error))
   70|      0|            case .completed:
   71|      0|                rxFatalErrorInDebug("Singles can't emit a completion event")
   72|      0|            }
   73|      0|        }
   74|      0|    }
   75|       |    
   76|       |    /**
   77|       |     Subscribes a success handler, and an error handler for this sequence.
   78|       |     
   79|       |     - parameter onSuccess: Action to invoke for each element in the observable sequence.
   80|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   81|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   82|       |     */
   83|      0|    public func subscribe(onSuccess: ((ElementType) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil) -> Disposable {
   84|      0|        #if DEBUG
   85|      0|             let callStack = Hooks.recordCallStackOnError ? Thread.callStackSymbols : []
   86|      0|        #else
   87|      0|            let callStack = [String]()
   88|      0|        #endif
   89|      0|    
   90|      0|        return self.primitiveSequence.subscribe { event in
   91|      0|            switch event {
   92|      0|            case .success(let element):
   93|      0|                onSuccess?(element)
   94|      0|            case .error(let error):
   95|      0|                if let onError = onError {
   96|      0|                    onError(error)
   97|      0|                } else {
   98|      0|                    Hooks.defaultErrorHandler(callStack, error)
   99|      0|                }
  100|      0|            }
  101|      0|        }
  102|      0|    }
  103|       |}
  104|       |
  105|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  106|       |    /**
  107|       |     Returns an observable sequence that contains a single element.
  108|       |     
  109|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  110|       |     
  111|       |     - parameter element: Single element in the resulting observable sequence.
  112|       |     - returns: An observable sequence containing the single specified element.
  113|       |     */
  114|      0|    public static func just(_ element: ElementType) -> Single<ElementType> {
  115|      0|        return Single(raw: Observable.just(element))
  116|      0|    }
  117|       |    
  118|       |    /**
  119|       |     Returns an observable sequence that contains a single element.
  120|       |     
  121|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  122|       |     
  123|       |     - parameter element: Single element in the resulting observable sequence.
  124|       |     - parameter scheduler: Scheduler to send the single element on.
  125|       |     - returns: An observable sequence containing the single specified element.
  126|       |     */
  127|      0|    public static func just(_ element: ElementType, scheduler: ImmediateSchedulerType) -> Single<ElementType> {
  128|      0|        return Single(raw: Observable.just(element, scheduler: scheduler))
  129|      0|    }
  130|       |
  131|       |    /**
  132|       |     Returns an observable sequence that terminates with an `error`.
  133|       |
  134|       |     - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  135|       |
  136|       |     - returns: The observable sequence that terminates with specified error.
  137|       |     */
  138|      0|    public static func error(_ error: Swift.Error) -> Single<ElementType> {
  139|      0|        return PrimitiveSequence(raw: Observable.error(error))
  140|      0|    }
  141|       |
  142|       |    /**
  143|       |     Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  144|       |
  145|       |     - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  146|       |
  147|       |     - returns: An observable sequence whose observers will never get called.
  148|       |     */
  149|      0|    public static func never() -> Single<ElementType> {
  150|      0|        return PrimitiveSequence(raw: Observable.never())
  151|      0|    }
  152|       |}
  153|       |
  154|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
  155|       |
  156|       |    /**
  157|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  158|       |
  159|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  160|       |
  161|       |     - parameter onSuccess: Action to invoke for each element in the observable sequence.
  162|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  163|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  164|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  165|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  166|       |     - returns: The source sequence with the side-effecting behavior applied.
  167|       |     */
  168|       |    public func `do`(onSuccess: ((ElementType) throws -> Void)? = nil,
  169|       |                     onError: ((Swift.Error) throws -> Void)? = nil,
  170|       |                     onSubscribe: (() -> Void)? = nil,
  171|       |                     onSubscribed: (() -> Void)? = nil,
  172|       |                     onDispose: (() -> Void)? = nil)
  173|      0|        -> Single<ElementType> {
  174|      0|            return Single(raw: self.primitiveSequence.source.do(
  175|      0|                onNext: onSuccess,
  176|      0|                onError: onError,
  177|      0|                onSubscribe: onSubscribe,
  178|      0|                onSubscribed: onSubscribed,
  179|      0|                onDispose: onDispose)
  180|      0|            )
  181|      0|    }
  182|       |
  183|       |    /**
  184|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  185|       |     
  186|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  187|       |     
  188|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  189|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  190|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  191|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  192|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  193|       |     - returns: The source sequence with the side-effecting behavior applied.
  194|       |     */
  195|       |    @available(*, deprecated, renamed: "do(onSuccess:onError:onSubscribe:onSubscribed:onDispose:)")
  196|       |    public func `do`(onNext: ((ElementType) throws -> Void)?,
  197|       |                     onError: ((Swift.Error) throws -> Void)? = nil,
  198|       |                     onSubscribe: (() -> Void)? = nil,
  199|       |                     onSubscribed: (() -> Void)? = nil,
  200|       |                     onDispose: (() -> Void)? = nil)
  201|      0|        -> Single<ElementType> {
  202|      0|            return self.`do`(
  203|      0|                onSuccess: onNext,
  204|      0|                onError: onError,
  205|      0|                onSubscribe: onSubscribe,
  206|      0|                onSubscribed: onSubscribed,
  207|      0|                onDispose: onDispose
  208|      0|            )
  209|      0|    }
  210|       |    
  211|       |    /**
  212|       |     Filters the elements of an observable sequence based on a predicate.
  213|       |     
  214|       |     - seealso: [filter operator on reactivex.io](http://reactivex.io/documentation/operators/filter.html)
  215|       |     
  216|       |     - parameter predicate: A function to test each source element for a condition.
  217|       |     - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
  218|       |     */
  219|       |    public func filter(_ predicate: @escaping (ElementType) throws -> Bool)
  220|      0|        -> Maybe<ElementType> {
  221|      0|            return Maybe(raw: self.primitiveSequence.source.filter(predicate))
  222|      0|    }
  223|       |    
  224|       |    
  225|       |    /**
  226|       |     Projects each element of an observable sequence into a new form.
  227|       |     
  228|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
  229|       |     
  230|       |     - parameter transform: A transform function to apply to each source element.
  231|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
  232|       |     
  233|       |     */
  234|       |    public func map<R>(_ transform: @escaping (ElementType) throws -> R)
  235|      0|        -> Single<R> {
  236|      0|            return Single(raw: self.primitiveSequence.source.map(transform))
  237|      0|    }
  238|       |    
  239|       |    /**
  240|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  241|       |     
  242|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  243|       |     
  244|       |     - parameter selector: A transform function to apply to each element.
  245|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  246|       |     */
  247|       |    public func flatMap<R>(_ selector: @escaping (ElementType) throws -> Single<R>)
  248|      0|        -> Single<R> {
  249|      0|            return Single<R>(raw: self.primitiveSequence.source.flatMap(selector))
  250|      0|    }
  251|       |
  252|       |    /**
  253|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  254|       |
  255|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  256|       |
  257|       |     - parameter selector: A transform function to apply to each element.
  258|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  259|       |     */
  260|       |    public func flatMapMaybe<R>(_ selector: @escaping (ElementType) throws -> Maybe<R>)
  261|      0|        -> Maybe<R> {
  262|      0|            return Maybe<R>(raw: self.primitiveSequence.source.flatMap(selector))
  263|      0|    }
  264|       |
  265|       |    /**
  266|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  267|       |
  268|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  269|       |
  270|       |     - parameter selector: A transform function to apply to each element.
  271|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  272|       |     */
  273|       |    public func flatMapCompletable(_ selector: @escaping (ElementType) throws -> Completable)
  274|      0|        -> Completable {
  275|      0|            return Completable(raw: self.primitiveSequence.source.flatMap(selector))
  276|      0|    }
  277|       |
  278|       |    /**
  279|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  280|       |     
  281|       |     - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  282|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  283|       |     */
  284|      0|    public static func zip<C: Collection, R>(_ collection: C, _ resultSelector: @escaping ([ElementType]) throws -> R) -> PrimitiveSequence<TraitType, R> where C.Iterator.Element == PrimitiveSequence<TraitType, ElementType> {
  285|      0|        
  286|      0|        if collection.isEmpty {
  287|      0|            return PrimitiveSequence<TraitType, R>.deferred {
  288|      0|                return PrimitiveSequence<TraitType, R>(raw: .just(try resultSelector([])))
  289|      0|            }
  290|      0|        }
  291|      0|        
  292|      0|        let raw = Observable.zip(collection.map { $0.asObservable() }, resultSelector)
  293|      0|        return PrimitiveSequence<TraitType, R>(raw: raw)
  294|      0|    }
  295|       |    
  296|       |    /**
  297|       |     Merges the specified observable sequences into one observable sequence all of the observable sequences have produced an element at a corresponding index.
  298|       |     
  299|       |     - returns: An observable sequence containing the result of combining elements of the sources.
  300|       |     */
  301|      0|    public static func zip<C: Collection>(_ collection: C) -> PrimitiveSequence<TraitType, [ElementType]> where C.Iterator.Element == PrimitiveSequence<TraitType, ElementType> {
  302|      0|        
  303|      0|        if collection.isEmpty {
  304|      0|            return PrimitiveSequence<TraitType, [ElementType]>(raw: .just([]))
  305|      0|        }
  306|      0|        
  307|      0|        let raw = Observable.zip(collection.map { $0.asObservable() })
  308|      0|        return PrimitiveSequence(raw: raw)
  309|      0|    }
  310|       |
  311|       |    /**
  312|       |     Continues an observable sequence that is terminated by an error with a single element.
  313|       |
  314|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  315|       |
  316|       |     - parameter element: Last element in an observable sequence in case error occurs.
  317|       |     - returns: An observable sequence containing the source sequence's elements, followed by the `element` in case an error occurred.
  318|       |     */
  319|       |    public func catchErrorJustReturn(_ element: ElementType)
  320|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  321|      0|        return PrimitiveSequence(raw: self.primitiveSequence.source.catchErrorJustReturn(element))
  322|      0|    }
  323|       |
  324|       |    /// Converts `self` to `Maybe` trait.
  325|       |    ///
  326|       |    /// - returns: Maybe trait that represents `self`.
  327|      0|    public func asMaybe() -> Maybe<ElementType> {
  328|      0|        return Maybe(raw: self.primitiveSequence.source)
  329|      0|    }
  330|       |
  331|       |    /// Converts `self` to `Completable` trait.
  332|       |    ///
  333|       |    /// - returns: Completable trait that represents `self`.
  334|      0|    public func asCompletable() -> Completable {
  335|      0|        return self.primitiveSequence.source.ignoreElements()
  336|      0|    }
  337|       |}

