/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion and deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey?
   44|       |    var _value0: T?
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey: T]?
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|      0|    init() {
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|      0|    mutating func insert(_ element: T) -> BagKey {
   65|      0|        let key = _nextKey
   66|      0|
   67|      0|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|      0|
   69|      0|        if _key0 == nil {
   70|      0|            _key0 = key
   71|      0|            _value0 = element
   72|      0|            return key
   73|      0|        }
   74|      0|
   75|      0|        _onlyFastPath = false
   76|      0|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|      0|        }
   81|      0|
   82|      0|        if _pairs.count < arrayDictionaryMaxSize {
   83|      0|            _pairs.append((key: key, value: element))
   84|      0|            return key
   85|      0|        }
   86|      0|        
   87|      0|        _dictionary = [key: element]
   88|      0|        
   89|      0|        return key
   90|      0|    }
   91|       |    
   92|       |    /// - returns: Number of elements in bag.
   93|      0|    var count: Int {
   94|      0|        let dictionaryCount: Int = _dictionary?.count ?? 0
   95|      0|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
   96|      0|    }
   97|       |    
   98|       |    /// Removes all elements from bag and clears capacity.
   99|      0|    mutating func removeAll() {
  100|      0|        _key0 = nil
  101|      0|        _value0 = nil
  102|      0|
  103|      0|        _pairs.removeAll(keepingCapacity: false)
  104|      0|        _dictionary?.removeAll(keepingCapacity: false)
  105|      0|    }
  106|       |    
  107|       |    /**
  108|       |    Removes element with a specific `key` from bag.
  109|       |    
  110|       |    - parameter key: Key that identifies element to remove from bag.
  111|       |    - returns: Element that bag contained, or nil in case element was already removed.
  112|       |    */
  113|      0|    mutating func removeKey(_ key: BagKey) -> T? {
  114|      0|        if _key0 == key {
  115|      0|            _key0 = nil
  116|      0|            let value = _value0!
  117|      0|            _value0 = nil
  118|      0|            return value
  119|      0|        }
  120|      0|
  121|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  122|      0|            return existingObject
  123|      0|        }
  124|      0|
  125|      0|        for i in 0 ..< _pairs.count where _pairs[i].key == key {
  126|      0|            let value = _pairs[i].value
  127|      0|            _pairs.remove(at: i)
  128|      0|            return value
  129|      0|        }
  130|      0|
  131|      0|        return nil
  132|      0|    }
  133|       |}
  134|       |
  135|       |extension Bag {
  136|       |    /// A textual representation of `self`, suitable for debugging.
  137|       |    var debugDescription : String {
  138|       |        return "\(self.count) elements in Bag"
  139|       |    }
  140|       |}
  141|       |
  142|       |extension Bag {
  143|       |    /// Enumerates elements inside the bag.
  144|       |    ///
  145|       |    /// - parameter action: Enumeration closure.
  146|      0|    func forEach(_ action: (T) -> Void) {
  147|      0|        if _onlyFastPath {
  148|      0|            if let value0 = _value0 {
  149|      0|                action(value0)
  150|      0|            }
  151|      0|            return
  152|      0|        }
  153|      0|
  154|      0|        let value0 = _value0
  155|      0|        let dictionary = _dictionary
  156|      0|
  157|      0|        if let value0 = value0 {
  158|      0|            action(value0)
  159|      0|        }
  160|      0|
  161|      0|        for i in 0 ..< _pairs.count {
  162|      0|            action(_pairs[i].value)
  163|      0|        }
  164|      0|
  165|      0|        if dictionary?.count ?? 0 > 0 {
  166|      0|            for element in dictionary!.values {
  167|      0|                action(element)
  168|      0|            }
  169|      0|        }
  170|      0|    }
  171|       |}
  172|       |
  173|       |extension BagKey: Hashable {
  174|       |    #if swift(>=4.2)
  175|      0|    func hash(into hasher: inout Hasher) {
  176|      0|        hasher.combine(rawValue)
  177|      0|    }
  178|       |    #else
  179|       |    var hashValue: Int {
  180|       |        return rawValue.hashValue
  181|       |    }
  182|       |    #endif
  183|       |}
  184|       |
  185|       |func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|       |    return lhs.rawValue == rhs.rawValue
  187|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      0|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      0|        _hasHigherPriority = hasHigherPriority
   17|      0|        _isEqual = isEqual
   18|      0|    }
   19|       |
   20|      0|    mutating func enqueue(_ element: Element) {
   21|      0|        _elements.append(element)
   22|      0|        bubbleToHigherPriority(_elements.count - 1)
   23|      0|    }
   24|       |
   25|      0|    func peek() -> Element? {
   26|      0|        return _elements.first
   27|      0|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      0|    mutating func remove(_ element: Element) {
   44|      0|        for i in 0 ..< _elements.count {
   45|      0|            if _isEqual(_elements[i], element) {
   46|      0|                removeAt(i)
   47|      0|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|       |    private mutating func removeAt(_ index: Int) {
   53|       |        let removingLast = index == _elements.count - 1
   54|       |        if !removingLast {
   55|       |            _elements.swapAt(index, _elements.count - 1)
   56|       |        }
   57|       |
   58|       |        _ = _elements.popLast()
   59|       |
   60|       |        if !removingLast {
   61|       |            bubbleToHigherPriority(index)
   62|       |            bubbleToLowerPriority(index)
   63|       |        }
   64|       |    }
   65|       |
   66|       |    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|       |        precondition(initialUnbalancedIndex >= 0)
   68|       |        precondition(initialUnbalancedIndex < _elements.count)
   69|       |
   70|       |        var unbalancedIndex = initialUnbalancedIndex
   71|       |
   72|       |        while unbalancedIndex > 0 {
   73|       |            let parentIndex = (unbalancedIndex - 1) / 2
   74|       |            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|       |            _elements.swapAt(unbalancedIndex, parentIndex)
   76|       |            unbalancedIndex = parentIndex
   77|       |        }
   78|       |    }
   79|       |
   80|       |    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   81|       |        precondition(initialUnbalancedIndex >= 0)
   82|       |        precondition(initialUnbalancedIndex < _elements.count)
   83|       |
   84|       |        var unbalancedIndex = initialUnbalancedIndex
   85|       |        while true {
   86|       |            let leftChildIndex = unbalancedIndex * 2 + 1
   87|       |            let rightChildIndex = unbalancedIndex * 2 + 2
   88|       |
   89|       |            var highestPriorityIndex = unbalancedIndex
   90|       |
   91|       |            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   92|       |                highestPriorityIndex = leftChildIndex
   93|       |            }
   94|       |
   95|       |            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   96|       |                highestPriorityIndex = rightChildIndex
   97|       |            }
   98|       |
   99|       |            guard highestPriorityIndex != unbalancedIndex else { break }
  100|       |            _elements.swapAt(highestPriorityIndex, unbalancedIndex)
  101|       |
  102|       |            unbalancedIndex = highestPriorityIndex
  103|       |        }
  104|       |    }
  105|       |}
  106|       |
  107|       |extension PriorityQueue : CustomDebugStringConvertible {
  108|      0|    var debugDescription: String {
  109|      0|        return _elements.debugDescription
  110|      0|    }
  111|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      0|    init(capacity: Int) {
   34|      0|        _initialCapacity = capacity
   35|      0|
   36|      0|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      0|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|       |    var count: Int {
   51|       |        return _count
   52|       |    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DeprecationWarner.swift:
    1|       |//
    2|       |//  DeprecationWarner.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Shai Mishali on 1/9/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |#if DEBUG
   12|       |    class DeprecationWarner {
   13|       |        private static var warned = Set<Kind>()
   14|       |        private static var _lock = NSRecursiveLock()
   15|       |        
   16|      0|        static func warnIfNeeded(_ kind: Kind) {
   17|      0|            _lock.lock(); defer { _lock.unlock() }
   18|      0|            guard !warned.contains(kind) else { return }
   19|      0|            
   20|      0|            warned.insert(kind)
   21|      0|            print("ℹ️ [DEPRECATED] \(kind.message)")
   22|      0|        }
   23|       |    }
   24|       |    
   25|       |    extension DeprecationWarner {
   26|       |        enum Kind {
   27|       |            case variable
   28|       |            case globalTestFunctionNext
   29|       |            case globalTestFunctionError
   30|       |            case globalTestFunctionCompleted
   31|       |            
   32|       |            var message: String {
   33|       |                switch self {
   34|       |                case .variable: return "`Variable` is planned for future deprecation. Please consider `BehaviorRelay` as a replacement. Read more at: https://git.io/vNqvx"
   35|       |                case .globalTestFunctionNext: return "The `next()` global function is planned for future deprecation. Please use `Recorded.next()` instead."
   36|       |                case .globalTestFunctionError: return "The `error()` global function is planned for future deprecation. Please use `Recorded.error()` instead."
   37|       |                case .globalTestFunctionCompleted: return "The `completed()` global function is planned for future deprecation. Please use `Recorded.completed()` instead."
   38|       |                }
   39|       |            }
   40|       |        }
   41|       |    }
   42|       |#endif
   43|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|      0|    private static var token: DispatchSpecificKey<()> = {
   13|      0|        let key = DispatchSpecificKey<()>()
   14|      0|        DispatchQueue.main.setSpecific(key: key, value: ())
   15|      0|        return key
   16|      0|    }()
   17|       |
   18|      0|    static var isMain: Bool {
   19|      0|        return DispatchQueue.getSpecific(key: token) != nil
   20|      0|    }
   21|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import protocol Foundation.NSCopying
   14|       |
   15|       |    extension Thread {
   16|      0|        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying) {
   17|      0|            let currentThread = Thread.current
   18|      0|            let threadDictionary = currentThread.threadDictionary
   19|      0|
   20|      0|            if let newValue = value {
   21|      0|                threadDictionary[key] = newValue
   22|      0|            }
   23|      0|            else {
   24|      0|                threadDictionary[key] = nil
   25|      0|            }
   26|      0|        }
   27|       |
   28|      0|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   29|      0|            let currentThread = Thread.current
   30|      0|            let threadDictionary = currentThread.threadDictionary
   31|      0|            
   32|      0|            return threadDictionary[key] as? T
   33|      0|        }
   34|       |    }
   35|       |
   36|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/Binder.swift:
    1|       |//
    2|       |//  Binder.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/17/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/**
   12|       | Observer that enforces interface binding rules:
   13|       | * can't bind errors (in debug builds binding of errors causes `fatalError` in release builds errors are being logged)
   14|       | * ensures binding is performed on a specific scheduler
   15|       |
   16|       | `Binder` doesn't retain target and in case target is released, element isn't bound.
   17|       | 
   18|       | By default it binds elements on main scheduler.
   19|       | */
   20|       |public struct Binder<Value>: ObserverType {
   21|       |    public typealias E = Value
   22|       |    
   23|       |    private let _binding: (Event<Value>) -> Void
   24|       |
   25|       |    /// Initializes `Binder`
   26|       |    ///
   27|       |    /// - parameter target: Target object.
   28|       |    /// - parameter scheduler: Scheduler used to bind the events.
   29|       |    /// - parameter binding: Binding logic.
   30|      0|    public init<Target: AnyObject>(_ target: Target, scheduler: ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Void) {
   31|      0|        weak var weakTarget = target
   32|      0|
   33|      0|        self._binding = { event in
   34|      0|            switch event {
   35|      0|            case .next(let element):
   36|      0|                _ = scheduler.schedule(element) { element in
   37|      0|                    if let target = weakTarget {
   38|      0|                        binding(target, element)
   39|      0|                    }
   40|      0|                    return Disposables.create()
   41|      0|                }
   42|      0|            case .error(let error):
   43|      0|                bindingError(error)
   44|      0|            case .completed:
   45|      0|                break
   46|      0|            }
   47|      0|        }
   48|      0|    }
   49|       |
   50|       |    /// Binds next element to owner view as described in `binding`.
   51|      0|    public func on(_ event: Event<Value>) {
   52|      0|        self._binding(event)
   53|      0|    }
   54|       |
   55|       |    /// Erases type of observer.
   56|       |    ///
   57|       |    /// - returns: type erased observer.
   58|      0|    public func asObserver() -> AnyObserver<Value> {
   59|      0|        return AnyObserver(eventHandler: self.on)
   60|      0|    }
   61|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/ControlTarget.swift:
    1|       |//
    2|       |//  ControlTarget.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS) || os(macOS)
   10|       |
   11|       |import RxSwift
   12|       |
   13|       |#if os(iOS) || os(tvOS)
   14|       |    import UIKit
   15|       |
   16|       |    typealias Control = UIKit.UIControl
   17|       |
   18|       |    #if swift(>=4.2)
   19|       |        public typealias ControlEvents = UIKit.UIControl.Event
   20|       |    #else
   21|       |        public typealias ControlEvents = UIKit.UIControlEvents
   22|       |    #endif
   23|       |#elseif os(macOS)
   24|       |    import Cocoa
   25|       |
   26|       |    typealias Control = Cocoa.NSControl
   27|       |#endif
   28|       |
   29|       |// This should be only used from `MainScheduler`
   30|       |final class ControlTarget: RxTarget {
   31|       |    typealias Callback = (Control) -> Void
   32|       |
   33|       |    let selector: Selector = #selector(ControlTarget.eventHandler(_:))
   34|       |
   35|       |    weak var control: Control?
   36|       |#if os(iOS) || os(tvOS)
   37|       |    let controlEvents: UIControlEvents
   38|       |#endif
   39|       |    var callback: Callback?
   40|       |    #if os(iOS) || os(tvOS)
   41|      0|    init(control: Control, controlEvents: UIControlEvents, callback: @escaping Callback) {
   42|      0|        MainScheduler.ensureRunningOnMainThread()
   43|      0|
   44|      0|        self.control = control
   45|      0|        self.controlEvents = controlEvents
   46|      0|        self.callback = callback
   47|      0|
   48|      0|        super.init()
   49|      0|
   50|      0|        control.addTarget(self, action: selector, for: controlEvents)
   51|      0|
   52|      0|        let method = self.method(for: selector)
   53|      0|        if method == nil {
   54|      0|            rxFatalError("Can't find method")
   55|      0|        }
   56|      0|    }
   57|       |#elseif os(macOS)
   58|       |    init(control: Control, callback: @escaping Callback) {
   59|       |        MainScheduler.ensureRunningOnMainThread()
   60|       |
   61|       |        self.control = control
   62|       |        self.callback = callback
   63|       |
   64|       |        super.init()
   65|       |
   66|       |        control.target = self
   67|       |        control.action = self.selector
   68|       |
   69|       |        let method = self.method(for: self.selector)
   70|       |        if method == nil {
   71|       |            rxFatalError("Can't find method")
   72|       |        }
   73|       |    }
   74|       |#endif
   75|       |
   76|      0|    @objc func eventHandler(_ sender: Control!) {
   77|      0|        if let callback = self.callback, let control = self.control {
   78|      0|            callback(control)
   79|      0|        }
   80|      0|    }
   81|       |
   82|      0|    override func dispose() {
   83|      0|        super.dispose()
   84|      0|#if os(iOS) || os(tvOS)
   85|      0|        self.control?.removeTarget(self, action: self.selector, for: self.controlEvents)
   86|      0|#elseif os(macOS)
   87|      0|        self.control?.target = nil
   88|      0|        self.control?.action = nil
   89|      0|#endif
   90|      0|        self.callback = nil
   91|      0|    }
   92|       |}
   93|       |
   94|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/DelegateProxy.swift:
    1|       |//
    2|       |//  DelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |    import RxSwift
   12|       |    #if SWIFT_PACKAGE && !os(Linux)
   13|       |        import RxCocoaRuntime
   14|       |    #endif
   15|       |
   16|       |    /// Base class for `DelegateProxyType` protocol.
   17|       |    ///
   18|       |    /// This implementation is not thread safe and can be used only from one thread (Main thread).
   19|       |    open class DelegateProxy<P: AnyObject, D>: _RXDelegateProxy {
   20|       |        public typealias ParentObject = P
   21|       |        public typealias Delegate = D
   22|       |
   23|       |        private var _sentMessageForSelector = [Selector: MessageDispatcher]()
   24|       |        private var _methodInvokedForSelector = [Selector: MessageDispatcher]()
   25|       |
   26|       |        /// Parent object associated with delegate proxy.
   27|       |        private weak var _parentObject: ParentObject?
   28|       |
   29|       |        fileprivate let _currentDelegateFor: (ParentObject) -> AnyObject?
   30|       |        fileprivate let _setCurrentDelegateTo: (AnyObject?, ParentObject) -> Void
   31|       |
   32|       |        /// Initializes new instance.
   33|       |        ///
   34|       |        /// - parameter parentObject: Optional parent object that owns `DelegateProxy` as associated object.
   35|       |        public init<Proxy: DelegateProxyType>(parentObject: ParentObject, delegateProxy: Proxy.Type)
   36|      0|            where Proxy: DelegateProxy<ParentObject, Delegate>, Proxy.ParentObject == ParentObject, Proxy.Delegate == Delegate {
   37|      0|            self._parentObject = parentObject
   38|      0|            self._currentDelegateFor = delegateProxy._currentDelegate
   39|      0|            self._setCurrentDelegateTo = delegateProxy._setCurrentDelegate
   40|      0|
   41|      0|            MainScheduler.ensureRunningOnMainThread()
   42|      0|            #if TRACE_RESOURCES
   43|      0|                _ = Resources.incrementTotal()
   44|      0|            #endif
   45|      0|            super.init()
   46|      0|        }
   47|       |
   48|       |        /**
   49|       |         Returns observable sequence of invocations of delegate methods. Elements are sent *before method is invoked*.
   50|       |
   51|       |         Only methods that have `void` return value can be observed using this method because
   52|       |         those methods are used as a notification mechanism. It doesn't matter if they are optional
   53|       |         or not. Observing is performed by installing a hidden associated `PublishSubject` that is
   54|       |         used to dispatch messages to observers.
   55|       |
   56|       |         Delegate methods that have non `void` return value can't be observed directly using this method
   57|       |         because:
   58|       |         * those methods are not intended to be used as a notification mechanism, but as a behavior customization mechanism
   59|       |         * there is no sensible automatic way to determine a default return value
   60|       |
   61|       |         In case observing of delegate methods that have return type is required, it can be done by
   62|       |         manually installing a `PublishSubject` or `BehaviorSubject` and implementing delegate method.
   63|       |
   64|       |         e.g.
   65|       |
   66|       |             // delegate proxy part (RxScrollViewDelegateProxy)
   67|       |
   68|       |             let internalSubject = PublishSubject<CGPoint>
   69|       |
   70|       |             public func requiredDelegateMethod(scrollView: UIScrollView, arg1: CGPoint) -> Bool {
   71|       |                 internalSubject.on(.next(arg1))
   72|       |                 return self._forwardToDelegate?.requiredDelegateMethod?(scrollView, arg1: arg1) ?? defaultReturnValue
   73|       |             }
   74|       |
   75|       |         ....
   76|       |
   77|       |             // reactive property implementation in a real class (`UIScrollView`)
   78|       |             public var property: Observable<CGPoint> {
   79|       |                 let proxy = RxScrollViewDelegateProxy.proxy(for: base)
   80|       |                 return proxy.internalSubject.asObservable()
   81|       |             }
   82|       |
   83|       |         **In case calling this method prints "Delegate proxy is already implementing `\(selector)`,
   84|       |         a more performant way of registering might exist.", that means that manual observing method
   85|       |         is required analog to the example above because delegate method has already been implemented.**
   86|       |
   87|       |         - parameter selector: Selector used to filter observed invocations of delegate methods.
   88|       |         - returns: Observable sequence of arguments passed to `selector` method.
   89|       |         */
   90|      0|        open func sentMessage(_ selector: Selector) -> Observable<[Any]> {
   91|      0|            MainScheduler.ensureRunningOnMainThread()
   92|      0|
   93|      0|            let subject = self._sentMessageForSelector[selector]
   94|      0|
   95|      0|            if let subject = subject {
   96|      0|                return subject.asObservable()
   97|      0|            }
   98|      0|            else {
   99|      0|                let subject = MessageDispatcher(selector: selector, delegateProxy: self)
  100|      0|                self._sentMessageForSelector[selector] = subject
  101|      0|                return subject.asObservable()
  102|      0|            }
  103|      0|        }
  104|       |
  105|       |        /**
  106|       |         Returns observable sequence of invoked delegate methods. Elements are sent *after method is invoked*.
  107|       |
  108|       |         Only methods that have `void` return value can be observed using this method because
  109|       |         those methods are used as a notification mechanism. It doesn't matter if they are optional
  110|       |         or not. Observing is performed by installing a hidden associated `PublishSubject` that is
  111|       |         used to dispatch messages to observers.
  112|       |
  113|       |         Delegate methods that have non `void` return value can't be observed directly using this method
  114|       |         because:
  115|       |         * those methods are not intended to be used as a notification mechanism, but as a behavior customization mechanism
  116|       |         * there is no sensible automatic way to determine a default return value
  117|       |
  118|       |         In case observing of delegate methods that have return type is required, it can be done by
  119|       |         manually installing a `PublishSubject` or `BehaviorSubject` and implementing delegate method.
  120|       |
  121|       |         e.g.
  122|       |
  123|       |             // delegate proxy part (RxScrollViewDelegateProxy)
  124|       |
  125|       |             let internalSubject = PublishSubject<CGPoint>
  126|       |
  127|       |             public func requiredDelegateMethod(scrollView: UIScrollView, arg1: CGPoint) -> Bool {
  128|       |                 internalSubject.on(.next(arg1))
  129|       |                 return self._forwardToDelegate?.requiredDelegateMethod?(scrollView, arg1: arg1) ?? defaultReturnValue
  130|       |             }
  131|       |
  132|       |         ....
  133|       |
  134|       |             // reactive property implementation in a real class (`UIScrollView`)
  135|       |             public var property: Observable<CGPoint> {
  136|       |                 let proxy = RxScrollViewDelegateProxy.proxy(for: base)
  137|       |                 return proxy.internalSubject.asObservable()
  138|       |             }
  139|       |
  140|       |         **In case calling this method prints "Delegate proxy is already implementing `\(selector)`,
  141|       |         a more performant way of registering might exist.", that means that manual observing method
  142|       |         is required analog to the example above because delegate method has already been implemented.**
  143|       |
  144|       |         - parameter selector: Selector used to filter observed invocations of delegate methods.
  145|       |         - returns: Observable sequence of arguments passed to `selector` method.
  146|       |         */
  147|      0|        open func methodInvoked(_ selector: Selector) -> Observable<[Any]> {
  148|      0|            MainScheduler.ensureRunningOnMainThread()
  149|      0|
  150|      0|            let subject = self._methodInvokedForSelector[selector]
  151|      0|
  152|      0|            if let subject = subject {
  153|      0|                return subject.asObservable()
  154|      0|            }
  155|      0|            else {
  156|      0|                let subject = MessageDispatcher(selector: selector, delegateProxy: self)
  157|      0|                self._methodInvokedForSelector[selector] = subject
  158|      0|                return subject.asObservable()
  159|      0|            }
  160|      0|        }
  161|       |
  162|      0|        fileprivate func checkSelectorIsObservable(_ selector: Selector) {
  163|      0|            MainScheduler.ensureRunningOnMainThread()
  164|      0|
  165|      0|            if self.hasWiredImplementation(for: selector) {
  166|      0|                print("⚠️ Delegate proxy is already implementing `\(selector)`, a more performant way of registering might exist.")
  167|      0|                return
  168|      0|            }
  169|      0|
  170|      0|            if self.voidDelegateMethodsContain(selector) {
  171|      0|                return
  172|      0|            }
  173|      0|
  174|      0|            // In case `_forwardToDelegate` is `nil`, it is assumed the check is being done prematurely.
  175|      0|            if !(self._forwardToDelegate?.responds(to: selector) ?? true) {
  176|      0|                print("⚠️ Using delegate proxy dynamic interception method but the target delegate object doesn't respond to the requested selector. " +
  177|      0|                    "In case pure Swift delegate proxy is being used please use manual observing method by using`PublishSubject`s. " +
  178|      0|                    " (selector: `\(selector)`, forwardToDelegate: `\(self._forwardToDelegate ?? self)`)")
  179|      0|            }
  180|      0|        }
  181|       |
  182|       |        // proxy
  183|       |
  184|      0|        open override func _sentMessage(_ selector: Selector, withArguments arguments: [Any]) {
  185|      0|            self._sentMessageForSelector[selector]?.on(.next(arguments))
  186|      0|        }
  187|       |
  188|      0|        open override func _methodInvoked(_ selector: Selector, withArguments arguments: [Any]) {
  189|      0|            self._methodInvokedForSelector[selector]?.on(.next(arguments))
  190|      0|        }
  191|       |
  192|       |        /// Returns reference of normal delegate that receives all forwarded messages
  193|       |        /// through `self`.
  194|       |        ///
  195|       |        /// - returns: Value of reference if set or nil.
  196|      0|        open func forwardToDelegate() -> Delegate? {
  197|      0|            return castOptionalOrFatalError(self._forwardToDelegate)
  198|      0|        }
  199|       |
  200|       |        /// Sets reference of normal delegate that receives all forwarded messages
  201|       |        /// through `self`.
  202|       |        ///
  203|       |        /// - parameter forwardToDelegate: Reference of delegate that receives all messages through `self`.
  204|       |        /// - parameter retainDelegate: Should `self` retain `forwardToDelegate`.
  205|      0|        open func setForwardToDelegate(_ delegate: Delegate?, retainDelegate: Bool) {
  206|      0|            #if DEBUG // 4.0 all configurations
  207|      0|                MainScheduler.ensureRunningOnMainThread()
  208|      0|            #endif
  209|      0|            self._setForwardToDelegate(delegate, retainDelegate: retainDelegate)
  210|      0|
  211|      0|            let sentSelectors: [Selector] = self._sentMessageForSelector.values.filter { $0.hasObservers }.map { $0.selector }
  212|      0|            let invokedSelectors: [Selector] = self._methodInvokedForSelector.values.filter { $0.hasObservers }.map { $0.selector }
  213|      0|            let allUsedSelectors = sentSelectors + invokedSelectors
  214|      0|
  215|      0|            for selector in Set(allUsedSelectors) {
  216|      0|                self.checkSelectorIsObservable(selector)
  217|      0|            }
  218|      0|
  219|      0|            self.reset()
  220|      0|        }
  221|       |
  222|      0|        private func hasObservers(selector: Selector) -> Bool {
  223|      0|            return (self._sentMessageForSelector[selector]?.hasObservers ?? false)
  224|      0|                || (self._methodInvokedForSelector[selector]?.hasObservers ?? false)
  225|      0|        }
  226|       |
  227|      0|        override open func responds(to aSelector: Selector!) -> Bool {
  228|      0|            return super.responds(to: aSelector)
  229|      0|                || (self._forwardToDelegate?.responds(to: aSelector) ?? false)
  230|      0|                || (self.voidDelegateMethodsContain(aSelector) && self.hasObservers(selector: aSelector))
  231|      0|        }
  232|       |
  233|      0|        fileprivate func reset() {
  234|      0|            guard let parentObject = self._parentObject else { return }
  235|      0|
  236|      0|            let maybeCurrentDelegate = self._currentDelegateFor(parentObject)
  237|      0|
  238|      0|            if maybeCurrentDelegate === self {
  239|      0|                self._setCurrentDelegateTo(nil, parentObject)
  240|      0|                self._setCurrentDelegateTo(castOrFatalError(self), parentObject)
  241|      0|            }
  242|      0|        }
  243|       |
  244|      0|        deinit {
  245|      0|            for v in self._sentMessageForSelector.values {
  246|      0|                v.on(.completed)
  247|      0|            }
  248|      0|            for v in self._methodInvokedForSelector.values {
  249|      0|                v.on(.completed)
  250|      0|            }
  251|      0|            #if TRACE_RESOURCES
  252|      0|                _ = Resources.decrementTotal()
  253|      0|            #endif
  254|      0|        }
  255|       |    
  256|       |
  257|       |    }
  258|       |
  259|       |    private let mainScheduler = MainScheduler()
  260|       |
  261|       |    fileprivate final class MessageDispatcher {
  262|       |        private let dispatcher: PublishSubject<[Any]>
  263|       |        private let result: Observable<[Any]>
  264|       |
  265|       |        fileprivate let selector: Selector
  266|       |
  267|      0|        init<P, D>(selector: Selector, delegateProxy _delegateProxy: DelegateProxy<P, D>) {
  268|      0|            weak var weakDelegateProxy = _delegateProxy
  269|      0|
  270|      0|            let dispatcher = PublishSubject<[Any]>()
  271|      0|            self.dispatcher = dispatcher
  272|      0|            self.selector = selector
  273|      0|
  274|      0|            self.result = dispatcher
  275|      0|                .do(onSubscribed: { weakDelegateProxy?.checkSelectorIsObservable(selector); weakDelegateProxy?.reset() }, onDispose: { weakDelegateProxy?.reset() })
  276|      0|                .share()
  277|      0|                .subscribeOn(mainScheduler)
  278|      0|        }
  279|       |
  280|       |        var on: (Event<[Any]>) -> Void {
  281|       |            return self.dispatcher.on
  282|       |        }
  283|       |
  284|       |        var hasObservers: Bool {
  285|       |            return self.dispatcher.hasObservers
  286|       |        }
  287|       |
  288|       |        func asObservable() -> Observable<[Any]> {
  289|       |            return self.result
  290|       |        }
  291|       |    }
  292|       |    
  293|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/DelegateProxyType.swift:
    1|       |//
    2|       |//  DelegateProxyType.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |    import func Foundation.objc_getAssociatedObject
   12|       |    import func Foundation.objc_setAssociatedObject
   13|       |
   14|       |    import RxSwift
   15|       |
   16|       |/**
   17|       |`DelegateProxyType` protocol enables using both normal delegates and Rx observable sequences with
   18|       |views that can have only one delegate/datasource registered.
   19|       |
   20|       |`Proxies` store information about observers, subscriptions and delegates
   21|       |for specific views.
   22|       |
   23|       |Type implementing `DelegateProxyType` should never be initialized directly.
   24|       |
   25|       |To fetch initialized instance of type implementing `DelegateProxyType`, `proxy` method
   26|       |should be used.
   27|       |
   28|       |This is more or less how it works.
   29|       |
   30|       |
   31|       |
   32|       |      +-------------------------------------------+
   33|       |      |                                           |                           
   34|       |      | UIView subclass (UIScrollView)            |                           
   35|       |      |                                           |
   36|       |      +-----------+-------------------------------+                           
   37|       |                  |                                                           
   38|       |                  | Delegate                                                  
   39|       |                  |                                                           
   40|       |                  |                                                           
   41|       |      +-----------v-------------------------------+                           
   42|       |      |                                           |                           
   43|       |      | Delegate proxy : DelegateProxyType        +-----+---->  Observable<T1>
   44|       |      |                , UIScrollViewDelegate     |     |
   45|       |      +-----------+-------------------------------+     +---->  Observable<T2>
   46|       |                  |                                     |                     
   47|       |                  |                                     +---->  Observable<T3>
   48|       |                  |                                     |                     
   49|       |                  | forwards events                     |
   50|       |                  | to custom delegate                  |
   51|       |                  |                                     v                     
   52|       |      +-----------v-------------------------------+                           
   53|       |      |                                           |                           
   54|       |      | Custom delegate (UIScrollViewDelegate)    |                           
   55|       |      |                                           |
   56|       |      +-------------------------------------------+                           
   57|       |
   58|       |
   59|       |Since RxCocoa needs to automagically create those Proxys and because views that have delegates can be hierarchical
   60|       |
   61|       |     UITableView : UIScrollView : UIView
   62|       |
   63|       |.. and corresponding delegates are also hierarchical
   64|       |
   65|       |     UITableViewDelegate : UIScrollViewDelegate : NSObject
   66|       |
   67|       |... this mechanism can be extended by using the following snippet in `registerKnownImplementations` or in some other
   68|       |     part of your app that executes before using `rx.*` (e.g. appDidFinishLaunching).
   69|       |
   70|       |    RxScrollViewDelegateProxy.register { RxTableViewDelegateProxy(parentObject: $0) }
   71|       |
   72|       |*/
   73|       |public protocol DelegateProxyType: class {
   74|       |    associatedtype ParentObject: AnyObject
   75|       |    associatedtype Delegate
   76|       |    
   77|       |    /// It is require that enumerate call `register` of the extended DelegateProxy subclasses here.
   78|       |    static func registerKnownImplementations()
   79|       |
   80|       |    /// Unique identifier for delegate
   81|       |    static var identifier: UnsafeRawPointer { get }
   82|       |
   83|       |    /// Returns designated delegate property for object.
   84|       |    ///
   85|       |    /// Objects can have multiple delegate properties.
   86|       |    ///
   87|       |    /// Each delegate property needs to have it's own type implementing `DelegateProxyType`.
   88|       |    ///
   89|       |    /// It's abstract method.
   90|       |    ///
   91|       |    /// - parameter object: Object that has delegate property.
   92|       |    /// - returns: Value of delegate property.
   93|       |    static func currentDelegate(for object: ParentObject) -> Delegate?
   94|       |
   95|       |    /// Sets designated delegate property for object.
   96|       |    ///
   97|       |    /// Objects can have multiple delegate properties.
   98|       |    ///
   99|       |    /// Each delegate property needs to have it's own type implementing `DelegateProxyType`.
  100|       |    ///
  101|       |    /// It's abstract method.
  102|       |    ///
  103|       |    /// - parameter toObject: Object that has delegate property.
  104|       |    /// - parameter delegate: Delegate value.
  105|       |    static func setCurrentDelegate(_ delegate: Delegate?, to object: ParentObject)
  106|       |
  107|       |    /// Returns reference of normal delegate that receives all forwarded messages
  108|       |    /// through `self`.
  109|       |    ///
  110|       |    /// - returns: Value of reference if set or nil.
  111|       |    func forwardToDelegate() -> Delegate?
  112|       |
  113|       |    /// Sets reference of normal delegate that receives all forwarded messages
  114|       |    /// through `self`.
  115|       |    ///
  116|       |    /// - parameter forwardToDelegate: Reference of delegate that receives all messages through `self`.
  117|       |    /// - parameter retainDelegate: Should `self` retain `forwardToDelegate`.
  118|       |    func setForwardToDelegate(_ forwardToDelegate: Delegate?, retainDelegate: Bool)
  119|       |}
  120|       |
  121|       |// default implementations
  122|       |extension DelegateProxyType {
  123|       |    /// Unique identifier for delegate
  124|      0|    public static var identifier: UnsafeRawPointer {
  125|      0|        let delegateIdentifier = ObjectIdentifier(Delegate.self)
  126|      0|        let integerIdentifier = Int(bitPattern: delegateIdentifier)
  127|      0|        return UnsafeRawPointer(bitPattern: integerIdentifier)!
  128|      0|    }
  129|       |}
  130|       |
  131|       |// workaround of Delegate: class
  132|       |extension DelegateProxyType {
  133|      0|    static func _currentDelegate(for object: ParentObject) -> AnyObject? {
  134|      0|        return currentDelegate(for: object).map { $0 as AnyObject }
  135|      0|    }
  136|       |    
  137|      0|    static func _setCurrentDelegate(_ delegate: AnyObject?, to object: ParentObject) {
  138|      0|        return setCurrentDelegate(castOptionalOrFatalError(delegate), to: object)
  139|      0|    }
  140|       |    
  141|      0|    func _forwardToDelegate() -> AnyObject? {
  142|      0|        return self.forwardToDelegate().map { $0 as AnyObject }
  143|      0|    }
  144|       |    
  145|      0|    func _setForwardToDelegate(_ forwardToDelegate: AnyObject?, retainDelegate: Bool) {
  146|      0|        return self.setForwardToDelegate(castOptionalOrFatalError(forwardToDelegate), retainDelegate: retainDelegate)
  147|      0|    }
  148|       |}
  149|       |
  150|       |extension DelegateProxyType {
  151|       |
  152|       |    /// Store DelegateProxy subclass to factory.
  153|       |    /// When make 'Rx*DelegateProxy' subclass, call 'Rx*DelegateProxySubclass.register(for:_)' 1 time, or use it in DelegateProxyFactory
  154|       |    /// 'Rx*DelegateProxy' can have one subclass implementation per concrete ParentObject type.
  155|       |    /// Should call it from concrete DelegateProxy type, not generic.
  156|      0|    public static func register<Parent>(make: @escaping (Parent) -> Self) {
  157|      0|        self.factory.extend(make: make)
  158|      0|    }
  159|       |
  160|       |    /// Creates new proxy for target object.
  161|       |    /// Should not call this function directory, use 'DelegateProxy.proxy(for:)'
  162|      0|    public static func createProxy(for object: AnyObject) -> Self {
  163|      0|        return castOrFatalError(factory.createProxy(for: object))
  164|      0|    }
  165|       |
  166|       |    /// Returns existing proxy for object or installs new instance of delegate proxy.
  167|       |    ///
  168|       |    /// - parameter object: Target object on which to install delegate proxy.
  169|       |    /// - returns: Installed instance of delegate proxy.
  170|       |    ///
  171|       |    ///
  172|       |    ///     extension Reactive where Base: UISearchBar {
  173|       |    ///
  174|       |    ///         public var delegate: DelegateProxy<UISearchBar, UISearchBarDelegate> {
  175|       |    ///            return RxSearchBarDelegateProxy.proxy(for: base)
  176|       |    ///         }
  177|       |    ///
  178|       |    ///         public var text: ControlProperty<String> {
  179|       |    ///             let source: Observable<String> = self.delegate.observe(#selector(UISearchBarDelegate.searchBar(_:textDidChange:)))
  180|       |    ///             ...
  181|       |    ///         }
  182|       |    ///     }
  183|      0|    public static func proxy(for object: ParentObject) -> Self {
  184|      0|        MainScheduler.ensureRunningOnMainThread()
  185|      0|
  186|      0|        let maybeProxy = self.assignedProxy(for: object)
  187|      0|
  188|      0|        let proxy: AnyObject
  189|      0|        if let existingProxy = maybeProxy {
  190|      0|            proxy = existingProxy
  191|      0|        }
  192|      0|        else {
  193|      0|            proxy = castOrFatalError(self.createProxy(for: object))
  194|      0|            self.assignProxy(proxy, toObject: object)
  195|      0|            assert(self.assignedProxy(for: object) === proxy)
  196|      0|        }
  197|      0|        let currentDelegate = self._currentDelegate(for: object)
  198|      0|        let delegateProxy: Self = castOrFatalError(proxy)
  199|      0|
  200|      0|        if currentDelegate !== delegateProxy {
  201|      0|            delegateProxy._setForwardToDelegate(currentDelegate, retainDelegate: false)
  202|      0|            assert(delegateProxy._forwardToDelegate() === currentDelegate)
  203|      0|            self._setCurrentDelegate(proxy, to: object)
  204|      0|            assert(self._currentDelegate(for: object) === proxy)
  205|      0|            assert(delegateProxy._forwardToDelegate() === currentDelegate)
  206|      0|        }
  207|      0|
  208|      0|        return delegateProxy
  209|      0|    }
  210|       |
  211|       |    /// Sets forward delegate for `DelegateProxyType` associated with a specific object and return disposable that can be used to unset the forward to delegate.
  212|       |    /// Using this method will also make sure that potential original object cached selectors are cleared and will report any accidental forward delegate mutations.
  213|       |    ///
  214|       |    /// - parameter forwardDelegate: Delegate object to set.
  215|       |    /// - parameter retainDelegate: Retain `forwardDelegate` while it's being set.
  216|       |    /// - parameter onProxyForObject: Object that has `delegate` property.
  217|       |    /// - returns: Disposable object that can be used to clear forward delegate.
  218|      0|    public static func installForwardDelegate(_ forwardDelegate: Delegate, retainDelegate: Bool, onProxyForObject object: ParentObject) -> Disposable {
  219|      0|        weak var weakForwardDelegate: AnyObject? = forwardDelegate as AnyObject
  220|      0|        let proxy = self.proxy(for: object)
  221|      0|
  222|      0|        assert(proxy._forwardToDelegate() === nil, "This is a feature to warn you that there is already a delegate (or data source) set somewhere previously. The action you are trying to perform will clear that delegate (data source) and that means that some of your features that depend on that delegate (data source) being set will likely stop working.\n" +
  223|      0|            "If you are ok with this, try to set delegate (data source) to `nil` in front of this operation.\n" +
  224|      0|            " This is the source object value: \(object)\n" +
  225|      0|            " This is the original delegate (data source) value: \(proxy.forwardToDelegate()!)\n" +
  226|      0|            "Hint: Maybe delegate was already set in xib or storyboard and now it's being overwritten in code.\n")
  227|      0|
  228|      0|        proxy.setForwardToDelegate(forwardDelegate, retainDelegate: retainDelegate)
  229|      0|
  230|      0|        return Disposables.create {
  231|      0|            MainScheduler.ensureRunningOnMainThread()
  232|      0|
  233|      0|            let delegate: AnyObject? = weakForwardDelegate
  234|      0|
  235|      0|            assert(delegate == nil || proxy._forwardToDelegate() === delegate, "Delegate was changed from time it was first set. Current \(String(describing: proxy.forwardToDelegate())), and it should have been \(proxy)")
  236|      0|
  237|      0|            proxy.setForwardToDelegate(nil, retainDelegate: retainDelegate)
  238|      0|        }
  239|      0|    }
  240|       |}
  241|       |
  242|       |
  243|       |// fileprivate extensions
  244|       |extension DelegateProxyType {
  245|       |    fileprivate static var factory: DelegateProxyFactory {
  246|       |        return DelegateProxyFactory.sharedFactory(for: self)
  247|       |    }
  248|       |
  249|       |    fileprivate static func assignedProxy(for object: ParentObject) -> AnyObject? {
  250|       |        let maybeDelegate = objc_getAssociatedObject(object, self.identifier)
  251|       |        return castOptionalOrFatalError(maybeDelegate)
  252|       |    }
  253|       |
  254|       |    fileprivate static func assignProxy(_ proxy: AnyObject, toObject object: ParentObject) {
  255|       |        objc_setAssociatedObject(object, self.identifier, proxy, .OBJC_ASSOCIATION_RETAIN)
  256|       |    }
  257|       |}
  258|       |
  259|       |/// Describes an object that has a delegate.
  260|       |public protocol HasDelegate: AnyObject {
  261|       |    /// Delegate type
  262|       |    associatedtype Delegate
  263|       |
  264|       |    /// Delegate
  265|       |    var delegate: Delegate? { get set }
  266|       |}
  267|       |
  268|       |extension DelegateProxyType where ParentObject: HasDelegate, Self.Delegate == ParentObject.Delegate {
  269|      0|    public static func currentDelegate(for object: ParentObject) -> Delegate? {
  270|      0|        return object.delegate
  271|      0|    }
  272|       |
  273|      0|    public static func setCurrentDelegate(_ delegate: Delegate?, to object: ParentObject) {
  274|      0|        object.delegate = delegate
  275|      0|    }
  276|       |}
  277|       |
  278|       |/// Describes an object that has a data source.
  279|       |public protocol HasDataSource: AnyObject {
  280|       |    /// Data source type
  281|       |    associatedtype DataSource
  282|       |
  283|       |    /// Data source
  284|       |    var dataSource: DataSource? { get set }
  285|       |}
  286|       |
  287|       |extension DelegateProxyType where ParentObject: HasDataSource, Self.Delegate == ParentObject.DataSource {
  288|      0|    public static func currentDelegate(for object: ParentObject) -> Delegate? {
  289|      0|        return object.dataSource
  290|      0|    }
  291|       |
  292|      0|    public static func setCurrentDelegate(_ delegate: Delegate?, to object: ParentObject) {
  293|      0|        object.dataSource = delegate
  294|      0|    }
  295|       |}
  296|       |
  297|       |/// Describes an object that has a prefetch data source.
  298|       |@available(iOS 10.0, tvOS 10.0, *)
  299|       |public protocol HasPrefetchDataSource: AnyObject {
  300|       |    /// Prefetch data source type
  301|       |    associatedtype PrefetchDataSource
  302|       |
  303|       |    /// Prefetch data source
  304|       |    var prefetchDataSource: PrefetchDataSource? { get set }
  305|       |}
  306|       |
  307|       |@available(iOS 10.0, tvOS 10.0, *)
  308|       |extension DelegateProxyType where ParentObject: HasPrefetchDataSource, Self.Delegate == ParentObject.PrefetchDataSource {
  309|      0|    public static func currentDelegate(for object: ParentObject) -> Delegate? {
  310|      0|        return object.prefetchDataSource
  311|      0|    }
  312|       |
  313|      0|    public static func setCurrentDelegate(_ delegate: Delegate?, to object: ParentObject) {
  314|      0|        object.prefetchDataSource = delegate
  315|      0|    }
  316|       |}
  317|       |
  318|       |    #if os(iOS) || os(tvOS)
  319|       |        import UIKit
  320|       |
  321|       |        extension ObservableType {
  322|       |            func subscribeProxyDataSource<DelegateProxy: DelegateProxyType>(ofObject object: DelegateProxy.ParentObject, dataSource: DelegateProxy.Delegate, retainDataSource: Bool, binding: @escaping (DelegateProxy, Event<E>) -> Void)
  323|       |                -> Disposable
  324|       |                where DelegateProxy.ParentObject: UIView
  325|      0|                , DelegateProxy.Delegate: AnyObject {
  326|      0|                let proxy = DelegateProxy.proxy(for: object)
  327|      0|                let unregisterDelegate = DelegateProxy.installForwardDelegate(dataSource, retainDelegate: retainDataSource, onProxyForObject: object)
  328|      0|                // this is needed to flush any delayed old state (https://github.com/RxSwiftCommunity/RxDataSources/pull/75)
  329|      0|                object.layoutIfNeeded()
  330|      0|
  331|      0|                let subscription = self.asObservable()
  332|      0|                    .observeOn(MainScheduler())
  333|      0|                    .catchError { error in
  334|      0|                        bindingError(error)
  335|      0|                        return Observable.empty()
  336|      0|                    }
  337|      0|                    // source can never end, otherwise it would release the subscriber, and deallocate the data source
  338|      0|                    .concat(Observable.never())
  339|      0|                    .takeUntil(object.rx.deallocated)
  340|      0|                    .subscribe { [weak object] (event: Event<E>) in
  341|      0|
  342|      0|                        if let object = object {
  343|      0|                            assert(proxy === DelegateProxy.currentDelegate(for: object), "Proxy changed from the time it was first set.\nOriginal: \(proxy)\nExisting: \(String(describing: DelegateProxy.currentDelegate(for: object)))")
  344|      0|                        }
  345|      0|                        
  346|      0|                        binding(proxy, event)
  347|      0|                        
  348|      0|                        switch event {
  349|      0|                        case .error(let error):
  350|      0|                            bindingError(error)
  351|      0|                            unregisterDelegate.dispose()
  352|      0|                        case .completed:
  353|      0|                            unregisterDelegate.dispose()
  354|      0|                        default:
  355|      0|                            break
  356|      0|                        }
  357|      0|                    }
  358|      0|                    
  359|      0|                return Disposables.create { [weak object] in
  360|      0|                    subscription.dispose()
  361|      0|                    object?.layoutIfNeeded()
  362|      0|                    unregisterDelegate.dispose()
  363|      0|                }
  364|      0|            }
  365|       |        }
  366|       |
  367|       |    #endif
  368|       |
  369|       |    /**
  370|       |
  371|       |     To add delegate proxy subclasses call `DelegateProxySubclass.register()` in `registerKnownImplementations` or in some other
  372|       |     part of your app that executes before using `rx.*` (e.g. appDidFinishLaunching).
  373|       |
  374|       |         class RxScrollViewDelegateProxy: DelegateProxy {
  375|       |             public static func registerKnownImplementations() {
  376|       |                 self.register { RxTableViewDelegateProxy(parentObject: $0) }
  377|       |         }
  378|       |         ...
  379|       |
  380|       |
  381|       |     */
  382|       |    private class DelegateProxyFactory {
  383|       |        private static var _sharedFactories: [UnsafeRawPointer: DelegateProxyFactory] = [:]
  384|       |
  385|       |        fileprivate static func sharedFactory<DelegateProxy: DelegateProxyType>(for proxyType: DelegateProxy.Type) -> DelegateProxyFactory {
  386|       |            MainScheduler.ensureRunningOnMainThread()
  387|       |            let identifier = DelegateProxy.identifier
  388|       |            if let factory = _sharedFactories[identifier] {
  389|       |                return factory
  390|       |            }
  391|       |            let factory = DelegateProxyFactory(for: proxyType)
  392|       |            _sharedFactories[identifier] = factory
  393|       |            DelegateProxy.registerKnownImplementations()
  394|       |            return factory
  395|       |        }
  396|       |
  397|       |        private var _factories: [ObjectIdentifier: ((AnyObject) -> AnyObject)]
  398|       |        private var _delegateProxyType: Any.Type
  399|       |        private var _identifier: UnsafeRawPointer
  400|       |
  401|      0|        private init<DelegateProxy: DelegateProxyType>(for proxyType: DelegateProxy.Type) {
  402|      0|            self._factories = [:]
  403|      0|            self._delegateProxyType = proxyType
  404|      0|            self._identifier = proxyType.identifier
  405|      0|        }
  406|       |
  407|      0|        fileprivate func extend<DelegateProxy: DelegateProxyType, ParentObject>(make: @escaping (ParentObject) -> DelegateProxy) {
  408|      0|                MainScheduler.ensureRunningOnMainThread()
  409|      0|                precondition(self._identifier == DelegateProxy.identifier, "Delegate proxy has inconsistent identifier")
  410|      0|                guard self._factories[ObjectIdentifier(ParentObject.self)] == nil else {
  411|      0|                    rxFatalError("The factory of \(ParentObject.self) is duplicated. DelegateProxy is not allowed of duplicated base object type.")
  412|      0|                }
  413|      0|                self._factories[ObjectIdentifier(ParentObject.self)] = { make(castOrFatalError($0)) }
  414|      0|        }
  415|       |
  416|      0|        fileprivate func createProxy(for object: AnyObject) -> AnyObject {
  417|      0|            MainScheduler.ensureRunningOnMainThread()
  418|      0|            var maybeMirror: Mirror? = Mirror(reflecting: object)
  419|      0|            while let mirror = maybeMirror {
  420|      0|                if let factory = self._factories[ObjectIdentifier(mirror.subjectType)] {
  421|      0|                    return factory(object)
  422|      0|                }
  423|      0|                maybeMirror = mirror.superclassMirror
  424|      0|            }
  425|      0|            rxFatalError("DelegateProxy has no factory of \(object). Implement DelegateProxy subclass for \(object) first.")
  426|      0|        }
  427|       |    }
  428|       |
  429|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/KeyPathBinder.swift:
    1|       |//
    2|       |//  KeyPathBinder.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Ryo Aoyama on 2/7/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension Reactive where Base: AnyObject {
   12|       |    
   13|       |    /// Bindable sink for arbitrary property using the given key path.
   14|       |    /// Binding runs on the MainScheduler.
   15|       |    ///
   16|       |    /// - parameter keyPath: Key path to write to the property.
   17|      0|    public subscript<Value>(keyPath: ReferenceWritableKeyPath<Base, Value>) -> Binder<Value> {
   18|      0|        return Binder(self.base) { base, value in
   19|      0|            base[keyPath: keyPath] = value
   20|      0|        }
   21|      0|    }
   22|       |    
   23|       |    /// Bindable sink for arbitrary property using the given key path.
   24|       |    /// Binding runs on the specified scheduler.
   25|       |    ///
   26|       |    /// - parameter keyPath: Key path to write to the property.
   27|       |    /// - parameter scheduler: Scheduler to run bindings on.
   28|      0|    public subscript<Value>(keyPath: ReferenceWritableKeyPath<Base, Value>, on scheduler: ImmediateSchedulerType) -> Binder<Value> {
   29|      0|        return Binder(self.base, scheduler: scheduler) { base, value in
   30|      0|            base[keyPath: keyPath] = value
   31|      0|        }
   32|      0|    }
   33|       |    
   34|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/NSLayoutConstraint+Rx.swift:
    1|       |//
    2|       |//  NSLayoutConstraint+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |#if os(macOS)
   12|       |    import Cocoa
   13|       |#else
   14|       |    import UIKit
   15|       |#endif
   16|       |
   17|       |import RxSwift
   18|       |
   19|       |#if os(iOS) || os(macOS) || os(tvOS)
   20|       |extension Reactive where Base: NSLayoutConstraint {
   21|       |    /// Bindable sink for `constant` property.
   22|      0|    public var constant: Binder<CGFloat> {
   23|      0|        return Binder(self.base) { constraint, constant in
   24|      0|            constraint.constant = constant
   25|      0|        }
   26|      0|    }
   27|       |    
   28|       |    /// Bindable sink for `active` property.
   29|       |    @available(iOS 8, OSX 10.10, *)
   30|      0|    public var active: Binder<Bool> {
   31|      0|        return Binder(self.base) { constraint, value in
   32|      0|            constraint.isActive = value
   33|      0|        }
   34|      0|    }
   35|       |}
   36|       |
   37|       |#endif
   38|       |
   39|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/Observable+Bind.swift:
    1|       |//
    2|       |//  Observable+Bind.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |import RxSwift
   11|       |
   12|       |extension ObservableType {
   13|       |    
   14|       |    /**
   15|       |    Creates new subscription and sends elements to observer.
   16|       |    
   17|       |    In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   18|       |    writing more consistent binding code.
   19|       |    
   20|       |    - parameter to: Observer that receives events.
   21|       |    - returns: Disposable object that can be used to unsubscribe the observer.
   22|       |    */
   23|      0|    public func bind<O: ObserverType>(to observer: O) -> Disposable where O.E == E {
   24|      0|        return self.subscribe(observer)
   25|      0|    }
   26|       |
   27|       |    /**
   28|       |     Creates new subscription and sends elements to observer.
   29|       |
   30|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   31|       |     writing more consistent binding code.
   32|       |
   33|       |     - parameter to: Observer that receives events.
   34|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   35|       |     */
   36|      0|    public func bind<O: ObserverType>(to observer: O) -> Disposable where O.E == E? {
   37|      0|        return self.map { $0 }.subscribe(observer)
   38|      0|    }
   39|       |
   40|       |    /**
   41|       |     Creates new subscription and sends elements to publish relay.
   42|       |     
   43|       |     In case error occurs in debug mode, `fatalError` will be raised.
   44|       |     In case error occurs in release mode, `error` will be logged.
   45|       |     
   46|       |     - parameter to: Target publish relay for sequence elements.
   47|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   48|       |     */
   49|      0|    public func bind(to relay: PublishRelay<E>) -> Disposable {
   50|      0|        return self.subscribe { e in
   51|      0|            switch e {
   52|      0|            case let .next(element):
   53|      0|                relay.accept(element)
   54|      0|            case let .error(error):
   55|      0|                rxFatalErrorInDebug("Binding error to publish relay: \(error)")
   56|      0|            case .completed:
   57|      0|                break
   58|      0|            }
   59|      0|        }
   60|      0|    }
   61|       |    
   62|       |    /**
   63|       |     Creates new subscription and sends elements to publish relay.
   64|       |     
   65|       |     In case error occurs in debug mode, `fatalError` will be raised.
   66|       |     In case error occurs in release mode, `error` will be logged.
   67|       |     
   68|       |     - parameter to: Target publish relay for sequence elements.
   69|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   70|       |     */
   71|      0|    public func bind(to relay: PublishRelay<E?>) -> Disposable {
   72|      0|        return self.map { $0 as E? }.bind(to: relay)
   73|      0|    }
   74|       |    
   75|       |    /**
   76|       |     Creates new subscription and sends elements to behavior relay.
   77|       |     
   78|       |     In case error occurs in debug mode, `fatalError` will be raised.
   79|       |     In case error occurs in release mode, `error` will be logged.
   80|       |     
   81|       |     - parameter to: Target behavior relay for sequence elements.
   82|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   83|       |     */
   84|      0|    public func bind(to relay: BehaviorRelay<E>) -> Disposable {
   85|      0|        return self.subscribe { e in
   86|      0|            switch e {
   87|      0|            case let .next(element):
   88|      0|                relay.accept(element)
   89|      0|            case let .error(error):
   90|      0|                rxFatalErrorInDebug("Binding error to behavior relay: \(error)")
   91|      0|            case .completed:
   92|      0|                break
   93|      0|            }
   94|      0|        }
   95|      0|    }
   96|       |    
   97|       |    /**
   98|       |     Creates new subscription and sends elements to behavior relay.
   99|       |     
  100|       |     In case error occurs in debug mode, `fatalError` will be raised.
  101|       |     In case error occurs in release mode, `error` will be logged.
  102|       |     
  103|       |     - parameter to: Target behavior relay for sequence elements.
  104|       |     - returns: Disposable object that can be used to unsubscribe the observer.
  105|       |     */
  106|      0|    public func bind(to relay: BehaviorRelay<E?>) -> Disposable {
  107|      0|        return self.map { $0 as E? }.bind(to: relay)
  108|      0|    }
  109|       |    
  110|       |    /**
  111|       |    Subscribes to observable sequence using custom binder function.
  112|       |    
  113|       |    - parameter to: Function used to bind elements from `self`.
  114|       |    - returns: Object representing subscription.
  115|       |    */
  116|      0|    public func bind<R>(to binder: (Self) -> R) -> R {
  117|      0|        return binder(self)
  118|      0|    }
  119|       |
  120|       |    /**
  121|       |    Subscribes to observable sequence using custom binder function and final parameter passed to binder function
  122|       |    after `self` is passed.
  123|       |    
  124|       |        public func bind<R1, R2>(to binder: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
  125|       |            return binder(self)(curriedArgument)
  126|       |        }
  127|       |    
  128|       |    - parameter to: Function used to bind elements from `self`.
  129|       |    - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
  130|       |    - returns: Object representing subscription.
  131|       |    */
  132|      0|    public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2 {
  133|      0|         return binder(self)(curriedArgument)
  134|      0|    }
  135|       |    
  136|       |    
  137|       |    /**
  138|       |    Subscribes an element handler to an observable sequence. 
  139|       |
  140|       |    In case error occurs in debug mode, `fatalError` will be raised.
  141|       |    In case error occurs in release mode, `error` will be logged.
  142|       |    
  143|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
  144|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
  145|       |    */
  146|      0|    public func bind(onNext: @escaping (E) -> Void) -> Disposable {
  147|      0|        return self.subscribe(onNext: onNext, onError: { error in
  148|      0|            rxFatalErrorInDebug("Binding error: \(error)")
  149|      0|        })
  150|      0|    }
  151|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/RxCocoaObjCRuntimeError+Extensions.swift:
    1|       |//
    2|       |//  RxCocoaObjCRuntimeError+Extensions.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/9/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if SWIFT_PACKAGE && !DISABLE_SWIZZLING && !os(Linux)
   10|       |    import RxCocoaRuntime
   11|       |#endif
   12|       |
   13|       |#if !DISABLE_SWIZZLING && !os(Linux)
   14|       |    /// RxCocoa ObjC runtime interception mechanism.
   15|       |    public enum RxCocoaInterceptionMechanism {
   16|       |        /// Unknown message interception mechanism.
   17|       |        case unknown
   18|       |        /// Key value observing interception mechanism.
   19|       |        case kvo
   20|       |    }
   21|       |
   22|       |    /// RxCocoa ObjC runtime modification errors.
   23|       |    public enum RxCocoaObjCRuntimeError
   24|       |        : Swift.Error
   25|       |        , CustomDebugStringConvertible {
   26|       |        /// Unknown error has occurred.
   27|       |        case unknown(target: AnyObject)
   28|       |
   29|       |        /**
   30|       |        If the object is reporting a different class then it's real class, that means that there is probably
   31|       |        already some interception mechanism in place or something weird is happening.
   32|       |
   33|       |        The most common case when this would happen is when using a combination of KVO (`observe`) and `sentMessage`.
   34|       |
   35|       |        This error is easily resolved by just using `sentMessage` observing before `observe`.
   36|       |
   37|       |        The reason why the other way around could create issues is because KVO will unregister it's interceptor
   38|       |        class and restore original class. Unfortunately that will happen no matter was there another interceptor
   39|       |        subclass registered in hierarchy or not.
   40|       |
   41|       |        Failure scenario:
   42|       |        * KVO sets class to be `__KVO__OriginalClass` (subclass of `OriginalClass`)
   43|       |        * `sentMessage` sets object class to be `_RX_namespace___KVO__OriginalClass` (subclass of `__KVO__OriginalClass`)
   44|       |        * then unobserving with KVO will restore class to be `OriginalClass` -> failure point (possibly a bug in KVO)
   45|       |
   46|       |        The reason why changing order of observing works is because any interception method on unregistration 
   47|       |        should return object's original real class (if that doesn't happen then it's really easy to argue that's a bug
   48|       |        in that interception mechanism).
   49|       |
   50|       |        This library won't remove registered interceptor even if there aren't any observers left because
   51|       |        it's highly unlikely it would have any benefit in real world use cases, and it's even more
   52|       |        dangerous.
   53|       |        */
   54|       |        case objectMessagesAlreadyBeingIntercepted(target: AnyObject, interceptionMechanism: RxCocoaInterceptionMechanism)
   55|       |
   56|       |        /// Trying to observe messages for selector that isn't implemented.
   57|       |        case selectorNotImplemented(target: AnyObject)
   58|       |
   59|       |        /// Core Foundation classes are usually toll free bridged. Those classes crash the program in case
   60|       |        /// `object_setClass` is performed on them.
   61|       |        ///
   62|       |        /// There is a possibility to just swizzle methods on original object, but since those won't be usual use
   63|       |        /// cases for this library, then an error will just be reported for now.
   64|       |        case cantInterceptCoreFoundationTollFreeBridgedObjects(target: AnyObject)
   65|       |
   66|       |        /// Two libraries have simultaneously tried to modify ObjC runtime and that was detected. This can only
   67|       |        /// happen in scenarios where multiple interception libraries are used.
   68|       |        ///
   69|       |        /// To synchronize other libraries intercepting messages for an object, use `synchronized` on target object and
   70|       |        /// it's meta-class.
   71|       |        case threadingCollisionWithOtherInterceptionMechanism(target: AnyObject)
   72|       |
   73|       |        /// For some reason saving original method implementation under RX namespace failed.
   74|       |        case savingOriginalForwardingMethodFailed(target: AnyObject)
   75|       |
   76|       |        /// Intercepting a sent message by replacing a method implementation with `_objc_msgForward` failed for some reason.
   77|       |        case replacingMethodWithForwardingImplementation(target: AnyObject)
   78|       |
   79|       |        /// Attempt to intercept one of the performance sensitive methods:
   80|       |        ///    * class
   81|       |        ///    * respondsToSelector:
   82|       |        ///    * methodSignatureForSelector:
   83|       |        ///    * forwardingTargetForSelector:
   84|       |        case observingPerformanceSensitiveMessages(target: AnyObject)
   85|       |
   86|       |        /// Message implementation has unsupported return type (for example large struct). The reason why this is a error
   87|       |        /// is because in some cases intercepting sent messages requires replacing implementation with `_objc_msgForward_stret`
   88|       |        /// instead of `_objc_msgForward`.
   89|       |        ///
   90|       |        /// The unsupported cases should be fairly uncommon.
   91|       |        case observingMessagesWithUnsupportedReturnType(target: AnyObject)
   92|       |    }
   93|       |
   94|       |    extension RxCocoaObjCRuntimeError {
   95|       |        /// A textual representation of `self`, suitable for debugging.
   96|       |        public var debugDescription: String {
   97|       |            switch self {
   98|       |            case let .unknown(target):
   99|       |                return "Unknown error occurred.\nTarget: `\(target)`"
  100|       |            case let .objectMessagesAlreadyBeingIntercepted(target, interceptionMechanism):
  101|       |                let interceptionMechanismDescription = interceptionMechanism == .kvo ? "KVO" : "other interception mechanism"
  102|       |                return "Collision between RxCocoa interception mechanism and \(interceptionMechanismDescription)."
  103|       |                    + " To resolve this conflict please use this interception mechanism first.\nTarget: \(target)"
  104|       |            case let .selectorNotImplemented(target):
  105|       |                return "Trying to observe messages for selector that isn't implemented.\nTarget: \(target)"
  106|       |            case let .cantInterceptCoreFoundationTollFreeBridgedObjects(target):
  107|       |                return "Interception of messages sent to Core Foundation isn't supported.\nTarget: \(target)"
  108|       |            case let .threadingCollisionWithOtherInterceptionMechanism(target):
  109|       |                return "Detected a conflict while modifying ObjC runtime.\nTarget: \(target)"
  110|       |            case let .savingOriginalForwardingMethodFailed(target):
  111|       |                return "Saving original method implementation failed.\nTarget: \(target)"
  112|       |            case let .replacingMethodWithForwardingImplementation(target):
  113|       |                return "Intercepting a sent message by replacing a method implementation with `_objc_msgForward` failed for some reason.\nTarget: \(target)"
  114|       |            case let .observingPerformanceSensitiveMessages(target):
  115|       |                return "Attempt to intercept one of the performance sensitive methods. \nTarget: \(target)"
  116|       |            case let .observingMessagesWithUnsupportedReturnType(target):
  117|       |                return "Attempt to intercept a method with unsupported return type. \nTarget: \(target)"
  118|       |            }
  119|       |        }
  120|       |    }
  121|       |    
  122|       |    // MARK: Conversions `NSError` > `RxCocoaObjCRuntimeError`
  123|       |
  124|       |    extension Error {
  125|      0|        func rxCocoaErrorForTarget(_ target: AnyObject) -> RxCocoaObjCRuntimeError {
  126|      0|            let error = self as NSError
  127|      0|            
  128|      0|            if error.domain == RXObjCRuntimeErrorDomain {
  129|      0|                let errorCode = RXObjCRuntimeError(rawValue: error.code) ?? .unknown
  130|      0|                
  131|      0|                switch errorCode {
  132|      0|                case .unknown:
  133|      0|                    return .unknown(target: target)
  134|      0|                case .objectMessagesAlreadyBeingIntercepted:
  135|      0|                    let isKVO = (error.userInfo[RXObjCRuntimeErrorIsKVOKey] as? NSNumber)?.boolValue ?? false
  136|      0|                    return .objectMessagesAlreadyBeingIntercepted(target: target, interceptionMechanism: isKVO ? .kvo : .unknown)
  137|      0|                case .selectorNotImplemented:
  138|      0|                    return .selectorNotImplemented(target: target)
  139|      0|                case .cantInterceptCoreFoundationTollFreeBridgedObjects:
  140|      0|                    return .cantInterceptCoreFoundationTollFreeBridgedObjects(target: target)
  141|      0|                case .threadingCollisionWithOtherInterceptionMechanism:
  142|      0|                    return .threadingCollisionWithOtherInterceptionMechanism(target: target)
  143|      0|                case .savingOriginalForwardingMethodFailed:
  144|      0|                    return .savingOriginalForwardingMethodFailed(target: target)
  145|      0|                case .replacingMethodWithForwardingImplementation:
  146|      0|                    return .replacingMethodWithForwardingImplementation(target: target)
  147|      0|                case .observingPerformanceSensitiveMessages:
  148|      0|                    return .observingPerformanceSensitiveMessages(target: target)
  149|      0|                case .observingMessagesWithUnsupportedReturnType:
  150|      0|                    return .observingMessagesWithUnsupportedReturnType(target: target)
  151|      0|                }
  152|      0|            }
  153|      0|            
  154|      0|            return RxCocoaObjCRuntimeError.unknown(target: target)
  155|      0|        }
  156|       |    }
  157|       |
  158|       |#endif
  159|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/RxTarget.swift:
    1|       |//
    2|       |//  RxTarget.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSObject
   10|       |
   11|       |import RxSwift
   12|       |
   13|       |class RxTarget : NSObject
   14|       |               , Disposable {
   15|       |    
   16|       |    private var retainSelf: RxTarget?
   17|       |    
   18|      0|    override init() {
   19|      0|        super.init()
   20|      0|        self.retainSelf = self
   21|      0|
   22|      0|#if TRACE_RESOURCES
   23|      0|        _ = Resources.incrementTotal()
   24|      0|#endif
   25|      0|
   26|      0|#if DEBUG
   27|      0|        MainScheduler.ensureRunningOnMainThread()
   28|      0|#endif
   29|      0|    }
   30|       |    
   31|      0|    func dispose() {
   32|      0|#if DEBUG
   33|      0|        MainScheduler.ensureRunningOnMainThread()
   34|      0|#endif
   35|      0|        self.retainSelf = nil
   36|      0|    }
   37|       |
   38|       |#if TRACE_RESOURCES
   39|       |    deinit {
   40|       |        _ = Resources.decrementTotal()
   41|       |    }
   42|       |#endif
   43|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Common/TextInput.swift:
    1|       |//
    2|       |//  TextInput.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |#if os(iOS) || os(tvOS)
   12|       |    import UIKit
   13|       |
   14|       |    /// Represents text input with reactive extensions.
   15|       |    public struct TextInput<Base: UITextInput> {
   16|       |        /// Base text input to extend.
   17|       |        public let base: Base
   18|       |
   19|       |        /// Reactive wrapper for `text` property.
   20|       |        public let text: ControlProperty<String?>
   21|       |
   22|       |        /// Initializes new text input.
   23|       |        ///
   24|       |        /// - parameter base: Base object.
   25|       |        /// - parameter text: Textual control property.
   26|      0|        public init(base: Base, text: ControlProperty<String?>) {
   27|      0|            self.base = base
   28|      0|            self.text = text
   29|      0|        }
   30|       |    }
   31|       |
   32|       |    extension Reactive where Base: UITextField {
   33|       |        /// Reactive text input.
   34|      0|        public var textInput: TextInput<Base> {
   35|      0|            return TextInput(base: base, text: self.text)
   36|      0|        }
   37|       |    }
   38|       |
   39|       |    extension Reactive where Base: UITextView {
   40|       |        /// Reactive text input.
   41|      0|        public var textInput: TextInput<Base> {
   42|      0|            return TextInput(base: base, text: self.text)
   43|      0|        }
   44|       |    }
   45|       |
   46|       |#endif
   47|       |
   48|       |#if os(macOS)
   49|       |    import Cocoa
   50|       |
   51|       |    /// Represents text input with reactive extensions.
   52|       |    public struct TextInput<Base: NSTextInputClient> {
   53|       |        /// Base text input to extend.
   54|       |        public let base: Base
   55|       |
   56|       |        /// Reactive wrapper for `text` property.
   57|       |        public let text: ControlProperty<String?>
   58|       |
   59|       |        /// Initializes new text input.
   60|       |        ///
   61|       |        /// - parameter base: Base object.
   62|       |        /// - parameter text: Textual control property.
   63|       |        public init(base: Base, text: ControlProperty<String?>) {
   64|       |            self.base = base
   65|       |            self.text = text
   66|       |        }
   67|       |    }
   68|       |
   69|       |    extension Reactive where Base: NSTextField, Base: NSTextInputClient {
   70|       |        /// Reactive text input.
   71|       |        public var textInput: TextInput<Base> {
   72|       |            return TextInput(base: self.base, text: self.text)
   73|       |        }
   74|       |    }
   75|       |
   76|       |#endif
   77|       |
   78|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Deprecated.swift:
    1|       |//
    2|       |//  Deprecated.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/19/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |import Dispatch
   11|       |
   12|       |extension ObservableType {
   13|       |
   14|       |    /**
   15|       |     Creates new subscription and sends elements to observer.
   16|       |
   17|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   18|       |     writing more consistent binding code.
   19|       |
   20|       |     - parameter observer: Observer that receives events.
   21|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   22|       |     */
   23|       |    @available(*, deprecated, renamed: "bind(to:)")
   24|      0|    public func bindTo<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   25|      0|        return self.subscribe(observer)
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |     Creates new subscription and sends elements to observer.
   30|       |
   31|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   32|       |     writing more consistent binding code.
   33|       |
   34|       |     - parameter observer: Observer that receives events.
   35|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   36|       |     */
   37|       |    @available(*, deprecated, renamed: "bind(to:)")
   38|      0|    public func bindTo<O: ObserverType>(_ observer: O) -> Disposable where O.E == E? {
   39|      0|        return self.map { $0 }.subscribe(observer)
   40|      0|    }
   41|       |
   42|       |    /**
   43|       |     Creates new subscription and sends elements to variable.
   44|       |
   45|       |     In case error occurs in debug mode, `fatalError` will be raised.
   46|       |     In case error occurs in release mode, `error` will be logged.
   47|       |
   48|       |     - parameter variable: Target variable for sequence elements.
   49|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   50|       |     */
   51|       |    @available(*, deprecated, renamed: "bind(to:)")
   52|      0|    public func bindTo(_ variable: Variable<E>) -> Disposable {
   53|      0|        return self.subscribe { e in
   54|      0|            switch e {
   55|      0|            case let .next(element):
   56|      0|                variable.value = element
   57|      0|            case let .error(error):
   58|      0|                let error = "Binding error to variable: \(error)"
   59|      0|                #if DEBUG
   60|      0|                    rxFatalError(error)
   61|      0|                #else
   62|      0|                    print(error)
   63|      0|                #endif
   64|      0|            case .completed:
   65|      0|                break
   66|      0|            }
   67|      0|        }
   68|      0|    }
   69|       |
   70|       |    /**
   71|       |     Creates new subscription and sends elements to variable.
   72|       |
   73|       |     In case error occurs in debug mode, `fatalError` will be raised.
   74|       |     In case error occurs in release mode, `error` will be logged.
   75|       |
   76|       |     - parameter variable: Target variable for sequence elements.
   77|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   78|       |     */
   79|       |    @available(*, deprecated, renamed: "bind(to:)")
   80|      0|    public func bindTo(_ variable: Variable<E?>) -> Disposable {
   81|      0|        return self.map { $0 as E? }.bindTo(variable)
   82|      0|    }
   83|       |
   84|       |    /**
   85|       |     Subscribes to observable sequence using custom binder function.
   86|       |
   87|       |     - parameter binder: Function used to bind elements from `self`.
   88|       |     - returns: Object representing subscription.
   89|       |     */
   90|       |    @available(*, deprecated, renamed: "bind(to:)")
   91|      0|    public func bindTo<R>(_ binder: (Self) -> R) -> R {
   92|      0|        return binder(self)
   93|      0|    }
   94|       |
   95|       |    /**
   96|       |     Subscribes to observable sequence using custom binder function and final parameter passed to binder function
   97|       |     after `self` is passed.
   98|       |
   99|       |     public func bindTo<R1, R2>(binder: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
  100|       |     return binder(self)(curriedArgument)
  101|       |     }
  102|       |
  103|       |     - parameter binder: Function used to bind elements from `self`.
  104|       |     - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
  105|       |     - returns: Object representing subscription.
  106|       |     */
  107|       |    @available(*, deprecated, renamed: "bind(to:)")
  108|      0|    public func bindTo<R1, R2>(_ binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2 {
  109|      0|        return binder(self)(curriedArgument)
  110|      0|    }
  111|       |
  112|       |
  113|       |    /**
  114|       |     Subscribes an element handler to an observable sequence.
  115|       |
  116|       |     In case error occurs in debug mode, `fatalError` will be raised.
  117|       |     In case error occurs in release mode, `error` will be logged.
  118|       |
  119|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  120|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
  121|       |     */
  122|       |    @available(*, deprecated, renamed: "bind(onNext:)")
  123|      0|    public func bindNext(_ onNext: @escaping (E) -> Void) -> Disposable {
  124|      0|        return self.subscribe(onNext: onNext, onError: { error in
  125|      0|            let error = "Binding error: \(error)"
  126|      0|            #if DEBUG
  127|      0|                rxFatalError(error)
  128|      0|            #else
  129|      0|                print(error)
  130|      0|            #endif
  131|      0|        })
  132|      0|    }
  133|       |}
  134|       |
  135|       |#if os(iOS) || os(tvOS)
  136|       |    import UIKit
  137|       |
  138|       |    extension NSTextStorage {
  139|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  140|      0|        public func createRxDelegateProxy() -> RxTextStorageDelegateProxy {
  141|      0|            fatalError()
  142|      0|        }
  143|       |    }
  144|       |
  145|       |    extension UIScrollView {
  146|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  147|      0|        public func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
  148|      0|            fatalError()
  149|      0|        }
  150|       |    }
  151|       |
  152|       |    extension UICollectionView {
  153|       |        @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  154|      0|        public func createRxDataSourceProxy() -> RxCollectionViewDataSourceProxy {
  155|      0|            fatalError()
  156|      0|        }
  157|       |    }
  158|       |
  159|       |    extension UITableView {
  160|       |        @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  161|      0|        public func createRxDataSourceProxy() -> RxTableViewDataSourceProxy {
  162|      0|            fatalError()
  163|      0|        }
  164|       |    }
  165|       |
  166|       |    extension UINavigationBar {
  167|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  168|      0|        public func createRxDelegateProxy() -> RxNavigationControllerDelegateProxy {
  169|      0|            fatalError()
  170|      0|        }
  171|       |    }
  172|       |
  173|       |    extension UINavigationController {
  174|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  175|      0|        public func createRxDelegateProxy() -> RxNavigationControllerDelegateProxy {
  176|      0|            fatalError()
  177|      0|        }
  178|       |    }
  179|       |
  180|       |    extension UITabBar {
  181|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  182|      0|        public func createRxDelegateProxy() -> RxTabBarDelegateProxy {
  183|      0|            fatalError()
  184|      0|        }
  185|       |    }
  186|       |
  187|       |    extension UITabBarController {
  188|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  189|      0|        public func createRxDelegateProxy() -> RxTabBarControllerDelegateProxy {
  190|      0|            fatalError()
  191|      0|        }
  192|       |    }
  193|       |
  194|       |    extension UISearchBar {
  195|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  196|      0|        public func createRxDelegateProxy() -> RxSearchBarDelegateProxy {
  197|      0|            fatalError()
  198|      0|        }
  199|       |    }
  200|       |
  201|       |#endif
  202|       |
  203|       |#if os(iOS)
  204|       |    extension UISearchController {
  205|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  206|      0|        public func createRxDelegateProxy() -> RxSearchControllerDelegateProxy {
  207|      0|            fatalError()
  208|      0|        }
  209|       |    }
  210|       |
  211|       |    extension UIPickerView {
  212|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  213|      0|        public func createRxDelegateProxy() -> RxPickerViewDelegateProxy {
  214|      0|            fatalError()
  215|      0|        }
  216|       |
  217|       |        @available(*, unavailable, message: "createRxDataSourceProxy is now unavailable, check DelegateProxyFactory")
  218|      0|        public func createRxDataSourceProxy() -> RxPickerViewDataSourceProxy {
  219|      0|            fatalError()
  220|      0|        }
  221|       |    }
  222|       |    extension UIWebView {
  223|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  224|      0|        public func createRxDelegateProxy() -> RxWebViewDelegateProxy {
  225|      0|            fatalError()
  226|      0|        }
  227|       |    }
  228|       |#endif
  229|       |
  230|       |#if os(macOS)
  231|       |    import Cocoa
  232|       |
  233|       |    extension NSTextField {
  234|       |        @available(*, unavailable, message: "createRxDelegateProxy is now unavailable, check DelegateProxyFactory")
  235|       |        public func createRxDelegateProxy() -> RxTextFieldDelegateProxy {
  236|       |            fatalError()
  237|       |        }
  238|       |    }
  239|       |#endif
  240|       |
  241|       |/**
  242|       | This method can be used in unit tests to ensure that driver is using mock schedulers instead of
  243|       | main schedulers.
  244|       |
  245|       | **This shouldn't be used in normal release builds.**
  246|       | */
  247|       |@available(*, deprecated, renamed: "SharingScheduler.mock(scheduler:action:)")
  248|      0|public func driveOnScheduler(_ scheduler: SchedulerType, action: () -> Void) {
  249|      0|    SharingScheduler.mock(scheduler: scheduler, action: action)
  250|      0|}
  251|       |
  252|       |extension Variable {
  253|       |    /// Converts `Variable` to `SharedSequence` unit.
  254|       |    ///
  255|       |    /// - returns: Observable sequence.
  256|       |    @available(*, deprecated, renamed: "asDriver()")
  257|      0|    public func asSharedSequence<SharingStrategy: SharingStrategyProtocol>(strategy: SharingStrategy.Type = SharingStrategy.self) -> SharedSequence<SharingStrategy, E> {
  258|      0|        let source = self.asObservable()
  259|      0|            .observeOn(SharingStrategy.scheduler)
  260|      0|        return SharedSequence(source)
  261|      0|    }
  262|       |}
  263|       |
  264|       |#if !os(Linux)
  265|       |
  266|       |extension DelegateProxy {
  267|       |    @available(*, unavailable, renamed: "assignedProxy(for:)")
  268|      0|    public static func assignedProxyFor(_ object: ParentObject) -> Delegate? {
  269|      0|        fatalError()
  270|      0|    }
  271|       |    
  272|       |    @available(*, unavailable, renamed: "currentDelegate(for:)")
  273|      0|    public static func currentDelegateFor(_ object: ParentObject) -> Delegate? {
  274|      0|        fatalError()
  275|      0|    }
  276|       |}
  277|       |
  278|       |#endif
  279|       |
  280|       |/**
  281|       |Observer that enforces interface binding rules:
  282|       | * can't bind errors (in debug builds binding of errors causes `fatalError` in release builds errors are being logged)
  283|       | * ensures binding is performed on main thread
  284|       | 
  285|       |`UIBindingObserver` doesn't retain target interface and in case owned interface element is released, element isn't bound.
  286|       | 
  287|       | In case event binding is attempted from non main dispatch queue, event binding will be dispatched async to main dispatch
  288|       | queue.
  289|       |*/
  290|       |@available(*, deprecated, renamed: "Binder")
  291|       |public final class UIBindingObserver<UIElementType, Value> : ObserverType where UIElementType: AnyObject {
  292|       |    public typealias E = Value
  293|       |
  294|       |    weak var UIElement: UIElementType?
  295|       |
  296|       |    let binding: (UIElementType, Value) -> Void
  297|       |
  298|       |    /// Initializes `ViewBindingObserver` using
  299|       |    @available(*, deprecated, renamed: "UIBinder.init(_:scheduler:binding:)")
  300|      0|    public init(UIElement: UIElementType, binding: @escaping (UIElementType, Value) -> Void) {
  301|      0|        self.UIElement = UIElement
  302|      0|        self.binding = binding
  303|      0|    }
  304|       |
  305|       |    /// Binds next element to owner view as described in `binding`.
  306|      0|    public func on(_ event: Event<Value>) {
  307|      0|        if !DispatchQueue.isMain {
  308|      0|            DispatchQueue.main.async {
  309|      0|                self.on(event)
  310|      0|            }
  311|      0|            return
  312|      0|        }
  313|      0|
  314|      0|        switch event {
  315|      0|        case .next(let element):
  316|      0|            if let view = self.UIElement {
  317|      0|                self.binding(view, element)
  318|      0|            }
  319|      0|        case .error(let error):
  320|      0|            bindingError(error)
  321|      0|        case .completed:
  322|      0|            break
  323|      0|        }
  324|      0|    }
  325|       |
  326|       |    /// Erases type of observer.
  327|       |    ///
  328|       |    /// - returns: type erased observer.
  329|      0|    public func asObserver() -> AnyObserver<Value> {
  330|      0|        return AnyObserver(eventHandler: self.on)
  331|      0|    }
  332|       |}
  333|       |
  334|       |
  335|       |#if os(iOS)
  336|       |    extension Reactive where Base: UIRefreshControl {
  337|       |
  338|       |        /// Bindable sink for `beginRefreshing()`, `endRefreshing()` methods.
  339|       |        @available(*, deprecated, renamed: "isRefreshing")
  340|      0|        public var refreshing: Binder<Bool> {
  341|      0|            return self.isRefreshing
  342|      0|        }
  343|       |    }
  344|       |#endif
  345|       |
  346|       |#if os(iOS) || os(tvOS)
  347|       |extension Reactive where Base: UIImageView {
  348|       |
  349|       |    /// Bindable sink for `image` property.
  350|       |    /// - parameter transitionType: Optional transition type while setting the image (kCATransitionFade, kCATransitionMoveIn, ...)
  351|       |    @available(*, deprecated, renamed: "image")
  352|      0|    public func image(transitionType: String? = nil) -> Binder<UIImage?> {
  353|      0|        return Binder(base) { imageView, image in
  354|      0|            if let transitionType = transitionType {
  355|      0|                if image != nil {
  356|      0|                    let transition = CATransition()
  357|      0|                    transition.duration = 0.25
  358|      0|                    #if swift(>=4.2)
  359|      0|                        transition.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
  360|      0|                        transition.type = CATransitionType(rawValue: transitionType)
  361|      0|                    #else
  362|      0|                        transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
  363|      0|                        transition.type = transitionType
  364|      0|                    #endif
  365|      0|                    imageView.layer.add(transition, forKey: kCATransition)
  366|      0|                }
  367|      0|            }
  368|      0|            else {
  369|      0|                imageView.layer.removeAllAnimations()
  370|      0|            }
  371|      0|            imageView.image = image
  372|      0|        }
  373|      0|    }
  374|       |}
  375|       |    
  376|       |extension Reactive where Base: UISegmentedControl {
  377|       |    @available(*, deprecated, renamed: "enabledForSegment(at:)")
  378|      0|    public func enabled(forSegmentAt segmentAt: Int) -> Binder<Bool> {
  379|      0|        return enabledForSegment(at: segmentAt)
  380|      0|    }
  381|       |}
  382|       |#endif
  383|       |
  384|       |#if os(macOS)
  385|       |
  386|       |    extension Reactive where Base: NSImageView {
  387|       |
  388|       |        /// Bindable sink for `image` property.
  389|       |        ///
  390|       |        /// - parameter transitionType: Optional transition type while setting the image (kCATransitionFade, kCATransitionMoveIn, ...)
  391|       |        @available(*, deprecated, renamed: "image")
  392|       |        public func image(transitionType: String? = nil) -> Binder<NSImage?> {
  393|       |            return Binder(self.base) { control, value in
  394|       |                if let transitionType = transitionType {
  395|       |                    if value != nil {
  396|       |                        let transition = CATransition()
  397|       |                        transition.duration = 0.25
  398|       |#if swift(>=4.2)
  399|       |                        transition.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
  400|       |                        transition.type = CATransitionType(rawValue: transitionType)
  401|       |#else
  402|       |                        transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
  403|       |                        transition.type = transitionType
  404|       |#endif
  405|       |                        control.layer?.add(transition, forKey: kCATransition)
  406|       |                    }
  407|       |                }
  408|       |                else {
  409|       |                    control.layer?.removeAllAnimations()
  410|       |                }
  411|       |                control.image = value
  412|       |            }
  413|       |        }
  414|       |    }
  415|       |#endif
  416|       |
  417|       |import RxSwift
  418|       |
  419|       |extension Variable {
  420|       |    /// Converts `Variable` to `Driver` trait.
  421|       |    ///
  422|       |    /// - returns: Driving observable sequence.
  423|      0|    public func asDriver() -> Driver<E> {
  424|      0|        let source = self.asObservable()
  425|      0|            .observeOn(DriverSharingStrategy.scheduler)
  426|      0|        return Driver(source)
  427|      0|    }
  428|       |}
  429|       |
  430|       |
  431|       |private let errorMessage = "`drive*` family of methods can be only called from `MainThread`.\n" +
  432|       |"This is required to ensure that the last replayed `Driver` element is delivered on `MainThread`.\n"
  433|       |
  434|       |extension SharedSequenceConvertibleType where SharingStrategy == DriverSharingStrategy {
  435|       |    /**
  436|       |     Creates new subscription and sends elements to variable.
  437|       |     This method can be only called from `MainThread`.
  438|       |
  439|       |     - parameter variable: Target variable for sequence elements.
  440|       |     - returns: Disposable object that can be used to unsubscribe the observer from the variable.
  441|       |     */
  442|      0|    public func drive(_ variable: Variable<E>) -> Disposable {
  443|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
  444|      0|        return self.drive(onNext: { e in
  445|      0|            variable.value = e
  446|      0|        })
  447|      0|    }
  448|       |
  449|       |    /**
  450|       |     Creates new subscription and sends elements to variable.
  451|       |     This method can be only called from `MainThread`.
  452|       |
  453|       |     - parameter variable: Target variable for sequence elements.
  454|       |     - returns: Disposable object that can be used to unsubscribe the observer from the variable.
  455|       |     */
  456|      0|    public func drive(_ variable: Variable<E?>) -> Disposable {
  457|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
  458|      0|        return self.drive(onNext: { e in
  459|      0|            variable.value = e
  460|      0|        })
  461|      0|    }
  462|       |}
  463|       |
  464|       |extension ObservableType {
  465|       |    /**
  466|       |     Creates new subscription and sends elements to variable.
  467|       |
  468|       |     In case error occurs in debug mode, `fatalError` will be raised.
  469|       |     In case error occurs in release mode, `error` will be logged.
  470|       |
  471|       |     - parameter to: Target variable for sequence elements.
  472|       |     - returns: Disposable object that can be used to unsubscribe the observer.
  473|       |     */
  474|      0|    public func bind(to variable: Variable<E>) -> Disposable {
  475|      0|        return self.subscribe { e in
  476|      0|            switch e {
  477|      0|            case let .next(element):
  478|      0|                variable.value = element
  479|      0|            case let .error(error):
  480|      0|                let error = "Binding error to variable: \(error)"
  481|      0|                #if DEBUG
  482|      0|                    rxFatalError(error)
  483|      0|                #else
  484|      0|                    print(error)
  485|      0|                #endif
  486|      0|            case .completed:
  487|      0|                break
  488|      0|            }
  489|      0|        }
  490|      0|    }
  491|       |
  492|       |    /**
  493|       |     Creates new subscription and sends elements to variable.
  494|       |
  495|       |     In case error occurs in debug mode, `fatalError` will be raised.
  496|       |     In case error occurs in release mode, `error` will be logged.
  497|       |
  498|       |     - parameter to: Target variable for sequence elements.
  499|       |     - returns: Disposable object that can be used to unsubscribe the observer.
  500|       |     */
  501|      0|    public func bind(to variable: Variable<E?>) -> Disposable {
  502|      0|        return self.map { $0 as E? }.bind(to: variable)
  503|      0|    }
  504|       |}
  505|       |
  506|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable+CoreGraphics.swift:
    1|       |//
    2|       |//  KVORepresentable+CoreGraphics.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import RxSwift
   12|       |import CoreGraphics
   13|       |
   14|       |import class Foundation.NSValue
   15|       |
   16|       |#if arch(x86_64) || arch(arm64)
   17|       |	let CGRectType = "{CGRect={CGPoint=dd}{CGSize=dd}}"
   18|       |    let CGSizeType = "{CGSize=dd}"
   19|       |    let CGPointType = "{CGPoint=dd}"
   20|       |#elseif arch(i386) || arch(arm) || arch(arm64_32)
   21|       |    let CGRectType = "{CGRect={CGPoint=ff}{CGSize=ff}}"
   22|       |    let CGSizeType = "{CGSize=ff}"
   23|       |    let CGPointType = "{CGPoint=ff}"
   24|       |#endif
   25|       |
   26|       |extension CGRect : KVORepresentable {
   27|       |    public typealias KVOType = NSValue
   28|       |
   29|       |    /// Constructs self from `NSValue`.
   30|      0|    public init?(KVOValue: KVOType) {
   31|      0|        if strcmp(KVOValue.objCType, CGRectType) != 0 {
   32|      0|            return nil
   33|      0|        }
   34|      0|        var typedValue = CGRect(x: 0, y: 0, width: 0, height: 0)
   35|      0|        KVOValue.getValue(&typedValue)
   36|      0|        self = typedValue
   37|      0|    }
   38|       |}
   39|       |
   40|       |extension CGPoint : KVORepresentable {
   41|       |    public typealias KVOType = NSValue
   42|       |
   43|       |    /// Constructs self from `NSValue`.
   44|      0|    public init?(KVOValue: KVOType) {
   45|      0|        if strcmp(KVOValue.objCType, CGPointType) != 0 {
   46|      0|            return nil
   47|      0|        }
   48|      0|        var typedValue = CGPoint(x: 0, y: 0)
   49|      0|        KVOValue.getValue(&typedValue)
   50|      0|        self = typedValue
   51|      0|    }
   52|       |}
   53|       |
   54|       |extension CGSize : KVORepresentable {
   55|       |    public typealias KVOType = NSValue
   56|       |
   57|       |    /// Constructs self from `NSValue`.
   58|      0|    public init?(KVOValue: KVOType) {
   59|      0|        if strcmp(KVOValue.objCType, CGSizeType) != 0 {
   60|      0|            return nil
   61|      0|        }
   62|      0|        var typedValue = CGSize(width: 0, height: 0)
   63|      0|        KVOValue.getValue(&typedValue)
   64|      0|        self = typedValue
   65|      0|    }
   66|       |}
   67|       |
   68|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable+Swift.swift:
    1|       |//
    2|       |//  KVORepresentable+Swift.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSNumber
   10|       |
   11|       |extension Int : KVORepresentable {
   12|       |    public typealias KVOType = NSNumber
   13|       |
   14|       |    /// Constructs `Self` using KVO value.
   15|      0|    public init?(KVOValue: KVOType) {
   16|      0|        self.init(KVOValue.int32Value)
   17|      0|    }
   18|       |}
   19|       |
   20|       |extension Int32 : KVORepresentable {
   21|       |    public typealias KVOType = NSNumber
   22|       |
   23|       |    /// Constructs `Self` using KVO value.
   24|      0|    public init?(KVOValue: KVOType) {
   25|      0|        self.init(KVOValue.int32Value)
   26|      0|    }
   27|       |}
   28|       |
   29|       |extension Int64 : KVORepresentable {
   30|       |    public typealias KVOType = NSNumber
   31|       |
   32|       |    /// Constructs `Self` using KVO value.
   33|      0|    public init?(KVOValue: KVOType) {
   34|      0|        self.init(KVOValue.int64Value)
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension UInt : KVORepresentable {
   39|       |    public typealias KVOType = NSNumber
   40|       |
   41|       |    /// Constructs `Self` using KVO value.
   42|      0|    public init?(KVOValue: KVOType) {
   43|      0|        self.init(KVOValue.uintValue)
   44|      0|    }
   45|       |}
   46|       |
   47|       |extension UInt32 : KVORepresentable {
   48|       |    public typealias KVOType = NSNumber
   49|       |
   50|       |    /// Constructs `Self` using KVO value.
   51|      0|    public init?(KVOValue: KVOType) {
   52|      0|        self.init(KVOValue.uint32Value)
   53|      0|    }
   54|       |}
   55|       |
   56|       |extension UInt64 : KVORepresentable {
   57|       |    public typealias KVOType = NSNumber
   58|       |
   59|       |    /// Constructs `Self` using KVO value.
   60|      0|    public init?(KVOValue: KVOType) {
   61|      0|        self.init(KVOValue.uint64Value)
   62|      0|    }
   63|       |}
   64|       |
   65|       |extension Bool : KVORepresentable {
   66|       |    public typealias KVOType = NSNumber
   67|       |
   68|       |    /// Constructs `Self` using KVO value.
   69|      0|    public init?(KVOValue: KVOType) {
   70|      0|        self.init(KVOValue.boolValue)
   71|      0|    }
   72|       |}
   73|       |
   74|       |
   75|       |extension RawRepresentable where RawValue: KVORepresentable {
   76|       |    /// Constructs `Self` using optional KVO value.
   77|      0|    init?(KVOValue: RawValue.KVOType?) {
   78|      0|        guard let KVOValue = KVOValue else {
   79|      0|            return nil
   80|      0|        }
   81|      0|
   82|      0|        guard let rawValue = RawValue(KVOValue: KVOValue) else {
   83|      0|            return nil
   84|      0|        }
   85|      0|
   86|      0|        self.init(rawValue: rawValue)
   87|      0|    }
   88|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable.swift:
    1|       |//
    2|       |//  KVORepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Type that is KVO representable (KVO mechanism can be used to observe it).
   10|       |public protocol KVORepresentable {
   11|       |    /// Associated KVO type.
   12|       |    associatedtype KVOType
   13|       |
   14|       |    /// Constructs `Self` using KVO value.
   15|       |    init?(KVOValue: KVOType)
   16|       |}
   17|       |
   18|       |extension KVORepresentable {
   19|       |    /// Initializes `KVORepresentable` with optional value.
   20|      0|    init?(KVOValue: KVOType?) {
   21|      0|        guard let KVOValue = KVOValue else {
   22|      0|            return nil
   23|      0|        }
   24|      0|
   25|      0|        self.init(KVOValue: KVOValue)
   26|      0|    }
   27|       |}
   28|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/Logging.swift:
    1|       |//
    2|       |//  Logging.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/3/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.URLRequest
   10|       |
   11|       |/// Simple logging settings for RxCocoa library.
   12|       |public struct Logging {
   13|       |    public typealias LogURLRequest = (URLRequest) -> Bool
   14|       |    
   15|       |    /// Log URL requests to standard output in curl format.
   16|      0|    public static var URLRequests: LogURLRequest =  { _ in
   17|      0|    #if DEBUG
   18|      0|        return true
   19|      0|    #else
   20|      0|        return false
   21|      0|    #endif
   22|      0|    }
   23|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx+KVORepresentable.swift:
    1|       |//
    2|       |//  NSObject+Rx+KVORepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import Foundation.NSObject
   12|       |import RxSwift
   13|       |
   14|       |/// Key value observing options
   15|       |public struct KeyValueObservingOptions: OptionSet {
   16|       |    /// Raw value
   17|       |    public let rawValue: UInt
   18|       |
   19|      0|    public init(rawValue: UInt) {
   20|      0|        self.rawValue = rawValue
   21|      0|    }
   22|       |
   23|       |    /// Whether a sequence element should be sent to the observer immediately, before the subscribe method even returns.
   24|       |    public static let initial = KeyValueObservingOptions(rawValue: 1 << 0)
   25|       |    /// Whether to send updated values.
   26|       |    public static let new = KeyValueObservingOptions(rawValue: 1 << 1)
   27|       |}
   28|       |
   29|       |extension Reactive where Base: NSObject {
   30|       |
   31|       |    /**
   32|       |     Specialization of generic `observe` method.
   33|       |
   34|       |     This is a special overload because to observe values of some type (for example `Int`), first values of KVO type
   35|       |     need to be observed (`NSNumber`), and then converted to result type.
   36|       |
   37|       |     For more information take a look at `observe` method.
   38|       |     */
   39|      0|    public func observe<E: KVORepresentable>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> {
   40|      0|        return self.observe(E.KVOType.self, keyPath, options: options, retainSelf: retainSelf)
   41|      0|            .map(E.init)
   42|      0|    }
   43|       |}
   44|       |
   45|       |#if !DISABLE_SWIZZLING && !os(Linux)
   46|       |    // KVO
   47|       |    extension Reactive where Base: NSObject {
   48|       |        /**
   49|       |        Specialization of generic `observeWeakly` method.
   50|       |
   51|       |        For more information take a look at `observeWeakly` method.
   52|       |        */
   53|      0|        public func observeWeakly<E: KVORepresentable>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial]) -> Observable<E?> {
   54|      0|            return self.observeWeakly(E.KVOType.self, keyPath, options: options)
   55|      0|                .map(E.init)
   56|      0|        }
   57|       |    }
   58|       |#endif
   59|       |
   60|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx+RawRepresentable.swift:
    1|       |//
    2|       |//  NSObject+Rx+RawRepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/9/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import RxSwift
   12|       |
   13|       |import Foundation.NSObject
   14|       |
   15|       |extension Reactive where Base: NSObject {
   16|       |    /**
   17|       |     Specialization of generic `observe` method.
   18|       |
   19|       |     This specialization first observes `KVORepresentable` value and then converts it to `RawRepresentable` value.
   20|       |     
   21|       |     It is useful for observing bridged ObjC enum values.
   22|       |
   23|       |     For more information take a look at `observe` method.
   24|       |     */
   25|      0|    public func observe<E: RawRepresentable>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> where E.RawValue: KVORepresentable {
   26|      0|        return self.observe(E.RawValue.KVOType.self, keyPath, options: options, retainSelf: retainSelf)
   27|      0|            .map(E.init)
   28|      0|    }
   29|       |}
   30|       |
   31|       |#if !DISABLE_SWIZZLING
   32|       |
   33|       |    // observeWeakly + RawRepresentable
   34|       |    extension Reactive where Base: NSObject {
   35|       |
   36|       |        /**
   37|       |         Specialization of generic `observeWeakly` method.
   38|       |
   39|       |         This specialization first observes `KVORepresentable` value and then converts it to `RawRepresentable` value.
   40|       |     
   41|       |         It is useful for observing bridged ObjC enum values.
   42|       |
   43|       |         For more information take a look at `observeWeakly` method.
   44|       |         */
   45|      0|        public func observeWeakly<E: RawRepresentable>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial]) -> Observable<E?> where E.RawValue: KVORepresentable {
   46|      0|            return self.observeWeakly(E.RawValue.KVOType.self, keyPath, options: options)
   47|      0|                .map(E.init)
   48|      0|        }
   49|       |    }
   50|       |#endif
   51|       |
   52|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx.swift:
    1|       |//
    2|       |//  NSObject+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import Foundation.NSObject
   12|       |import RxSwift
   13|       |#if SWIFT_PACKAGE && !DISABLE_SWIZZLING && !os(Linux)
   14|       |    import RxCocoaRuntime
   15|       |#endif
   16|       |
   17|       |#if !DISABLE_SWIZZLING && !os(Linux)
   18|       |private var deallocatingSubjectTriggerContext: UInt8 = 0
   19|       |private var deallocatingSubjectContext: UInt8 = 0
   20|       |#endif
   21|       |private var deallocatedSubjectTriggerContext: UInt8 = 0
   22|       |private var deallocatedSubjectContext: UInt8 = 0
   23|       |
   24|       |#if !os(Linux)
   25|       |
   26|       |/**
   27|       |KVO is a tricky mechanism.
   28|       |
   29|       |When observing child in a ownership hierarchy, usually retaining observing target is wanted behavior.
   30|       |When observing parent in a ownership hierarchy, usually retaining target isn't wanter behavior.
   31|       |
   32|       |KVO with weak references is especially tricky. For it to work, some kind of swizzling is required.
   33|       |That can be done by
   34|       |    * replacing object class dynamically (like KVO does)
   35|       |    * by swizzling `dealloc` method on all instances for a class.
   36|       |    * some third method ...
   37|       |
   38|       |Both approaches can fail in certain scenarios:
   39|       |    * problems arise when swizzlers return original object class (like KVO does when nobody is observing)
   40|       |    * Problems can arise because replacing dealloc method isn't atomic operation (get implementation,
   41|       |    set implementation).
   42|       |
   43|       |Second approach is chosen. It can fail in case there are multiple libraries dynamically trying
   44|       |to replace dealloc method. In case that isn't the case, it should be ok.
   45|       |*/
   46|       |extension Reactive where Base: NSObject {
   47|       |
   48|       |
   49|       |    /**
   50|       |     Observes values on `keyPath` starting from `self` with `options` and retains `self` if `retainSelf` is set.
   51|       |
   52|       |     `observe` is just a simple and performant wrapper around KVO mechanism.
   53|       |
   54|       |     * it can be used to observe paths starting from `self` or from ancestors in ownership graph (`retainSelf = false`)
   55|       |     * it can be used to observe paths starting from descendants in ownership graph (`retainSelf = true`)
   56|       |     * the paths have to consist only of `strong` properties, otherwise you are risking crashing the system by not unregistering KVO observer before dealloc.
   57|       |
   58|       |     If support for weak properties is needed or observing arbitrary or unknown relationships in the
   59|       |     ownership tree, `observeWeakly` is the preferred option.
   60|       |
   61|       |     - parameter keyPath: Key path of property names to observe.
   62|       |     - parameter options: KVO mechanism notification options.
   63|       |     - parameter retainSelf: Retains self during observation if set `true`.
   64|       |     - returns: Observable sequence of objects on `keyPath`.
   65|       |     */
   66|      0|    public func observe<E>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> {
   67|      0|        return KVOObservable(object: self.base, keyPath: keyPath, options: options, retainTarget: retainSelf).asObservable()
   68|      0|    }
   69|       |}
   70|       |
   71|       |#endif
   72|       |
   73|       |#if !DISABLE_SWIZZLING && !os(Linux)
   74|       |// KVO
   75|       |extension Reactive where Base: NSObject {
   76|       |    /**
   77|       |     Observes values on `keyPath` starting from `self` with `options` and doesn't retain `self`.
   78|       |
   79|       |     It can be used in all cases where `observe` can be used and additionally
   80|       |
   81|       |     * because it won't retain observed target, it can be used to observe arbitrary object graph whose ownership relation is unknown
   82|       |     * it can be used to observe `weak` properties
   83|       |
   84|       |     **Since it needs to intercept object deallocation process it needs to perform swizzling of `dealloc` method on observed object.**
   85|       |
   86|       |     - parameter keyPath: Key path of property names to observe.
   87|       |     - parameter options: KVO mechanism notification options.
   88|       |     - returns: Observable sequence of objects on `keyPath`.
   89|       |     */
   90|      0|    public func observeWeakly<E>(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial]) -> Observable<E?> {
   91|      0|        return observeWeaklyKeyPathFor(self.base, keyPath: keyPath, options: options)
   92|      0|            .map { n in
   93|      0|                return n as? E
   94|      0|            }
   95|      0|    }
   96|       |}
   97|       |#endif
   98|       |
   99|       |// Dealloc
  100|       |extension Reactive where Base: AnyObject {
  101|       |    
  102|       |    /**
  103|       |    Observable sequence of object deallocated events.
  104|       |    
  105|       |    After object is deallocated one `()` element will be produced and sequence will immediately complete.
  106|       |    
  107|       |    - returns: Observable sequence of object deallocated events.
  108|       |    */
  109|      0|    public var deallocated: Observable<Void> {
  110|      0|        return self.synchronized {
  111|      0|            if let deallocObservable = objc_getAssociatedObject(self.base, &deallocatedSubjectContext) as? DeallocObservable {
  112|      0|                return deallocObservable._subject
  113|      0|            }
  114|      0|
  115|      0|            let deallocObservable = DeallocObservable()
  116|      0|
  117|      0|            objc_setAssociatedObject(self.base, &deallocatedSubjectContext, deallocObservable, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  118|      0|            return deallocObservable._subject
  119|      0|        }
  120|      0|    }
  121|       |
  122|       |#if !DISABLE_SWIZZLING && !os(Linux)
  123|       |
  124|       |    /**
  125|       |     Observable sequence of message arguments that completes when object is deallocated.
  126|       |     
  127|       |     Each element is produced before message is invoked on target object. `methodInvoked`
  128|       |     exists in case observing of invoked messages is needed.
  129|       |
  130|       |     In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  131|       |     
  132|       |     In case some argument is `nil`, instance of `NSNull()` will be sent.
  133|       |
  134|       |     - returns: Observable sequence of arguments passed to `selector` method.
  135|       |     */
  136|      0|    public func sentMessage(_ selector: Selector) -> Observable<[Any]> {
  137|      0|        return self.synchronized {
  138|      0|            // in case of dealloc selector replay subject behavior needs to be used
  139|      0|            if selector == deallocSelector {
  140|      0|                return self.deallocating.map { _ in [] }
  141|      0|            }
  142|      0|
  143|      0|            do {
  144|      0|                let proxy: MessageSentProxy = try self.registerMessageInterceptor(selector)
  145|      0|                return proxy.messageSent.asObservable()
  146|      0|            }
  147|      0|            catch let e {
  148|      0|                return Observable.error(e)
  149|      0|            }
  150|      0|        }
  151|      0|    }
  152|       |
  153|       |    /**
  154|       |     Observable sequence of message arguments that completes when object is deallocated.
  155|       |
  156|       |     Each element is produced after message is invoked on target object. `sentMessage`
  157|       |     exists in case interception of sent messages before they were invoked is needed.
  158|       |
  159|       |     In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  160|       |
  161|       |     In case some argument is `nil`, instance of `NSNull()` will be sent.
  162|       |
  163|       |     - returns: Observable sequence of arguments passed to `selector` method.
  164|       |     */
  165|      0|    public func methodInvoked(_ selector: Selector) -> Observable<[Any]> {
  166|      0|        return self.synchronized {
  167|      0|            // in case of dealloc selector replay subject behavior needs to be used
  168|      0|            if selector == deallocSelector {
  169|      0|                return self.deallocated.map { _ in [] }
  170|      0|            }
  171|      0|
  172|      0|
  173|      0|            do {
  174|      0|                let proxy: MessageSentProxy = try self.registerMessageInterceptor(selector)
  175|      0|                return proxy.methodInvoked.asObservable()
  176|      0|            }
  177|      0|            catch let e {
  178|      0|                return Observable.error(e)
  179|      0|            }
  180|      0|        }
  181|      0|    }
  182|       |
  183|       |    /**
  184|       |    Observable sequence of object deallocating events.
  185|       |    
  186|       |    When `dealloc` message is sent to `self` one `()` element will be produced and after object is deallocated sequence
  187|       |    will immediately complete.
  188|       |     
  189|       |    In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  190|       |    
  191|       |    - returns: Observable sequence of object deallocating events.
  192|       |    */
  193|       |    public var deallocating: Observable<()> {
  194|      0|        return self.synchronized {
  195|      0|            do {
  196|      0|                let proxy: DeallocatingProxy = try self.registerMessageInterceptor(deallocSelector)
  197|      0|                return proxy.messageSent.asObservable()
  198|      0|            }
  199|      0|            catch let e {
  200|      0|                return Observable.error(e)
  201|      0|            }
  202|      0|        }
  203|       |    }
  204|       |
  205|       |    fileprivate func registerMessageInterceptor<T: MessageInterceptorSubject>(_ selector: Selector) throws -> T {
  206|       |        let rxSelector = RX_selector(selector)
  207|       |        let selectorReference = RX_reference_from_selector(rxSelector)
  208|       |
  209|       |        let subject: T
  210|       |        if let existingSubject = objc_getAssociatedObject(self.base, selectorReference) as? T {
  211|       |            subject = existingSubject
  212|       |        }
  213|       |        else {
  214|       |            subject = T()
  215|       |            objc_setAssociatedObject(
  216|       |                self.base,
  217|       |                selectorReference,
  218|       |                subject,
  219|       |                .OBJC_ASSOCIATION_RETAIN_NONATOMIC
  220|       |            )
  221|       |        }
  222|       |
  223|       |        if subject.isActive {
  224|       |            return subject
  225|       |        }
  226|       |
  227|       |        var error: NSError?
  228|       |        let targetImplementation = RX_ensure_observing(self.base, selector, &error)
  229|       |        if targetImplementation == nil {
  230|       |            throw error?.rxCocoaErrorForTarget(self.base) ?? RxCocoaError.unknown
  231|       |        }
  232|       |
  233|       |        subject.targetImplementation = targetImplementation!
  234|       |
  235|       |        return subject
  236|       |    }
  237|       |#endif
  238|       |}
  239|       |
  240|       |// MARK: Message interceptors
  241|       |
  242|       |#if !DISABLE_SWIZZLING && !os(Linux)
  243|       |
  244|       |    private protocol MessageInterceptorSubject: class {
  245|       |        init()
  246|       |
  247|       |        var isActive: Bool {
  248|       |            get
  249|       |        }
  250|       |
  251|       |        var targetImplementation: IMP { get set }
  252|       |    }
  253|       |
  254|       |    fileprivate final class DeallocatingProxy
  255|       |        : MessageInterceptorSubject
  256|       |        , RXDeallocatingObserver {
  257|       |        typealias E = ()
  258|       |
  259|       |        let messageSent = ReplaySubject<()>.create(bufferSize: 1)
  260|       |
  261|       |        @objc var targetImplementation: IMP = RX_default_target_implementation()
  262|       |
  263|      0|        var isActive: Bool {
  264|      0|            return self.targetImplementation != RX_default_target_implementation()
  265|      0|        }
  266|       |
  267|      0|        init() {
  268|      0|        }
  269|       |
  270|      0|        @objc func deallocating() {
  271|      0|            self.messageSent.on(.next(()))
  272|      0|        }
  273|       |
  274|      0|        deinit {
  275|      0|            self.messageSent.on(.completed)
  276|      0|        }
  277|       |    }
  278|       |
  279|       |    fileprivate final class MessageSentProxy
  280|       |        : MessageInterceptorSubject
  281|       |        , RXMessageSentObserver {
  282|       |        typealias E = [AnyObject]
  283|       |
  284|       |        let messageSent = PublishSubject<[Any]>()
  285|       |        let methodInvoked = PublishSubject<[Any]>()
  286|       |
  287|       |        @objc var targetImplementation: IMP = RX_default_target_implementation()
  288|       |
  289|      0|        var isActive: Bool {
  290|      0|            return self.targetImplementation != RX_default_target_implementation()
  291|      0|        }
  292|       |
  293|      0|        init() {
  294|      0|        }
  295|       |
  296|      0|        @objc func messageSent(withArguments arguments: [Any]) {
  297|      0|            self.messageSent.on(.next(arguments))
  298|      0|        }
  299|       |
  300|      0|        @objc func methodInvoked(withArguments arguments: [Any]) {
  301|      0|            self.methodInvoked.on(.next(arguments))
  302|      0|        }
  303|       |
  304|      0|        deinit {
  305|      0|            self.messageSent.on(.completed)
  306|      0|            self.methodInvoked.on(.completed)
  307|      0|        }
  308|       |    }
  309|       |
  310|       |#endif
  311|       |
  312|       |
  313|       |fileprivate final class DeallocObservable {
  314|       |    let _subject = ReplaySubject<Void>.create(bufferSize:1)
  315|       |
  316|      0|    init() {
  317|      0|    }
  318|       |
  319|      0|    deinit {
  320|      0|        self._subject.on(.next(()))
  321|      0|        self._subject.on(.completed)
  322|      0|    }
  323|       |}
  324|       |
  325|       |// MARK: KVO
  326|       |
  327|       |#if !os(Linux)
  328|       |
  329|       |private protocol KVOObservableProtocol {
  330|       |    var target: AnyObject { get }
  331|       |    var keyPath: String { get }
  332|       |    var retainTarget: Bool { get }
  333|       |    var options: KeyValueObservingOptions { get }
  334|       |}
  335|       |
  336|       |fileprivate final class KVOObserver
  337|       |    : _RXKVOObserver
  338|       |    , Disposable {
  339|       |    typealias Callback = (Any?) -> Void
  340|       |
  341|       |    var retainSelf: KVOObserver?
  342|       |
  343|      0|    init(parent: KVOObservableProtocol, callback: @escaping Callback) {
  344|      0|        #if TRACE_RESOURCES
  345|      0|            _ = Resources.incrementTotal()
  346|      0|        #endif
  347|      0|
  348|      0|        super.init(target: parent.target, retainTarget: parent.retainTarget, keyPath: parent.keyPath, options: parent.options.nsOptions, callback: callback)
  349|      0|        self.retainSelf = self
  350|      0|    }
  351|       |
  352|      0|    override func dispose() {
  353|      0|        super.dispose()
  354|      0|        self.retainSelf = nil
  355|      0|    }
  356|       |
  357|      0|    deinit {
  358|      0|        #if TRACE_RESOURCES
  359|      0|            _ = Resources.decrementTotal()
  360|      0|        #endif
  361|      0|    }
  362|       |}
  363|       |
  364|       |fileprivate final class KVOObservable<Element>
  365|       |    : ObservableType
  366|       |    , KVOObservableProtocol {
  367|       |    typealias E = Element?
  368|       |
  369|       |    unowned var target: AnyObject
  370|       |    var strongTarget: AnyObject?
  371|       |
  372|       |    var keyPath: String
  373|       |    var options: KeyValueObservingOptions
  374|       |    var retainTarget: Bool
  375|       |
  376|      0|    init(object: AnyObject, keyPath: String, options: KeyValueObservingOptions, retainTarget: Bool) {
  377|      0|        self.target = object
  378|      0|        self.keyPath = keyPath
  379|      0|        self.options = options
  380|      0|        self.retainTarget = retainTarget
  381|      0|        if retainTarget {
  382|      0|            self.strongTarget = object
  383|      0|        }
  384|      0|    }
  385|       |
  386|      0|    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == Element? {
  387|      0|        let observer = KVOObserver(parent: self) { value in
  388|      0|            if value as? NSNull != nil {
  389|      0|                observer.on(.next(nil))
  390|      0|                return
  391|      0|            }
  392|      0|            observer.on(.next(value as? Element))
  393|      0|        }
  394|      0|
  395|      0|        return Disposables.create(with: observer.dispose)
  396|      0|    }
  397|       |
  398|       |}
  399|       |
  400|       |fileprivate extension KeyValueObservingOptions {
  401|       |    var nsOptions: NSKeyValueObservingOptions {
  402|       |        var result: UInt = 0
  403|       |        if self.contains(.new) {
  404|       |            result |= NSKeyValueObservingOptions.new.rawValue
  405|       |        }
  406|       |        if self.contains(.initial) {
  407|       |            result |= NSKeyValueObservingOptions.initial.rawValue
  408|       |        }
  409|       |        
  410|       |        return NSKeyValueObservingOptions(rawValue: result)
  411|       |    }
  412|       |}
  413|       |
  414|       |#endif
  415|       |
  416|       |#if !DISABLE_SWIZZLING && !os(Linux)
  417|       |
  418|       |    private func observeWeaklyKeyPathFor(_ target: NSObject, keyPath: String, options: KeyValueObservingOptions) -> Observable<AnyObject?> {
  419|      0|        let components = keyPath.components(separatedBy: ".").filter { $0 != "self" }
  420|       |
  421|       |        let observable = observeWeaklyKeyPathFor(target, keyPathSections: components, options: options)
  422|       |            .finishWithNilWhenDealloc(target)
  423|       |
  424|       |        if !options.isDisjoint(with: .initial) {
  425|       |            return observable
  426|       |        }
  427|       |        else {
  428|       |            return observable
  429|       |                .skip(1)
  430|       |        }
  431|       |    }
  432|       |
  433|       |    // This should work correctly
  434|       |    // Identifiers can't contain `,`, so the only place where `,` can appear
  435|       |    // is as a delimiter.
  436|       |    // This means there is `W` as element in an array of property attributes.
  437|      0|    private func isWeakProperty(_ properyRuntimeInfo: String) -> Bool {
  438|      0|        return properyRuntimeInfo.range(of: ",W,") != nil
  439|      0|    }
  440|       |
  441|       |    fileprivate extension ObservableType where E == AnyObject? {
  442|       |        func finishWithNilWhenDealloc(_ target: NSObject)
  443|       |            -> Observable<AnyObject?> {
  444|       |                let deallocating = target.rx.deallocating
  445|       |
  446|       |                return deallocating
  447|      0|                    .map { _ in
  448|      0|                        return Observable.just(nil)
  449|      0|                    }
  450|       |                    .startWith(self.asObservable())
  451|       |                    .switchLatest()
  452|       |        }
  453|       |    }
  454|       |
  455|       |    private func observeWeaklyKeyPathFor(
  456|       |        _ target: NSObject,
  457|       |        keyPathSections: [String],
  458|       |        options: KeyValueObservingOptions
  459|       |        ) -> Observable<AnyObject?> {
  460|       |
  461|       |        weak var weakTarget: AnyObject? = target
  462|       |
  463|       |        let propertyName = keyPathSections[0]
  464|       |        let remainingPaths = Array(keyPathSections[1..<keyPathSections.count])
  465|       |
  466|       |        let property = class_getProperty(object_getClass(target), propertyName)
  467|       |        if property == nil {
  468|       |            return Observable.error(RxCocoaError.invalidPropertyName(object: target, propertyName: propertyName))
  469|       |        }
  470|       |        let propertyAttributes = property_getAttributes(property!)
  471|       |
  472|       |        // should dealloc hook be in place if week property, or just create strong reference because it doesn't matter
  473|       |        let isWeak = isWeakProperty(propertyAttributes.map(String.init) ?? "")
  474|       |        let propertyObservable = KVOObservable(object: target, keyPath: propertyName, options: options.union(.initial), retainTarget: false) as KVOObservable<AnyObject>
  475|       |
  476|       |        // KVO recursion for value changes
  477|       |        return propertyObservable
  478|      0|            .flatMapLatest { (nextTarget: AnyObject?) -> Observable<AnyObject?> in
  479|      0|                if nextTarget == nil {
  480|      0|                    return Observable.just(nil)
  481|      0|                }
  482|      0|                let nextObject = nextTarget! as? NSObject
  483|      0|
  484|      0|                let strongTarget: AnyObject? = weakTarget
  485|      0|
  486|      0|                if nextObject == nil {
  487|      0|                    return Observable.error(RxCocoaError.invalidObjectOnKeyPath(object: nextTarget!, sourceObject: strongTarget ?? NSNull(), propertyName: propertyName))
  488|      0|                }
  489|      0|
  490|      0|                // if target is alive, then send change
  491|      0|                // if it's deallocated, don't send anything
  492|      0|                if strongTarget == nil {
  493|      0|                    return Observable.empty()
  494|      0|                }
  495|      0|
  496|      0|                let nextElementsObservable = keyPathSections.count == 1
  497|      0|                    ? Observable.just(nextTarget)
  498|      0|                    : observeWeaklyKeyPathFor(nextObject!, keyPathSections: remainingPaths, options: options)
  499|      0|                
  500|      0|                if isWeak {
  501|      0|                    return nextElementsObservable
  502|      0|                        .finishWithNilWhenDealloc(nextObject!)
  503|      0|                }
  504|      0|                else {
  505|      0|                    return nextElementsObservable
  506|      0|                }
  507|      0|        }
  508|       |    }
  509|       |#endif
  510|       |
  511|       |// MARK: Constants
  512|       |
  513|       |private let deallocSelector = NSSelectorFromString("dealloc")
  514|       |
  515|       |// MARK: AnyObject + Reactive
  516|       |
  517|       |extension Reactive where Base: AnyObject {
  518|       |    func synchronized<T>( _ action: () -> T) -> T {
  519|       |        objc_sync_enter(self.base)
  520|       |        let result = action()
  521|       |        objc_sync_exit(self.base)
  522|       |        return result
  523|       |    }
  524|       |}
  525|       |
  526|       |extension Reactive where Base: AnyObject {
  527|       |    /**
  528|       |     Helper to make sure that `Observable` returned from `createCachedObservable` is only created once.
  529|       |     This is important because there is only one `target` and `action` properties on `NSControl` or `UIBarButtonItem`.
  530|       |     */
  531|      0|    func lazyInstanceObservable<T: AnyObject>(_ key: UnsafeRawPointer, createCachedObservable: () -> T) -> T {
  532|      0|        if let value = objc_getAssociatedObject(self.base, key) {
  533|      0|            return value as! T
  534|      0|        }
  535|      0|        
  536|      0|        let observable = createCachedObservable()
  537|      0|        
  538|      0|        objc_setAssociatedObject(self.base, key, observable, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  539|      0|        
  540|      0|        return observable
  541|      0|    }
  542|       |}
  543|       |
  544|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/NotificationCenter+Rx.swift:
    1|       |//
    2|       |//  NotificationCenter+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NotificationCenter
   10|       |import struct Foundation.Notification
   11|       |
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: NotificationCenter {
   15|       |    /**
   16|       |    Transforms notifications posted to notification center to observable sequence of notifications.
   17|       |    
   18|       |    - parameter name: Optional name used to filter notifications.
   19|       |    - parameter object: Optional object used to filter notifications.
   20|       |    - returns: Observable sequence of posted notifications.
   21|       |    */
   22|      0|    public func notification(_ name: Notification.Name?, object: AnyObject? = nil) -> Observable<Notification> {
   23|      0|        return Observable.create { [weak object] observer in
   24|      0|            let nsObserver = self.base.addObserver(forName: name, object: object, queue: nil) { notification in
   25|      0|                observer.on(.next(notification))
   26|      0|            }
   27|      0|            
   28|      0|            return Disposables.create {
   29|      0|                self.base.removeObserver(nsObserver)
   30|      0|            }
   31|      0|        }
   32|      0|    }
   33|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Foundation/URLSession+Rx.swift:
    1|       |//
    2|       |//  URLSession+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.URL
   10|       |import struct Foundation.URLRequest
   11|       |import struct Foundation.Data
   12|       |import struct Foundation.Date
   13|       |import struct Foundation.TimeInterval
   14|       |import class Foundation.HTTPURLResponse
   15|       |import class Foundation.URLSession
   16|       |import class Foundation.URLResponse
   17|       |import class Foundation.JSONSerialization
   18|       |import class Foundation.NSError
   19|       |import var Foundation.NSURLErrorCancelled
   20|       |import var Foundation.NSURLErrorDomain
   21|       |
   22|       |#if os(Linux)
   23|       |    // don't know why
   24|       |    import Foundation
   25|       |#endif
   26|       |
   27|       |import RxSwift
   28|       |
   29|       |/// RxCocoa URL errors.
   30|       |public enum RxCocoaURLError
   31|       |    : Swift.Error {
   32|       |    /// Unknown error occurred.
   33|       |    case unknown
   34|       |    /// Response is not NSHTTPURLResponse
   35|       |    case nonHTTPResponse(response: URLResponse)
   36|       |    /// Response is not successful. (not in `200 ..< 300` range)
   37|       |    case httpRequestFailed(response: HTTPURLResponse, data: Data?)
   38|       |    /// Deserialization error.
   39|       |    case deserializationError(error: Swift.Error)
   40|       |}
   41|       |
   42|       |extension RxCocoaURLError
   43|       |    : CustomDebugStringConvertible {
   44|       |    /// A textual representation of `self`, suitable for debugging.
   45|      0|    public var debugDescription: String {
   46|      0|        switch self {
   47|      0|        case .unknown:
   48|      0|            return "Unknown error has occurred."
   49|      0|        case let .nonHTTPResponse(response):
   50|      0|            return "Response is not NSHTTPURLResponse `\(response)`."
   51|      0|        case let .httpRequestFailed(response, _):
   52|      0|            return "HTTP request failed with `\(response.statusCode)`."
   53|      0|        case let .deserializationError(error):
   54|      0|            return "Error during deserialization of the response: \(error)"
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|      0|private func escapeTerminalString(_ value: String) -> String {
   60|      0|    return value.replacingOccurrences(of: "\"", with: "\\\"", options:[], range: nil)
   61|      0|}
   62|       |
   63|      0|fileprivate func convertURLRequestToCurlCommand(_ request: URLRequest) -> String {
   64|      0|    let method = request.httpMethod ?? "GET"
   65|      0|    var returnValue = "curl -X \(method) "
   66|      0|
   67|      0|    if let httpBody = request.httpBody, request.httpMethod == "POST" {
   68|      0|        let maybeBody = String(data: httpBody, encoding: String.Encoding.utf8)
   69|      0|        if let body = maybeBody {
   70|      0|            returnValue += "-d \"\(escapeTerminalString(body))\" "
   71|      0|        }
   72|      0|    }
   73|      0|
   74|      0|    for (key, value) in request.allHTTPHeaderFields ?? [:] {
   75|      0|        let escapedKey = escapeTerminalString(key as String)
   76|      0|        let escapedValue = escapeTerminalString(value as String)
   77|      0|        returnValue += "\n    -H \"\(escapedKey): \(escapedValue)\" "
   78|      0|    }
   79|      0|
   80|      0|    let URLString = request.url?.absoluteString ?? "<unknown url>"
   81|      0|
   82|      0|    returnValue += "\n\"\(escapeTerminalString(URLString))\""
   83|      0|
   84|      0|    returnValue += " -i -v"
   85|      0|
   86|      0|    return returnValue
   87|      0|}
   88|       |
   89|      0|private func convertResponseToString(_ response: URLResponse?, _ error: NSError?, _ interval: TimeInterval) -> String {
   90|      0|    let ms = Int(interval * 1000)
   91|      0|
   92|      0|    if let response = response as? HTTPURLResponse {
   93|      0|        if 200 ..< 300 ~= response.statusCode {
   94|      0|            return "Success (\(ms)ms): Status \(response.statusCode)"
   95|      0|        }
   96|      0|        else {
   97|      0|            return "Failure (\(ms)ms): Status \(response.statusCode)"
   98|      0|        }
   99|      0|    }
  100|      0|
  101|      0|    if let error = error {
  102|      0|        if error.domain == NSURLErrorDomain && error.code == NSURLErrorCancelled {
  103|      0|            return "Canceled (\(ms)ms)"
  104|      0|        }
  105|      0|        return "Failure (\(ms)ms): NSError > \(error)"
  106|      0|    }
  107|      0|
  108|      0|    return "<Unhandled response from server>"
  109|      0|}
  110|       |
  111|       |extension Reactive where Base: URLSession {
  112|       |    /**
  113|       |    Observable sequence of responses for URL request.
  114|       |    
  115|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  116|       |    
  117|       |    **URL requests will be performed per subscribed observer.**
  118|       |    
  119|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  120|       |    
  121|       |    - parameter request: URL request.
  122|       |    - returns: Observable sequence of URL responses.
  123|       |    */
  124|      0|    public func response(request: URLRequest) -> Observable<(response: HTTPURLResponse, data: Data)> {
  125|      0|        return Observable.create { observer in
  126|      0|
  127|      0|            // smart compiler should be able to optimize this out
  128|      0|            let d: Date?
  129|      0|
  130|      0|            if Logging.URLRequests(request) {
  131|      0|                d = Date()
  132|      0|            }
  133|      0|            else {
  134|      0|               d = nil
  135|      0|            }
  136|      0|
  137|      0|            let task = self.base.dataTask(with: request) { data, response, error in
  138|      0|
  139|      0|                if Logging.URLRequests(request) {
  140|      0|                    let interval = Date().timeIntervalSince(d ?? Date())
  141|      0|                    print(convertURLRequestToCurlCommand(request))
  142|      0|                    #if os(Linux)
  143|      0|                        print(convertResponseToString(response, error.flatMap { $0 as? NSError }, interval))
  144|      0|                    #else
  145|      0|                        print(convertResponseToString(response, error.map { $0 as NSError }, interval))
  146|      0|                    #endif
  147|      0|                }
  148|      0|                
  149|      0|                guard let response = response, let data = data else {
  150|      0|                    observer.on(.error(error ?? RxCocoaURLError.unknown))
  151|      0|                    return
  152|      0|                }
  153|      0|
  154|      0|                guard let httpResponse = response as? HTTPURLResponse else {
  155|      0|                    observer.on(.error(RxCocoaURLError.nonHTTPResponse(response: response)))
  156|      0|                    return
  157|      0|                }
  158|      0|
  159|      0|                observer.on(.next((httpResponse, data)))
  160|      0|                observer.on(.completed)
  161|      0|            }
  162|      0|
  163|      0|            task.resume()
  164|      0|
  165|      0|            return Disposables.create(with: task.cancel)
  166|      0|        }
  167|      0|    }
  168|       |
  169|       |    /**
  170|       |    Observable sequence of response data for URL request.
  171|       |    
  172|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  173|       |    
  174|       |    **URL requests will be performed per subscribed observer.**
  175|       |    
  176|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  177|       |    
  178|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  179|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  180|       |    
  181|       |    - parameter request: URL request.
  182|       |    - returns: Observable sequence of response data.
  183|       |    */
  184|      0|    public func data(request: URLRequest) -> Observable<Data> {
  185|      0|        return self.response(request: request).map { pair -> Data in
  186|      0|            if 200 ..< 300 ~= pair.0.statusCode {
  187|      0|                return pair.1
  188|      0|            }
  189|      0|            else {
  190|      0|                throw RxCocoaURLError.httpRequestFailed(response: pair.0, data: pair.1)
  191|      0|            }
  192|      0|        }
  193|      0|    }
  194|       |
  195|       |    /**
  196|       |    Observable sequence of response JSON for URL request.
  197|       |    
  198|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  199|       |    
  200|       |    **URL requests will be performed per subscribed observer.**
  201|       |    
  202|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  203|       |    
  204|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  205|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  206|       |    
  207|       |    If there is an error during JSON deserialization observable sequence will fail with that error.
  208|       |    
  209|       |    - parameter request: URL request.
  210|       |    - returns: Observable sequence of response JSON.
  211|       |    */
  212|      0|    public func json(request: URLRequest, options: JSONSerialization.ReadingOptions = []) -> Observable<Any> {
  213|      0|        return self.data(request: request).map { data -> Any in
  214|      0|            do {
  215|      0|                return try JSONSerialization.jsonObject(with: data, options: options)
  216|      0|            } catch let error {
  217|      0|                throw RxCocoaURLError.deserializationError(error: error)
  218|      0|            }
  219|      0|        }
  220|      0|    }
  221|       |
  222|       |    /**
  223|       |    Observable sequence of response JSON for GET request with `URL`.
  224|       |     
  225|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  226|       |    
  227|       |    **URL requests will be performed per subscribed observer.**
  228|       |    
  229|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  230|       |    
  231|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  232|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  233|       |    
  234|       |    If there is an error during JSON deserialization observable sequence will fail with that error.
  235|       |    
  236|       |    - parameter url: URL of `NSURLRequest` request.
  237|       |    - returns: Observable sequence of response JSON.
  238|       |    */
  239|      0|    public func json(url: Foundation.URL) -> Observable<Any> {
  240|      0|        return self.json(request: URLRequest(url: url))
  241|      0|    }
  242|       |}
  243|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXDelegateProxy.m:
    1|       |//
    2|       |//  _RXDelegateProxy.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "include/_RXDelegateProxy.h"
   10|       |#import "include/_RX.h"
   11|       |#import "include/_RXObjCRuntime.h"
   12|       |
   13|       |@interface _RXDelegateProxy () {
   14|       |    id __weak __forwardToDelegate;
   15|       |}
   16|       |
   17|       |@property (nonatomic, strong) id strongForwardDelegate;
   18|       |
   19|       |@end
   20|       |
   21|       |static NSMutableDictionary *voidSelectorsPerClass = nil;
   22|       |
   23|       |@implementation _RXDelegateProxy
   24|       |
   25|      0|+(NSSet*)collectVoidSelectorsForProtocol:(Protocol *)protocol {
   26|      0|    NSMutableSet *selectors = [NSMutableSet set];
   27|      0|
   28|      0|    unsigned int protocolMethodCount = 0;
   29|      0|    struct objc_method_description *pMethods = protocol_copyMethodDescriptionList(protocol, NO, YES, &protocolMethodCount);
   30|      0|
   31|      0|    for (unsigned int i = 0; i < protocolMethodCount; ++i) {
   32|      0|        struct objc_method_description method = pMethods[i];
   33|      0|        if (RX_is_method_with_description_void(method)) {
   34|      0|            [selectors addObject:SEL_VALUE(method.name)];
   35|      0|        }
   36|      0|    }
   37|      0|            
   38|      0|    free(pMethods);
   39|      0|
   40|      0|    unsigned int numberOfBaseProtocols = 0;
   41|      0|    Protocol * __unsafe_unretained * pSubprotocols = protocol_copyProtocolList(protocol, &numberOfBaseProtocols);
   42|      0|
   43|      0|    for (unsigned int i = 0; i < numberOfBaseProtocols; ++i) {
   44|      0|        [selectors unionSet:[self collectVoidSelectorsForProtocol:pSubprotocols[i]]];
   45|      0|    }
   46|      0|    
   47|      0|    free(pSubprotocols);
   48|      0|
   49|      0|    return selectors;
   50|      0|}
   51|       |
   52|      0|+(void)initialize {
   53|      0|    @synchronized (_RXDelegateProxy.class) {
   54|      0|        if (voidSelectorsPerClass == nil) {
   55|      0|            voidSelectorsPerClass = [[NSMutableDictionary alloc] init];
   56|      0|        }
   57|      0|
   58|      0|        NSMutableSet *voidSelectors = [NSMutableSet set];
   59|      0|
   60|      0|#define CLASS_HIERARCHY_MAX_DEPTH 100
   61|      0|
   62|      0|        NSInteger  classHierarchyDepth = 0;
   63|      0|        Class      targetClass         = NULL;
   64|      0|
   65|      0|        for (classHierarchyDepth = 0, targetClass = self;
   66|      0|             classHierarchyDepth < CLASS_HIERARCHY_MAX_DEPTH && targetClass != nil;
   67|      0|             ++classHierarchyDepth, targetClass = class_getSuperclass(targetClass)
   68|      0|        ) {
   69|      0|            unsigned int count;
   70|      0|            Protocol *__unsafe_unretained *pProtocols = class_copyProtocolList(targetClass, &count);
   71|      0|            
   72|      0|            for (unsigned int i = 0; i < count; i++) {
   73|      0|                NSSet *selectorsForProtocol = [self collectVoidSelectorsForProtocol:pProtocols[i]];
   74|      0|                [voidSelectors unionSet:selectorsForProtocol];
   75|      0|            }
   76|      0|            
   77|      0|            free(pProtocols);
   78|      0|        }
   79|      0|
   80|      0|        if (classHierarchyDepth == CLASS_HIERARCHY_MAX_DEPTH) {
   81|      0|            NSLog(@"Detected weird class hierarchy with depth over %d. Starting with this class -> %@", CLASS_HIERARCHY_MAX_DEPTH, self);
   82|      0|#if DEBUG
   83|      0|            abort();
   84|      0|#endif
   85|      0|        }
   86|      0|        
   87|      0|        voidSelectorsPerClass[CLASS_VALUE(self)] = voidSelectors;
   88|      0|    }
   89|      0|}
   90|       |
   91|      0|-(id)_forwardToDelegate {
   92|      0|    return __forwardToDelegate;
   93|      0|}
   94|       |
   95|      0|-(void)_setForwardToDelegate:(id __nullable)forwardToDelegate retainDelegate:(BOOL)retainDelegate {
   96|      0|    __forwardToDelegate = forwardToDelegate;
   97|      0|    if (retainDelegate) {
   98|      0|        self.strongForwardDelegate = forwardToDelegate;
   99|      0|    }
  100|      0|    else {
  101|      0|        self.strongForwardDelegate = nil;
  102|      0|    }
  103|      0|}
  104|       |
  105|      0|-(BOOL)hasWiredImplementationForSelector:(SEL)selector {
  106|      0|    return [super respondsToSelector:selector];
  107|      0|}
  108|       |
  109|      0|-(BOOL)voidDelegateMethodsContain:(SEL)selector {
  110|      0|    @synchronized(_RXDelegateProxy.class) {
  111|      0|        NSSet *voidSelectors = voidSelectorsPerClass[CLASS_VALUE(self.class)];
  112|      0|        NSAssert(voidSelectors != nil, @"Set of allowed methods not initialized");
  113|      0|        return [voidSelectors containsObject:SEL_VALUE(selector)];
  114|      0|    }
  115|      0|}
  116|       |
  117|      0|-(void)forwardInvocation:(NSInvocation *)anInvocation {
  118|      0|    BOOL isVoid = RX_is_method_signature_void(anInvocation.methodSignature);
  119|      0|    NSArray *arguments = nil;
  120|      0|    if (isVoid) {
  121|      0|        arguments = RX_extract_arguments(anInvocation);
  122|      0|        [self _sentMessage:anInvocation.selector withArguments:arguments];
  123|      0|    }
  124|      0|    
  125|      0|    if (self._forwardToDelegate && [self._forwardToDelegate respondsToSelector:anInvocation.selector]) {
  126|      0|        [anInvocation invokeWithTarget:self._forwardToDelegate];
  127|      0|    }
  128|      0|
  129|      0|    if (isVoid) {
  130|      0|        [self _methodInvoked:anInvocation.selector withArguments:arguments];
  131|      0|    }
  132|      0|}
  133|       |
  134|       |// abstract method
  135|      0|-(void)_sentMessage:(SEL)selector withArguments:(NSArray *)arguments {
  136|      0|
  137|      0|}
  138|       |
  139|       |// abstract method
  140|      0|-(void)_methodInvoked:(SEL)selector withArguments:(NSArray *)arguments {
  141|      0|
  142|      0|}
  143|       |
  144|      0|-(void)dealloc {
  145|      0|}
  146|       |
  147|       |@end

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXKVOObserver.m:
    1|       |//
    2|       |//  _RXKVOObserver.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "include/_RXKVOObserver.h"
   10|       |
   11|       |@interface _RXKVOObserver ()
   12|       |
   13|       |@property (nonatomic, unsafe_unretained) id            target;
   14|       |@property (nonatomic, strong           ) id            retainedTarget;
   15|       |@property (nonatomic, copy             ) NSString     *keyPath;
   16|       |@property (nonatomic, copy             ) void (^callback)(id);
   17|       |
   18|       |@end
   19|       |
   20|       |@implementation _RXKVOObserver
   21|       |
   22|       |-(instancetype)initWithTarget:(id)target
   23|       |                 retainTarget:(BOOL)retainTarget
   24|       |                      keyPath:(NSString*)keyPath
   25|       |                      options:(NSKeyValueObservingOptions)options
   26|      0|                     callback:(void (^)(id))callback {
   27|      0|    self = [super init];
   28|      0|    if (!self) return nil;
   29|      0|    
   30|      0|    self.target = target;
   31|      0|    if (retainTarget) {
   32|      0|        self.retainedTarget = target;
   33|      0|    }
   34|      0|    self.keyPath = keyPath;
   35|      0|    self.callback = callback;
   36|      0|    
   37|      0|    [self.target addObserver:self forKeyPath:self.keyPath options:options context:nil];
   38|      0|    
   39|      0|    return self;
   40|      0|}
   41|       |
   42|      0|-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
   43|      0|    @synchronized(self) {
   44|      0|        self.callback(change[NSKeyValueChangeNewKey]);
   45|      0|    }
   46|      0|}
   47|       |
   48|      0|-(void)dispose {
   49|      0|    [self.target removeObserver:self forKeyPath:self.keyPath context:nil];
   50|      0|    self.target = nil;
   51|      0|    self.retainedTarget = nil;
   52|      0|}
   53|       |
   54|       |@end

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXObjCRuntime.m:
    1|       |//
    2|       |//  _RXObjCRuntime.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import <pthread.h>
   10|       |#import <Foundation/Foundation.h>
   11|       |#import <objc/runtime.h>
   12|       |#import <objc/message.h>
   13|       |#import <libkern/OSAtomic.h>
   14|       |#import <stdatomic.h>
   15|       |
   16|       |#import "include/_RX.h"
   17|       |#import "include/_RXObjCRuntime.h"
   18|       |
   19|       |// self + cmd
   20|      0|#define HIDDEN_ARGUMENT_COUNT   2
   21|       |
   22|       |#if !DISABLE_SWIZZLING
   23|       |
   24|       |#define NSErrorParam NSError *__autoreleasing __nullable * __nullable
   25|       |
   26|       |@class RXObjCRuntime;
   27|       |
   28|       |BOOL RXAbortOnThreadingHazard = NO;
   29|       |
   30|       |typedef NSInvocation       *NSInvocationRef;
   31|       |typedef NSMethodSignature  *NSMethodSignatureRef;
   32|       |typedef unsigned char       rx_uchar;
   33|       |typedef unsigned short      rx_ushort;
   34|       |typedef unsigned int        rx_uint;
   35|       |typedef unsigned long       rx_ulong;
   36|       |typedef id (^rx_block)(id);
   37|       |typedef BOOL (^RXInterceptWithOptimizedObserver)(RXObjCRuntime * __nonnull self, Class __nonnull class, SEL __nonnull selector, NSErrorParam error);
   38|       |
   39|       |static CFTypeID  defaultTypeID;
   40|       |static SEL       deallocSelector;
   41|       |
   42|       |static int RxSwizzlingTargetClassKey = 0;
   43|       |
   44|       |#if TRACE_RESOURCES
   45|       |_Atomic static int32_t numberOInterceptedMethods = 0;
   46|       |_Atomic static int32_t numberOfForwardedMethods = 0;
   47|       |#endif
   48|       |
   49|       |#define THREADING_HAZARD(class) \
   50|      0|    NSLog(@"There was a problem swizzling on `%@`.\nYou have probably two libraries performing swizzling in runtime.\nWe didn't want to crash your program, but this is not good ...\nYou an solve this problem by either not using swizzling in this library, removing one of those other libraries, or making sure that swizzling parts are synchronized (only perform them on main thread).\nAnd yes, this message will self destruct when you clear the console, and since it's non deterministic, the problem could still exist and it will be hard for you to reproduce it.", NSStringFromClass(class)); ABORT_IN_DEBUG if (RXAbortOnThreadingHazard) { abort(); }
   51|       |
   52|    108|#define ALWAYS(condition, message) if (!(condition)) { [NSException raise:@"RX Invalid Operator" format:@"%@", message]; }
   53|       |#define ALWAYS_WITH_INFO(condition, message) NSAssert((condition), @"%@ [%@] > %@", NSStringFromClass(class), NSStringFromSelector(selector), (message))
   54|       |#define C_ALWAYS(condition, message) NSCAssert((condition), @"%@ [%@] > %@", NSStringFromClass(class), NSStringFromSelector(selector), (message))
   55|       |
   56|      0|#define RX_PREFIX @"_RX_namespace_"
   57|       |
   58|      0|#define RX_ARG_id(value)           ((value) ?: [NSNull null])
   59|      0|#define RX_ARG_char(value)         [NSNumber numberWithChar:value]
   60|      0|#define RX_ARG_short(value)        [NSNumber numberWithShort:value]
   61|      0|#define RX_ARG_int(value)          [NSNumber numberWithInt:value]
   62|      0|#define RX_ARG_long(value)         [NSNumber numberWithLong:value]
   63|       |#define RX_ARG_BOOL(value)         [NSNumber numberWithBool:value]
   64|      0|#define RX_ARG_SEL(value)          [NSNumber valueWithPointer:value]
   65|      0|#define RX_ARG_rx_uchar(value)     [NSNumber numberWithUnsignedInt:value]
   66|      0|#define RX_ARG_rx_ushort(value)    [NSNumber numberWithUnsignedInt:value]
   67|      0|#define RX_ARG_rx_uint(value)      [NSNumber numberWithUnsignedInt:value]
   68|      0|#define RX_ARG_rx_ulong(value)     [NSNumber numberWithUnsignedLong:value]
   69|      0|#define RX_ARG_rx_block(value)     ((id)(value) ?: [NSNull null])
   70|      0|#define RX_ARG_float(value)        [NSNumber numberWithFloat:value]
   71|      0|#define RX_ARG_double(value)       [NSNumber numberWithDouble:value]
   72|       |
   73|       |typedef struct supported_type {
   74|       |    const char *encoding;
   75|       |} supported_type_t;
   76|       |
   77|       |static supported_type_t supported_types[] = {
   78|       |    { .encoding = @encode(void)},
   79|       |    { .encoding = @encode(id)},
   80|       |    { .encoding = @encode(Class)},
   81|       |    { .encoding = @encode(void (^)(void))},
   82|       |    { .encoding = @encode(char)},
   83|       |    { .encoding = @encode(short)},
   84|       |    { .encoding = @encode(int)},
   85|       |    { .encoding = @encode(long)},
   86|       |    { .encoding = @encode(long long)},
   87|       |    { .encoding = @encode(unsigned char)},
   88|       |    { .encoding = @encode(unsigned short)},
   89|       |    { .encoding = @encode(unsigned int)},
   90|       |    { .encoding = @encode(unsigned long)},
   91|       |    { .encoding = @encode(unsigned long long)},
   92|       |    { .encoding = @encode(float)},
   93|       |    { .encoding = @encode(double)},
   94|       |    { .encoding = @encode(BOOL)},
   95|       |    { .encoding = @encode(const char*)},
   96|       |};
   97|       |
   98|       |NSString * __nonnull const RXObjCRuntimeErrorDomain   = @"RXObjCRuntimeErrorDomain";
   99|       |NSString * __nonnull const RXObjCRuntimeErrorIsKVOKey = @"RXObjCRuntimeErrorIsKVOKey";
  100|       |
  101|      0|BOOL RX_return_type_is_supported(const char *type) {
  102|      0|    if (type == nil) {
  103|      0|        return NO;
  104|      0|    }
  105|      0|
  106|      0|    for (int i = 0; i < sizeof(supported_types) / sizeof(supported_type_t); ++i) {
  107|      0|        if (supported_types[i].encoding[0] != type[0]) {
  108|      0|            continue;
  109|      0|        }
  110|      0|        if (strcmp(supported_types[i].encoding, type) == 0) {
  111|      0|            return YES;
  112|      0|        }
  113|      0|    }
  114|      0|
  115|      0|    return NO;
  116|      0|}
  117|       |
  118|      0|static BOOL RX_method_has_supported_return_type(Method method) {
  119|      0|    const char *rawEncoding = method_getTypeEncoding(method);
  120|      0|    ALWAYS(rawEncoding != nil, @"Example encoding method is nil.");
  121|      0|
  122|      0|    NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:rawEncoding];
  123|      0|    ALWAYS(methodSignature != nil, @"Method signature method is nil.");
  124|      0|
  125|      0|    return RX_return_type_is_supported(methodSignature.methodReturnType);
  126|      0|}
  127|       |
  128|      0|SEL __nonnull RX_selector(SEL __nonnull selector) {
  129|      0|    NSString *selectorString = NSStringFromSelector(selector);
  130|      0|    return NSSelectorFromString([RX_PREFIX stringByAppendingString:selectorString]);
  131|      0|}
  132|       |
  133|       |#endif
  134|       |
  135|      0|BOOL RX_is_method_signature_void(NSMethodSignature * __nonnull methodSignature) {
  136|      0|    const char *methodReturnType = methodSignature.methodReturnType;
  137|      0|    return strcmp(methodReturnType, @encode(void)) == 0;
  138|      0|}
  139|       |
  140|      0|BOOL RX_is_method_with_description_void(struct objc_method_description method) {
  141|      0|    return strncmp(method.types, @encode(void), 1) == 0;
  142|      0|}
  143|       |
  144|      0|id __nonnull RX_extract_argument_at_index(NSInvocation * __nonnull invocation, NSUInteger index) {
  145|      0|    const char *argumentType = [invocation.methodSignature getArgumentTypeAtIndex:index];
  146|      0|    
  147|      0|#define RETURN_VALUE(type) \
  148|      0|    else if (strcmp(argumentType, @encode(type)) == 0) {\
  149|      0|        type val = 0; \
  150|      0|        [invocation getArgument:&val atIndex:index]; \
  151|      0|        return @(val); \
  152|      0|    }
  153|      0|
  154|      0|    // Skip const type qualifier.
  155|      0|    if (argumentType[0] == 'r') {
  156|      0|        argumentType++;
  157|      0|    }
  158|      0|    
  159|      0|    if (strcmp(argumentType, @encode(id)) == 0
  160|      0|        || strcmp(argumentType, @encode(Class)) == 0
  161|      0|        || strcmp(argumentType, @encode(void (^)(void))) == 0
  162|      0|    ) {
  163|      0|        __unsafe_unretained id argument = nil;
  164|      0|        [invocation getArgument:&argument atIndex:index];
  165|      0|        return argument;
  166|      0|    }
  167|      0|    RETURN_VALUE(char)
  168|      0|    RETURN_VALUE(short)
  169|      0|    RETURN_VALUE(int)
  170|      0|    RETURN_VALUE(long)
  171|      0|    RETURN_VALUE(long long)
  172|      0|    RETURN_VALUE(unsigned char)
  173|      0|    RETURN_VALUE(unsigned short)
  174|      0|    RETURN_VALUE(unsigned int)
  175|      0|    RETURN_VALUE(unsigned long)
  176|      0|    RETURN_VALUE(unsigned long long)
  177|      0|    RETURN_VALUE(float)
  178|      0|    RETURN_VALUE(double)
  179|      0|    RETURN_VALUE(BOOL)
  180|      0|    RETURN_VALUE(const char *)
  181|      0|    else {
  182|      0|        NSUInteger size = 0;
  183|      0|        NSGetSizeAndAlignment(argumentType, &size, NULL);
  184|      0|        NSCParameterAssert(size > 0);
  185|      0|        uint8_t data[size];
  186|      0|        [invocation getArgument:&data atIndex:index];
  187|      0|        
  188|      0|        return [NSValue valueWithBytes:&data objCType:argumentType];
  189|      0|    }
  190|      0|}
  191|       |
  192|      0|NSArray *RX_extract_arguments(NSInvocation *invocation) {
  193|      0|    NSUInteger numberOfArguments = invocation.methodSignature.numberOfArguments;
  194|      0|    NSUInteger numberOfVisibleArguments = numberOfArguments - HIDDEN_ARGUMENT_COUNT;
  195|      0|    
  196|      0|    NSCParameterAssert(numberOfVisibleArguments >= 0);
  197|      0|    
  198|      0|    NSMutableArray *arguments = [NSMutableArray arrayWithCapacity:numberOfVisibleArguments];
  199|      0|    
  200|      0|    for (NSUInteger index = HIDDEN_ARGUMENT_COUNT; index < numberOfArguments; ++index) {
  201|      0|        [arguments addObject:RX_extract_argument_at_index(invocation, index) ?: [NSNull null]];
  202|      0|    }
  203|      0|    
  204|      0|    return arguments;
  205|      0|}
  206|       |
  207|      0|IMP __nonnull RX_default_target_implementation(void) {
  208|      0|    return _objc_msgForward;
  209|      0|}
  210|       |
  211|       |#if !DISABLE_SWIZZLING
  212|       |
  213|      0|void * __nonnull RX_reference_from_selector(SEL __nonnull selector) {
  214|      0|    return selector;
  215|      0|}
  216|       |
  217|      0|static BOOL RX_forward_invocation(id __nonnull __unsafe_unretained self, NSInvocation *invocation) {
  218|      0|    SEL originalSelector = RX_selector(invocation.selector);
  219|      0|
  220|      0|    id<RXMessageSentObserver> messageSentObserver = objc_getAssociatedObject(self, originalSelector);
  221|      0|
  222|      0|    if (messageSentObserver != nil) {
  223|      0|        NSArray *arguments = RX_extract_arguments(invocation);
  224|      0|        [messageSentObserver messageSentWithArguments:arguments];
  225|      0|    }
  226|      0|
  227|      0|    if ([self respondsToSelector:originalSelector]) {
  228|      0|        invocation.selector = originalSelector;
  229|      0|        [invocation invokeWithTarget:self];
  230|      0|
  231|      0|        if (messageSentObserver != nil) {
  232|      0|            NSArray *arguments = RX_extract_arguments(invocation);
  233|      0|            [messageSentObserver methodInvokedWithArguments:arguments];
  234|      0|        }
  235|      0|
  236|      0|        return YES;
  237|      0|    }
  238|      0|
  239|      0|    return NO;
  240|      0|}
  241|       |
  242|      0|static BOOL RX_responds_to_selector(id __nonnull __unsafe_unretained self, SEL selector) {
  243|      0|    Class class = object_getClass(self);
  244|      0|    if (class == nil) { return NO; }
  245|      0|
  246|      0|    Method m = class_getInstanceMethod(class, selector);
  247|      0|    return m != nil;
  248|      0|
  249|      0|}
  250|       |
  251|      0|static NSMethodSignatureRef RX_method_signature(id __nonnull __unsafe_unretained self, SEL selector) {
  252|      0|    Class class = object_getClass(self);
  253|      0|    if (class == nil) { return nil; }
  254|      0|
  255|      0|    Method method = class_getInstanceMethod(class, selector);
  256|      0|    if (method == nil) { return nil; }
  257|      0|
  258|      0|    const char *encoding = method_getTypeEncoding(method);
  259|      0|    if (encoding == nil) { return nil; }
  260|      0|
  261|      0|    return [NSMethodSignature signatureWithObjCTypes:encoding];
  262|      0|}
  263|       |
  264|     27|static NSString * __nonnull RX_method_encoding(Method __nonnull method) {
  265|     27|    const char *typeEncoding = method_getTypeEncoding(method);
  266|     27|    ALWAYS(typeEncoding != nil, @"Method encoding is nil.");
  267|     27|
  268|     27|    NSString *encoding = [NSString stringWithCString:typeEncoding encoding:NSASCIIStringEncoding];
  269|     27|    ALWAYS(encoding != nil, @"Can't convert encoding to NSString.");
  270|     27|    return encoding;
  271|     27|}
  272|       |
  273|       |@interface RXObjCRuntime: NSObject
  274|       |
  275|       |@property (nonatomic, assign) pthread_mutex_t lock;
  276|       |
  277|       |@property (nonatomic, strong) NSMutableSet<NSValue *> *classesThatSupportObservingByForwarding;
  278|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, NSMutableSet<NSValue*> *> *forwardedSelectorsByClass;
  279|       |
  280|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, Class> *dynamicSubclassByRealClass;
  281|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, NSMutableDictionary<NSValue*, NSValue *>*> *interceptorIMPbySelectorsByClass;
  282|       |
  283|       |+(RXObjCRuntime*)instance;
  284|       |
  285|       |-(void)performLocked:(void (^)(RXObjCRuntime* __nonnull))action;
  286|       |-(IMP __nullable)ensurePrepared:(id __nonnull)target forObserving:(SEL __nonnull)selector error:(NSErrorParam)error;
  287|       |-(BOOL)ensureSwizzledSelector:(SEL __nonnull)selector
  288|       |                      ofClass:(Class __nonnull)class
  289|       |   newImplementationGenerator:(IMP(^)(void))newImplementationGenerator
  290|       |replacementImplementationGenerator:(IMP (^)(IMP originalImplementation))replacementImplementationGenerator
  291|       |                        error:(NSErrorParam)error;
  292|       |
  293|       |
  294|       |+(void)registerOptimizedObserver:(RXInterceptWithOptimizedObserver)registration encodedAs:(SEL)selector;
  295|       |
  296|       |@end
  297|       |
  298|       |/**
  299|       | All API methods perform work on locked instance of `RXObjCRuntime`. In that way it's easy to prove
  300|       | that every action is properly locked.
  301|       | */
  302|      0|IMP __nullable RX_ensure_observing(id __nonnull target, SEL __nonnull selector, NSErrorParam error) {
  303|      0|    __block IMP targetImplementation = nil;
  304|      0|    // Target is the second object that needs to be synchronized to TRY to make sure other swizzling framework
  305|      0|    // won't do something in parallel.
  306|      0|    // Even though this is too fine grained locking and more coarse grained locks should exist, this is just in case
  307|      0|    // someone calls this method directly without any external lock.
  308|      0|    @synchronized(target) {
  309|      0|        // The only other resource that all other swizzling libraries have in common without introducing external
  310|      0|        // dependencies is class object.
  311|      0|        //
  312|      0|        // It is polite to try to synchronize it in hope other unknown entities will also attempt to do so.
  313|      0|        // It's like trying to figure out how to communicate with aliens without actually communicating,
  314|      0|        // save for the fact that aliens are people, programmers, authors of swizzling libraries.
  315|      0|        @synchronized([target class]) {
  316|      0|            [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
  317|      0|                targetImplementation = [self ensurePrepared:target
  318|      0|                                               forObserving:selector
  319|      0|                                                      error:error];
  320|      0|            }];
  321|      0|        }
  322|      0|    }
  323|      0|
  324|      0|    return targetImplementation;
  325|      0|}
  326|       |
  327|       |// bodies
  328|       |
  329|      0|#define FORWARD_BODY(invocation)                        if (RX_forward_invocation(self, NAME_CAT(_, 0, invocation))) { return; }
  330|       |
  331|      0|#define RESPONDS_TO_SELECTOR_BODY(selector)             if (RX_responds_to_selector(self, NAME_CAT(_, 0, selector))) return YES;
  332|       |
  333|      0|#define CLASS_BODY(...)                                 return actAsClass;
  334|       |
  335|       |#define METHOD_SIGNATURE_FOR_SELECTOR_BODY(selector)                                            \
  336|      0|    NSMethodSignatureRef methodSignature = RX_method_signature(self, NAME_CAT(_, 0, selector)); \
  337|      0|    if (methodSignature != nil) {                                                               \
  338|      0|        return methodSignature;                                                                 \
  339|      0|    }
  340|       |
  341|       |#define DEALLOCATING_BODY(...)                                                        \
  342|      0|    id<RXDeallocatingObserver> observer = objc_getAssociatedObject(self, rxSelector); \
  343|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                \
  344|      0|        [observer deallocating];                                                      \
  345|      0|    }
  346|       |
  347|       |#define OBSERVE_BODY(...)                                                              \
  348|      0|    id<RXMessageSentObserver> observer = objc_getAssociatedObject(self, rxSelector);   \
  349|      0|                                                                                       \
  350|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                 \
  351|      0|        [observer messageSentWithArguments:@[COMMA_DELIMITED_ARGUMENTS(__VA_ARGS__)]]; \
  352|      0|    }                                                                                  \
  353|       |
  354|       |
  355|       |#define OBSERVE_INVOKED_BODY(...)                                                        \
  356|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                   \
  357|      0|        [observer methodInvokedWithArguments:@[COMMA_DELIMITED_ARGUMENTS(__VA_ARGS__)]]; \
  358|      0|    }                                                                                    \
  359|       |
  360|       |
  361|      0|#define BUILD_ARG_WRAPPER(type)                   RX_ARG_ ## type                                                     //RX_ARG_ ## type
  362|       |
  363|       |#define CAT(_1, _2, head, tail)                   RX_CAT2(head, tail)
  364|      0|#define SEPARATE_BY_COMMA(_1, _2, head, tail)     head, tail
  365|       |#define SEPARATE_BY_SPACE(_1, _2, head, tail)     head tail
  366|      0|#define SEPARATE_BY_UNDERSCORE(head, tail)        RX_CAT2(RX_CAT2(head, _), tail)
  367|       |
  368|       |#define UNDERSCORE_TYPE_CAT(_1, index, type)      RX_CAT2(_, type)                                                    // generates -> _type
  369|      0|#define NAME_CAT(_1, index, type)                 SEPARATE_BY_UNDERSCORE(type, index)                                 // generates -> type_0
  370|       |#define TYPE_AND_NAME_CAT(_1, index, type)        type SEPARATE_BY_UNDERSCORE(type, index)                            // generates -> type type_0
  371|      0|#define NOT_NULL_ARGUMENT_CAT(_1, index, type)    BUILD_ARG_WRAPPER(type)(NAME_CAT(_1, index, type))                  // generates -> ((id)(type_0) ?: [NSNull null])
  372|       |#define EXAMPLE_PARAMETER(_1, index, type)        RX_CAT2(_, type):(type)SEPARATE_BY_UNDERSCORE(type, index)          // generates -> _type:(type)type_0
  373|       |#define SELECTOR_PART(_1, index, type)            RX_CAT2(_, type:)                                                   // generates -> _type:
  374|       |
  375|      0|#define COMMA_DELIMITED_ARGUMENTS(...)            RX_FOREACH(_, SEPARATE_BY_COMMA, NOT_NULL_ARGUMENT_CAT, ## __VA_ARGS__)
  376|      0|#define ARGUMENTS(...)                            RX_FOREACH_COMMA(_, NAME_CAT, ## __VA_ARGS__)
  377|       |#define DECLARE_ARGUMENTS(...)                    RX_FOREACH_COMMA(_, TYPE_AND_NAME_CAT, ## __VA_ARGS__)
  378|       |
  379|       |// optimized observe methods
  380|       |
  381|       |#define GENERATE_METHOD_IDENTIFIER(...)          RX_CAT2(swizzle, RX_FOREACH(_, CAT, UNDERSCORE_TYPE_CAT, ## __VA_ARGS__))
  382|       |
  383|       |#define GENERATE_OBSERVE_METHOD_DECLARATION(...)                                 \
  384|       |    -(BOOL)GENERATE_METHOD_IDENTIFIER(__VA_ARGS__):(Class __nonnull)class        \
  385|       |                                          selector:(SEL)selector                 \
  386|       |                                             error:(NSErrorParam)error {         \
  387|       |
  388|       |
  389|       |#define BUILD_EXAMPLE_METHOD(return_value, ...) \
  390|      0|    +(return_value)RX_CAT2(RX_CAT2(example_, return_value), RX_FOREACH(_, SEPARATE_BY_SPACE, EXAMPLE_PARAMETER, ## __VA_ARGS__)) {}
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void) example_void]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id) example_void_id:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_char) example_void_char:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_short) example_void_short:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_int) example_void_int:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_long) example_void_long:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uchar) example_void_rx_uchar:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ushort) example_void_rx_ushort:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uint) example_void_rx_uint:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ulong) example_void_rx_ulong:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_block) example_void_rx_block:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_float) example_void_float:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_double) example_void_double:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_SEL) example_void_SEL:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_id) example_void_id:_id:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_char) example_void_id:_char:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_short) example_void_id:_short:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_int) example_void_id:_int:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_long) example_void_id:_long:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uchar) example_void_id:_rx_uchar:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ushort) example_void_id:_rx_ushort:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uint) example_void_id:_rx_uint:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ulong) example_void_id:_rx_ulong:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_block) example_void_id:_rx_block:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_float) example_void_id:_float:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_double) example_void_id:_double:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_SEL) example_void_id:_SEL:]
  ------------------
  391|       |
  392|       |#define BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ...) \
  393|       |    RX_CAT2(RX_CAT2(example_, return_value), RX_FOREACH(_, SEPARATE_BY_SPACE, SELECTOR_PART, ## __VA_ARGS__))
  394|       |
  395|       |#define SWIZZLE_OBSERVE_METHOD(return_value, ...)                                                                                                       \
  396|       |    @interface RXObjCRuntime (GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__))                                                                 \
  397|       |    @end                                                                                                                                                \
  398|       |                                                                                                                                                        \
  399|       |    @implementation RXObjCRuntime(GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__))                                                             \
  400|       |    BUILD_EXAMPLE_METHOD(return_value, ## __VA_ARGS__)                                                                                                  \
  401|      0|    SWIZZLE_METHOD(return_value, GENERATE_OBSERVE_METHOD_DECLARATION(return_value, ## __VA_ARGS__), OBSERVE_BODY, OBSERVE_INVOKED_BODY, ## __VA_ARGS__) \
  402|       |                                                                                                                                                        \
  403|     27|    +(void)load {                                                                                                                                       \
  404|     27|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  405|     27|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  406|     27|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  407|      0|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  408|      0|       } encodedAs:exampleSelector];                                                                                                                    \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__35+[RXObjCRuntime(swizzle_void) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__38+[RXObjCRuntime(swizzle_void_id) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__40+[RXObjCRuntime(swizzle_void_char) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_short) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__39+[RXObjCRuntime(swizzle_void_int) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__40+[RXObjCRuntime(swizzle_void_long) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_uchar) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__45+[RXObjCRuntime(swizzle_void_rx_ushort) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_rx_uint) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_ulong) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_block) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_float) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_double) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__39+[RXObjCRuntime(swizzle_void_SEL) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_id_id) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_id_char) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_id_short) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_id_int) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_id_long) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_uchar) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__48+[RXObjCRuntime(swizzle_void_id_rx_ushort) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__46+[RXObjCRuntime(swizzle_void_id_rx_uint) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_ulong) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_block) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_id_float) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__45+[RXObjCRuntime(swizzle_void_id_double) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_id_SEL) load]_block_invoke
  ------------------
  409|     27|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_char) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_short) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_int) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_long) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uchar) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ushort) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uint) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ulong) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_block) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_float) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_double) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_SEL) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_id) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_char) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_short) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_int) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_long) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uchar) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ushort) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uint) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ulong) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_block) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_float) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_double) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_SEL) load]:
  |  403|      1|    +(void)load {                                                                                                                                       \
  |  404|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  405|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  406|      1|            SEL __nonnull selector, NSErrorParam error) {                                                                                               \
  |  407|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  408|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  409|      1|    }                                                                                                                                                   \
  ------------------
  410|       |                                                                                                                                                        \
  411|       |    @end                                                                                                                                                \
  412|       |
  413|       |// infrastructure method
  414|       |
  415|       |#define NO_BODY(...)
  416|       |
  417|       |#define SWIZZLE_INFRASTRUCTURE_METHOD(return_value, method_name, parameters, method_selector, body, ...)               \
  418|       |    SWIZZLE_METHOD(return_value, -(BOOL)method_name:(Class __nonnull)class parameters error:(NSErrorParam)error        \
  419|       |        {                                                                                                              \
  420|       |            SEL selector = method_selector; , body, NO_BODY, __VA_ARGS__)                                              \
  421|       |
  422|       |
  423|       |// common base
  424|       |
  425|      0|#define SWIZZLE_METHOD(return_value, method_prototype, body, invoked_body, ...)                                          \
  426|      0|method_prototype                                                                                                         \
  427|      0|    __unused SEL rxSelector = RX_selector(selector);                                                                     \
  428|      0|    IMP (^newImplementationGenerator)(void) = ^() {                                                                          \
  429|      0|        __block IMP thisIMP = nil;                                                                                       \
  430|      0|        id newImplementation = ^return_value(__unsafe_unretained id self DECLARE_ARGUMENTS(__VA_ARGS__)) {               \
  431|      0|            body(__VA_ARGS__)                                                                                            \
  432|      0|                                                                                                                         \
  433|      0|            struct objc_super superInfo = {                                                                              \
  434|      0|                .receiver = self,                                                                                        \
  435|      0|                .super_class = class_getSuperclass(class)                                                                \
  436|      0|            };                                                                                                           \
  437|      0|                                                                                                                         \
  438|      0|            return_value (*msgSend)(struct objc_super *, SEL DECLARE_ARGUMENTS(__VA_ARGS__))                             \
  439|      0|                = (__typeof__(msgSend))objc_msgSendSuper;                                                                \
  440|      0|            @try {                                                                                                       \
  441|      0|              return msgSend(&superInfo, selector ARGUMENTS(__VA_ARGS__));                                               \
  442|      0|            }                                                                                                            \
  443|      0|            @finally { invoked_body(__VA_ARGS__) }                                                                       \
  444|      0|        };                                                                                                               \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke_2
  ------------------
  445|      0|                                                                                                                         \
  446|      0|        thisIMP = imp_implementationWithBlock(newImplementation);                                                        \
  447|      0|        return thisIMP;                                                                                                  \
  448|      0|    };                                                                                                                   \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke
  ------------------
  449|      0|                                                                                                                         \
  450|      0|    IMP (^replacementImplementationGenerator)(IMP) = ^(IMP originalImplementation) {                                     \
  451|      0|        __block return_value (*originalImplementationTyped)(__unsafe_unretained id, SEL DECLARE_ARGUMENTS(__VA_ARGS__) ) \
  452|      0|            = (__typeof__(originalImplementationTyped))(originalImplementation);                                         \
  453|      0|                                                                                                                         \
  454|      0|        __block IMP thisIMP = nil;                                                                                       \
  455|      0|        id implementationReplacement = ^return_value(__unsafe_unretained id self DECLARE_ARGUMENTS(__VA_ARGS__) ) {      \
  456|      0|            body(__VA_ARGS__)                                                                                            \
  457|      0|            @try {                                                                                                       \
  458|      0|                return originalImplementationTyped(self, selector ARGUMENTS(__VA_ARGS__));                               \
  459|      0|            }                                                                                                            \
  460|      0|            @finally { invoked_body(__VA_ARGS__) }                                                                       \
  461|      0|        };                                                                                                               \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke_2.159
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke_2.186
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke_2.212
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke_2.234
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke_2.256
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke_2.278
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke_2.300
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke_2.322
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke_2.344
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke_2.366
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke_2.388
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke_2.410
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke_2.432
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke_2.454
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke_2.478
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke_2.500
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke_2.522
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke_2.544
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke_2.566
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke_2.588
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke_2.610
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke_2.632
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke_2.654
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke_2.676
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke_2.698
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke_2.720
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke_2.742
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke_2.764
  ------------------
  462|      0|                                                                                                                         \
  463|      0|        thisIMP = imp_implementationWithBlock(implementationReplacement);                                                \
  464|      0|        return thisIMP;                                                                                                  \
  465|      0|    };                                                                                                                   \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke.158
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke.185
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke.211
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke.233
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke.255
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke.277
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke.299
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke.321
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke.343
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke.365
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke.387
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke.409
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke.431
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke.453
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke.477
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke.499
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke.521
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke.543
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke.565
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke.587
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke.609
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke.631
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke.653
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke.675
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke.697
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke.719
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke.741
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke.763
  ------------------
  466|      0|                                                                                                                         \
  467|      0|    return [self ensureSwizzledSelector:selector                                                                         \
  468|      0|                                ofClass:class                                                                            \
  469|      0|             newImplementationGenerator:newImplementationGenerator                                                       \
  470|      0|     replacementImplementationGenerator:replacementImplementationGenerator                                               \
  471|      0|                                  error:error];                                                                          \
  472|      0| }                                                                                                                       \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]
  ------------------
  473|       |
  474|       |
  475|       |@interface RXObjCRuntime (InfrastructureMethods)
  476|       |@end
  477|       |
  478|       |// MARK: Infrastructure Methods
  479|       |
  480|       |@implementation RXObjCRuntime (InfrastructureMethods)
  481|       |
  482|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  483|       |    void,
  484|       |    swizzleForwardInvocation,
  485|       |    ,
  486|       |    @selector(forwardInvocation:),
  487|      0|    FORWARD_BODY,
  488|       |    NSInvocationRef
  489|       |)
  490|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  491|       |    BOOL,
  492|       |    swizzleRespondsToSelector,
  493|       |    ,
  494|       |    @selector(respondsToSelector:),
  495|      0|    RESPONDS_TO_SELECTOR_BODY,
  496|       |    SEL
  497|       |)
  498|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  499|       |    Class __nonnull,
  500|       |    swizzleClass,
  501|       |    toActAs:(Class)actAsClass,
  502|       |    @selector(class),
  503|      0|    CLASS_BODY
  504|       |)
  505|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  506|       |    NSMethodSignatureRef,
  507|       |    swizzleMethodSignatureForSelector,
  508|       |    ,
  509|       |    @selector(methodSignatureForSelector:),
  510|      0|    METHOD_SIGNATURE_FOR_SELECTOR_BODY,
  511|       |    SEL
  512|       |)
  513|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  514|       |    void,
  515|       |    swizzleDeallocating,
  516|       |    ,
  517|       |    deallocSelector,
  518|      0|    DEALLOCATING_BODY
  519|       |)
  520|       |
  521|       |@end
  522|       |
  523|       |// MARK: Optimized intercepting methods for specific combination of parameter types
  524|       |
  525|       |SWIZZLE_OBSERVE_METHOD(void)
  526|       |
  527|       |SWIZZLE_OBSERVE_METHOD(void, id)
  528|       |SWIZZLE_OBSERVE_METHOD(void, char)
  529|       |SWIZZLE_OBSERVE_METHOD(void, short)
  530|       |SWIZZLE_OBSERVE_METHOD(void, int)
  531|       |SWIZZLE_OBSERVE_METHOD(void, long)
  532|       |SWIZZLE_OBSERVE_METHOD(void, rx_uchar)
  533|       |SWIZZLE_OBSERVE_METHOD(void, rx_ushort)
  534|       |SWIZZLE_OBSERVE_METHOD(void, rx_uint)
  535|       |SWIZZLE_OBSERVE_METHOD(void, rx_ulong)
  536|       |SWIZZLE_OBSERVE_METHOD(void, rx_block)
  537|       |SWIZZLE_OBSERVE_METHOD(void, float)
  538|       |SWIZZLE_OBSERVE_METHOD(void, double)
  539|       |SWIZZLE_OBSERVE_METHOD(void, SEL)
  540|       |
  541|       |SWIZZLE_OBSERVE_METHOD(void, id, id)
  542|       |SWIZZLE_OBSERVE_METHOD(void, id, char)
  543|       |SWIZZLE_OBSERVE_METHOD(void, id, short)
  544|       |SWIZZLE_OBSERVE_METHOD(void, id, int)
  545|       |SWIZZLE_OBSERVE_METHOD(void, id, long)
  546|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_uchar)
  547|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_ushort)
  548|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_uint)
  549|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_ulong)
  550|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_block)
  551|       |SWIZZLE_OBSERVE_METHOD(void, id, float)
  552|       |SWIZZLE_OBSERVE_METHOD(void, id, double)
  553|       |SWIZZLE_OBSERVE_METHOD(void, id, SEL)
  554|       |
  555|       |// MARK: RXObjCRuntime
  556|       |
  557|       |@implementation RXObjCRuntime
  558|       |
  559|       |static RXObjCRuntime *_instance = nil;
  560|       |static NSMutableDictionary<NSString *, RXInterceptWithOptimizedObserver> *optimizedObserversByMethodEncoding = nil;
  561|       |
  562|      0|+(RXObjCRuntime*)instance {
  563|      0|    return _instance;
  564|      0|}
  565|       |
  566|      1|+(void)initialize {
  567|      1|    _instance = [[RXObjCRuntime alloc] init];
  568|      1|    defaultTypeID = CFGetTypeID((CFTypeRef)RXObjCRuntime.class); // just need a reference of some object not from CF
  569|      1|    deallocSelector = NSSelectorFromString(@"dealloc");
  570|      1|    NSAssert(_instance != nil, @"Failed to initialize swizzling");
  571|      1|}
  572|       |
  573|      1|-(instancetype)init {
  574|      1|    self = [super init];
  575|      1|    if (!self) return nil;
  576|      1|
  577|      1|    self.classesThatSupportObservingByForwarding = [NSMutableSet set];
  578|      1|    self.forwardedSelectorsByClass = [NSMutableDictionary dictionary];
  579|      1|
  580|      1|    self.dynamicSubclassByRealClass = [NSMutableDictionary dictionary];
  581|      1|    self.interceptorIMPbySelectorsByClass = [NSMutableDictionary dictionary];
  582|      1|
  583|      1|    pthread_mutexattr_t lock_attr;
  584|      1|    pthread_mutexattr_init(&lock_attr);
  585|      1|    pthread_mutexattr_settype(&lock_attr, PTHREAD_MUTEX_RECURSIVE);
  586|      1|    pthread_mutex_init(&_lock, &lock_attr);
  587|      1|    pthread_mutexattr_destroy(&lock_attr);
  588|      1|    
  589|      1|    return self;
  590|      1|}
  591|       |
  592|      0|-(void)performLocked:(void (^)(RXObjCRuntime* __nonnull))action {
  593|      0|    pthread_mutex_lock(&_lock);
  594|      0|    action(self);
  595|      0|    pthread_mutex_unlock(&_lock);
  596|      0|}
  597|       |
  598|     27|+(void)registerOptimizedObserver:(RXInterceptWithOptimizedObserver)registration encodedAs:(SEL)selector {
  599|     27|    Method exampleEncodingMethod = class_getClassMethod(self, selector);
  600|     27|    ALWAYS(exampleEncodingMethod != nil, @"Example encoding method is nil.");
  601|     27|
  602|     27|    NSString *methodEncoding = RX_method_encoding(exampleEncodingMethod);
  603|     27|
  604|     27|    if (optimizedObserversByMethodEncoding == nil) {
  605|      1|        optimizedObserversByMethodEncoding = [NSMutableDictionary dictionary];
  606|      1|    }
  607|     27|
  608|     27|    DLOG(@"Added optimized method: %@ (%@)", methodEncoding, NSStringFromSelector(selector));
  609|     27|    ALWAYS(optimizedObserversByMethodEncoding[methodEncoding] == nil, @"Optimized observer already registered")
  610|     27|    optimizedObserversByMethodEncoding[methodEncoding] = registration;
  611|     27|}
  612|       |
  613|       |/**
  614|       | This is the main entry point for observing messages sent to arbitrary objects.
  615|       | */
  616|      0|-(IMP __nullable)ensurePrepared:(id __nonnull)target forObserving:(SEL __nonnull)selector error:(NSErrorParam)error {
  617|      0|    Method instanceMethod = class_getInstanceMethod([target class], selector);
  618|      0|    if (instanceMethod == nil) {
  619|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  620|      0|                                           code:RXObjCRuntimeErrorSelectorNotImplemented
  621|      0|                                       userInfo:nil], nil);
  622|      0|    }
  623|      0|
  624|      0|    if (selector == @selector(class)
  625|      0|    ||  selector == @selector(forwardingTargetForSelector:)
  626|      0|    ||  selector == @selector(methodSignatureForSelector:)
  627|      0|    ||  selector == @selector(respondsToSelector:)) {
  628|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  629|      0|                                           code:RXObjCRuntimeErrorObservingPerformanceSensitiveMessages
  630|      0|                                       userInfo:nil], nil);
  631|      0|    }
  632|      0|
  633|      0|    // For `dealloc` message, original implementation will be swizzled.
  634|      0|    // This is a special case because observing `dealloc` message is performed when `observeWeakly` is used.
  635|      0|    //
  636|      0|    // Some toll free bridged classes don't handle `object_setClass` well and cause crashes.
  637|      0|    //
  638|      0|    // To make `deallocating` as robust as possible, original implementation will be replaced.
  639|      0|    if (selector == deallocSelector) {
  640|      0|        Class __nonnull deallocSwizzingTarget = [target class];
  641|      0|        IMP interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:deallocSwizzingTarget];
  642|      0|        if (interceptorIMPForSelector != nil) {
  643|      0|            return interceptorIMPForSelector;
  644|      0|        }
  645|      0|
  646|      0|        if (![self swizzleDeallocating:deallocSwizzingTarget error:error]) {
  647|      0|            return nil;
  648|      0|        }
  649|      0|
  650|      0|        interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:deallocSwizzingTarget];
  651|      0|        if (interceptorIMPForSelector != nil) {
  652|      0|            return interceptorIMPForSelector;
  653|      0|        }
  654|      0|    }
  655|      0|    else {
  656|      0|        Class __nullable swizzlingImplementorClass = [self prepareTargetClassForObserving:target error:error];
  657|      0|        if (swizzlingImplementorClass == nil) {
  658|      0|            return nil;
  659|      0|        }
  660|      0|
  661|      0|        NSString *methodEncoding = RX_method_encoding(instanceMethod);
  662|      0|        RXInterceptWithOptimizedObserver optimizedIntercept = optimizedObserversByMethodEncoding[methodEncoding];
  663|      0|
  664|      0|        if (!RX_method_has_supported_return_type(instanceMethod)) {
  665|      0|            RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  666|      0|                                               code:RXObjCRuntimeErrorObservingMessagesWithUnsupportedReturnType
  667|      0|                                           userInfo:nil], nil);
  668|      0|        }
  669|      0|
  670|      0|        // optimized interception method
  671|      0|        if (optimizedIntercept != nil) {
  672|      0|            IMP interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
  673|      0|            if (interceptorIMPForSelector != nil) {
  674|      0|                return interceptorIMPForSelector;
  675|      0|            }
  676|      0|
  677|      0|            if (!optimizedIntercept(self, swizzlingImplementorClass, selector, error)) {
  678|      0|                return nil;
  679|      0|            }
  680|      0|
  681|      0|            interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
  682|      0|            if (interceptorIMPForSelector != nil) {
  683|      0|                return interceptorIMPForSelector;
  684|      0|            }
  685|      0|        }
  686|      0|        // default fallback to observing by forwarding messages
  687|      0|        else {
  688|      0|            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
  689|      0|                return RX_default_target_implementation();
  690|      0|            }
  691|      0|
  692|      0|            if (![self observeByForwardingMessages:swizzlingImplementorClass
  693|      0|                                          selector:selector
  694|      0|                                            target:target
  695|      0|                                             error:error]) {
  696|      0|                return nil;
  697|      0|            }
  698|      0|
  699|      0|            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
  700|      0|                return RX_default_target_implementation();
  701|      0|            }
  702|      0|        }
  703|      0|    }
  704|      0|
  705|      0|    RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  706|      0|                                       code:RXObjCRuntimeErrorUnknown
  707|      0|                                   userInfo:nil], nil);
  708|      0|}
  709|       |
  710|      0|-(Class __nullable)prepareTargetClassForObserving:(id __nonnull)target error:(NSErrorParam)error {
  711|      0|    Class swizzlingClass = objc_getAssociatedObject(target, &RxSwizzlingTargetClassKey);
  712|      0|    if (swizzlingClass != nil) {
  713|      0|        return swizzlingClass;
  714|      0|    }
  715|      0|
  716|      0|    Class __nonnull wannaBeClass = [target class];
  717|      0|    /**
  718|      0|     Core Foundation classes are usually toll free bridged. Those classes crash the program in case
  719|      0|     `object_setClass` is performed on them.
  720|      0|
  721|      0|     There is a possibility to just swizzle methods on original object, but since those won't be usual use
  722|      0|     cases for this library, then an error will just be reported for now.
  723|      0|     */
  724|      0|    BOOL isThisTollFreeFoundationClass = CFGetTypeID((CFTypeRef)target) != defaultTypeID;
  725|      0|
  726|      0|    if (isThisTollFreeFoundationClass) {
  727|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  728|      0|                                           code:RXObjCRuntimeErrorCantInterceptCoreFoundationTollFreeBridgedObjects
  729|      0|                                       userInfo:nil], nil);
  730|      0|    }
  731|      0|
  732|      0|    /**
  733|      0|     If the object is reporting a different class then what it's real class, that means that there is probably
  734|      0|     already some interception mechanism in place or something weird is happening.
  735|      0|     
  736|      0|     Most common case when this would happen is when using KVO (`observe`) and `sentMessage`.
  737|      0|
  738|      0|     This error is easily resolved by just using `sentMessage` observing before `observe`.
  739|      0|     
  740|      0|     The reason why other way around could create issues is because KVO will unregister it's interceptor 
  741|      0|     class and restore original class. Unfortunately that will happen no matter was there another interceptor
  742|      0|     subclass registered in hierarchy or not.
  743|      0|     
  744|      0|     Failure scenario:
  745|      0|     * KVO sets class to be `__KVO__OriginalClass` (subclass of `OriginalClass`)
  746|      0|     * `sentMessage` sets object class to be `_RX_namespace___KVO__OriginalClass` (subclass of `__KVO__OriginalClass`)
  747|      0|     * then unobserving with KVO will restore class to be `OriginalClass` -> failure point
  748|      0|
  749|      0|     The reason why changing order of observing works is because any interception method should return
  750|      0|     object's original real class (if that doesn't happen then it's really easy to argue that's a bug
  751|      0|     in that other library).
  752|      0|     
  753|      0|     This library won't remove registered interceptor even if there aren't any observers left because
  754|      0|     it's highly unlikely it would have any benefit in real world use cases, and it's even more
  755|      0|     dangerous.
  756|      0|     */
  757|      0|    if ([target class] != object_getClass(target)) {
  758|      0|        BOOL isKVO = [target respondsToSelector:NSSelectorFromString(@"_isKVOA")];
  759|      0|
  760|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  761|      0|                                           code:RXObjCRuntimeErrorObjectMessagesAlreadyBeingIntercepted
  762|      0|                                       userInfo:@{
  763|      0|                                                  RXObjCRuntimeErrorIsKVOKey : @(isKVO)
  764|      0|                                                  }], nil);
  765|      0|    }
  766|      0|
  767|      0|    Class __nullable dynamicFakeSubclass = [self ensureHasDynamicFakeSubclass:wannaBeClass error:error];
  768|      0|
  769|      0|    if (dynamicFakeSubclass == nil) {
  770|      0|        return nil;
  771|      0|    }
  772|      0|
  773|      0|    Class previousClass = object_setClass(target, dynamicFakeSubclass);
  774|      0|    if (previousClass != wannaBeClass) {
  775|      0|        THREADING_HAZARD(wannaBeClass);
  776|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  777|      0|                                           code:RXObjCRuntimeErrorThreadingCollisionWithOtherInterceptionMechanism
  778|      0|                                       userInfo:nil], nil);
  779|      0|    }
  780|      0|
  781|      0|    objc_setAssociatedObject(target, &RxSwizzlingTargetClassKey, dynamicFakeSubclass, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  782|      0|    return dynamicFakeSubclass;
  783|      0|}
  784|       |
  785|       |
  786|      0|-(BOOL)forwardingSelector:(SEL)selector forClass:(Class __nonnull)class {
  787|      0|    return [self.forwardedSelectorsByClass[CLASS_VALUE(class)] containsObject:SEL_VALUE(selector)];
  788|      0|}
  789|       |
  790|      0|-(void)registerForwardedSelector:(SEL)selector forClass:(Class __nonnull)class {
  791|      0|    NSValue *classValue = CLASS_VALUE(class);
  792|      0|
  793|      0|    NSMutableSet<NSValue *> *forwardedSelectors = self.forwardedSelectorsByClass[classValue];
  794|      0|
  795|      0|    if (forwardedSelectors == nil) {
  796|      0|        forwardedSelectors = [NSMutableSet set];
  797|      0|        self.forwardedSelectorsByClass[classValue] = forwardedSelectors;
  798|      0|    }
  799|      0|
  800|      0|    [forwardedSelectors addObject:SEL_VALUE(selector)];
  801|      0|}
  802|       |
  803|       |-(BOOL)observeByForwardingMessages:(Class __nonnull)swizzlingImplementorClass
  804|       |                          selector:(SEL)selector
  805|       |                            target:(id __nonnull)target
  806|      0|                             error:(NSErrorParam)error {
  807|      0|    if (![self ensureForwardingMethodsAreSwizzled:swizzlingImplementorClass error:error]) {
  808|      0|        return NO;
  809|      0|    }
  810|      0|
  811|      0|    ALWAYS(![self forwardingSelector:selector forClass:swizzlingImplementorClass], @"Already observing selector for class");
  812|      0|
  813|       |#if TRACE_RESOURCES
  814|       |    atomic_fetch_add(&numberOfForwardedMethods, 1);
  815|       |#endif
  816|       |    SEL rxSelector = RX_selector(selector);
  817|      0|
  818|      0|    Method instanceMethod = class_getInstanceMethod(swizzlingImplementorClass, selector);
  819|      0|    ALWAYS(instanceMethod != nil, @"Instance method is nil");
  820|      0|
  821|      0|    const char* methodEncoding = method_getTypeEncoding(instanceMethod);
  822|      0|    ALWAYS(methodEncoding != nil, @"Method encoding is nil.");
  823|      0|    NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:methodEncoding];
  824|      0|    ALWAYS(methodSignature != nil, @"Method signature is invalid.");
  825|      0|
  826|      0|    IMP implementation = method_getImplementation(instanceMethod);
  827|      0|
  828|      0|    if (implementation == nil) {
  829|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  830|      0|                                           code:RXObjCRuntimeErrorSelectorNotImplemented
  831|      0|                                       userInfo:nil], NO);
  832|      0|    }
  833|      0|
  834|      0|    if (!class_addMethod(swizzlingImplementorClass, rxSelector, implementation, methodEncoding)) {
  835|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  836|      0|                                           code:RXObjCRuntimeErrorSavingOriginalForwardingMethodFailed
  837|      0|                                       userInfo:nil], NO);
  838|      0|    }
  839|      0|
  840|      0|    if (!class_addMethod(swizzlingImplementorClass, selector, _objc_msgForward, methodEncoding)) {
  841|      0|        if (implementation != method_setImplementation(instanceMethod, _objc_msgForward)) {
  842|      0|            THREADING_HAZARD(swizzlingImplementorClass);
  843|      0|            RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  844|      0|                                               code:RXObjCRuntimeErrorReplacingMethodWithForwardingImplementation
  845|      0|                                           userInfo:nil], NO);
  846|      0|        }
  847|      0|    }
  848|      0|
  849|      0|    DLOG(@"Rx uses forwarding to observe `%@` for `%@`.", NSStringFromSelector(selector), swizzlingImplementorClass);
  850|      0|    [self registerForwardedSelector:selector forClass:swizzlingImplementorClass];
  851|      0|
  852|      0|    return YES;
  853|      0|}
  854|       |
  855|       |/**
  856|       | If object don't have some weird behavior, claims it's the same class that runtime shows,
  857|       | then dynamic subclass is created (only this instance will have performance hit).
  858|       | 
  859|       | In case something weird is detected, then original base class is being swizzled and all instances
  860|       | will have somewhat reduced performance.
  861|       | 
  862|       | This is especially handy optimization for weak KVO. Nobody will swizzle for example `NSString`,
  863|       | but to know when instance of a `NSString` was deallocated, performance hit will be only felt on a 
  864|       | single instance of `NSString`, not all instances of `NSString`s.
  865|       | */
  866|      0|-(Class __nullable)ensureHasDynamicFakeSubclass:(Class __nonnull)class error:(NSErrorParam)error {
  867|      0|    Class dynamicFakeSubclass = self.dynamicSubclassByRealClass[CLASS_VALUE(class)];
  868|      0|    if (dynamicFakeSubclass != nil) {
  869|      0|        return dynamicFakeSubclass;
  870|      0|    }
  871|      0|
  872|      0|    NSString *dynamicFakeSubclassName = [RX_PREFIX stringByAppendingString:NSStringFromClass(class)];
  873|      0|    const char *dynamicFakeSubclassNameRaw = dynamicFakeSubclassName.UTF8String;
  874|      0|    dynamicFakeSubclass = objc_allocateClassPair(class, dynamicFakeSubclassNameRaw, 0);
  875|      0|    ALWAYS(dynamicFakeSubclass != nil, @"Class not generated");
  876|      0|
  877|      0|    if (![self swizzleClass:dynamicFakeSubclass toActAs:class error:error]) {
  878|      0|        return nil;
  879|      0|    }
  880|      0|
  881|      0|    objc_registerClassPair(dynamicFakeSubclass);
  882|      0|
  883|      0|    [self.dynamicSubclassByRealClass setObject:dynamicFakeSubclass forKey:CLASS_VALUE(class)];
  884|      0|    ALWAYS(self.dynamicSubclassByRealClass[CLASS_VALUE(class)] != nil, @"Class not registered");
  885|      0|
  886|      0|    return dynamicFakeSubclass;
  887|      0|}
  888|       |
  889|      0|-(BOOL)ensureForwardingMethodsAreSwizzled:(Class __nonnull)class error:(NSErrorParam)error {
  890|      0|    NSValue *classValue = CLASS_VALUE(class);
  891|      0|    if ([self.classesThatSupportObservingByForwarding containsObject:classValue]) {
  892|      0|        return YES;
  893|      0|    }
  894|      0|
  895|      0|    if (![self swizzleForwardInvocation:class error:error]) { return NO; }
  896|      0|    if (![self swizzleMethodSignatureForSelector:class error:error]) { return NO; }
  897|      0|    if (![self swizzleRespondsToSelector:class error:error]) { return NO; }
  898|      0|
  899|      0|    [self.classesThatSupportObservingByForwarding addObject:classValue];
  900|      0|
  901|      0|    return YES;
  902|      0|}
  903|       |
  904|      0|-(void)registerInterceptedSelector:(SEL)selector implementation:(IMP)implementation forClass:(Class)class {
  905|      0|    NSValue * __nonnull classValue = CLASS_VALUE(class);
  906|      0|    NSValue * __nonnull selectorValue = SEL_VALUE(selector);
  907|      0|
  908|      0|    NSMutableDictionary *swizzledIMPBySelectorsForClass = self.interceptorIMPbySelectorsByClass[classValue];
  909|      0|
  910|      0|    if (swizzledIMPBySelectorsForClass == nil) {
  911|      0|        swizzledIMPBySelectorsForClass = [NSMutableDictionary dictionary];
  912|      0|        self.interceptorIMPbySelectorsByClass[classValue] = swizzledIMPBySelectorsForClass;
  913|      0|    }
  914|      0|
  915|      0|    swizzledIMPBySelectorsForClass[selectorValue] = IMP_VALUE(implementation);
  916|      0|
  917|      0|    ALWAYS([self interceptorImplementationForSelector:selector forClass:class] != nil, @"Class should have been swizzled");
  918|      0|}
  919|       |
  920|      0|-(IMP)interceptorImplementationForSelector:(SEL)selector forClass:(Class)class {
  921|      0|    NSValue * __nonnull classValue = CLASS_VALUE(class);
  922|      0|    NSValue * __nonnull selectorValue = SEL_VALUE(selector);
  923|      0|
  924|      0|    NSMutableDictionary *swizzledIMPBySelectorForClass = self.interceptorIMPbySelectorsByClass[classValue];
  925|      0|
  926|      0|    NSValue *impValue = swizzledIMPBySelectorForClass[selectorValue];
  927|      0|    return impValue.pointerValue;
  928|      0|}
  929|       |
  930|       |-(BOOL)ensureSwizzledSelector:(SEL __nonnull)selector
  931|       |                      ofClass:(Class __nonnull)class
  932|       |   newImplementationGenerator:(IMP(^)(void))newImplementationGenerator
  933|       |replacementImplementationGenerator:(IMP (^)(IMP originalImplementation))replacementImplementationGenerator
  934|      0|                        error:(NSErrorParam)error {
  935|      0|    if ([self interceptorImplementationForSelector:selector forClass:class] != nil) {
  936|      0|        DLOG(@"Trying to register same intercept at least once, this sounds like a possible bug");
  937|      0|        return YES;
  938|      0|    }
  939|      0|
  940|       |#if TRACE_RESOURCES
  941|       |    atomic_fetch_add(&numberOInterceptedMethods, 1);
  942|       |#endif
  943|       |    
  944|      0|    DLOG(@"Rx is swizzling `%@` for `%@`", NSStringFromSelector(selector), class);
  945|      0|
  946|      0|    Method existingMethod = class_getInstanceMethod(class, selector);
  947|      0|    ALWAYS(existingMethod != nil, @"Method doesn't exist");
  948|      0|
  949|      0|    const char *encoding = method_getTypeEncoding(existingMethod);
  950|      0|    ALWAYS(encoding != nil, @"Encoding is nil");
  951|      0|
  952|      0|    IMP newImplementation = newImplementationGenerator();
  953|      0|
  954|      0|    if (class_addMethod(class, selector, newImplementation, encoding)) {
  955|      0|        // new method added, job done
  956|      0|        [self registerInterceptedSelector:selector implementation:newImplementation forClass:class];
  957|      0|
  958|      0|        return YES;
  959|      0|    }
  960|      0|
  961|      0|    imp_removeBlock(newImplementation);
  962|      0|
  963|      0|    // if add fails, that means that method already exists on targetClass
  964|      0|    Method existingMethodOnTargetClass = existingMethod;
  965|      0|
  966|      0|    IMP originalImplementation = method_getImplementation(existingMethodOnTargetClass);
  967|      0|    ALWAYS(originalImplementation != nil, @"Method must exist.");
  968|      0|    IMP implementationReplacementIMP = replacementImplementationGenerator(originalImplementation);
  969|      0|    ALWAYS(implementationReplacementIMP != nil, @"Method must exist.");
  970|      0|    IMP originalImplementationAfterChange = method_setImplementation(existingMethodOnTargetClass, implementationReplacementIMP);
  971|      0|    ALWAYS(originalImplementation != nil, @"Method must exist.");
  972|      0|
  973|      0|    // If method replacing failed, who knows what happened, better not trying again, otherwise program can get
  974|      0|    // corrupted.
  975|      0|    [self registerInterceptedSelector:selector implementation:implementationReplacementIMP forClass:class];
  976|      0|
  977|      0|    // ¯\_(ツ)_/¯
  978|      0|    if (originalImplementationAfterChange != originalImplementation) {
  979|      0|        THREADING_HAZARD(class);
  980|      0|        return NO;
  981|      0|    }
  982|      0|
  983|      0|    return YES;
  984|      0|}
  985|       |
  986|       |@end
  987|       |
  988|       |#if TRACE_RESOURCES
  989|       |
  990|       |NSInteger RX_number_of_dynamic_subclasses() {
  991|       |    __block NSInteger count = 0;
  992|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
  993|       |        count = self.dynamicSubclassByRealClass.count;
  994|       |    }];
  995|       |
  996|       |    return count;
  997|       |}
  998|       |
  999|       |NSInteger RX_number_of_forwarding_enabled_classes() {
 1000|       |    __block NSInteger count = 0;
 1001|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
 1002|       |        count = self.classesThatSupportObservingByForwarding.count;
 1003|       |    }];
 1004|       |
 1005|       |    return count;
 1006|       |}
 1007|       |
 1008|       |NSInteger RX_number_of_intercepting_classes() {
 1009|       |    __block NSInteger count = 0;
 1010|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
 1011|       |        count = self.interceptorIMPbySelectorsByClass.count;
 1012|       |    }];
 1013|       |
 1014|       |    return count;
 1015|       |}
 1016|       |
 1017|       |NSInteger RX_number_of_forwarded_methods() {
 1018|       |    return numberOfForwardedMethods;
 1019|       |}
 1020|       |
 1021|       |NSInteger RX_number_of_swizzled_methods() {
 1022|       |    return numberOInterceptedMethods;
 1023|       |}
 1024|       |
 1025|       |#endif
 1026|       |
 1027|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Runtime/include/_RX.h:
    1|       |//
    2|       |//  _RX.h
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import <Foundation/Foundation.h>
   10|       |#import <objc/runtime.h>
   11|       |
   12|       |/**
   13|       | ################################################################################
   14|       | This file is part of RX private API
   15|       | ################################################################################
   16|       | */
   17|       |
   18|       |#if        TRACE_RESOURCES >= 2
   19|       |#   define DLOG(...)         NSLog(__VA_ARGS__)
   20|       |#else
   21|       |#   define DLOG(...)
   22|       |#endif
   23|       |
   24|       |#if        DEBUG
   25|      0|#   define ABORT_IN_DEBUG    abort();
   26|       |#else
   27|       |#   define ABORT_IN_DEBUG
   28|       |#endif
   29|       |
   30|       |
   31|      0|#define SEL_VALUE(x)      [NSValue valueWithPointer:(x)]
   32|      0|#define CLASS_VALUE(x)    [NSValue valueWithNonretainedObject:(x)]
   33|      0|#define IMP_VALUE(x)      [NSValue valueWithPointer:(x)]
   34|       |
   35|       |/**
   36|       | Checks that the local `error` instance exists before assigning it's value by reference.
   37|       | This macro exists to work around static analysis warnings — `NSError` is always assumed to be `nullable`, even though we explicitly define the method parameter as `nonnull`. See http://www.openradar.me/21766176 for more details.
   38|       | */
   39|      0|#define RX_THROW_ERROR(errorValue, returnValue) if (error != nil) { *error = (errorValue); } return (returnValue);
   40|       |
   41|      0|#define RX_CAT2(_1, _2) _RX_CAT2(_1, _2)
   42|      0|#define _RX_CAT2(_1, _2) _1 ## _2
   43|       |
   44|       |#define RX_ELEMENT_AT(n, ...) RX_CAT2(_RX_ELEMENT_AT_, n)(__VA_ARGS__)
   45|       |#define _RX_ELEMENT_AT_0(x, ...) x
   46|       |#define _RX_ELEMENT_AT_1(_0, x, ...) x
   47|       |#define _RX_ELEMENT_AT_2(_0, _1, x, ...) x
   48|       |#define _RX_ELEMENT_AT_3(_0, _1, _2, x, ...) x
   49|       |#define _RX_ELEMENT_AT_4(_0, _1, _2, _3, x, ...) x
   50|       |#define _RX_ELEMENT_AT_5(_0, _1, _2, _3, _4, x, ...) x
   51|       |#define _RX_ELEMENT_AT_6(_0, _1, _2, _3, _4, _5, x, ...) x
   52|       |
   53|       |#define RX_COUNT(...) RX_ELEMENT_AT(6, ## __VA_ARGS__, 6, 5, 4, 3, 2, 1, 0)
   54|       |#define RX_EMPTY(...) RX_ELEMENT_AT(6, ## __VA_ARGS__, 0, 0, 0, 0, 0, 0, 1)
   55|       |
   56|       |/**
   57|       | #define SUM(context, index, head, tail) head + tail
   58|       | #define MAP(context, index, element) (context)[index] * (element)
   59|       |
   60|       | RX_FOR(numbers, SUM, MAP, b0, b1, b2);
   61|       |
   62|       | (numbers)[0] * (b0) + (numbers)[1] * (b1) + (numbers[2]) * (b2)
   63|       | */
   64|       |
   65|      0|#define RX_FOREACH(context, concat, map, ...) RX_FOR_MAX(RX_COUNT(__VA_ARGS__), _RX_FOREACH_CONCAT, _RX_FOREACH_MAP, context, concat, map, __VA_ARGS__)
   66|      0|#define _RX_FOREACH_CONCAT(index, head, tail, context, concat, map, ...) concat(context, index, head, tail)
   67|      0|#define _RX_FOREACH_MAP(index, context, concat, map, ...) map(context, index, RX_ELEMENT_AT(index, __VA_ARGS__))
   68|       |
   69|       |/**
   70|       | #define MAP(context, index, item) (context)[index] * (item)
   71|       |
   72|       | RX_FOR_COMMA(numbers, MAP, b0, b1);
   73|       |
   74|       | ,(numbers)[0] * b0, (numbers)[1] * b1
   75|       | */
   76|      0|#define RX_FOREACH_COMMA(context, map, ...) RX_CAT2(_RX_FOREACH_COMMA_EMPTY_, RX_EMPTY(__VA_ARGS__))(context, map, ## __VA_ARGS__)
   77|       |#define _RX_FOREACH_COMMA_EMPTY_1(context, map, ...)
   78|      0|#define _RX_FOREACH_COMMA_EMPTY_0(context, map, ...) , RX_FOR_MAX(RX_COUNT(__VA_ARGS__), _RX_FOREACH_COMMA_CONCAT, _RX_FOREACH_COMMA_MAP, context, map, __VA_ARGS__)
   79|      0|#define _RX_FOREACH_COMMA_CONCAT(index, head, tail, context, map, ...) head, tail
   80|      0|#define _RX_FOREACH_COMMA_MAP(index, context, map, ...) map(context, index, RX_ELEMENT_AT(index, __VA_ARGS__))
   81|       |
   82|       |// rx for
   83|       |
   84|      0|#define RX_FOR_MAX(max, concat, map, ...) RX_CAT2(RX_FOR_, max)(concat, map, ## __VA_ARGS__)
   85|       |
   86|       |#define RX_FOR_0(concat, map, ...)
   87|      0|#define RX_FOR_1(concat, map, ...) map(0, __VA_ARGS__)
   88|      0|#define RX_FOR_2(concat, map, ...) concat(1, RX_FOR_1(concat, map, ## __VA_ARGS__), map(1, __VA_ARGS__), __VA_ARGS__)
   89|       |#define RX_FOR_3(concat, map, ...) concat(2, RX_FOR_2(concat, map, ## __VA_ARGS__), map(2, __VA_ARGS__), __VA_ARGS__)
   90|       |#define RX_FOR_4(concat, map, ...) concat(3, RX_FOR_3(concat, map, ## __VA_ARGS__), map(3, __VA_ARGS__), __VA_ARGS__)
   91|       |#define RX_FOR_5(concat, map, ...) concat(4, RX_FOR_4(concat, map, ## __VA_ARGS__), map(4, __VA_ARGS__), __VA_ARGS__)
   92|       |#define RX_FOR_6(concat, map, ...) concat(5, RX_FOR_5(concat, map, ## __VA_ARGS__), map(5, __VA_ARGS__), __VA_ARGS__)
   93|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/RxCocoa.swift:
    1|       |//
    2|       |//  RxCocoa.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSNull
   10|       |
   11|       |import RxSwift
   12|       |#if os(iOS)
   13|       |    import UIKit
   14|       |#endif
   15|       |
   16|       |/// RxCocoa errors.
   17|       |public enum RxCocoaError
   18|       |    : Swift.Error
   19|       |    , CustomDebugStringConvertible {
   20|       |    /// Unknown error has occurred.
   21|       |    case unknown
   22|       |    /// Invalid operation was attempted.
   23|       |    case invalidOperation(object: Any)
   24|       |    /// Items are not yet bound to user interface but have been requested.
   25|       |    case itemsNotYetBound(object: Any)
   26|       |    /// Invalid KVO Path.
   27|       |    case invalidPropertyName(object: Any, propertyName: String)
   28|       |    /// Invalid object on key path.
   29|       |    case invalidObjectOnKeyPath(object: Any, sourceObject: AnyObject, propertyName: String)
   30|       |    /// Error during swizzling.
   31|       |    case errorDuringSwizzling
   32|       |    /// Casting error.
   33|       |    case castingError(object: Any, targetType: Any.Type)
   34|       |}
   35|       |
   36|       |
   37|       |// MARK: Debug descriptions
   38|       |
   39|       |extension RxCocoaError {
   40|       |    /// A textual representation of `self`, suitable for debugging.
   41|       |    public var debugDescription: String {
   42|       |        switch self {
   43|       |        case .unknown:
   44|       |            return "Unknown error occurred."
   45|       |        case let .invalidOperation(object):
   46|       |            return "Invalid operation was attempted on `\(object)`."
   47|       |        case let .itemsNotYetBound(object):
   48|       |            return "Data source is set, but items are not yet bound to user interface for `\(object)`."
   49|       |        case let .invalidPropertyName(object, propertyName):
   50|       |            return "Object `\(object)` doesn't have a property named `\(propertyName)`."
   51|       |        case let .invalidObjectOnKeyPath(object, sourceObject, propertyName):
   52|       |            return "Unobservable object `\(object)` was observed as `\(propertyName)` of `\(sourceObject)`."
   53|       |        case .errorDuringSwizzling:
   54|       |            return "Error during swizzling."
   55|       |        case let .castingError(object, targetType):
   56|       |            return "Error casting `\(object)` to `\(targetType)`"
   57|       |        }
   58|       |    }
   59|       |}
   60|       |
   61|       |
   62|       |
   63|       |// MARK: Error binding policies
   64|       |
   65|      0|func bindingError(_ error: Swift.Error) {
   66|      0|    let error = "Binding error: \(error)"
   67|      0|#if DEBUG
   68|      0|    rxFatalError(error)
   69|      0|#else
   70|      0|    print(error)
   71|      0|#endif
   72|      0|}
   73|       |
   74|       |/// Swift does not implement abstract methods. This method is used as a runtime check to ensure that methods which intended to be abstract (i.e., they should be implemented in subclasses) are not called directly on the superclass.
   75|      0|func rxAbstractMethod(message: String = "Abstract method", file: StaticString = #file, line: UInt = #line) -> Swift.Never {
   76|      0|    rxFatalError(message, file: file, line: line)
   77|      0|}
   78|       |
   79|       |func rxFatalError(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) -> Swift.Never  {
   80|       |    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
   81|      0|    fatalError(lastMessage(), file: file, line: line)
   82|       |}
   83|       |
   84|      0|func rxFatalErrorInDebug(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) {
   85|      0|    #if DEBUG
   86|      0|        fatalError(lastMessage(), file: file, line: line)
   87|      0|    #else
   88|      0|        print("\(file):\(line): \(lastMessage())")
   89|      0|    #endif
   90|      0|}
   91|       |
   92|       |// MARK: casts or fatal error
   93|       |
   94|       |// workaround for Swift compiler bug, cheers compiler team :)
   95|      0|func castOptionalOrFatalError<T>(_ value: Any?) -> T? {
   96|      0|    if value == nil {
   97|      0|        return nil
   98|      0|    }
   99|      0|    let v: T = castOrFatalError(value)
  100|      0|    return v
  101|      0|}
  102|       |
  103|      0|func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws -> T {
  104|      0|    guard let returnValue = object as? T else {
  105|      0|        throw RxCocoaError.castingError(object: object, targetType: resultType)
  106|      0|    }
  107|      0|
  108|      0|    return returnValue
  109|      0|}
  110|       |
  111|      0|func castOptionalOrThrow<T>(_ resultType: T.Type, _ object: AnyObject) throws -> T? {
  112|      0|    if NSNull().isEqual(object) {
  113|      0|        return nil
  114|      0|    }
  115|      0|
  116|      0|    guard let returnValue = object as? T else {
  117|      0|        throw RxCocoaError.castingError(object: object, targetType: resultType)
  118|      0|    }
  119|      0|
  120|      0|    return returnValue
  121|      0|}
  122|       |
  123|      0|func castOrFatalError<T>(_ value: AnyObject!, message: String) -> T {
  124|      0|    let maybeResult: T? = value as? T
  125|      0|    guard let result = maybeResult else {
  126|      0|        rxFatalError(message)
  127|      0|    }
  128|      0|    
  129|      0|    return result
  130|      0|}
  131|       |
  132|       |func castOrFatalError<T>(_ value: Any!) -> T {
  133|       |    let maybeResult: T? = value as? T
  134|       |    guard let result = maybeResult else {
  135|       |        rxFatalError("Failure converting from \(String(describing: value)) to \(T.self)")
  136|       |    }
  137|       |    
  138|       |    return result
  139|       |}
  140|       |
  141|       |// MARK: Error messages
  142|       |
  143|       |let dataSourceNotSet = "DataSource not set"
  144|       |let delegateNotSet = "Delegate not set"
  145|       |
  146|       |// MARK: Shared with RxSwift
  147|       |
  148|       |func rxFatalError(_ lastMessage: String) -> Never  {
  149|       |    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
  150|      0|    fatalError(lastMessage)
  151|       |}
  152|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/BehaviorRelay.swift:
    1|       |//
    2|       |//  BehaviorRelay.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/7/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// BehaviorRelay is a wrapper for `BehaviorSubject`.
   12|       |///
   13|       |/// Unlike `BehaviorSubject` it can't terminate with error or completed.
   14|       |public final class BehaviorRelay<Element>: ObservableType {
   15|       |    public typealias E = Element
   16|       |
   17|       |    private let _subject: BehaviorSubject<Element>
   18|       |
   19|       |    /// Accepts `event` and emits it to subscribers
   20|      0|    public func accept(_ event: Element) {
   21|      0|        self._subject.onNext(event)
   22|      0|    }
   23|       |
   24|       |    /// Current value of behavior subject
   25|      0|    public var value: Element {
   26|      0|        // this try! is ok because subject can't error out or be disposed
   27|      0|        return try! self._subject.value()
   28|      0|    }
   29|       |
   30|       |    /// Initializes behavior relay with initial value.
   31|      0|    public init(value: Element) {
   32|      0|        self._subject = BehaviorSubject(value: value)
   33|      0|    }
   34|       |
   35|       |    /// Subscribes observer
   36|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   37|      0|        return self._subject.subscribe(observer)
   38|      0|    }
   39|       |
   40|       |    /// - returns: Canonical interface for push style sequence
   41|      0|    public func asObservable() -> Observable<Element> {
   42|      0|        return self._subject.asObservable()
   43|      0|    }
   44|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/ControlEvent.swift:
    1|       |//
    2|       |//  ControlEvent.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// A protocol that extends `ControlEvent`.
   12|       |public protocol ControlEventType : ObservableType {
   13|       |
   14|       |    /// - returns: `ControlEvent` interface
   15|       |    func asControlEvent() -> ControlEvent<E>
   16|       |}
   17|       |
   18|       |/**
   19|       |    A trait for `Observable`/`ObservableType` that represents an event on a UI element.
   20|       |
   21|       |    Properties:
   22|       |
   23|       |    - it never fails,
   24|       |    - it doesn’t send any initial value on subscription,
   25|       |    - it `Complete`s the sequence when the control deallocates,
   26|       |    - it never errors out, and
   27|       |    - it delivers events on `MainScheduler.instance`.
   28|       |
   29|       |    **The implementation of `ControlEvent` will ensure that sequence of events is being subscribed on main scheduler
   30|       |     (`subscribeOn(ConcurrentMainScheduler.instance)` behavior).**
   31|       |
   32|       |    **It is the implementor’s responsibility to make sure that all other properties enumerated above are satisfied.**
   33|       |
   34|       |    **If they aren’t, using this trait will communicate wrong properties, and could potentially break someone’s code.**
   35|       |
   36|       |    **If the `events` observable sequence passed into thr initializer doesn’t satisfy all enumerated
   37|       |     properties, don’t use this trait.**
   38|       |*/
   39|       |public struct ControlEvent<PropertyType> : ControlEventType {
   40|       |    public typealias E = PropertyType
   41|       |
   42|       |    let _events: Observable<PropertyType>
   43|       |
   44|       |    /// Initializes control event with a observable sequence that represents events.
   45|       |    ///
   46|       |    /// - parameter events: Observable sequence that represents events.
   47|       |    /// - returns: Control event created with a observable sequence of events.
   48|      0|    public init<Ev: ObservableType>(events: Ev) where Ev.E == E {
   49|      0|        self._events = events.subscribeOn(ConcurrentMainScheduler.instance)
   50|      0|    }
   51|       |
   52|       |    /// Subscribes an observer to control events.
   53|       |    ///
   54|       |    /// - parameter observer: Observer to subscribe to events.
   55|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from receiving control events.
   56|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   57|      0|        return self._events.subscribe(observer)
   58|      0|    }
   59|       |
   60|       |    /// - returns: `Observable` interface.
   61|      0|    public func asObservable() -> Observable<E> {
   62|      0|        return self._events
   63|      0|    }
   64|       |
   65|       |    /// - returns: `ControlEvent` interface.
   66|      0|    public func asControlEvent() -> ControlEvent<E> {
   67|      0|        return self
   68|      0|    }
   69|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/ControlProperty.swift:
    1|       |//
    2|       |//  ControlProperty.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// Protocol that enables extension of `ControlProperty`.
   12|       |public protocol ControlPropertyType : ObservableType, ObserverType {
   13|       |
   14|       |    /// - returns: `ControlProperty` interface
   15|       |    func asControlProperty() -> ControlProperty<E>
   16|       |}
   17|       |
   18|       |/**
   19|       |    Trait for `Observable`/`ObservableType` that represents property of UI element.
   20|       | 
   21|       |    Sequence of values only represents initial control value and user initiated value changes.
   22|       |    Programmatic value changes won't be reported.
   23|       |
   24|       |    It's properties are:
   25|       |
   26|       |    - it never fails
   27|       |    - `shareReplay(1)` behavior
   28|       |        - it's stateful, upon subscription (calling subscribe) last element is immediately replayed if it was produced
   29|       |    - it will `Complete` sequence on control being deallocated
   30|       |    - it never errors out
   31|       |    - it delivers events on `MainScheduler.instance`
   32|       |
   33|       |    **The implementation of `ControlProperty` will ensure that sequence of values is being subscribed on main scheduler
   34|       |    (`subscribeOn(ConcurrentMainScheduler.instance)` behavior).**
   35|       |
   36|       |    **It is implementor's responsibility to make sure that that all other properties enumerated above are satisfied.**
   37|       |
   38|       |    **If they aren't, then using this trait communicates wrong properties and could potentially break someone's code.**
   39|       |
   40|       |    **In case `values` observable sequence that is being passed into initializer doesn't satisfy all enumerated
   41|       |    properties, please don't use this trait.**
   42|       |*/
   43|       |public struct ControlProperty<PropertyType> : ControlPropertyType {
   44|       |    public typealias E = PropertyType
   45|       |
   46|       |    let _values: Observable<PropertyType>
   47|       |    let _valueSink: AnyObserver<PropertyType>
   48|       |
   49|       |    /// Initializes control property with a observable sequence that represents property values and observer that enables
   50|       |    /// binding values to property.
   51|       |    ///
   52|       |    /// - parameter values: Observable sequence that represents property values.
   53|       |    /// - parameter valueSink: Observer that enables binding values to control property.
   54|       |    /// - returns: Control property created with a observable sequence of values and an observer that enables binding values
   55|       |    /// to property.
   56|      0|    public init<V: ObservableType, S: ObserverType>(values: V, valueSink: S) where E == V.E, E == S.E {
   57|      0|        self._values = values.subscribeOn(ConcurrentMainScheduler.instance)
   58|      0|        self._valueSink = valueSink.asObserver()
   59|      0|    }
   60|       |
   61|       |    /// Subscribes an observer to control property values.
   62|       |    ///
   63|       |    /// - parameter observer: Observer to subscribe to property values.
   64|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from receiving control property values.
   65|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   66|      0|        return self._values.subscribe(observer)
   67|      0|    }
   68|       |
   69|       |    /// `ControlEvent` of user initiated value changes. Every time user updates control value change event
   70|       |    /// will be emitted from `changed` event.
   71|       |    ///
   72|       |    /// Programmatic changes to control value won't be reported.
   73|       |    ///
   74|       |    /// It contains all control property values except for first one.
   75|       |    ///
   76|       |    /// The name only implies that sequence element will be generated once user changes a value and not that
   77|       |    /// adjacent sequence values need to be different (e.g. because of interaction between programmatic and user updates,
   78|       |    /// or for any other reason).
   79|      0|    public var changed: ControlEvent<PropertyType> {
   80|      0|        return ControlEvent(events: self._values.skip(1))
   81|      0|    }
   82|       |
   83|       |    /// - returns: `Observable` interface.
   84|      0|    public func asObservable() -> Observable<E> {
   85|      0|        return self._values
   86|      0|    }
   87|       |
   88|       |    /// - returns: `ControlProperty` interface.
   89|      0|    public func asControlProperty() -> ControlProperty<E> {
   90|      0|        return self
   91|      0|    }
   92|       |
   93|       |    /// Binds event to user interface.
   94|       |    ///
   95|       |    /// - In case next element is received, it is being set to control value.
   96|       |    /// - In case error is received, DEBUG buids raise fatal error, RELEASE builds log event to standard output.
   97|       |    /// - In case sequence completes, nothing happens.
   98|      0|    public func on(_ event: Event<E>) {
   99|      0|        switch event {
  100|      0|        case .error(let error):
  101|      0|            bindingError(error)
  102|      0|        case .next:
  103|      0|            self._valueSink.on(event)
  104|      0|        case .completed:
  105|      0|            self._valueSink.on(event)
  106|      0|        }
  107|      0|    }
  108|       |}
  109|       |
  110|       |extension ControlPropertyType where E == String? {
  111|       |    /// Transforms control property of type `String?` into control property of type `String`.
  112|      0|    public var orEmpty: ControlProperty<String> {
  113|      0|        let original: ControlProperty<String?> = self.asControlProperty()
  114|      0|
  115|      0|        let values: Observable<String> = original._values.map { $0 ?? "" }
  116|      0|        let valueSink: AnyObserver<String> = original._valueSink.mapObserver { $0 }
  117|      0|        return ControlProperty<String>(values: values, valueSink: valueSink)
  118|      0|    }
  119|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/BehaviorRelay+Driver.swift:
    1|       |//
    2|       |//  BehaviorRelay+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/7/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension BehaviorRelay {
   12|       |    /// Converts `BehaviorRelay` to `Driver`.
   13|       |    ///
   14|       |    /// - returns: Observable sequence.
   15|      0|    public func asDriver() -> Driver<Element> {
   16|      0|        let source = self.asObservable()
   17|      0|            .observeOn(DriverSharingStrategy.scheduler)
   18|      0|        return SharedSequence(source)
   19|      0|    }
   20|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ControlEvent+Driver.swift:
    1|       |//
    2|       |//  ControlEvent+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |    
   11|       |extension ControlEvent {
   12|       |    /// Converts `ControlEvent` to `Driver` trait.
   13|       |    ///
   14|       |    /// `ControlEvent` already can't fail, so no special case needs to be handled.
   15|      0|    public func asDriver() -> Driver<E> {
   16|      0|        return self.asDriver { _ -> Driver<E> in
   17|      0|            #if DEBUG
   18|      0|                rxFatalError("Somehow driver received error from a source that shouldn't fail.")
   19|      0|            #else
   20|      0|                return Driver.empty()
   21|      0|            #endif
   22|      0|        }
   23|      0|    }
   24|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ControlProperty+Driver.swift:
    1|       |//
    2|       |//  ControlProperty+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension ControlProperty {
   12|       |    /// Converts `ControlProperty` to `Driver` trait.
   13|       |    ///
   14|       |    /// `ControlProperty` already can't fail, so no special case needs to be handled.
   15|      0|    public func asDriver() -> Driver<E> {
   16|      0|        return self.asDriver { _ -> Driver<E> in
   17|      0|            #if DEBUG
   18|      0|                rxFatalError("Somehow driver received error from a source that shouldn't fail.")
   19|      0|            #else
   20|      0|                return Driver.empty()
   21|      0|            #endif
   22|      0|        }
   23|      0|    }
   24|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/Driver+Subscription.swift:
    1|       |//
    2|       |//  Driver+Subscription.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |private let errorMessage = "`drive*` family of methods can be only called from `MainThread`.\n" +
   12|       |"This is required to ensure that the last replayed `Driver` element is delivered on `MainThread`.\n"
   13|       |
   14|       |extension SharedSequenceConvertibleType where SharingStrategy == DriverSharingStrategy {
   15|       |    /**
   16|       |    Creates new subscription and sends elements to observer.
   17|       |    This method can be only called from `MainThread`.
   18|       |
   19|       |    In this form it's equivalent to `subscribe` method, but it communicates intent better.
   20|       |
   21|       |    - parameter observer: Observer that receives events.
   22|       |    - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   23|       |    */
   24|      0|    public func drive<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   25|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   26|      0|        return self.asSharedSequence().asObservable().subscribe(observer)
   27|      0|    }
   28|       |
   29|       |    /**
   30|       |     Creates new subscription and sends elements to observer.
   31|       |     This method can be only called from `MainThread`.
   32|       |
   33|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better.
   34|       |
   35|       |     - parameter observer: Observer that receives events.
   36|       |     - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   37|       |     */
   38|      0|    public func drive<O: ObserverType>(_ observer: O) -> Disposable where O.E == E? {
   39|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   40|      0|        return self.asSharedSequence().asObservable().map { $0 as E? }.subscribe(observer)
   41|      0|    }
   42|       |
   43|       |    /**
   44|       |    Creates new subscription and sends elements to `BehaviorRelay`.
   45|       |    This method can be only called from `MainThread`.
   46|       |
   47|       |    - parameter relay: Target relay for sequence elements.
   48|       |    - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   49|       |    */
   50|      0|    public func drive(_ relay: BehaviorRelay<E>) -> Disposable {
   51|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   52|      0|        return self.drive(onNext: { e in
   53|      0|            relay.accept(e)
   54|      0|        })
   55|      0|    }
   56|       |
   57|       |    /**
   58|       |     Creates new subscription and sends elements to `BehaviorRelay`.
   59|       |     This method can be only called from `MainThread`.
   60|       |
   61|       |     - parameter relay: Target relay for sequence elements.
   62|       |     - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   63|       |     */
   64|      0|    public func drive(_ relay: BehaviorRelay<E?>) -> Disposable {
   65|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   66|      0|        return self.drive(onNext: { e in
   67|      0|            relay.accept(e)
   68|      0|        })
   69|      0|    }
   70|       |
   71|       |    /**
   72|       |    Subscribes to observable sequence using custom binder function.
   73|       |    This method can be only called from `MainThread`.
   74|       |
   75|       |    - parameter with: Function used to bind elements from `self`.
   76|       |    - returns: Object representing subscription.
   77|       |    */
   78|      0|    public func drive<R>(_ transformation: (Observable<E>) -> R) -> R {
   79|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   80|      0|        return transformation(self.asObservable())
   81|      0|    }
   82|       |
   83|       |    /**
   84|       |    Subscribes to observable sequence using custom binder function and final parameter passed to binder function
   85|       |    after `self` is passed.
   86|       |
   87|       |        public func drive<R1, R2>(with: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
   88|       |            return with(self)(curriedArgument)
   89|       |        }
   90|       |
   91|       |    This method can be only called from `MainThread`.
   92|       |
   93|       |    - parameter with: Function used to bind elements from `self`.
   94|       |    - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
   95|       |    - returns: Object representing subscription.
   96|       |    */
   97|      0|    public func drive<R1, R2>(_ with: (Observable<E>) -> (R1) -> R2, curriedArgument: R1) -> R2 {
   98|      0|        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
   99|      0|        return with(self.asObservable())(curriedArgument)
  100|      0|    }
  101|       |    
  102|       |    /**
  103|       |    Subscribes an element handler, a completion handler and disposed handler to an observable sequence.
  104|       |    This method can be only called from `MainThread`.
  105|       |    
  106|       |    Error callback is not exposed because `Driver` can't error out.
  107|       |    
  108|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
  109|       |    - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  110|       |    gracefully completed, errored, or if the generation is canceled by disposing subscription)
  111|       |    - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
  112|       |    gracefully completed, errored, or if the generation is canceled by disposing subscription)
  113|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
  114|       |    */
  115|       |    public func drive(onNext: ((E) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil) -> Disposable {
  116|       |        MainScheduler.ensureRunningOnMainThread(errorMessage: errorMessage)
  117|       |        return self.asObservable().subscribe(onNext: onNext, onCompleted: onCompleted, onDisposed: onDisposed)
  118|       |    }
  119|       |}
  120|       |
  121|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/Driver.swift:
    1|       |//
    2|       |//  Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/**
   12|       | Trait that represents observable sequence with following properties:
   13|       |
   14|       | - it never fails
   15|       | - it delivers events on `MainScheduler.instance`
   16|       | - `share(replay: 1, scope: .whileConnected)` sharing strategy
   17|       | 
   18|       | Additional explanation:
   19|       | - all observers share sequence computation resources
   20|       | - it's stateful, upon subscription (calling subscribe) last element is immediately replayed if it was produced
   21|       | - computation of elements is reference counted with respect to the number of observers
   22|       | - if there are no subscribers, it will release sequence computation resources
   23|       |
   24|       | In case trait that models event bus is required, please check `Signal`.
   25|       |
   26|       | `Driver<Element>` can be considered a builder pattern for observable sequences that drive the application.
   27|       |
   28|       | If observable sequence has produced at least one element, after new subscription is made last produced element will be
   29|       | immediately replayed on the same thread on which the subscription was made.
   30|       |
   31|       | When using `drive*`, `subscribe*` and `bind*` family of methods, they should always be called from main thread.
   32|       |
   33|       | If `drive*`, `subscribe*` and `bind*` are called from background thread, it is possible that initial replay
   34|       | will happen on background thread, and subsequent events will arrive on main thread.
   35|       |
   36|       | To find out more about traits and how to use them, please visit `Documentation/Traits.md`.
   37|       | */
   38|       |public typealias Driver<E> = SharedSequence<DriverSharingStrategy, E>
   39|       |
   40|       |public struct DriverSharingStrategy: SharingStrategyProtocol {
   41|      0|    public static var scheduler: SchedulerType { return SharingScheduler.make() }
   42|      0|    public static func share<E>(_ source: Observable<E>) -> Observable<E> {
   43|      0|        return source.share(replay: 1, scope: .whileConnected)
   44|      0|    }
   45|       |}
   46|       |
   47|       |extension SharedSequenceConvertibleType where SharingStrategy == DriverSharingStrategy {
   48|       |    /// Adds `asDriver` to `SharingSequence` with `DriverSharingStrategy`.
   49|      0|    public func asDriver() -> Driver<E> {
   50|      0|        return self.asSharedSequence()
   51|      0|    }
   52|       |}
   53|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ObservableConvertibleType+Driver.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension ObservableConvertibleType {
   12|       |    /**
   13|       |    Converts observable sequence to `Driver` trait.
   14|       |    
   15|       |    - parameter onErrorJustReturn: Element to return in case of error and after that complete the sequence.
   16|       |    - returns: Driver trait.
   17|       |    */
   18|      0|    public func asDriver(onErrorJustReturn: E) -> Driver<E> {
   19|      0|        let source = self
   20|      0|            .asObservable()
   21|      0|            .observeOn(DriverSharingStrategy.scheduler)
   22|      0|            .catchErrorJustReturn(onErrorJustReturn)
   23|      0|        return Driver(source)
   24|      0|    }
   25|       |    
   26|       |    /**
   27|       |    Converts observable sequence to `Driver` trait.
   28|       |    
   29|       |    - parameter onErrorDriveWith: Driver that continues to drive the sequence in case of error.
   30|       |    - returns: Driver trait.
   31|       |    */
   32|      0|    public func asDriver(onErrorDriveWith: Driver<E>) -> Driver<E> {
   33|      0|        let source = self
   34|      0|            .asObservable()
   35|      0|            .observeOn(DriverSharingStrategy.scheduler)
   36|      0|            .catchError { _ in
   37|      0|                onErrorDriveWith.asObservable()
   38|      0|            }
   39|      0|        return Driver(source)
   40|      0|    }
   41|       |
   42|       |    /**
   43|       |    Converts observable sequence to `Driver` trait.
   44|       |    
   45|       |    - parameter onErrorRecover: Calculates driver that continues to drive the sequence in case of error.
   46|       |    - returns: Driver trait.
   47|       |    */
   48|      0|    public func asDriver(onErrorRecover: @escaping (_ error: Swift.Error) -> Driver<E>) -> Driver<E> {
   49|      0|        let source = self
   50|      0|            .asObservable()
   51|      0|            .observeOn(DriverSharingStrategy.scheduler)
   52|      0|            .catchError { error in
   53|      0|                onErrorRecover(error).asObservable()
   54|      0|            }
   55|      0|        return Driver(source)
   56|      0|    }
   57|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/PublishRelay.swift:
    1|       |//
    2|       |//  PublishRelay.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// PublishRelay is a wrapper for `PublishSubject`.
   12|       |///
   13|       |/// Unlike `PublishSubject` it can't terminate with error or completed.
   14|       |public final class PublishRelay<Element>: ObservableType {
   15|       |    public typealias E = Element
   16|       |
   17|       |    private let _subject: PublishSubject<Element>
   18|       |    
   19|       |    // Accepts `event` and emits it to subscribers
   20|      0|    public func accept(_ event: Element) {
   21|      0|        self._subject.onNext(event)
   22|      0|    }
   23|       |    
   24|       |    /// Initializes with internal empty subject.
   25|      0|    public init() {
   26|      0|        self._subject = PublishSubject()
   27|      0|    }
   28|       |
   29|       |    /// Subscribes observer
   30|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   31|      0|        return self._subject.subscribe(observer)
   32|      0|    }
   33|       |    
   34|       |    /// - returns: Canonical interface for push style sequence
   35|      0|    public func asObservable() -> Observable<Element> {
   36|      0|        return self._subject.asObservable()
   37|      0|    }
   38|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/ObservableConvertibleType+SharedSequence.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/1/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension ObservableConvertibleType {
   12|       |    /**
   13|       |     Converts anything convertible to `Observable` to `SharedSequence` unit.
   14|       |
   15|       |     - parameter onErrorJustReturn: Element to return in case of error and after that complete the sequence.
   16|       |     - returns: Driving observable sequence.
   17|       |     */
   18|      0|    public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: E) -> SharedSequence<S, E> {
   19|      0|        let source = self
   20|      0|            .asObservable()
   21|      0|            .observeOn(S.scheduler)
   22|      0|            .catchErrorJustReturn(onErrorJustReturn)
   23|      0|        return SharedSequence(source)
   24|      0|    }
   25|       |
   26|       |    /**
   27|       |     Converts anything convertible to `Observable` to `SharedSequence` unit.
   28|       |
   29|       |     - parameter onErrorDriveWith: SharedSequence that provides elements of the sequence in case of error.
   30|       |     - returns: Driving observable sequence.
   31|       |     */
   32|      0|    public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: SharedSequence<S, E>) -> SharedSequence<S, E> {
   33|      0|        let source = self
   34|      0|            .asObservable()
   35|      0|            .observeOn(S.scheduler)
   36|      0|            .catchError { _ in
   37|      0|                onErrorDriveWith.asObservable()
   38|      0|            }
   39|      0|        return SharedSequence(source)
   40|      0|    }
   41|       |
   42|       |    /**
   43|       |     Converts anything convertible to `Observable` to `SharedSequence` unit.
   44|       |
   45|       |     - parameter onErrorRecover: Calculates driver that continues to drive the sequence in case of error.
   46|       |     - returns: Driving observable sequence.
   47|       |     */
   48|      0|    public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (_ error: Swift.Error) -> SharedSequence<S, E>) -> SharedSequence<S, E> {
   49|      0|        let source = self
   50|      0|            .asObservable()
   51|      0|            .observeOn(S.scheduler)
   52|      0|            .catchError { error in
   53|      0|                onErrorRecover(error).asObservable()
   54|      0|            }
   55|      0|        return SharedSequence(source)
   56|      0|    }
   57|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SchedulerType+SharedSequence.swift:
    1|       |//
    2|       |//  SchedulerType+SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/27/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |public enum SharingScheduler {
   12|       |    /// Default scheduler used in SharedSequence based traits.
   13|      0|    public private(set) static var make: () -> SchedulerType = { MainScheduler() }
   14|       |
   15|       |    /**
   16|       |     This method can be used in unit tests to ensure that built in shared sequences are using mock schedulers instead
   17|       |     of main schedulers.
   18|       |
   19|       |     **This shouldn't be used in normal release builds.**
   20|       |    */
   21|      0|    static public func mock(scheduler: SchedulerType, action: () -> Void) {
   22|      0|        return mock(makeScheduler: { scheduler }, action: action)
   23|      0|    }
   24|       |
   25|       |    /**
   26|       |     This method can be used in unit tests to ensure that built in shared sequences are using mock schedulers instead
   27|       |     of main schedulers.
   28|       |
   29|       |     **This shouldn't be used in normal release builds.**
   30|       |     */
   31|       |    static public func mock(makeScheduler: @escaping () -> SchedulerType, action: () -> Void) {
   32|       |        let originalMake = make
   33|       |        make = makeScheduler
   34|       |
   35|       |        action()
   36|       |
   37|       |        // If you remove this line , compiler buggy optimizations will change behavior of this code
   38|       |        _forceCompilerToStopDoingInsaneOptimizationsThatBreakCode(makeScheduler)
   39|       |        // Scary, I know
   40|       |
   41|       |        make = originalMake
   42|       |    }
   43|       |}
   44|       |
   45|       |#if os(Linux)
   46|       |    import Glibc
   47|       |#else
   48|       |    import func Foundation.arc4random
   49|       |#endif
   50|       |
   51|       |func _forceCompilerToStopDoingInsaneOptimizationsThatBreakCode(_ scheduler: () -> SchedulerType) {
   52|       |    let a: Int32 = 1
   53|       |#if os(Linux)
   54|       |    let b = 314 + Int32(Glibc.random() & 1)
   55|       |#else
   56|       |    let b = 314 + Int32(arc4random() & 1)
   57|       |#endif
   58|       |    if a == b {
   59|       |        print(scheduler())
   60|       |    }
   61|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence+Operators+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  SharedSequence+Operators+arity.swift
    4|       |//  RxCocoa
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 10/14/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |import RxSwift
   11|       |
   12|       |
   13|       |
   14|       |// 2
   15|       |
   16|       |extension SharedSequence {
   17|       |    /**
   18|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   19|       |
   20|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   24|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   25|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
   26|      0|            SharingStrategy == O2.SharingStrategy {
   27|      0|        let source = Observable.zip(
   28|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(),
   29|      0|            resultSelector: resultSelector
   30|      0|        )
   31|      0|
   32|      0|        return SharedSequence<SharingStrategy, E>(source)
   33|      0|    }
   34|       |}
   35|       |
   36|       |extension SharedSequenceConvertibleType where E == Any {
   37|       |    /**
   38|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
   39|       |
   40|       |    - returns: An observable sequence containing the result of combining elements of the sources.
   41|       |    */
   42|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   43|       |        (_ source1: O1, _ source2: O2)
   44|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E)> where SharingStrategy == O1.SharingStrategy,
   45|      0|            SharingStrategy == O2.SharingStrategy {
   46|      0|        let source = Observable.zip(
   47|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable()
   48|      0|        )
   49|      0|
   50|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E)>(source)
   51|      0|    }
   52|       |}
   53|       |
   54|       |extension SharedSequence {
   55|       |    /**
   56|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   57|       |
   58|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   59|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   60|       |    */
   61|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   62|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   63|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
   64|      0|            SharingStrategy == O2.SharingStrategy {
   65|      0|        let source = Observable.combineLatest(
   66|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(),
   67|      0|                resultSelector: resultSelector
   68|      0|            )
   69|      0|
   70|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
   71|      0|    }
   72|       |}
   73|       |
   74|       |extension SharedSequenceConvertibleType where E == Any {
   75|       |    /**
   76|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
   77|       |
   78|       |    - returns: An observable sequence containing the result of combining elements of the sources.
   79|       |    */
   80|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   81|       |        (_ source1: O1, _ source2: O2)
   82|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E)> where SharingStrategy == O1.SharingStrategy,
   83|      0|            SharingStrategy == O2.SharingStrategy {
   84|      0|        let source = Observable.combineLatest(
   85|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable()
   86|      0|            )
   87|      0|
   88|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E)>(source)
   89|      0|    }
   90|       |}
   91|       |
   92|       |
   93|       |
   94|       |// 3
   95|       |
   96|       |extension SharedSequence {
   97|       |    /**
   98|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   99|       |
  100|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  101|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  102|       |    */
  103|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
  104|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  105|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  106|       |            SharingStrategy == O2.SharingStrategy,
  107|      0|            SharingStrategy == O3.SharingStrategy {
  108|      0|        let source = Observable.zip(
  109|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(),
  110|      0|            resultSelector: resultSelector
  111|      0|        )
  112|      0|
  113|      0|        return SharedSequence<SharingStrategy, E>(source)
  114|      0|    }
  115|       |}
  116|       |
  117|       |extension SharedSequenceConvertibleType where E == Any {
  118|       |    /**
  119|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  120|       |
  121|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  122|       |    */
  123|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
  124|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  125|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E)> where SharingStrategy == O1.SharingStrategy,
  126|       |            SharingStrategy == O2.SharingStrategy,
  127|      0|            SharingStrategy == O3.SharingStrategy {
  128|      0|        let source = Observable.zip(
  129|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable()
  130|      0|        )
  131|      0|
  132|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E)>(source)
  133|      0|    }
  134|       |}
  135|       |
  136|       |extension SharedSequence {
  137|       |    /**
  138|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  139|       |
  140|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  141|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  142|       |    */
  143|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
  144|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  145|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  146|       |            SharingStrategy == O2.SharingStrategy,
  147|      0|            SharingStrategy == O3.SharingStrategy {
  148|      0|        let source = Observable.combineLatest(
  149|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(),
  150|      0|                resultSelector: resultSelector
  151|      0|            )
  152|      0|
  153|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  154|      0|    }
  155|       |}
  156|       |
  157|       |extension SharedSequenceConvertibleType where E == Any {
  158|       |    /**
  159|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  160|       |
  161|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  162|       |    */
  163|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
  164|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  165|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E)> where SharingStrategy == O1.SharingStrategy,
  166|       |            SharingStrategy == O2.SharingStrategy,
  167|      0|            SharingStrategy == O3.SharingStrategy {
  168|      0|        let source = Observable.combineLatest(
  169|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable()
  170|      0|            )
  171|      0|
  172|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E)>(source)
  173|      0|    }
  174|       |}
  175|       |
  176|       |
  177|       |
  178|       |// 4
  179|       |
  180|       |extension SharedSequence {
  181|       |    /**
  182|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  183|       |
  184|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  185|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  186|       |    */
  187|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  188|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  189|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  190|       |            SharingStrategy == O2.SharingStrategy,
  191|       |            SharingStrategy == O3.SharingStrategy,
  192|      0|            SharingStrategy == O4.SharingStrategy {
  193|      0|        let source = Observable.zip(
  194|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(),
  195|      0|            resultSelector: resultSelector
  196|      0|        )
  197|      0|
  198|      0|        return SharedSequence<SharingStrategy, E>(source)
  199|      0|    }
  200|       |}
  201|       |
  202|       |extension SharedSequenceConvertibleType where E == Any {
  203|       |    /**
  204|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  205|       |
  206|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  207|       |    */
  208|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  209|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  210|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E)> where SharingStrategy == O1.SharingStrategy,
  211|       |            SharingStrategy == O2.SharingStrategy,
  212|       |            SharingStrategy == O3.SharingStrategy,
  213|      0|            SharingStrategy == O4.SharingStrategy {
  214|      0|        let source = Observable.zip(
  215|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable()
  216|      0|        )
  217|      0|
  218|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E)>(source)
  219|      0|    }
  220|       |}
  221|       |
  222|       |extension SharedSequence {
  223|       |    /**
  224|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  225|       |
  226|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  227|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  228|       |    */
  229|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  230|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  231|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  232|       |            SharingStrategy == O2.SharingStrategy,
  233|       |            SharingStrategy == O3.SharingStrategy,
  234|      0|            SharingStrategy == O4.SharingStrategy {
  235|      0|        let source = Observable.combineLatest(
  236|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(),
  237|      0|                resultSelector: resultSelector
  238|      0|            )
  239|      0|
  240|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  241|      0|    }
  242|       |}
  243|       |
  244|       |extension SharedSequenceConvertibleType where E == Any {
  245|       |    /**
  246|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  247|       |
  248|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  249|       |    */
  250|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  251|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  252|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E)> where SharingStrategy == O1.SharingStrategy,
  253|       |            SharingStrategy == O2.SharingStrategy,
  254|       |            SharingStrategy == O3.SharingStrategy,
  255|      0|            SharingStrategy == O4.SharingStrategy {
  256|      0|        let source = Observable.combineLatest(
  257|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable()
  258|      0|            )
  259|      0|
  260|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E)>(source)
  261|      0|    }
  262|       |}
  263|       |
  264|       |
  265|       |
  266|       |// 5
  267|       |
  268|       |extension SharedSequence {
  269|       |    /**
  270|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  271|       |
  272|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  273|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  274|       |    */
  275|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  276|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  277|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  278|       |            SharingStrategy == O2.SharingStrategy,
  279|       |            SharingStrategy == O3.SharingStrategy,
  280|       |            SharingStrategy == O4.SharingStrategy,
  281|      0|            SharingStrategy == O5.SharingStrategy {
  282|      0|        let source = Observable.zip(
  283|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(),
  284|      0|            resultSelector: resultSelector
  285|      0|        )
  286|      0|
  287|      0|        return SharedSequence<SharingStrategy, E>(source)
  288|      0|    }
  289|       |}
  290|       |
  291|       |extension SharedSequenceConvertibleType where E == Any {
  292|       |    /**
  293|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  294|       |
  295|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  296|       |    */
  297|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  298|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  299|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E)> where SharingStrategy == O1.SharingStrategy,
  300|       |            SharingStrategy == O2.SharingStrategy,
  301|       |            SharingStrategy == O3.SharingStrategy,
  302|       |            SharingStrategy == O4.SharingStrategy,
  303|      0|            SharingStrategy == O5.SharingStrategy {
  304|      0|        let source = Observable.zip(
  305|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable()
  306|      0|        )
  307|      0|
  308|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E)>(source)
  309|      0|    }
  310|       |}
  311|       |
  312|       |extension SharedSequence {
  313|       |    /**
  314|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  315|       |
  316|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  317|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  318|       |    */
  319|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  320|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  321|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  322|       |            SharingStrategy == O2.SharingStrategy,
  323|       |            SharingStrategy == O3.SharingStrategy,
  324|       |            SharingStrategy == O4.SharingStrategy,
  325|      0|            SharingStrategy == O5.SharingStrategy {
  326|      0|        let source = Observable.combineLatest(
  327|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(),
  328|      0|                resultSelector: resultSelector
  329|      0|            )
  330|      0|
  331|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  332|      0|    }
  333|       |}
  334|       |
  335|       |extension SharedSequenceConvertibleType where E == Any {
  336|       |    /**
  337|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  338|       |
  339|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  340|       |    */
  341|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  342|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  343|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E)> where SharingStrategy == O1.SharingStrategy,
  344|       |            SharingStrategy == O2.SharingStrategy,
  345|       |            SharingStrategy == O3.SharingStrategy,
  346|       |            SharingStrategy == O4.SharingStrategy,
  347|      0|            SharingStrategy == O5.SharingStrategy {
  348|      0|        let source = Observable.combineLatest(
  349|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable()
  350|      0|            )
  351|      0|
  352|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E)>(source)
  353|      0|    }
  354|       |}
  355|       |
  356|       |
  357|       |
  358|       |// 6
  359|       |
  360|       |extension SharedSequence {
  361|       |    /**
  362|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  363|       |
  364|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  365|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  366|       |    */
  367|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  368|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  369|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  370|       |            SharingStrategy == O2.SharingStrategy,
  371|       |            SharingStrategy == O3.SharingStrategy,
  372|       |            SharingStrategy == O4.SharingStrategy,
  373|       |            SharingStrategy == O5.SharingStrategy,
  374|      0|            SharingStrategy == O6.SharingStrategy {
  375|      0|        let source = Observable.zip(
  376|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(),
  377|      0|            resultSelector: resultSelector
  378|      0|        )
  379|      0|
  380|      0|        return SharedSequence<SharingStrategy, E>(source)
  381|      0|    }
  382|       |}
  383|       |
  384|       |extension SharedSequenceConvertibleType where E == Any {
  385|       |    /**
  386|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  387|       |
  388|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  389|       |    */
  390|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  391|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  392|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> where SharingStrategy == O1.SharingStrategy,
  393|       |            SharingStrategy == O2.SharingStrategy,
  394|       |            SharingStrategy == O3.SharingStrategy,
  395|       |            SharingStrategy == O4.SharingStrategy,
  396|       |            SharingStrategy == O5.SharingStrategy,
  397|      0|            SharingStrategy == O6.SharingStrategy {
  398|      0|        let source = Observable.zip(
  399|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable()
  400|      0|        )
  401|      0|
  402|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)>(source)
  403|      0|    }
  404|       |}
  405|       |
  406|       |extension SharedSequence {
  407|       |    /**
  408|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  409|       |
  410|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  411|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  412|       |    */
  413|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  414|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  415|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  416|       |            SharingStrategy == O2.SharingStrategy,
  417|       |            SharingStrategy == O3.SharingStrategy,
  418|       |            SharingStrategy == O4.SharingStrategy,
  419|       |            SharingStrategy == O5.SharingStrategy,
  420|      0|            SharingStrategy == O6.SharingStrategy {
  421|      0|        let source = Observable.combineLatest(
  422|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(),
  423|      0|                resultSelector: resultSelector
  424|      0|            )
  425|      0|
  426|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  427|      0|    }
  428|       |}
  429|       |
  430|       |extension SharedSequenceConvertibleType where E == Any {
  431|       |    /**
  432|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  433|       |
  434|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  435|       |    */
  436|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  437|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  438|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> where SharingStrategy == O1.SharingStrategy,
  439|       |            SharingStrategy == O2.SharingStrategy,
  440|       |            SharingStrategy == O3.SharingStrategy,
  441|       |            SharingStrategy == O4.SharingStrategy,
  442|       |            SharingStrategy == O5.SharingStrategy,
  443|      0|            SharingStrategy == O6.SharingStrategy {
  444|      0|        let source = Observable.combineLatest(
  445|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable()
  446|      0|            )
  447|      0|
  448|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)>(source)
  449|      0|    }
  450|       |}
  451|       |
  452|       |
  453|       |
  454|       |// 7
  455|       |
  456|       |extension SharedSequence {
  457|       |    /**
  458|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  459|       |
  460|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  461|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  462|       |    */
  463|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  464|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  465|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  466|       |            SharingStrategy == O2.SharingStrategy,
  467|       |            SharingStrategy == O3.SharingStrategy,
  468|       |            SharingStrategy == O4.SharingStrategy,
  469|       |            SharingStrategy == O5.SharingStrategy,
  470|       |            SharingStrategy == O6.SharingStrategy,
  471|      0|            SharingStrategy == O7.SharingStrategy {
  472|      0|        let source = Observable.zip(
  473|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(),
  474|      0|            resultSelector: resultSelector
  475|      0|        )
  476|      0|
  477|      0|        return SharedSequence<SharingStrategy, E>(source)
  478|      0|    }
  479|       |}
  480|       |
  481|       |extension SharedSequenceConvertibleType where E == Any {
  482|       |    /**
  483|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  484|       |
  485|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  486|       |    */
  487|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  488|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  489|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> where SharingStrategy == O1.SharingStrategy,
  490|       |            SharingStrategy == O2.SharingStrategy,
  491|       |            SharingStrategy == O3.SharingStrategy,
  492|       |            SharingStrategy == O4.SharingStrategy,
  493|       |            SharingStrategy == O5.SharingStrategy,
  494|       |            SharingStrategy == O6.SharingStrategy,
  495|      0|            SharingStrategy == O7.SharingStrategy {
  496|      0|        let source = Observable.zip(
  497|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable()
  498|      0|        )
  499|      0|
  500|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)>(source)
  501|      0|    }
  502|       |}
  503|       |
  504|       |extension SharedSequence {
  505|       |    /**
  506|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  507|       |
  508|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  509|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  510|       |    */
  511|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  512|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  513|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  514|       |            SharingStrategy == O2.SharingStrategy,
  515|       |            SharingStrategy == O3.SharingStrategy,
  516|       |            SharingStrategy == O4.SharingStrategy,
  517|       |            SharingStrategy == O5.SharingStrategy,
  518|       |            SharingStrategy == O6.SharingStrategy,
  519|      0|            SharingStrategy == O7.SharingStrategy {
  520|      0|        let source = Observable.combineLatest(
  521|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(),
  522|      0|                resultSelector: resultSelector
  523|      0|            )
  524|      0|
  525|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  526|      0|    }
  527|       |}
  528|       |
  529|       |extension SharedSequenceConvertibleType where E == Any {
  530|       |    /**
  531|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  532|       |
  533|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  534|       |    */
  535|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  536|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  537|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> where SharingStrategy == O1.SharingStrategy,
  538|       |            SharingStrategy == O2.SharingStrategy,
  539|       |            SharingStrategy == O3.SharingStrategy,
  540|       |            SharingStrategy == O4.SharingStrategy,
  541|       |            SharingStrategy == O5.SharingStrategy,
  542|       |            SharingStrategy == O6.SharingStrategy,
  543|      0|            SharingStrategy == O7.SharingStrategy {
  544|      0|        let source = Observable.combineLatest(
  545|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable()
  546|      0|            )
  547|      0|
  548|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)>(source)
  549|      0|    }
  550|       |}
  551|       |
  552|       |
  553|       |
  554|       |// 8
  555|       |
  556|       |extension SharedSequence {
  557|       |    /**
  558|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  559|       |
  560|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  561|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  562|       |    */
  563|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  564|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  565|       |        -> SharedSequence<O1.SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  566|       |            SharingStrategy == O2.SharingStrategy,
  567|       |            SharingStrategy == O3.SharingStrategy,
  568|       |            SharingStrategy == O4.SharingStrategy,
  569|       |            SharingStrategy == O5.SharingStrategy,
  570|       |            SharingStrategy == O6.SharingStrategy,
  571|       |            SharingStrategy == O7.SharingStrategy,
  572|      0|            SharingStrategy == O8.SharingStrategy {
  573|      0|        let source = Observable.zip(
  574|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable(),
  575|      0|            resultSelector: resultSelector
  576|      0|        )
  577|      0|
  578|      0|        return SharedSequence<SharingStrategy, E>(source)
  579|      0|    }
  580|       |}
  581|       |
  582|       |extension SharedSequenceConvertibleType where E == Any {
  583|       |    /**
  584|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever all of the observable sequences have produced an element at a corresponding index.
  585|       |
  586|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  587|       |    */
  588|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  589|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  590|       |        -> SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> where SharingStrategy == O1.SharingStrategy,
  591|       |            SharingStrategy == O2.SharingStrategy,
  592|       |            SharingStrategy == O3.SharingStrategy,
  593|       |            SharingStrategy == O4.SharingStrategy,
  594|       |            SharingStrategy == O5.SharingStrategy,
  595|       |            SharingStrategy == O6.SharingStrategy,
  596|       |            SharingStrategy == O7.SharingStrategy,
  597|      0|            SharingStrategy == O8.SharingStrategy {
  598|      0|        let source = Observable.zip(
  599|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable()
  600|      0|        )
  601|      0|
  602|      0|        return SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)>(source)
  603|      0|    }
  604|       |}
  605|       |
  606|       |extension SharedSequence {
  607|       |    /**
  608|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  609|       |
  610|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  611|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  612|       |    */
  613|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  614|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  615|       |        -> SharedSequence<SharingStrategy, E> where SharingStrategy == O1.SharingStrategy,
  616|       |            SharingStrategy == O2.SharingStrategy,
  617|       |            SharingStrategy == O3.SharingStrategy,
  618|       |            SharingStrategy == O4.SharingStrategy,
  619|       |            SharingStrategy == O5.SharingStrategy,
  620|       |            SharingStrategy == O6.SharingStrategy,
  621|       |            SharingStrategy == O7.SharingStrategy,
  622|      0|            SharingStrategy == O8.SharingStrategy {
  623|      0|        let source = Observable.combineLatest(
  624|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable(),
  625|      0|                resultSelector: resultSelector
  626|      0|            )
  627|      0|
  628|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  629|      0|    }
  630|       |}
  631|       |
  632|       |extension SharedSequenceConvertibleType where E == Any {
  633|       |    /**
  634|       |    Merges the specified observable sequences into one observable sequence of element tuples whenever any of the observable sequences produces an element.
  635|       |
  636|       |    - returns: An observable sequence containing the result of combining elements of the sources.
  637|       |    */
  638|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  639|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  640|       |        -> SharedSequence<SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> where SharingStrategy == O1.SharingStrategy,
  641|       |            SharingStrategy == O2.SharingStrategy,
  642|       |            SharingStrategy == O3.SharingStrategy,
  643|       |            SharingStrategy == O4.SharingStrategy,
  644|       |            SharingStrategy == O5.SharingStrategy,
  645|       |            SharingStrategy == O6.SharingStrategy,
  646|       |            SharingStrategy == O7.SharingStrategy,
  647|      0|            SharingStrategy == O8.SharingStrategy {
  648|      0|        let source = Observable.combineLatest(
  649|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable()
  650|      0|            )
  651|      0|
  652|      0|        return SharedSequence<O1.SharingStrategy, (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)>(source)
  653|      0|    }
  654|       |}
  655|       |
  656|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence+Operators.swift:
    1|       |//
    2|       |//  SharedSequence+Operators.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |// MARK: map
   12|       |extension SharedSequenceConvertibleType {
   13|       |    
   14|       |    /**
   15|       |    Projects each element of an observable sequence into a new form.
   16|       |    
   17|       |    - parameter selector: A transform function to apply to each source element.
   18|       |    - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
   19|       |    */
   20|      0|    public func map<R>(_ selector: @escaping (E) -> R) -> SharedSequence<SharingStrategy, R> {
   21|      0|        let source = self
   22|      0|            .asObservable()
   23|      0|            .map(selector)
   24|      0|        return SharedSequence<SharingStrategy, R>(source)
   25|      0|    }
   26|       |}
   27|       |
   28|       |// MARK: filter
   29|       |extension SharedSequenceConvertibleType {
   30|       |    /**
   31|       |    Filters the elements of an observable sequence based on a predicate.
   32|       |    
   33|       |    - parameter predicate: A function to test each source element for a condition.
   34|       |    - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
   35|       |    */
   36|      0|    public func filter(_ predicate: @escaping (E) -> Bool) -> SharedSequence<SharingStrategy, E> {
   37|      0|        let source = self
   38|      0|            .asObservable()
   39|      0|            .filter(predicate)
   40|      0|        return SharedSequence(source)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// MARK: switchLatest
   45|       |extension SharedSequenceConvertibleType where E : SharedSequenceConvertibleType {
   46|       |    
   47|       |    /**
   48|       |    Transforms an observable sequence of observable sequences into an observable sequence
   49|       |    producing values only from the most recent observable sequence.
   50|       |    
   51|       |    Each time a new inner observable sequence is received, unsubscribe from the
   52|       |    previous inner observable sequence.
   53|       |    
   54|       |    - returns: The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   55|       |    */
   56|      0|    public func switchLatest() -> SharedSequence<E.SharingStrategy, E.E> {
   57|      0|        let source: Observable<E.E> = self
   58|      0|            .asObservable()
   59|      0|            .map { $0.asSharedSequence() }
   60|      0|            .switchLatest()
   61|      0|        return SharedSequence<E.SharingStrategy, E.E>(source)
   62|      0|    }
   63|       |}
   64|       |
   65|       |// MARK: flatMapLatest
   66|       |extension SharedSequenceConvertibleType {
   67|       |    /**
   68|       |     Projects each element of an observable sequence into a new sequence of observable sequences and then
   69|       |     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
   70|       |
   71|       |     It is a combination of `map` + `switchLatest` operator
   72|       |
   73|       |     - parameter selector: A transform function to apply to each element.
   74|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an
   75|       |     Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   76|       |     */
   77|       |    public func flatMapLatest<Sharing, R>(_ selector: @escaping (E) -> SharedSequence<Sharing, R>)
   78|      0|        -> SharedSequence<Sharing, R> {
   79|      0|        let source: Observable<R> = self
   80|      0|            .asObservable()
   81|      0|            .flatMapLatest(selector)
   82|      0|        return SharedSequence<Sharing, R>(source)
   83|      0|    }
   84|       |}
   85|       |
   86|       |// MARK: flatMapFirst
   87|       |extension SharedSequenceConvertibleType {
   88|       |
   89|       |    /**
   90|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   91|       |     If element is received while there is some projected observable sequence being merged it will simply be ignored.
   92|       |
   93|       |     - parameter selector: A transform function to apply to element that was observed while no observable is executing in parallel.
   94|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence that was received while no other sequence was being calculated.
   95|       |     */
   96|       |    public func flatMapFirst<Sharing, R>(_ selector: @escaping (E) -> SharedSequence<Sharing, R>)
   97|      0|        -> SharedSequence<Sharing, R> {
   98|      0|        let source: Observable<R> = self
   99|      0|            .asObservable()
  100|      0|            .flatMapFirst(selector)
  101|      0|        return SharedSequence<Sharing, R>(source)
  102|      0|    }
  103|       |}
  104|       |
  105|       |// MARK: do
  106|       |extension SharedSequenceConvertibleType {
  107|       |    /**
  108|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  109|       |
  110|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  111|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  112|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  113|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  114|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  115|       |     - returns: The source sequence with the side-effecting behavior applied.
  116|       |     */
  117|       |    public func `do`(onNext: ((E) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onSubscribe: (() -> Void)? = nil, onSubscribed: (() -> Void)? = nil, onDispose: (() -> Void)? = nil)
  118|      0|        -> SharedSequence<SharingStrategy, E> {
  119|      0|        let source = self.asObservable()
  120|      0|            .do(onNext: onNext, onCompleted: onCompleted, onSubscribe: onSubscribe, onSubscribed: onSubscribed, onDispose: onDispose)
  121|      0|
  122|      0|        return SharedSequence(source)
  123|      0|    }
  124|       |}
  125|       |
  126|       |// MARK: debug
  127|       |extension SharedSequenceConvertibleType {
  128|       |    
  129|       |    /**
  130|       |    Prints received events for all observers on standard output.
  131|       |    
  132|       |    - parameter identifier: Identifier that is printed together with event description to standard output.
  133|       |    - returns: An observable sequence whose events are printed to standard output.
  134|       |    */
  135|      0|    public func debug(_ identifier: String? = nil, trimOutput: Bool = false, file: String = #file, line: UInt = #line, function: String = #function) -> SharedSequence<SharingStrategy, E> {
  136|      0|        let source = self.asObservable()
  137|      0|            .debug(identifier, trimOutput: trimOutput, file: file, line: line, function: function)
  138|      0|        return SharedSequence(source)
  139|      0|    }
  140|       |}
  141|       |
  142|       |// MARK: distinctUntilChanged
  143|       |extension SharedSequenceConvertibleType where E: Equatable {
  144|       |    
  145|       |    /**
  146|       |    Returns an observable sequence that contains only distinct contiguous elements according to equality operator.
  147|       |    
  148|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on equality operator, from the source sequence.
  149|       |    */
  150|       |    public func distinctUntilChanged()
  151|      0|        -> SharedSequence<SharingStrategy, E> {
  152|      0|        let source = self.asObservable()
  153|      0|            .distinctUntilChanged({ $0 }, comparer: { ($0 == $1) })
  154|      0|            
  155|      0|        return SharedSequence(source)
  156|      0|    }
  157|       |}
  158|       |
  159|       |extension SharedSequenceConvertibleType {
  160|       |    
  161|       |    /**
  162|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `keySelector`.
  163|       |    
  164|       |    - parameter keySelector: A function to compute the comparison key for each element.
  165|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
  166|       |    */
  167|      0|    public func distinctUntilChanged<K: Equatable>(_ keySelector: @escaping (E) -> K) -> SharedSequence<SharingStrategy, E> {
  168|      0|        let source = self.asObservable()
  169|      0|            .distinctUntilChanged(keySelector, comparer: { $0 == $1 })
  170|      0|        return SharedSequence(source)
  171|      0|    }
  172|       |   
  173|       |    /**
  174|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `comparer`.
  175|       |    
  176|       |    - parameter comparer: Equality comparer for computed key values.
  177|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on `comparer`, from the source sequence.
  178|       |    */
  179|      0|    public func distinctUntilChanged(_ comparer: @escaping (E, E) -> Bool) -> SharedSequence<SharingStrategy, E> {
  180|      0|        let source = self.asObservable()
  181|      0|            .distinctUntilChanged({ $0 }, comparer: comparer)
  182|      0|        return SharedSequence<SharingStrategy, E>(source)
  183|      0|    }
  184|       |    
  185|       |    /**
  186|       |    Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
  187|       |    
  188|       |    - parameter keySelector: A function to compute the comparison key for each element.
  189|       |    - parameter comparer: Equality comparer for computed key values.
  190|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value and the comparer, from the source sequence.
  191|       |    */
  192|      0|    public func distinctUntilChanged<K>(_ keySelector: @escaping (E) -> K, comparer: @escaping (K, K) -> Bool) -> SharedSequence<SharingStrategy, E> {
  193|      0|        let source = self.asObservable()
  194|      0|            .distinctUntilChanged(keySelector, comparer: comparer)
  195|      0|        return SharedSequence<SharingStrategy, E>(source)
  196|      0|    }
  197|       |}
  198|       |
  199|       |
  200|       |// MARK: flatMap
  201|       |extension SharedSequenceConvertibleType {
  202|       |    
  203|       |    /**
  204|       |    Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  205|       |    
  206|       |    - parameter selector: A transform function to apply to each element.
  207|       |    - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  208|       |    */
  209|      0|    public func flatMap<Sharing, R>(_ selector: @escaping (E) -> SharedSequence<Sharing, R>) -> SharedSequence<Sharing, R> {
  210|      0|        let source = self.asObservable()
  211|      0|            .flatMap(selector)
  212|      0|        
  213|      0|        return SharedSequence(source)
  214|      0|    }
  215|       |}
  216|       |
  217|       |// MARK: merge
  218|       |extension SharedSequenceConvertibleType {
  219|       |    /**
  220|       |     Merges elements from all observable sequences from collection into a single observable sequence.
  221|       |
  222|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  223|       |
  224|       |     - parameter sources: Collection of observable sequences to merge.
  225|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  226|       |     */
  227|       |    public static func merge<C: Collection>(_ sources: C) -> SharedSequence<SharingStrategy, E>
  228|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, E> {
  229|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  230|      0|        return SharedSequence<SharingStrategy, E>(source)
  231|      0|    }
  232|       |
  233|       |    /**
  234|       |     Merges elements from all observable sequences from array into a single observable sequence.
  235|       |
  236|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  237|       |
  238|       |     - parameter sources: Array of observable sequences to merge.
  239|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  240|       |     */
  241|      0|    public static func merge(_ sources: [SharedSequence<SharingStrategy, E>]) -> SharedSequence<SharingStrategy, E> {
  242|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  243|      0|        return SharedSequence<SharingStrategy, E>(source)
  244|      0|    }
  245|       |
  246|       |    /**
  247|       |     Merges elements from all observable sequences into a single observable sequence.
  248|       |
  249|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  250|       |
  251|       |     - parameter sources: Collection of observable sequences to merge.
  252|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  253|       |     */
  254|      0|    public static func merge(_ sources: SharedSequence<SharingStrategy, E>...) -> SharedSequence<SharingStrategy, E> {
  255|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  256|      0|        return SharedSequence<SharingStrategy, E>(source)
  257|      0|    }
  258|       |    
  259|       |}
  260|       |
  261|       |// MARK: merge
  262|       |extension SharedSequenceConvertibleType where E : SharedSequenceConvertibleType {
  263|       |    /**
  264|       |    Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.
  265|       |    
  266|       |    - returns: The observable sequence that merges the elements of the observable sequences.
  267|       |    */
  268|      0|    public func merge() -> SharedSequence<E.SharingStrategy, E.E> {
  269|      0|        let source = self.asObservable()
  270|      0|            .map { $0.asSharedSequence() }
  271|      0|            .merge()
  272|      0|        return SharedSequence<E.SharingStrategy, E.E>(source)
  273|      0|    }
  274|       |    
  275|       |    /**
  276|       |    Merges elements from all inner observable sequences into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  277|       |    
  278|       |    - parameter maxConcurrent: Maximum number of inner observable sequences being subscribed to concurrently.
  279|       |    - returns: The observable sequence that merges the elements of the inner sequences.
  280|       |    */
  281|       |    public func merge(maxConcurrent: Int)
  282|      0|        -> SharedSequence<E.SharingStrategy, E.E> {
  283|      0|        let source = self.asObservable()
  284|      0|            .map { $0.asSharedSequence() }
  285|      0|            .merge(maxConcurrent: maxConcurrent)
  286|      0|        return SharedSequence<E.SharingStrategy, E.E>(source)
  287|      0|    }
  288|       |}
  289|       |
  290|       |// MARK: throttle
  291|       |extension SharedSequenceConvertibleType {
  292|       |    
  293|       |    /**
  294|       |     Returns an Observable that emits the first and the latest item emitted by the source Observable during sequential time windows of a specified duration.
  295|       |
  296|       |     This operator makes sure that no two elements are emitted in less then dueTime.
  297|       |
  298|       |     - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
  299|       |
  300|       |     - parameter dueTime: Throttling duration for each element.
  301|       |     - parameter latest: Should latest element received in a dueTime wide time window since last element emission be emitted.
  302|       |     - returns: The throttled sequence.
  303|       |    */
  304|       |    public func throttle(_ dueTime: RxTimeInterval, latest: Bool = true)
  305|      0|        -> SharedSequence<SharingStrategy, E> {
  306|      0|        let source = self.asObservable()
  307|      0|            .throttle(dueTime, latest: latest, scheduler: SharingStrategy.scheduler)
  308|      0|
  309|      0|        return SharedSequence(source)
  310|      0|    }
  311|       |
  312|       |    /**
  313|       |    Ignores elements from an observable sequence which are followed by another element within a specified relative time duration, using the specified scheduler to run throttling timers.
  314|       |    
  315|       |    - parameter dueTime: Throttling duration for each element.
  316|       |    - returns: The throttled sequence.
  317|       |    */
  318|       |    public func debounce(_ dueTime: RxTimeInterval)
  319|      0|        -> SharedSequence<SharingStrategy, E> {
  320|      0|        let source = self.asObservable()
  321|      0|            .debounce(dueTime, scheduler: SharingStrategy.scheduler)
  322|      0|
  323|      0|        return SharedSequence(source)
  324|      0|    }
  325|       |}
  326|       |
  327|       |// MARK: scan
  328|       |extension SharedSequenceConvertibleType {
  329|       |    /**
  330|       |    Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
  331|       |    
  332|       |    For aggregation behavior with no intermediate results, see `reduce`.
  333|       |    
  334|       |    - parameter seed: The initial accumulator value.
  335|       |    - parameter accumulator: An accumulator function to be invoked on each element.
  336|       |    - returns: An observable sequence containing the accumulated values.
  337|       |    */
  338|       |    public func scan<A>(_ seed: A, accumulator: @escaping (A, E) -> A)
  339|      0|        -> SharedSequence<SharingStrategy, A> {
  340|      0|        let source = self.asObservable()
  341|      0|            .scan(seed, accumulator: accumulator)
  342|      0|        return SharedSequence<SharingStrategy, A>(source)
  343|      0|    }
  344|       |}
  345|       |
  346|       |// MARK: concat
  347|       |
  348|       |extension SharedSequence {
  349|       |    /**
  350|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  351|       |
  352|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  353|       |     */
  354|       |    public static func concat<S: Sequence>(_ sequence: S) -> SharedSequence<SharingStrategy, Element>
  355|      0|        where S.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  356|      0|            let source = Observable.concat(sequence.lazy.map { $0.asObservable() })
  357|      0|            return SharedSequence<SharingStrategy, Element>(source)
  358|      0|    }
  359|       |
  360|       |    /**
  361|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  362|       |
  363|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  364|       |     */
  365|       |    public static func concat<C: Collection>(_ collection: C) -> SharedSequence<SharingStrategy, Element>
  366|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  367|      0|        let source = Observable.concat(collection.map { $0.asObservable() })
  368|      0|        return SharedSequence<SharingStrategy, Element>(source)
  369|      0|    }
  370|       |}
  371|       |
  372|       |// MARK: zip
  373|       |
  374|       |extension SharedSequence {
  375|       |    /**
  376|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  377|       |
  378|       |     - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  379|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  380|       |     */
  381|       |    public static func zip<C: Collection, R>(_ collection: C, _ resultSelector: @escaping ([Element]) throws -> R) -> SharedSequence<SharingStrategy, R>
  382|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  383|      0|        let source = Observable.zip(collection.map { $0.asSharedSequence().asObservable() }, resultSelector)
  384|      0|        return SharedSequence<SharingStrategy, R>(source)
  385|      0|    }
  386|       |
  387|       |    /**
  388|       |     Merges the specified observable sequences into one observable sequence all of the observable sequences have produced an element at a corresponding index.
  389|       |
  390|       |     - returns: An observable sequence containing the result of combining elements of the sources.
  391|       |     */
  392|       |    public static func zip<C: Collection>(_ collection: C) -> SharedSequence<SharingStrategy, [Element]>
  393|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  394|      0|            let source = Observable.zip(collection.map { $0.asSharedSequence().asObservable() })
  395|      0|            return SharedSequence<SharingStrategy, [Element]>(source)
  396|      0|    }
  397|       |}
  398|       |
  399|       |// MARK: combineLatest
  400|       |
  401|       |extension SharedSequence {
  402|       |    /**
  403|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  404|       |
  405|       |     - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  406|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  407|       |     */
  408|       |    public static func combineLatest<C: Collection, R>(_ collection: C, _ resultSelector: @escaping ([Element]) throws -> R) -> SharedSequence<SharingStrategy, R>
  409|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  410|      0|        let source = Observable.combineLatest(collection.map { $0.asObservable() }, resultSelector)
  411|      0|        return SharedSequence<SharingStrategy, R>(source)
  412|      0|    }
  413|       |
  414|       |    /**
  415|       |     Merges the specified observable sequences into one observable sequence whenever any of the observable sequences produces an element.
  416|       |
  417|       |     - returns: An observable sequence containing the result of combining elements of the sources.
  418|       |     */
  419|       |    public static func combineLatest<C: Collection>(_ collection: C) -> SharedSequence<SharingStrategy, [Element]>
  420|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  421|      0|        let source = Observable.combineLatest(collection.map { $0.asObservable() })
  422|      0|        return SharedSequence<SharingStrategy, [Element]>(source)
  423|      0|    }
  424|       |}
  425|       |
  426|       |// MARK: withLatestFrom
  427|       |extension SharedSequenceConvertibleType {
  428|       |
  429|       |    /**
  430|       |    Merges two observable sequences into one observable sequence by combining each element from self with the latest element from the second source, if any.
  431|       |
  432|       |    - parameter second: Second observable source.
  433|       |    - parameter resultSelector: Function to invoke for each element from the self combined with the latest element from the second source, if any.
  434|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  435|       |    */
  436|      0|    public func withLatestFrom<SecondO: SharedSequenceConvertibleType, ResultType>(_ second: SecondO, resultSelector: @escaping (E, SecondO.E) -> ResultType) -> SharedSequence<SharingStrategy, ResultType> where SecondO.SharingStrategy == SharingStrategy {
  437|      0|        let source = self.asObservable()
  438|      0|            .withLatestFrom(second.asSharedSequence(), resultSelector: resultSelector)
  439|      0|
  440|      0|        return SharedSequence<SharingStrategy, ResultType>(source)
  441|      0|    }
  442|       |
  443|       |    /**
  444|       |    Merges two observable sequences into one observable sequence by using latest element from the second sequence every time when `self` emits an element.
  445|       |
  446|       |    - parameter second: Second observable source.
  447|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  448|       |    */
  449|      0|    public func withLatestFrom<SecondO: SharedSequenceConvertibleType>(_ second: SecondO) -> SharedSequence<SharingStrategy, SecondO.E> {
  450|      0|        let source = self.asObservable()
  451|      0|            .withLatestFrom(second.asSharedSequence())
  452|      0|
  453|      0|        return SharedSequence<SharingStrategy, SecondO.E>(source)
  454|      0|    }
  455|       |}
  456|       |
  457|       |// MARK: skip
  458|       |extension SharedSequenceConvertibleType {
  459|       |
  460|       |    /**
  461|       |     Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
  462|       |
  463|       |     - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
  464|       |
  465|       |     - parameter count: The number of elements to skip before returning the remaining elements.
  466|       |     - returns: An observable sequence that contains the elements that occur after the specified index in the input sequence.
  467|       |     */
  468|       |    public func skip(_ count: Int)
  469|      0|        -> SharedSequence<SharingStrategy, E> {
  470|      0|        let source = self.asObservable()
  471|      0|            .skip(count)
  472|      0|        return SharedSequence(source)
  473|      0|    }
  474|       |}
  475|       |
  476|       |// MARK: startWith
  477|       |extension SharedSequenceConvertibleType {
  478|       |    
  479|       |    /**
  480|       |    Prepends a value to an observable sequence.
  481|       |
  482|       |    - seealso: [startWith operator on reactivex.io](http://reactivex.io/documentation/operators/startwith.html)
  483|       |    
  484|       |    - parameter element: Element to prepend to the specified sequence.
  485|       |    - returns: The source sequence prepended with the specified values.
  486|       |    */
  487|       |    public func startWith(_ element: E)
  488|      0|        -> SharedSequence<SharingStrategy, E> {
  489|      0|        let source = self.asObservable()
  490|      0|                .startWith(element)
  491|      0|
  492|      0|        return SharedSequence(source)
  493|      0|    }
  494|       |}
  495|       |
  496|       |// MARK: delay
  497|       |extension SharedSequenceConvertibleType {
  498|       |
  499|       |    /**
  500|       |     Returns an observable sequence by the source observable sequence shifted forward in time by a specified delay. Error events from the source observable sequence are not delayed.
  501|       |
  502|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
  503|       |
  504|       |     - parameter dueTime: Relative time shift of the source by.
  505|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
  506|       |     - returns: the source Observable shifted in time by the specified delay.
  507|       |     */
  508|       |    public func delay(_ dueTime: RxTimeInterval)
  509|      0|        -> SharedSequence<SharingStrategy, E> {
  510|      0|        let source = self.asObservable()
  511|      0|            .delay(dueTime, scheduler: SharingStrategy.scheduler)
  512|      0|
  513|      0|        return SharedSequence(source)
  514|      0|    }
  515|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence.swift:
    1|       |//
    2|       |//  SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/**
   12|       |    Trait that represents observable sequence that shares computation resources with following properties:
   13|       |
   14|       |    - it never fails
   15|       |    - it delivers events on `SharingStrategy.scheduler`
   16|       |    - sharing strategy is customizable using `SharingStrategy.share` behavior
   17|       |
   18|       |    `SharedSequence<Element>` can be considered a builder pattern for observable sequences that share computation resources.
   19|       |
   20|       |    To find out more about units and how to use them, please visit `Documentation/Traits.md`.
   21|       |*/
   22|       |public struct SharedSequence<S: SharingStrategyProtocol, Element> : SharedSequenceConvertibleType {
   23|       |    public typealias E = Element
   24|       |    public typealias SharingStrategy = S
   25|       |
   26|       |    let _source: Observable<E>
   27|       |
   28|      0|    init(_ source: Observable<E>) {
   29|      0|        self._source = S.share(source)
   30|      0|    }
   31|       |
   32|      0|    init(raw: Observable<E>) {
   33|      0|        self._source = raw
   34|      0|    }
   35|       |
   36|       |    #if EXPANDABLE_SHARED_SEQUENCE
   37|       |    /**
   38|       |     This method is extension hook in case this unit needs to extended from outside the library.
   39|       |     
   40|       |     By defining `EXPANDABLE_SHARED_SEQUENCE` one agrees that it's up to him to ensure shared sequence
   41|       |     properties are preserved after extension.
   42|       |    */
   43|       |    public static func createUnsafe<O: ObservableType>(source: O) -> SharedSequence<S, O.E> {
   44|       |        return SharedSequence<S, O.E>(raw: source.asObservable())
   45|       |    }
   46|       |    #endif
   47|       |
   48|       |    /**
   49|       |    - returns: Built observable sequence.
   50|       |    */
   51|      0|    public func asObservable() -> Observable<E> {
   52|      0|        return self._source
   53|      0|    }
   54|       |
   55|       |    /**
   56|       |    - returns: `self`
   57|       |    */
   58|      0|    public func asSharedSequence() -> SharedSequence<SharingStrategy, E> {
   59|      0|        return self
   60|      0|    }
   61|       |}
   62|       |
   63|       |/**
   64|       | Different `SharedSequence` sharing strategies must conform to this protocol.
   65|       | */
   66|       |public protocol SharingStrategyProtocol {
   67|       |    /**
   68|       |     Scheduled on which all sequence events will be delivered.
   69|       |    */
   70|       |    static var scheduler: SchedulerType { get }
   71|       |
   72|       |    /**
   73|       |     Computation resources sharing strategy for multiple sequence observers.
   74|       |     
   75|       |     E.g. One can choose `share(replay:scope:)`
   76|       |     as sequence event sharing strategies, but also do something more exotic, like
   77|       |     implementing promises or lazy loading chains.
   78|       |    */
   79|       |    static func share<E>(_ source: Observable<E>) -> Observable<E>
   80|       |}
   81|       |
   82|       |/**
   83|       |A type that can be converted to `SharedSequence`.
   84|       |*/
   85|       |public protocol SharedSequenceConvertibleType : ObservableConvertibleType {
   86|       |    associatedtype SharingStrategy: SharingStrategyProtocol
   87|       |
   88|       |    /**
   89|       |    Converts self to `SharedSequence`.
   90|       |    */
   91|       |    func asSharedSequence() -> SharedSequence<SharingStrategy, E>
   92|       |}
   93|       |
   94|       |extension SharedSequenceConvertibleType {
   95|      0|    public func asObservable() -> Observable<E> {
   96|      0|        return self.asSharedSequence().asObservable()
   97|      0|    }
   98|       |}
   99|       |
  100|       |
  101|       |extension SharedSequence {
  102|       |
  103|       |    /**
  104|       |    Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  105|       |
  106|       |    - returns: An observable sequence with no elements.
  107|       |    */
  108|      0|    public static func empty() -> SharedSequence<S, E> {
  109|      0|        return SharedSequence(raw: Observable.empty().subscribeOn(S.scheduler))
  110|      0|    }
  111|       |
  112|       |    /**
  113|       |    Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  114|       |
  115|       |    - returns: An observable sequence whose observers will never get called.
  116|       |    */
  117|      0|    public static func never() -> SharedSequence<S, E> {
  118|      0|        return SharedSequence(raw: Observable.never())
  119|      0|    }
  120|       |
  121|       |    /**
  122|       |    Returns an observable sequence that contains a single element.
  123|       |
  124|       |    - parameter element: Single element in the resulting observable sequence.
  125|       |    - returns: An observable sequence containing the single specified element.
  126|       |    */
  127|      0|    public static func just(_ element: E) -> SharedSequence<S, E> {
  128|      0|        return SharedSequence(raw: Observable.just(element).subscribeOn(S.scheduler))
  129|      0|    }
  130|       |
  131|       |    /**
  132|       |     Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
  133|       |
  134|       |     - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
  135|       |     - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
  136|       |     */
  137|       |    public static func deferred(_ observableFactory: @escaping () -> SharedSequence<S, E>)
  138|      0|        -> SharedSequence<S, E> {
  139|      0|        return SharedSequence(Observable.deferred { observableFactory().asObservable() })
  140|      0|    }
  141|       |
  142|       |    /**
  143|       |    This method creates a new Observable instance with a variable number of elements.
  144|       |
  145|       |    - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  146|       |
  147|       |    - parameter elements: Elements to generate.
  148|       |    - returns: The observable sequence whose elements are pulled from the given arguments.
  149|       |    */
  150|      0|    public static func of(_ elements: E ...) -> SharedSequence<S, E> {
  151|      0|        let source = Observable.from(elements, scheduler: S.scheduler)
  152|      0|        return SharedSequence(raw: source)
  153|      0|    }
  154|       |}
  155|       |
  156|       |extension SharedSequence {
  157|       |    
  158|       |    /**
  159|       |    This method converts an array to an observable sequence.
  160|       |     
  161|       |    - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  162|       |     
  163|       |    - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
  164|       |     */
  165|      0|    public static func from(_ array: [E]) -> SharedSequence<S, E> {
  166|      0|        let source = Observable.from(array, scheduler: S.scheduler)
  167|      0|        return SharedSequence(raw: source)
  168|      0|    }
  169|       |    
  170|       |    /**
  171|       |     This method converts a sequence to an observable sequence.
  172|       |     
  173|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  174|       |     
  175|       |     - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
  176|       |    */
  177|      0|    public static func from<S: Sequence>(_ sequence: S) -> SharedSequence<SharingStrategy, E> where S.Iterator.Element == E {
  178|      0|        let source = Observable.from(sequence, scheduler: SharingStrategy.scheduler)
  179|      0|        return SharedSequence(raw: source)
  180|      0|    }
  181|       |    
  182|       |    /**
  183|       |     This method converts a optional to an observable sequence.
  184|       |     
  185|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  186|       |     
  187|       |     - parameter optional: Optional element in the resulting observable sequence.
  188|       |     
  189|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
  190|       |     */
  191|      0|    public static func from(optional: E?) -> SharedSequence<S, E> {
  192|      0|        let source = Observable.from(optional: optional, scheduler: S.scheduler)
  193|      0|        return SharedSequence(raw: source)
  194|      0|    }
  195|       |}
  196|       |
  197|       |extension SharedSequence where Element : RxAbstractInteger {
  198|       |    /**
  199|       |     Returns an observable sequence that produces a value after each period, using the specified scheduler to run timers and to send out observer messages.
  200|       |
  201|       |     - seealso: [interval operator on reactivex.io](http://reactivex.io/documentation/operators/interval.html)
  202|       |
  203|       |     - parameter period: Period for producing the values in the resulting sequence.
  204|       |     - returns: An observable sequence that produces a value after each period.
  205|       |     */
  206|       |    public static func interval(_ period: RxTimeInterval)
  207|      0|        -> SharedSequence<S, E> {
  208|      0|        return SharedSequence(Observable.interval(period, scheduler: S.scheduler))
  209|      0|    }
  210|       |}
  211|       |
  212|       |// MARK: timer
  213|       |
  214|       |extension SharedSequence where Element: RxAbstractInteger {
  215|       |    /**
  216|       |     Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
  217|       |
  218|       |     - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
  219|       |
  220|       |     - parameter dueTime: Relative time at which to produce the first value.
  221|       |     - parameter period: Period to produce subsequent values.
  222|       |     - returns: An observable sequence that produces a value after due time has elapsed and then each period.
  223|       |     */
  224|       |    public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval)
  225|      0|        -> SharedSequence<S, E> {
  226|      0|        return SharedSequence(Observable.timer(dueTime, period: period, scheduler: S.scheduler))
  227|      0|    }
  228|       |}
  229|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Signal/ControlEvent+Signal.swift:
    1|       |//
    2|       |//  ControlEvent+Signal.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/1/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension ControlEvent {
   12|       |    /// Converts `ControlEvent` to `Signal` trait.
   13|       |    ///
   14|       |    /// `ControlEvent` already can't fail, so no special case needs to be handled.
   15|      0|    public func asSignal() -> Signal<E> {
   16|      0|        return self.asSignal { _ -> Signal<E> in
   17|      0|            #if DEBUG
   18|      0|                rxFatalError("Somehow signal received error from a source that shouldn't fail.")
   19|      0|            #else
   20|      0|                return Signal.empty()
   21|      0|            #endif
   22|      0|        }
   23|      0|    }
   24|       |}
   25|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Signal/ObservableConvertibleType+Signal.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+Signal.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension ObservableConvertibleType {
   12|       |    /**
   13|       |     Converts observable sequence to `Signal` trait.
   14|       |
   15|       |     - parameter onErrorJustReturn: Element to return in case of error and after that complete the sequence.
   16|       |     - returns: Signal trait.
   17|       |     */
   18|      0|    public func asSignal(onErrorJustReturn: E) -> Signal<E> {
   19|      0|        let source = self
   20|      0|            .asObservable()
   21|      0|            .observeOn(SignalSharingStrategy.scheduler)
   22|      0|            .catchErrorJustReturn(onErrorJustReturn)
   23|      0|        return Signal(source)
   24|      0|    }
   25|       |
   26|       |    /**
   27|       |     Converts observable sequence to `Driver` trait.
   28|       |
   29|       |     - parameter onErrorDriveWith: Driver that continues to drive the sequence in case of error.
   30|       |     - returns: Signal trait.
   31|       |     */
   32|      0|    public func asSignal(onErrorSignalWith: Signal<E>) -> Signal<E> {
   33|      0|        let source = self
   34|      0|            .asObservable()
   35|      0|            .observeOn(SignalSharingStrategy.scheduler)
   36|      0|            .catchError { _ in
   37|      0|                onErrorSignalWith.asObservable()
   38|      0|            }
   39|      0|        return Signal(source)
   40|      0|    }
   41|       |
   42|       |    /**
   43|       |     Converts observable sequence to `Driver` trait.
   44|       |
   45|       |     - parameter onErrorRecover: Calculates driver that continues to drive the sequence in case of error.
   46|       |     - returns: Signal trait.
   47|       |     */
   48|      0|    public func asSignal(onErrorRecover: @escaping (_ error: Swift.Error) -> Signal<E>) -> Signal<E> {
   49|      0|        let source = self
   50|      0|            .asObservable()
   51|      0|            .observeOn(SignalSharingStrategy.scheduler)
   52|      0|            .catchError { error in
   53|      0|                onErrorRecover(error).asObservable()
   54|      0|            }
   55|      0|        return Signal(source)
   56|      0|    }
   57|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Signal/PublishRelay+Signal.swift:
    1|       |//
    2|       |//  PublishRelay+Signal.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/28/15.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension PublishRelay {
   12|       |    /// Converts `PublishRelay` to `Signal`.
   13|       |    ///
   14|       |    /// - returns: Observable sequence.
   15|      0|    public func asSignal() -> Signal<Element> {
   16|      0|        let source = self.asObservable()
   17|      0|            .observeOn(SignalSharingStrategy.scheduler)
   18|      0|        return SharedSequence(source)
   19|      0|    }
   20|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Signal/Signal+Subscription.swift:
    1|       |//
    2|       |//  Signal+Subscription.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |extension SharedSequenceConvertibleType where SharingStrategy == SignalSharingStrategy {
   12|       |    /**
   13|       |     Creates new subscription and sends elements to observer.
   14|       |
   15|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better.
   16|       |
   17|       |     - parameter to: Observer that receives events.
   18|       |     - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   19|       |     */
   20|      0|    public func emit<O: ObserverType>(to observer: O) -> Disposable where O.E == E {
   21|      0|        return self.asSharedSequence().asObservable().subscribe(observer)
   22|      0|    }
   23|       |
   24|       |    /**
   25|       |     Creates new subscription and sends elements to observer.
   26|       |
   27|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better.
   28|       |
   29|       |     - parameter to: Observer that receives events.
   30|       |     - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   31|       |     */
   32|      0|    public func emit<O: ObserverType>(to observer: O) -> Disposable where O.E == E? {
   33|      0|        return self.asSharedSequence().asObservable().map { $0 as E? }.subscribe(observer)
   34|      0|    }
   35|       |
   36|       |    /**
   37|       |     Creates new subscription and sends elements to `BehaviorRelay`.
   38|       |     - parameter relay: Target relay for sequence elements.
   39|       |     - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   40|       |     */
   41|      0|    public func emit(to relay: BehaviorRelay<E>) -> Disposable {
   42|      0|        return self.emit(onNext: { e in
   43|      0|            relay.accept(e)
   44|      0|        })
   45|      0|    }
   46|       |    
   47|       |    /**
   48|       |     Creates new subscription and sends elements to `BehaviorRelay`.
   49|       |     - parameter relay: Target relay for sequence elements.
   50|       |     - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   51|       |     */
   52|      0|    public func emit(to relay: BehaviorRelay<E?>) -> Disposable {
   53|      0|        return self.emit(onNext: { e in
   54|      0|            relay.accept(e)
   55|      0|        })
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |     Creates new subscription and sends elements to relay.
   60|       |
   61|       |     - parameter relay: Target relay for sequence elements.
   62|       |     - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   63|       |     */
   64|      0|    public func emit(to relay: PublishRelay<E>) -> Disposable {
   65|      0|        return self.emit(onNext: { e in
   66|      0|            relay.accept(e)
   67|      0|        })
   68|      0|    }
   69|       |
   70|       |    /**
   71|       |     Creates new subscription and sends elements to relay.
   72|       |
   73|       |     - parameter to: Target relay for sequence elements.
   74|       |     - returns: Disposable object that can be used to unsubscribe the observer from the relay.
   75|       |     */
   76|      0|    public func emit(to relay: PublishRelay<E?>) -> Disposable {
   77|      0|        return self.emit(onNext: { e in
   78|      0|            relay.accept(e)
   79|      0|        })
   80|      0|    }
   81|       |
   82|       |    /**
   83|       |     Subscribes an element handler, a completion handler and disposed handler to an observable sequence.
   84|       |
   85|       |     Error callback is not exposed because `Signal` can't error out.
   86|       |
   87|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
   88|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   89|       |     gracefully completed, errored, or if the generation is canceled by disposing subscription)
   90|       |     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
   91|       |     gracefully completed, errored, or if the generation is canceled by disposing subscription)
   92|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
   93|       |     */
   94|       |    public func emit(onNext: ((E) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil) -> Disposable {
   95|       |        return self.asObservable().subscribe(onNext: onNext, onCompleted: onCompleted, onDisposed: onDisposed)
   96|       |    }
   97|       |}
   98|       |
   99|       |
  100|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/Traits/Signal/Signal.swift:
    1|       |//
    2|       |//  Signal.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/**
   12|       | Trait that represents observable sequence with following properties:
   13|       | 
   14|       | - it never fails
   15|       | - it delivers events on `MainScheduler.instance`
   16|       | - `share(scope: .whileConnected)` sharing strategy
   17|       |
   18|       | Additional explanation:
   19|       | - all observers share sequence computation resources
   20|       | - there is no replaying of sequence elements on new observer subscription
   21|       | - computation of elements is reference counted with respect to the number of observers
   22|       | - if there are no subscribers, it will release sequence computation resources
   23|       |
   24|       | In case trait that models state propagation is required, please check `Driver`.
   25|       |
   26|       | `Signal<Element>` can be considered a builder pattern for observable sequences that model imperative events part of the application.
   27|       | 
   28|       | To find out more about units and how to use them, please visit `Documentation/Traits.md`.
   29|       | */
   30|       |public typealias Signal<E> = SharedSequence<SignalSharingStrategy, E>
   31|       |
   32|       |public struct SignalSharingStrategy : SharingStrategyProtocol {
   33|      0|    public static var scheduler: SchedulerType { return SharingScheduler.make() }
   34|       |    
   35|      0|    public static func share<E>(_ source: Observable<E>) -> Observable<E> {
   36|      0|        return source.share(scope: .whileConnected)
   37|      0|    }
   38|       |}
   39|       |
   40|       |extension SharedSequenceConvertibleType where SharingStrategy == SignalSharingStrategy {
   41|       |    /// Adds `asPublisher` to `SharingSequence` with `PublishSharingStrategy`.
   42|      0|    public func asSignal() -> Signal<E> {
   43|      0|        return self.asSharedSequence()
   44|      0|    }
   45|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/DataSources/RxCollectionViewReactiveArrayDataSource.swift:
    1|       |//
    2|       |//  RxCollectionViewReactiveArrayDataSource.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |// objc monkey business
   15|       |class _RxCollectionViewReactiveArrayDataSource
   16|       |    : NSObject
   17|       |    , UICollectionViewDataSource {
   18|       |    
   19|       |    @objc(numberOfSectionsInCollectionView:)
   20|      0|    func numberOfSections(in: UICollectionView) -> Int {
   21|      0|        return 1
   22|      0|    }
   23|       |
   24|      0|    func _collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   25|      0|        return 0
   26|      0|    }
   27|       |    
   28|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   29|      0|        return _collectionView(collectionView, numberOfItemsInSection: section)
   30|      0|    }
   31|       |
   32|      0|    fileprivate func _collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   33|      0|        rxAbstractMethod()
   34|      0|    }
   35|       |
   36|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   37|      0|        return _collectionView(collectionView, cellForItemAt: indexPath)
   38|      0|    }
   39|       |}
   40|       |
   41|       |class RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S: Sequence>
   42|       |    : RxCollectionViewReactiveArrayDataSource<S.Iterator.Element>
   43|       |    , RxCollectionViewDataSourceType {
   44|       |    typealias Element = S
   45|       |
   46|      0|    override init(cellFactory: @escaping CellFactory) {
   47|      0|        super.init(cellFactory: cellFactory)
   48|      0|    }
   49|       |    
   50|      0|    func collectionView(_ collectionView: UICollectionView, observedEvent: Event<S>) {
   51|      0|        Binder(self) { collectionViewDataSource, sectionModels in
   52|      0|            let sections = Array(sectionModels)
   53|      0|            collectionViewDataSource.collectionView(collectionView, observedElements: sections)
   54|      0|        }.on(observedEvent)
   55|      0|    }
   56|       |}
   57|       |
   58|       |
   59|       |// Please take a look at `DelegateProxyType.swift`
   60|       |class RxCollectionViewReactiveArrayDataSource<Element>
   61|       |    : _RxCollectionViewReactiveArrayDataSource
   62|       |    , SectionedViewDataSourceType {
   63|       |    
   64|       |    typealias CellFactory = (UICollectionView, Int, Element) -> UICollectionViewCell
   65|       |    
   66|       |    var itemModels: [Element]?
   67|       |    
   68|       |    func modelAtIndex(_ index: Int) -> Element? {
   69|       |        return itemModels?[index]
   70|       |    }
   71|       |
   72|       |    func model(at indexPath: IndexPath) throws -> Any {
   73|      0|        precondition(indexPath.section == 0)
   74|       |        guard let item = itemModels?[indexPath.item] else {
   75|       |            throw RxCocoaError.itemsNotYetBound(object: self)
   76|       |        }
   77|       |        return item
   78|       |    }
   79|       |    
   80|       |    var cellFactory: CellFactory
   81|       |    
   82|      0|    init(cellFactory: @escaping CellFactory) {
   83|      0|        self.cellFactory = cellFactory
   84|      0|    }
   85|       |    
   86|       |    // data source
   87|       |    
   88|       |    override func _collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   89|      0|        return itemModels?.count ?? 0
   90|       |    }
   91|       |    
   92|       |    override func _collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   93|       |        return cellFactory(collectionView, indexPath.item, itemModels![indexPath.item])
   94|       |    }
   95|       |    
   96|       |    // reactive
   97|       |    
   98|       |    func collectionView(_ collectionView: UICollectionView, observedElements: [Element]) {
   99|       |        self.itemModels = observedElements
  100|       |        
  101|       |        collectionView.reloadData()
  102|       |
  103|       |        // workaround for http://stackoverflow.com/questions/39867325/ios-10-bug-uicollectionview-received-layout-attributes-for-a-cell-with-an-index
  104|       |        collectionView.collectionViewLayout.invalidateLayout()
  105|       |    }
  106|       |}
  107|       |
  108|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/DataSources/RxPickerViewAdapter.swift:
    1|       |//
    2|       |//  RxPickerViewAdapter.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Sergey Shulga on 12/07/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |class RxPickerViewArrayDataSource<T>: NSObject, UIPickerViewDataSource, SectionedViewDataSourceType {
   15|       |    fileprivate var items: [T] = []
   16|       |    
   17|      0|    func model(at indexPath: IndexPath) throws -> Any {
   18|      0|        guard items.indices ~= indexPath.row else {
   19|      0|            throw RxCocoaError.itemsNotYetBound(object: self)
   20|      0|        }
   21|      0|        return items[indexPath.row]
   22|      0|    }
   23|       |
   24|      0|    func numberOfComponents(in pickerView: UIPickerView) -> Int {
   25|      0|        return 1
   26|      0|    }
   27|       |    
   28|      0|    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {
   29|      0|        return items.count
   30|      0|    }
   31|       |}
   32|       |
   33|       |class RxPickerViewSequenceDataSource<S: Sequence>
   34|       |    : RxPickerViewArrayDataSource<S.Iterator.Element>
   35|       |    , RxPickerViewDataSourceType {
   36|       |    typealias Element = S
   37|       |
   38|      0|    func pickerView(_ pickerView: UIPickerView, observedEvent: Event<S>) {
   39|      0|        Binder(self) { dataSource, items in
   40|      0|            dataSource.items = items
   41|      0|            pickerView.reloadAllComponents()
   42|      0|        }
   43|      0|        .on(observedEvent.map(Array.init))
   44|      0|    }
   45|       |}
   46|       |
   47|       |final class RxStringPickerViewAdapter<S: Sequence>
   48|       |    : RxPickerViewSequenceDataSource<S>
   49|       |    , UIPickerViewDelegate {
   50|       |    
   51|       |    typealias TitleForRow = (Int, S.Iterator.Element) -> String?
   52|       |    private let titleForRow: TitleForRow
   53|       |    
   54|      0|    init(titleForRow: @escaping TitleForRow) {
   55|      0|        self.titleForRow = titleForRow
   56|      0|        super.init()
   57|      0|    }
   58|       |    
   59|      0|    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {
   60|      0|        return titleForRow(row, items[row])
   61|      0|    }
   62|       |}
   63|       |
   64|       |final class RxAttributedStringPickerViewAdapter<S: Sequence>: RxPickerViewSequenceDataSource<S>, UIPickerViewDelegate {
   65|       |    typealias AttributedTitleForRow = (Int, S.Iterator.Element) -> NSAttributedString?
   66|       |    private let attributedTitleForRow: AttributedTitleForRow
   67|       |    
   68|      0|    init(attributedTitleForRow: @escaping AttributedTitleForRow) {
   69|      0|        self.attributedTitleForRow = attributedTitleForRow
   70|      0|        super.init()
   71|      0|    }
   72|       |    
   73|      0|    func pickerView(_ pickerView: UIPickerView, attributedTitleForRow row: Int, forComponent component: Int) -> NSAttributedString? {
   74|      0|        return attributedTitleForRow(row, items[row])
   75|      0|    }
   76|       |}
   77|       |
   78|       |final class RxPickerViewAdapter<S: Sequence>: RxPickerViewSequenceDataSource<S>, UIPickerViewDelegate {
   79|       |    typealias ViewForRow = (Int, S.Iterator.Element, UIView?) -> UIView
   80|       |    private let viewForRow: ViewForRow
   81|       |    
   82|      0|    init(viewForRow: @escaping ViewForRow) {
   83|      0|        self.viewForRow = viewForRow
   84|      0|        super.init()
   85|      0|    }
   86|       |    
   87|      0|    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {
   88|      0|        return viewForRow(row, items[row], view)
   89|      0|    }
   90|       |}
   91|       |
   92|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/DataSources/RxTableViewReactiveArrayDataSource.swift:
    1|       |//
    2|       |//  RxTableViewReactiveArrayDataSource.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/26/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |// objc monkey business
   15|       |class _RxTableViewReactiveArrayDataSource
   16|       |    : NSObject
   17|       |    , UITableViewDataSource {
   18|       |    
   19|      0|    func numberOfSections(in tableView: UITableView) -> Int {
   20|      0|        return 1
   21|      0|    }
   22|       |   
   23|      0|    func _tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   24|      0|        return 0
   25|      0|    }
   26|       |    
   27|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   28|      0|        return _tableView(tableView, numberOfRowsInSection: section)
   29|      0|    }
   30|       |
   31|      0|    fileprivate func _tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   32|      0|        rxAbstractMethod()
   33|      0|    }
   34|       |
   35|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   36|      0|        return _tableView(tableView, cellForRowAt: indexPath)
   37|      0|    }
   38|       |}
   39|       |
   40|       |
   41|       |class RxTableViewReactiveArrayDataSourceSequenceWrapper<S: Sequence>
   42|       |    : RxTableViewReactiveArrayDataSource<S.Iterator.Element>
   43|       |    , RxTableViewDataSourceType {
   44|       |    typealias Element = S
   45|       |
   46|      0|    override init(cellFactory: @escaping CellFactory) {
   47|      0|        super.init(cellFactory: cellFactory)
   48|      0|    }
   49|       |
   50|      0|    func tableView(_ tableView: UITableView, observedEvent: Event<S>) {
   51|      0|        Binder(self) { tableViewDataSource, sectionModels in
   52|      0|            let sections = Array(sectionModels)
   53|      0|            tableViewDataSource.tableView(tableView, observedElements: sections)
   54|      0|        }.on(observedEvent)
   55|      0|    }
   56|       |}
   57|       |
   58|       |// Please take a look at `DelegateProxyType.swift`
   59|       |class RxTableViewReactiveArrayDataSource<Element>
   60|       |    : _RxTableViewReactiveArrayDataSource
   61|       |    , SectionedViewDataSourceType {
   62|       |    typealias CellFactory = (UITableView, Int, Element) -> UITableViewCell
   63|       |    
   64|       |    var itemModels: [Element]?
   65|       |    
   66|       |    func modelAtIndex(_ index: Int) -> Element? {
   67|       |        return itemModels?[index]
   68|       |    }
   69|       |
   70|       |    func model(at indexPath: IndexPath) throws -> Any {
   71|      0|        precondition(indexPath.section == 0)
   72|       |        guard let item = itemModels?[indexPath.item] else {
   73|       |            throw RxCocoaError.itemsNotYetBound(object: self)
   74|       |        }
   75|       |        return item
   76|       |    }
   77|       |
   78|       |    let cellFactory: CellFactory
   79|       |    
   80|      0|    init(cellFactory: @escaping CellFactory) {
   81|      0|        self.cellFactory = cellFactory
   82|      0|    }
   83|       |    
   84|       |    override func _tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   85|      0|        return itemModels?.count ?? 0
   86|       |    }
   87|       |    
   88|       |    override func _tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   89|       |        return cellFactory(tableView, indexPath.item, itemModels![indexPath.row])
   90|       |    }
   91|       |    
   92|       |    // reactive
   93|       |    
   94|       |    func tableView(_ tableView: UITableView, observedElements: [Element]) {
   95|       |        self.itemModels = observedElements
   96|       |        
   97|       |        tableView.reloadData()
   98|       |    }
   99|       |}
  100|       |
  101|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/NSTextStorage+Rx.swift:
    1|       |//
    2|       |//  NSTextStorage+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 12/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    import RxSwift
   11|       |    import UIKit
   12|       |
   13|       |    #if swift(>=4.2)
   14|       |        public typealias NSTextStorageEditActions = NSTextStorage.EditActions
   15|       |    #endif
   16|       |    
   17|       |    extension Reactive where Base: NSTextStorage {
   18|       |
   19|       |        /// Reactive wrapper for `delegate`.
   20|       |        ///
   21|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   22|      0|        public var delegate: DelegateProxy<NSTextStorage, NSTextStorageDelegate> {
   23|      0|            return RxTextStorageDelegateProxy.proxy(for: base)
   24|      0|        }
   25|       |
   26|       |        /// Reactive wrapper for `delegate` message.
   27|      0|        public var didProcessEditingRangeChangeInLength: Observable<(editedMask:NSTextStorageEditActions, editedRange:NSRange, delta:Int)> {
   28|      0|            return delegate
   29|      0|                .methodInvoked(#selector(NSTextStorageDelegate.textStorage(_:didProcessEditing:range:changeInLength:)))
   30|      0|                .map { a in
   31|      0|                    let editedMask = NSTextStorageEditActions(rawValue: try castOrThrow(UInt.self, a[1]) )
   32|      0|                    let editedRange = try castOrThrow(NSValue.self, a[2]).rangeValue
   33|      0|                    let delta = try castOrThrow(Int.self, a[3])
   34|      0|                    
   35|      0|                    return (editedMask, editedRange, delta)
   36|      0|                }
   37|      0|        }
   38|       |    }
   39|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxCollectionViewDataSourcePrefetchingProxy.swift:
    1|       |//
    2|       |//  RxCollectionViewDataSourcePrefetchingProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Rowan Livingstone on 2/15/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |@available(iOS 10.0, tvOS 10.0, *)
   15|       |extension UICollectionView: HasPrefetchDataSource {
   16|       |    public typealias PrefetchDataSource = UICollectionViewDataSourcePrefetching
   17|       |}
   18|       |
   19|       |@available(iOS 10.0, tvOS 10.0, *)
   20|       |fileprivate let collectionViewPrefetchDataSourceNotSet = CollectionViewPrefetchDataSourceNotSet()
   21|       |
   22|       |@available(iOS 10.0, tvOS 10.0, *)
   23|       |fileprivate final class CollectionViewPrefetchDataSourceNotSet
   24|       |    : NSObject
   25|       |    , UICollectionViewDataSourcePrefetching {
   26|       |
   27|      0|    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {}
   28|       |
   29|       |}
   30|       |
   31|       |@available(iOS 10.0, tvOS 10.0, *)
   32|       |open class RxCollectionViewDataSourcePrefetchingProxy
   33|       |    : DelegateProxy<UICollectionView, UICollectionViewDataSourcePrefetching>
   34|       |    , DelegateProxyType
   35|       |    , UICollectionViewDataSourcePrefetching {
   36|       |
   37|       |    /// Typed parent object.
   38|       |    public weak private(set) var collectionView: UICollectionView?
   39|       |
   40|       |    /// - parameter collectionView: Parent object for delegate proxy.
   41|      0|    public init(collectionView: ParentObject) {
   42|      0|        self.collectionView = collectionView
   43|      0|        super.init(parentObject: collectionView, delegateProxy: RxCollectionViewDataSourcePrefetchingProxy.self)
   44|      0|    }
   45|       |
   46|       |    // Register known implementations
   47|      0|    public static func registerKnownImplementations() {
   48|      0|        self.register { RxCollectionViewDataSourcePrefetchingProxy(collectionView: $0) }
   49|      0|    }
   50|       |
   51|       |    fileprivate var _prefetchItemsPublishSubject: PublishSubject<[IndexPath]>?
   52|       |
   53|       |    /// Optimized version used for observing prefetch items callbacks.
   54|      0|    internal var prefetchItemsPublishSubject: PublishSubject<[IndexPath]> {
   55|      0|        if let subject = _prefetchItemsPublishSubject {
   56|      0|            return subject
   57|      0|        }
   58|      0|
   59|      0|        let subject = PublishSubject<[IndexPath]>()
   60|      0|        _prefetchItemsPublishSubject = subject
   61|      0|
   62|      0|        return subject
   63|      0|    }
   64|       |
   65|       |    private weak var _requiredMethodsPrefetchDataSource: UICollectionViewDataSourcePrefetching? = collectionViewPrefetchDataSourceNotSet
   66|       |
   67|       |    // MARK: delegate
   68|       |
   69|       |    /// Required delegate method implementation.
   70|      0|    public func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
   71|      0|        if let subject = _prefetchItemsPublishSubject {
   72|      0|            subject.on(.next(indexPaths))
   73|      0|        }
   74|      0|
   75|      0|        (_requiredMethodsPrefetchDataSource ?? collectionViewPrefetchDataSourceNotSet).collectionView(collectionView, prefetchItemsAt: indexPaths)
   76|      0|    }
   77|       |
   78|       |    /// For more information take a look at `DelegateProxyType`.
   79|      0|    open override func setForwardToDelegate(_ forwardToDelegate: UICollectionViewDataSourcePrefetching?, retainDelegate: Bool) {
   80|      0|        _requiredMethodsPrefetchDataSource = forwardToDelegate ?? collectionViewPrefetchDataSourceNotSet
   81|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   82|      0|    }
   83|       |
   84|      0|    deinit {
   85|      0|        if let subject = _prefetchItemsPublishSubject {
   86|      0|            subject.on(.completed)
   87|      0|        }
   88|      0|    }
   89|       |
   90|       |}
   91|       |
   92|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxCollectionViewDataSourceProxy.swift:
    1|       |//
    2|       |//  RxCollectionViewDataSourceProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UICollectionView: HasDataSource {
   15|       |    public typealias DataSource = UICollectionViewDataSource
   16|       |}
   17|       |
   18|       |fileprivate let collectionViewDataSourceNotSet = CollectionViewDataSourceNotSet()
   19|       |
   20|       |fileprivate final class CollectionViewDataSourceNotSet
   21|       |    : NSObject
   22|       |    , UICollectionViewDataSource {
   23|       |
   24|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   25|      0|        return 0
   26|      0|    }
   27|       |    
   28|       |    // The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:
   29|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   30|      0|        rxAbstractMethod(message: dataSourceNotSet)
   31|      0|    }
   32|       |    
   33|       |}
   34|       |
   35|       |/// For more information take a look at `DelegateProxyType`.
   36|       |open class RxCollectionViewDataSourceProxy
   37|       |    : DelegateProxy<UICollectionView, UICollectionViewDataSource>
   38|       |    , DelegateProxyType 
   39|       |    , UICollectionViewDataSource {
   40|       |
   41|       |    /// Typed parent object.
   42|       |    public weak private(set) var collectionView: UICollectionView?
   43|       |
   44|       |    /// - parameter collectionView: Parent object for delegate proxy.
   45|      0|    public init(collectionView: ParentObject) {
   46|      0|        self.collectionView = collectionView
   47|      0|        super.init(parentObject: collectionView, delegateProxy: RxCollectionViewDataSourceProxy.self)
   48|      0|    }
   49|       |
   50|       |    // Register known implementations
   51|      0|    public static func registerKnownImplementations() {
   52|      0|        self.register { RxCollectionViewDataSourceProxy(collectionView: $0) }
   53|      0|    }
   54|       |
   55|       |    private weak var _requiredMethodsDataSource: UICollectionViewDataSource? = collectionViewDataSourceNotSet
   56|       |
   57|       |    // MARK: delegate
   58|       |
   59|       |    /// Required delegate method implementation.
   60|      0|    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   61|      0|        return (_requiredMethodsDataSource ?? collectionViewDataSourceNotSet).collectionView(collectionView, numberOfItemsInSection: section)
   62|      0|    }
   63|       |    
   64|       |    /// Required delegate method implementation.
   65|      0|    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   66|      0|        return (_requiredMethodsDataSource ?? collectionViewDataSourceNotSet).collectionView(collectionView, cellForItemAt: indexPath)
   67|      0|    }
   68|       |
   69|       |    /// For more information take a look at `DelegateProxyType`.
   70|      0|    open override func setForwardToDelegate(_ forwardToDelegate: UICollectionViewDataSource?, retainDelegate: Bool) {
   71|      0|        _requiredMethodsDataSource = forwardToDelegate ?? collectionViewDataSourceNotSet
   72|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   73|      0|    }
   74|       |}
   75|       |
   76|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxCollectionViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxCollectionViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |/// For more information take a look at `DelegateProxyType`.
   15|       |open class RxCollectionViewDelegateProxy
   16|       |    : RxScrollViewDelegateProxy
   17|       |    , UICollectionViewDelegate
   18|       |    , UICollectionViewDelegateFlowLayout {
   19|       |
   20|       |    /// Typed parent object.
   21|       |    public weak private(set) var collectionView: UICollectionView?
   22|       |
   23|       |    /// Initializes `RxCollectionViewDelegateProxy`
   24|       |    ///
   25|       |    /// - parameter collectionView: Parent object for delegate proxy.
   26|      0|    public init(collectionView: UICollectionView) {
   27|      0|        self.collectionView = collectionView
   28|      0|        super.init(scrollView: collectionView)
   29|      0|    }
   30|       |}
   31|       |
   32|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxNavigationControllerDelegateProxy.swift:
    1|       |//
    2|       |//  RxNavigationControllerDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Diogo on 13/04/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |    import UIKit
   12|       |    import RxSwift
   13|       |
   14|       |    extension UINavigationController: HasDelegate {
   15|       |        public typealias Delegate = UINavigationControllerDelegate
   16|       |    }
   17|       |
   18|       |    /// For more information take a look at `DelegateProxyType`.
   19|       |    open class RxNavigationControllerDelegateProxy
   20|       |        : DelegateProxy<UINavigationController, UINavigationControllerDelegate>
   21|       |        , DelegateProxyType 
   22|       |        , UINavigationControllerDelegate {
   23|       |
   24|       |        /// Typed parent object.
   25|       |        public weak private(set) var navigationController: UINavigationController?
   26|       |
   27|       |        /// - parameter navigationController: Parent object for delegate proxy.
   28|      0|        public init(navigationController: ParentObject) {
   29|      0|            self.navigationController = navigationController
   30|      0|            super.init(parentObject: navigationController, delegateProxy: RxNavigationControllerDelegateProxy.self)
   31|      0|        }
   32|       |
   33|       |        // Register known implementations
   34|      0|        public static func registerKnownImplementations() {
   35|      0|            self.register { RxNavigationControllerDelegateProxy(navigationController: $0) }
   36|      0|        }
   37|       |    }
   38|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxPickerViewDataSourceProxy.swift:
    1|       |//
    2|       |//  RxPickerViewDataSourceProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Sergey Shulga on 05/07/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UIPickerView: HasDataSource {
   15|       |    public typealias DataSource = UIPickerViewDataSource
   16|       |}
   17|       |
   18|       |private let pickerViewDataSourceNotSet = PickerViewDataSourceNotSet()
   19|       |
   20|       |final private class PickerViewDataSourceNotSet: NSObject, UIPickerViewDataSource {
   21|      0|    func numberOfComponents(in pickerView: UIPickerView) -> Int {
   22|      0|        return 0
   23|      0|    }
   24|       |    
   25|      0|    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {
   26|      0|        return 0
   27|      0|    }
   28|       |}
   29|       |
   30|       |/// For more information take a look at `DelegateProxyType`.
   31|       |public class RxPickerViewDataSourceProxy
   32|       |    : DelegateProxy<UIPickerView, UIPickerViewDataSource>
   33|       |    , DelegateProxyType
   34|       |    , UIPickerViewDataSource {
   35|       |
   36|       |    /// Typed parent object.
   37|       |    public weak private(set) var pickerView: UIPickerView?
   38|       |
   39|       |    /// - parameter pickerView: Parent object for delegate proxy.
   40|      0|    public init(pickerView: ParentObject) {
   41|      0|        self.pickerView = pickerView
   42|      0|        super.init(parentObject: pickerView, delegateProxy: RxPickerViewDataSourceProxy.self)
   43|      0|    }
   44|       |
   45|       |    // Register known implementations
   46|      0|    public static func registerKnownImplementations() {
   47|      0|        self.register { RxPickerViewDataSourceProxy(pickerView: $0) }
   48|      0|    }
   49|       |
   50|       |    private weak var _requiredMethodsDataSource: UIPickerViewDataSource? = pickerViewDataSourceNotSet
   51|       |
   52|       |    // MARK: UIPickerViewDataSource
   53|       |
   54|       |    /// Required delegate method implementation.
   55|      0|    public func numberOfComponents(in pickerView: UIPickerView) -> Int {
   56|      0|        return (_requiredMethodsDataSource ?? pickerViewDataSourceNotSet).numberOfComponents(in: pickerView)
   57|      0|    }
   58|       |
   59|       |    /// Required delegate method implementation.
   60|      0|    public func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {
   61|      0|        return (_requiredMethodsDataSource ?? pickerViewDataSourceNotSet).pickerView(pickerView, numberOfRowsInComponent: component)
   62|      0|    }
   63|       |    
   64|       |    /// For more information take a look at `DelegateProxyType`.
   65|      0|    public override func setForwardToDelegate(_ forwardToDelegate: UIPickerViewDataSource?, retainDelegate: Bool) {
   66|      0|        _requiredMethodsDataSource = forwardToDelegate ?? pickerViewDataSourceNotSet
   67|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   68|      0|    }
   69|       |}
   70|       |
   71|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxPickerViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxPickerViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |    import RxSwift
   12|       |    import UIKit
   13|       |
   14|       |    extension UIPickerView: HasDelegate {
   15|       |        public typealias Delegate = UIPickerViewDelegate
   16|       |    }
   17|       |
   18|       |    open class RxPickerViewDelegateProxy
   19|       |        : DelegateProxy<UIPickerView, UIPickerViewDelegate>
   20|       |        , DelegateProxyType 
   21|       |        , UIPickerViewDelegate {
   22|       |
   23|       |        /// Typed parent object.
   24|       |        public weak private(set) var pickerView: UIPickerView?
   25|       |
   26|       |        /// - parameter pickerView: Parent object for delegate proxy.
   27|      0|        public init(pickerView: ParentObject) {
   28|      0|            self.pickerView = pickerView
   29|      0|            super.init(parentObject: pickerView, delegateProxy: RxPickerViewDelegateProxy.self)
   30|      0|        }
   31|       |
   32|       |        // Register known implementationss
   33|      0|        public static func registerKnownImplementations() {
   34|      0|            self.register { RxPickerViewDelegateProxy(pickerView: $0) }
   35|      0|        }
   36|       |    }
   37|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxScrollViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxScrollViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |    
   14|       |extension UIScrollView: HasDelegate {
   15|       |    public typealias Delegate = UIScrollViewDelegate
   16|       |}
   17|       |
   18|       |/// For more information take a look at `DelegateProxyType`.
   19|       |open class RxScrollViewDelegateProxy
   20|       |    : DelegateProxy<UIScrollView, UIScrollViewDelegate>
   21|       |    , DelegateProxyType 
   22|       |    , UIScrollViewDelegate {
   23|       |
   24|       |    /// Typed parent object.
   25|       |    public weak private(set) var scrollView: UIScrollView?
   26|       |
   27|       |    /// - parameter scrollView: Parent object for delegate proxy.
   28|      0|    public init(scrollView: ParentObject) {
   29|      0|        self.scrollView = scrollView
   30|      0|        super.init(parentObject: scrollView, delegateProxy: RxScrollViewDelegateProxy.self)
   31|      0|    }
   32|       |
   33|       |    // Register known implementations
   34|      0|    public static func registerKnownImplementations() {
   35|      0|        self.register { RxScrollViewDelegateProxy(scrollView: $0) }
   36|      0|        self.register { RxTableViewDelegateProxy(tableView: $0) }
   37|      0|        self.register { RxCollectionViewDelegateProxy(collectionView: $0) }
   38|      0|        self.register { RxTextViewDelegateProxy(textView: $0) }
   39|      0|    }
   40|       |
   41|       |    fileprivate var _contentOffsetBehaviorSubject: BehaviorSubject<CGPoint>?
   42|       |    fileprivate var _contentOffsetPublishSubject: PublishSubject<()>?
   43|       |
   44|       |    /// Optimized version used for observing content offset changes.
   45|      0|    internal var contentOffsetBehaviorSubject: BehaviorSubject<CGPoint> {
   46|      0|        if let subject = _contentOffsetBehaviorSubject {
   47|      0|            return subject
   48|      0|        }
   49|      0|
   50|      0|        let subject = BehaviorSubject<CGPoint>(value: self.scrollView?.contentOffset ?? CGPoint.zero)
   51|      0|        _contentOffsetBehaviorSubject = subject
   52|      0|
   53|      0|        return subject
   54|      0|    }
   55|       |
   56|       |    /// Optimized version used for observing content offset changes.
   57|      0|    internal var contentOffsetPublishSubject: PublishSubject<()> {
   58|      0|        if let subject = _contentOffsetPublishSubject {
   59|      0|            return subject
   60|      0|        }
   61|      0|
   62|      0|        let subject = PublishSubject<()>()
   63|      0|        _contentOffsetPublishSubject = subject
   64|      0|
   65|      0|        return subject
   66|      0|    }
   67|       |    
   68|       |    // MARK: delegate methods
   69|       |
   70|       |    /// For more information take a look at `DelegateProxyType`.
   71|      0|    public func scrollViewDidScroll(_ scrollView: UIScrollView) {
   72|      0|        if let subject = _contentOffsetBehaviorSubject {
   73|      0|            subject.on(.next(scrollView.contentOffset))
   74|      0|        }
   75|      0|        if let subject = _contentOffsetPublishSubject {
   76|      0|            subject.on(.next(()))
   77|      0|        }
   78|      0|        self._forwardToDelegate?.scrollViewDidScroll?(scrollView)
   79|      0|    }
   80|       |    
   81|      0|    deinit {
   82|      0|        if let subject = _contentOffsetBehaviorSubject {
   83|      0|            subject.on(.completed)
   84|      0|        }
   85|      0|
   86|      0|        if let subject = _contentOffsetPublishSubject {
   87|      0|            subject.on(.completed)
   88|      0|        }
   89|      0|    }
   90|       |}
   91|       |
   92|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxSearchBarDelegateProxy.swift:
    1|       |//
    2|       |//  RxSearchBarDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UISearchBar: HasDelegate {
   15|       |    public typealias Delegate = UISearchBarDelegate
   16|       |}
   17|       |
   18|       |/// For more information take a look at `DelegateProxyType`.
   19|       |open class RxSearchBarDelegateProxy
   20|       |    : DelegateProxy<UISearchBar, UISearchBarDelegate>
   21|       |    , DelegateProxyType 
   22|       |    , UISearchBarDelegate {
   23|       |
   24|       |    /// Typed parent object.
   25|       |    public weak private(set) var searchBar: UISearchBar?
   26|       |
   27|       |    /// - parameter searchBar: Parent object for delegate proxy.
   28|      0|    public init(searchBar: ParentObject) {
   29|      0|        self.searchBar = searchBar
   30|      0|        super.init(parentObject: searchBar, delegateProxy: RxSearchBarDelegateProxy.self)
   31|      0|    }
   32|       |
   33|       |    // Register known implementations
   34|      0|    public static func registerKnownImplementations() {
   35|      0|        self.register { RxSearchBarDelegateProxy(searchBar: $0) }
   36|      0|    }
   37|       |}
   38|       |
   39|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxSearchControllerDelegateProxy.swift:
    1|       |//
    2|       |//  RxSearchControllerDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 3/17/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension UISearchController: HasDelegate {
   15|       |    public typealias Delegate = UISearchControllerDelegate
   16|       |}
   17|       |
   18|       |/// For more information take a look at `DelegateProxyType`.
   19|       |@available(iOS 8.0, *)
   20|       |open class RxSearchControllerDelegateProxy
   21|       |    : DelegateProxy<UISearchController, UISearchControllerDelegate>
   22|       |    , DelegateProxyType 
   23|       |    , UISearchControllerDelegate {
   24|       |
   25|       |    /// Typed parent object.
   26|       |    public weak private(set) var searchController: UISearchController?
   27|       |
   28|       |    /// - parameter searchController: Parent object for delegate proxy.
   29|      0|    public init(searchController: UISearchController) {
   30|      0|        self.searchController = searchController
   31|      0|        super.init(parentObject: searchController, delegateProxy: RxSearchControllerDelegateProxy.self)
   32|      0|    }
   33|       |    
   34|       |    // Register known implementations
   35|      0|    public static func registerKnownImplementations() {
   36|      0|        self.register { RxSearchControllerDelegateProxy(searchController: $0) }
   37|      0|    }
   38|       |}
   39|       |   
   40|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTabBarControllerDelegateProxy.swift:
    1|       |//
    2|       |//  RxTabBarControllerDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yusuke Kita on 2016/12/07.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UITabBarController: HasDelegate {
   15|       |    public typealias Delegate = UITabBarControllerDelegate
   16|       |}
   17|       |
   18|       |/// For more information take a look at `DelegateProxyType`.
   19|       |open class RxTabBarControllerDelegateProxy
   20|       |    : DelegateProxy<UITabBarController, UITabBarControllerDelegate>
   21|       |    , DelegateProxyType 
   22|       |    , UITabBarControllerDelegate {
   23|       |
   24|       |    /// Typed parent object.
   25|       |    public weak private(set) var tabBar: UITabBarController?
   26|       |
   27|       |    /// - parameter tabBar: Parent object for delegate proxy.
   28|      0|    public init(tabBar: ParentObject) {
   29|      0|        self.tabBar = tabBar
   30|      0|        super.init(parentObject: tabBar, delegateProxy: RxTabBarControllerDelegateProxy.self)
   31|      0|    }
   32|       |
   33|       |    // Register known implementations
   34|      0|    public static func registerKnownImplementations() {
   35|      0|        self.register { RxTabBarControllerDelegateProxy(tabBar: $0) }
   36|      0|    }
   37|       |}
   38|       |
   39|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTabBarDelegateProxy.swift:
    1|       |//
    2|       |//  RxTabBarDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Jesse Farless on 5/14/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UITabBar: HasDelegate {
   15|       |    public typealias Delegate = UITabBarDelegate
   16|       |}
   17|       |
   18|       |/// For more information take a look at `DelegateProxyType`.
   19|       |open class RxTabBarDelegateProxy
   20|       |    : DelegateProxy<UITabBar, UITabBarDelegate>
   21|       |    , DelegateProxyType 
   22|       |    , UITabBarDelegate {
   23|       |
   24|       |    /// Typed parent object.
   25|       |    public weak private(set) var tabBar: UITabBar?
   26|       |
   27|       |    /// - parameter tabBar: Parent object for delegate proxy.
   28|      0|    public init(tabBar: ParentObject) {
   29|      0|        self.tabBar = tabBar
   30|      0|        super.init(parentObject: tabBar, delegateProxy: RxTabBarDelegateProxy.self)
   31|      0|    }
   32|       |
   33|       |    // Register known implementations
   34|      0|    public static func registerKnownImplementations() {
   35|      0|        self.register { RxTabBarDelegateProxy(tabBar: $0) }
   36|      0|    }
   37|       |
   38|       |    /// For more information take a look at `DelegateProxyType`.
   39|      0|    open class func currentDelegate(for object: ParentObject) -> UITabBarDelegate? {
   40|      0|        return object.delegate
   41|      0|    }
   42|       |
   43|       |    /// For more information take a look at `DelegateProxyType`.
   44|      0|    open class func setCurrentDelegate(_ delegate: UITabBarDelegate?, to object: ParentObject) {
   45|      0|        object.delegate = delegate
   46|      0|    }
   47|       |}
   48|       |
   49|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTableViewDataSourcePrefetchingProxy.swift:
    1|       |//
    2|       |//  RxTableViewDataSourcePrefetchingProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Rowan Livingstone on 2/15/18.
    6|       |//  Copyright © 2018 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |@available(iOS 10.0, tvOS 10.0, *)
   15|       |extension UITableView: HasPrefetchDataSource {
   16|       |    public typealias PrefetchDataSource = UITableViewDataSourcePrefetching
   17|       |}
   18|       |
   19|       |@available(iOS 10.0, tvOS 10.0, *)
   20|       |fileprivate let tableViewPrefetchDataSourceNotSet = TableViewPrefetchDataSourceNotSet()
   21|       |
   22|       |@available(iOS 10.0, tvOS 10.0, *)
   23|       |fileprivate final class TableViewPrefetchDataSourceNotSet
   24|       |    : NSObject
   25|       |    , UITableViewDataSourcePrefetching {
   26|       |
   27|      0|    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {}
   28|       |
   29|       |}
   30|       |
   31|       |@available(iOS 10.0, tvOS 10.0, *)
   32|       |open class RxTableViewDataSourcePrefetchingProxy
   33|       |    : DelegateProxy<UITableView, UITableViewDataSourcePrefetching>
   34|       |    , DelegateProxyType
   35|       |    , UITableViewDataSourcePrefetching {
   36|       |
   37|       |    /// Typed parent object.
   38|       |    public weak private(set) var tableView: UITableView?
   39|       |
   40|       |    /// - parameter tableView: Parent object for delegate proxy.
   41|      0|    public init(tableView: ParentObject) {
   42|      0|        self.tableView = tableView
   43|      0|        super.init(parentObject: tableView, delegateProxy: RxTableViewDataSourcePrefetchingProxy.self)
   44|      0|    }
   45|       |
   46|       |    // Register known implementations
   47|      0|    public static func registerKnownImplementations() {
   48|      0|        self.register { RxTableViewDataSourcePrefetchingProxy(tableView: $0) }
   49|      0|    }
   50|       |
   51|       |    fileprivate var _prefetchRowsPublishSubject: PublishSubject<[IndexPath]>?
   52|       |
   53|       |    /// Optimized version used for observing prefetch rows callbacks.
   54|      0|    internal var prefetchRowsPublishSubject: PublishSubject<[IndexPath]> {
   55|      0|        if let subject = _prefetchRowsPublishSubject {
   56|      0|            return subject
   57|      0|        }
   58|      0|
   59|      0|        let subject = PublishSubject<[IndexPath]>()
   60|      0|        _prefetchRowsPublishSubject = subject
   61|      0|
   62|      0|        return subject
   63|      0|    }
   64|       |
   65|       |    private weak var _requiredMethodsPrefetchDataSource: UITableViewDataSourcePrefetching? = tableViewPrefetchDataSourceNotSet
   66|       |
   67|       |    // MARK: delegate
   68|       |
   69|       |    /// Required delegate method implementation.
   70|      0|    public func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {
   71|      0|        if let subject = _prefetchRowsPublishSubject {
   72|      0|            subject.on(.next(indexPaths))
   73|      0|        }
   74|      0|
   75|      0|        (_requiredMethodsPrefetchDataSource ?? tableViewPrefetchDataSourceNotSet).tableView(tableView, prefetchRowsAt: indexPaths)
   76|      0|    }
   77|       |
   78|       |    /// For more information take a look at `DelegateProxyType`.
   79|      0|    open override func setForwardToDelegate(_ forwardToDelegate: UITableViewDataSourcePrefetching?, retainDelegate: Bool) {
   80|      0|        _requiredMethodsPrefetchDataSource = forwardToDelegate ?? tableViewPrefetchDataSourceNotSet
   81|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   82|      0|    }
   83|       |
   84|      0|    deinit {
   85|      0|        if let subject = _prefetchRowsPublishSubject {
   86|      0|            subject.on(.completed)
   87|      0|        }
   88|      0|    }
   89|       |
   90|       |}
   91|       |
   92|       |#endif
   93|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTableViewDataSourceProxy.swift:
    1|       |//
    2|       |//  RxTableViewDataSourceProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |    
   14|       |extension UITableView: HasDataSource {
   15|       |    public typealias DataSource = UITableViewDataSource
   16|       |}
   17|       |
   18|       |fileprivate let tableViewDataSourceNotSet = TableViewDataSourceNotSet()
   19|       |
   20|       |fileprivate final class TableViewDataSourceNotSet
   21|       |    : NSObject
   22|       |    , UITableViewDataSource {
   23|       |
   24|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   25|      0|        return 0
   26|      0|    }
   27|       |    
   28|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   29|      0|        rxAbstractMethod(message: dataSourceNotSet)
   30|      0|    }
   31|       |}
   32|       |
   33|       |/// For more information take a look at `DelegateProxyType`.
   34|       |open class RxTableViewDataSourceProxy
   35|       |    : DelegateProxy<UITableView, UITableViewDataSource>
   36|       |    , DelegateProxyType 
   37|       |    , UITableViewDataSource {
   38|       |
   39|       |    /// Typed parent object.
   40|       |    public weak private(set) var tableView: UITableView?
   41|       |
   42|       |    /// - parameter tableView: Parent object for delegate proxy.
   43|      0|    public init(tableView: UITableView) {
   44|      0|        self.tableView = tableView
   45|      0|        super.init(parentObject: tableView, delegateProxy: RxTableViewDataSourceProxy.self)
   46|      0|    }
   47|       |
   48|       |    // Register known implementations
   49|      0|    public static func registerKnownImplementations() {
   50|      0|        self.register { RxTableViewDataSourceProxy(tableView: $0) }
   51|      0|    }
   52|       |
   53|       |    fileprivate weak var _requiredMethodsDataSource: UITableViewDataSource? = tableViewDataSourceNotSet
   54|       |
   55|       |    // MARK: delegate
   56|       |
   57|       |    /// Required delegate method implementation.
   58|      0|    public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   59|      0|        return (_requiredMethodsDataSource ?? tableViewDataSourceNotSet).tableView(tableView, numberOfRowsInSection: section)
   60|      0|    }
   61|       |
   62|       |    /// Required delegate method implementation.
   63|      0|    public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   64|      0|        return (_requiredMethodsDataSource ?? tableViewDataSourceNotSet).tableView(tableView, cellForRowAt: indexPath)
   65|      0|    }
   66|       |
   67|       |    /// For more information take a look at `DelegateProxyType`.
   68|      0|    open override func setForwardToDelegate(_ forwardToDelegate: UITableViewDataSource?, retainDelegate: Bool) {
   69|      0|        _requiredMethodsDataSource = forwardToDelegate  ?? tableViewDataSourceNotSet
   70|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   71|      0|    }
   72|       |
   73|       |}
   74|       |
   75|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTableViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxTableViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |/// For more information take a look at `DelegateProxyType`.
   15|       |open class RxTableViewDelegateProxy
   16|       |    : RxScrollViewDelegateProxy
   17|       |    , UITableViewDelegate {
   18|       |
   19|       |    /// Typed parent object.
   20|       |    public weak private(set) var tableView: UITableView?
   21|       |
   22|       |    /// - parameter tableView: Parent object for delegate proxy.
   23|      0|    public init(tableView: UITableView) {
   24|      0|        self.tableView = tableView
   25|      0|        super.init(scrollView: tableView)
   26|      0|    }
   27|       |
   28|       |}
   29|       |
   30|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTextStorageDelegateProxy.swift:
    1|       |//
    2|       |//  RxTextStorageDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 12/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |    import RxSwift
   12|       |    import UIKit
   13|       |
   14|       |    extension NSTextStorage: HasDelegate {
   15|       |        public typealias Delegate = NSTextStorageDelegate
   16|       |    }
   17|       |
   18|       |    open class RxTextStorageDelegateProxy
   19|       |        : DelegateProxy<NSTextStorage, NSTextStorageDelegate>
   20|       |        , DelegateProxyType 
   21|       |        , NSTextStorageDelegate {
   22|       |
   23|       |        /// Typed parent object.
   24|       |        public weak private(set) var textStorage: NSTextStorage?
   25|       |
   26|       |        /// - parameter textStorage: Parent object for delegate proxy.
   27|      0|        public init(textStorage: NSTextStorage) {
   28|      0|            self.textStorage = textStorage
   29|      0|            super.init(parentObject: textStorage, delegateProxy: RxTextStorageDelegateProxy.self)
   30|      0|        }
   31|       |
   32|       |        // Register known implementations
   33|      0|        public static func registerKnownImplementations() {
   34|      0|            self.register { RxTextStorageDelegateProxy(textStorage: $0) }
   35|      0|        }
   36|       |    }
   37|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTextViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxTextViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 7/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |/// For more information take a look at `DelegateProxyType`.
   15|       |open class RxTextViewDelegateProxy
   16|       |    : RxScrollViewDelegateProxy
   17|       |    , UITextViewDelegate {
   18|       |
   19|       |    /// Typed parent object.
   20|       |    public weak private(set) var textView: UITextView?
   21|       |
   22|       |    /// - parameter textview: Parent object for delegate proxy.
   23|      0|    public init(textView: UITextView) {
   24|      0|        self.textView = textView
   25|      0|        super.init(scrollView: textView)
   26|      0|    }
   27|       |
   28|       |    // MARK: delegate methods
   29|       |
   30|       |    /// For more information take a look at `DelegateProxyType`.
   31|      0|    @objc open func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
   32|      0|        /**
   33|      0|         We've had some issues with observing text changes. This is here just in case we need the same hack in future and that 
   34|      0|         we wouldn't need to change the public interface.
   35|      0|        */
   36|      0|        let forwardToDelegate = self.forwardToDelegate() as? UITextViewDelegate
   37|      0|        return forwardToDelegate?.textView?(textView,
   38|      0|            shouldChangeTextIn: range,
   39|      0|            replacementText: text) ?? true
   40|      0|    }
   41|       |}
   42|       |
   43|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxWebViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxWebViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 9/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension UIWebView: HasDelegate {
   15|       |    public typealias Delegate = UIWebViewDelegate
   16|       |}
   17|       |
   18|       |open class RxWebViewDelegateProxy
   19|       |    : DelegateProxy<UIWebView, UIWebViewDelegate>
   20|       |    , DelegateProxyType 
   21|       |    , UIWebViewDelegate {
   22|       |
   23|       |    /// Typed parent object.
   24|       |    public weak private(set) var webView: UIWebView?
   25|       |
   26|       |    /// - parameter webView: Parent object for delegate proxy.
   27|      0|    public init(webView: ParentObject) {
   28|      0|        self.webView = webView
   29|      0|        super.init(parentObject: webView, delegateProxy: RxWebViewDelegateProxy.self)
   30|      0|    }
   31|       |
   32|       |    // Register known implementations
   33|      0|    public static func registerKnownImplementations() {
   34|      0|        self.register { RxWebViewDelegateProxy(webView: $0) }
   35|      0|    }
   36|       |}
   37|       |
   38|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIActivityIndicatorView+Rx.swift:
    1|       |//
    2|       |//  UIActivityIndicatorView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Ivan Persidskiy on 02/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UIActivityIndicatorView {
   15|       |
   16|       |    /// Bindable sink for `startAnimating()`, `stopAnimating()` methods.
   17|      0|    public var isAnimating: Binder<Bool> {
   18|      0|        return Binder(self.base) { activityIndicator, active in
   19|      0|            if active {
   20|      0|                activityIndicator.startAnimating()
   21|      0|            } else {
   22|      0|                activityIndicator.stopAnimating()
   23|      0|            }
   24|      0|        }
   25|      0|    }
   26|       |
   27|       |}
   28|       |
   29|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIAlertAction+Rx.swift:
    1|       |//
    2|       |//  UIAlertAction+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 5/7/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UIAlertAction {
   15|       |
   16|       |    /// Bindable sink for `enabled` property.
   17|      0|    public var isEnabled: Binder<Bool> {
   18|      0|        return Binder(self.base) { alertAction, value in
   19|      0|            alertAction.isEnabled = value
   20|      0|        }
   21|      0|    }
   22|       |    
   23|       |}
   24|       |    
   25|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIApplication+Rx.swift:
    1|       |//
    2|       |//  UIApplication+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Mads Bøgeskov on 18/01/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |    import UIKit
   12|       |    import RxSwift
   13|       |
   14|       |    extension Reactive where Base: UIApplication {
   15|       |        
   16|       |        /// Bindable sink for `networkActivityIndicatorVisible`.
   17|      0|        public var isNetworkActivityIndicatorVisible: Binder<Bool> {
   18|      0|            return Binder(self.base) { application, active in
   19|      0|                application.isNetworkActivityIndicatorVisible = active
   20|      0|            }
   21|      0|        }
   22|       |    }
   23|       |#endif
   24|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIBarButtonItem+Rx.swift:
    1|       |//
    2|       |//  UIBarButtonItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |fileprivate var rx_tap_key: UInt8 = 0
   15|       |
   16|       |extension Reactive where Base: UIBarButtonItem {
   17|       |    
   18|       |    /// Bindable sink for `enabled` property.
   19|      0|    public var isEnabled: Binder<Bool> {
   20|      0|        return Binder(self.base) { element, value in
   21|      0|            element.isEnabled = value
   22|      0|        }
   23|      0|    }
   24|       |    
   25|       |    /// Bindable sink for `title` property.
   26|      0|    public var title: Binder<String> {
   27|      0|        return Binder(self.base) { element, value in
   28|      0|            element.title = value
   29|      0|        }
   30|      0|    }
   31|       |
   32|       |    /// Reactive wrapper for target action pattern on `self`.
   33|      0|    public var tap: ControlEvent<()> {
   34|      0|        let source = lazyInstanceObservable(&rx_tap_key) { () -> Observable<()> in
   35|      0|            Observable.create { [weak control = self.base] observer in
   36|      0|                guard let control = control else {
   37|      0|                    observer.on(.completed)
   38|      0|                    return Disposables.create()
   39|      0|                }
   40|      0|                let target = BarButtonItemTarget(barButtonItem: control) {
   41|      0|                    observer.on(.next(()))
   42|      0|                }
   43|      0|                return target
   44|      0|            }
   45|      0|            .takeUntil(self.deallocated)
   46|      0|            .share()
   47|      0|        }
   48|      0|        
   49|      0|        return ControlEvent(events: source)
   50|      0|    }
   51|       |}
   52|       |
   53|       |
   54|       |@objc
   55|       |final class BarButtonItemTarget: RxTarget {
   56|       |    typealias Callback = () -> Void
   57|       |    
   58|       |    weak var barButtonItem: UIBarButtonItem?
   59|       |    var callback: Callback!
   60|       |    
   61|      0|    init(barButtonItem: UIBarButtonItem, callback: @escaping () -> Void) {
   62|      0|        self.barButtonItem = barButtonItem
   63|      0|        self.callback = callback
   64|      0|        super.init()
   65|      0|        barButtonItem.target = self
   66|      0|        barButtonItem.action = #selector(BarButtonItemTarget.action(_:))
   67|      0|    }
   68|       |    
   69|      0|    override func dispose() {
   70|      0|        super.dispose()
   71|      0|#if DEBUG
   72|      0|        MainScheduler.ensureRunningOnMainThread()
   73|      0|#endif
   74|      0|        
   75|      0|        barButtonItem?.target = nil
   76|      0|        barButtonItem?.action = nil
   77|      0|        
   78|      0|        callback = nil
   79|      0|    }
   80|       |    
   81|      0|    @objc func action(_ sender: AnyObject) {
   82|      0|        callback()
   83|      0|    }
   84|       |    
   85|       |}
   86|       |
   87|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIButton+Rx.swift:
    1|       |//
    2|       |//  UIButton+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UIButton {
   15|       |    
   16|       |    /// Reactive wrapper for `TouchUpInside` control event.
   17|      0|    public var tap: ControlEvent<Void> {
   18|      0|        return controlEvent(.touchUpInside)
   19|      0|    }
   20|       |}
   21|       |
   22|       |#endif
   23|       |
   24|       |#if os(tvOS)
   25|       |
   26|       |import RxSwift
   27|       |import UIKit
   28|       |
   29|       |extension Reactive where Base: UIButton {
   30|       |
   31|       |    /// Reactive wrapper for `PrimaryActionTriggered` control event.
   32|       |    public var primaryAction: ControlEvent<Void> {
   33|       |        return controlEvent(.primaryActionTriggered)
   34|       |    }
   35|       |
   36|       |}
   37|       |
   38|       |#endif
   39|       |
   40|       |#if os(iOS) || os(tvOS)
   41|       |
   42|       |import RxSwift
   43|       |import UIKit
   44|       |
   45|       |#if swift(>=4.2)
   46|       |    public typealias UIControlState = UIControl.State
   47|       |#endif
   48|       |
   49|       |extension Reactive where Base: UIButton {
   50|       |    
   51|       |    /// Reactive wrapper for `setTitle(_:for:)`
   52|      0|    public func title(for controlState: UIControlState = []) -> Binder<String?> {
   53|      0|        return Binder(self.base) { button, title -> Void in
   54|      0|            button.setTitle(title, for: controlState)
   55|      0|        }
   56|      0|    }
   57|       |
   58|       |    /// Reactive wrapper for `setImage(_:for:)`
   59|      0|    public func image(for controlState: UIControlState = []) -> Binder<UIImage?> {
   60|      0|        return Binder(self.base) { button, image -> Void in
   61|      0|            button.setImage(image, for: controlState)
   62|      0|        }
   63|      0|    }
   64|       |
   65|       |    /// Reactive wrapper for `setBackgroundImage(_:for:)`
   66|      0|    public func backgroundImage(for controlState: UIControlState = []) -> Binder<UIImage?> {
   67|      0|        return Binder(self.base) { button, image -> Void in
   68|      0|            button.setBackgroundImage(image, for: controlState)
   69|      0|        }
   70|      0|    }
   71|       |    
   72|       |}
   73|       |#endif
   74|       |
   75|       |#if os(iOS) || os(tvOS)
   76|       |
   77|       |    import RxSwift
   78|       |    import UIKit
   79|       |    
   80|       |    extension Reactive where Base: UIButton {
   81|       |        
   82|       |        /// Reactive wrapper for `setAttributedTitle(_:controlState:)`
   83|      0|        public func attributedTitle(for controlState: UIControlState = []) -> Binder<NSAttributedString?> {
   84|      0|            return Binder(self.base) { button, attributedTitle -> Void in
   85|      0|                button.setAttributedTitle(attributedTitle, for: controlState)
   86|      0|            }
   87|      0|        }
   88|       |        
   89|       |    }
   90|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UICollectionView+Rx.swift:
    1|       |//
    2|       |//  UICollectionView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |// Items
   15|       |
   16|       |extension Reactive where Base: UICollectionView {
   17|       |
   18|       |    /**
   19|       |    Binds sequences of elements to collection view items.
   20|       |    
   21|       |    - parameter source: Observable sequence of items.
   22|       |    - parameter cellFactory: Transform between sequence elements and view cells.
   23|       |    - returns: Disposable object that can be used to unbind.
   24|       |     
   25|       |     Example
   26|       |    
   27|       |         let items = Observable.just([
   28|       |             1,
   29|       |             2,
   30|       |             3
   31|       |         ])
   32|       |
   33|       |         items
   34|       |         .bind(to: collectionView.rx.items) { (collectionView, row, element) in
   35|       |            let indexPath = IndexPath(row: row, section: 0)
   36|       |            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath) as! NumberCell
   37|       |             cell.value?.text = "\(element) @ \(row)"
   38|       |             return cell
   39|       |         }
   40|       |         .disposed(by: disposeBag)
   41|       |    */
   42|       |    public func items<S: Sequence, O: ObservableType>
   43|       |        (_ source: O)
   44|       |        -> (_ cellFactory: @escaping (UICollectionView, Int, S.Iterator.Element) -> UICollectionViewCell)
   45|      0|        -> Disposable where O.E == S {
   46|      0|        return { cellFactory in
   47|      0|            let dataSource = RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S>(cellFactory: cellFactory)
   48|      0|            return self.items(dataSource: dataSource)(source)
   49|      0|        }
   50|      0|        
   51|      0|    }
   52|       |    
   53|       |    /**
   54|       |    Binds sequences of elements to collection view items.
   55|       |    
   56|       |    - parameter cellIdentifier: Identifier used to dequeue cells.
   57|       |    - parameter source: Observable sequence of items.
   58|       |    - parameter configureCell: Transform between sequence elements and view cells.
   59|       |    - parameter cellType: Type of table view cell.
   60|       |    - returns: Disposable object that can be used to unbind.
   61|       |     
   62|       |     Example
   63|       |
   64|       |         let items = Observable.just([
   65|       |             1,
   66|       |             2,
   67|       |             3
   68|       |         ])
   69|       |
   70|       |         items
   71|       |             .bind(to: collectionView.rx.items(cellIdentifier: "Cell", cellType: NumberCell.self)) { (row, element, cell) in
   72|       |                cell.value?.text = "\(element) @ \(row)"
   73|       |             }
   74|       |             .disposed(by: disposeBag)
   75|       |    */
   76|       |    public func items<S: Sequence, Cell: UICollectionViewCell, O : ObservableType>
   77|       |        (cellIdentifier: String, cellType: Cell.Type = Cell.self)
   78|       |        -> (_ source: O)
   79|       |        -> (_ configureCell: @escaping (Int, S.Iterator.Element, Cell) -> Void)
   80|      0|        -> Disposable where O.E == S {
   81|      0|        return { source in
   82|      0|            return { configureCell in
   83|      0|                let dataSource = RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S> { cv, i, item in
   84|      0|                    let indexPath = IndexPath(item: i, section: 0)
   85|      0|                    let cell = cv.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as! Cell
   86|      0|                    configureCell(i, item, cell)
   87|      0|                    return cell
   88|      0|                }
   89|      0|                    
   90|      0|                return self.items(dataSource: dataSource)(source)
   91|      0|            }
   92|      0|        }
   93|      0|    }
   94|       |
   95|       |    
   96|       |    /**
   97|       |    Binds sequences of elements to collection view items using a custom reactive data used to perform the transformation.
   98|       |    
   99|       |    - parameter dataSource: Data source used to transform elements to view cells.
  100|       |    - parameter source: Observable sequence of items.
  101|       |    - returns: Disposable object that can be used to unbind.
  102|       |     
  103|       |     Example
  104|       |     
  105|       |         let dataSource = RxCollectionViewSectionedReloadDataSource<SectionModel<String, Double>>()
  106|       |
  107|       |         let items = Observable.just([
  108|       |             SectionModel(model: "First section", items: [
  109|       |                 1.0,
  110|       |                 2.0,
  111|       |                 3.0
  112|       |             ]),
  113|       |             SectionModel(model: "Second section", items: [
  114|       |                 1.0,
  115|       |                 2.0,
  116|       |                 3.0
  117|       |             ]),
  118|       |             SectionModel(model: "Third section", items: [
  119|       |                 1.0,
  120|       |                 2.0,
  121|       |                 3.0
  122|       |             ])
  123|       |         ])
  124|       |
  125|       |         dataSource.configureCell = { (dataSource, cv, indexPath, element) in
  126|       |             let cell = cv.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath) as! NumberCell
  127|       |             cell.value?.text = "\(element) @ row \(indexPath.row)"
  128|       |             return cell
  129|       |         }
  130|       |
  131|       |         items
  132|       |            .bind(to: collectionView.rx.items(dataSource: dataSource))
  133|       |            .disposed(by: disposeBag)
  134|       |    */
  135|       |    public func items<
  136|       |            DataSource: RxCollectionViewDataSourceType & UICollectionViewDataSource,
  137|       |            O: ObservableType>
  138|       |        (dataSource: DataSource)
  139|       |        -> (_ source: O)
  140|       |        -> Disposable where DataSource.Element == O.E
  141|       |          {
  142|      0|        return { source in
  143|      0|            // This is called for sideeffects only, and to make sure delegate proxy is in place when
  144|      0|            // data source is being bound.
  145|      0|            // This is needed because theoretically the data source subscription itself might
  146|      0|            // call `self.rx.delegate`. If that happens, it might cause weird side effects since
  147|      0|            // setting data source will set delegate, and UICollectionView might get into a weird state.
  148|      0|            // Therefore it's better to set delegate proxy first, just to be sure.
  149|      0|            _ = self.delegate
  150|      0|            // Strong reference is needed because data source is in use until result subscription is disposed
  151|      0|            return source.subscribeProxyDataSource(ofObject: self.base, dataSource: dataSource, retainDataSource: true) { [weak collectionView = self.base] (_: RxCollectionViewDataSourceProxy, event) -> Void in
  152|      0|                guard let collectionView = collectionView else {
  153|      0|                    return
  154|      0|                }
  155|      0|                dataSource.collectionView(collectionView, observedEvent: event)
  156|      0|            }
  157|      0|        }
  158|       |    }
  159|       |}
  160|       |
  161|       |extension Reactive where Base: UICollectionView {
  162|       |    public typealias DisplayCollectionViewCellEvent = (cell: UICollectionViewCell, at: IndexPath)
  163|       |    public typealias DisplayCollectionViewSupplementaryViewEvent = (supplementaryView: UICollectionReusableView, elementKind: String, at: IndexPath)
  164|       |
  165|       |    /// Reactive wrapper for `dataSource`.
  166|       |    ///
  167|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
  168|      0|    public var dataSource: DelegateProxy<UICollectionView, UICollectionViewDataSource> {
  169|      0|        return RxCollectionViewDataSourceProxy.proxy(for: base)
  170|      0|    }
  171|       |    
  172|       |    /// Installs data source as forwarding delegate on `rx.dataSource`.
  173|       |    /// Data source won't be retained.
  174|       |    ///
  175|       |    /// It enables using normal delegate mechanism with reactive delegate mechanism.
  176|       |    ///
  177|       |    /// - parameter dataSource: Data source object.
  178|       |    /// - returns: Disposable object that can be used to unbind the data source.
  179|       |    public func setDataSource(_ dataSource: UICollectionViewDataSource)
  180|      0|        -> Disposable {
  181|      0|        return RxCollectionViewDataSourceProxy.installForwardDelegate(dataSource, retainDelegate: false, onProxyForObject: self.base)
  182|      0|    }
  183|       |   
  184|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didSelectItemAtIndexPath:)`.
  185|      0|    public var itemSelected: ControlEvent<IndexPath> {
  186|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))
  187|      0|            .map { a in
  188|      0|                return try castOrThrow(IndexPath.self, a[1])
  189|      0|            }
  190|      0|        
  191|      0|        return ControlEvent(events: source)
  192|      0|    }
  193|       |
  194|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didDeselectItemAtIndexPath:)`.
  195|      0|    public var itemDeselected: ControlEvent<IndexPath> {
  196|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didDeselectItemAt:)))
  197|      0|            .map { a in
  198|      0|                return try castOrThrow(IndexPath.self, a[1])
  199|      0|        }
  200|      0|
  201|      0|        return ControlEvent(events: source)
  202|      0|    }
  203|       |
  204|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didHighlightItemAt:)`.
  205|      0|    public var itemHighlighted: ControlEvent<IndexPath> {
  206|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didHighlightItemAt:)))
  207|      0|            .map { a in
  208|      0|                return try castOrThrow(IndexPath.self, a[1])
  209|      0|            }
  210|      0|        
  211|      0|        return ControlEvent(events: source)
  212|      0|    }
  213|       |
  214|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didUnhighlightItemAt:)`.
  215|      0|    public var itemUnhighlighted: ControlEvent<IndexPath> {
  216|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didUnhighlightItemAt:)))
  217|      0|            .map { a in
  218|      0|                return try castOrThrow(IndexPath.self, a[1])
  219|      0|            }
  220|      0|        
  221|      0|        return ControlEvent(events: source)
  222|      0|    }
  223|       |
  224|       |    /// Reactive wrapper for `delegate` message `collectionView:willDisplay:forItemAt:`.
  225|      0|    public var willDisplayCell: ControlEvent<DisplayCollectionViewCellEvent> {
  226|      0|        let source: Observable<DisplayCollectionViewCellEvent> = self.delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:willDisplay:forItemAt:)))
  227|      0|            .map { a in
  228|      0|                return (try castOrThrow(UICollectionViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  229|      0|            }
  230|      0|        
  231|      0|        return ControlEvent(events: source)
  232|      0|    }
  233|       |
  234|       |    /// Reactive wrapper for `delegate` message `collectionView(_:willDisplaySupplementaryView:forElementKind:at:)`.
  235|      0|    public var willDisplaySupplementaryView: ControlEvent<DisplayCollectionViewSupplementaryViewEvent> {
  236|      0|        let source: Observable<DisplayCollectionViewSupplementaryViewEvent> = self.delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:willDisplaySupplementaryView:forElementKind:at:)))
  237|      0|            .map { a in
  238|      0|                return (try castOrThrow(UICollectionReusableView.self, a[1]),
  239|      0|                        try castOrThrow(String.self, a[2]),
  240|      0|                        try castOrThrow(IndexPath.self, a[3]))
  241|      0|            }
  242|      0|
  243|      0|        return ControlEvent(events: source)
  244|      0|    }
  245|       |
  246|       |    /// Reactive wrapper for `delegate` message `collectionView:didEndDisplaying:forItemAt:`.
  247|      0|    public var didEndDisplayingCell: ControlEvent<DisplayCollectionViewCellEvent> {
  248|      0|        let source: Observable<DisplayCollectionViewCellEvent> = self.delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didEndDisplaying:forItemAt:)))
  249|      0|            .map { a in
  250|      0|                return (try castOrThrow(UICollectionViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  251|      0|            }
  252|      0|
  253|      0|        return ControlEvent(events: source)
  254|      0|    }
  255|       |
  256|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didEndDisplayingSupplementaryView:forElementOfKind:at:)`.
  257|      0|    public var didEndDisplayingSupplementaryView: ControlEvent<DisplayCollectionViewSupplementaryViewEvent> {
  258|      0|        let source: Observable<DisplayCollectionViewSupplementaryViewEvent> = self.delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didEndDisplayingSupplementaryView:forElementOfKind:at:)))
  259|      0|            .map { a in
  260|      0|                return (try castOrThrow(UICollectionReusableView.self, a[1]),
  261|      0|                        try castOrThrow(String.self, a[2]),
  262|      0|                        try castOrThrow(IndexPath.self, a[3]))
  263|      0|            }
  264|      0|
  265|      0|        return ControlEvent(events: source)
  266|      0|    }
  267|       |    
  268|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didSelectItemAtIndexPath:)`.
  269|       |    ///
  270|       |    /// It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  271|       |    /// or any other data source conforming to `SectionedViewDataSourceType` protocol.
  272|       |    ///
  273|       |    /// ```
  274|       |    ///     collectionView.rx.modelSelected(MyModel.self)
  275|       |    ///        .map { ...
  276|       |    /// ```
  277|      0|    public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  278|      0|        let source: Observable<T> = itemSelected.flatMap { [weak view = self.base as UICollectionView] indexPath -> Observable<T> in
  279|      0|            guard let view = view else {
  280|      0|                return Observable.empty()
  281|      0|            }
  282|      0|
  283|      0|            return Observable.just(try view.rx.model(at: indexPath))
  284|      0|        }
  285|      0|        
  286|      0|        return ControlEvent(events: source)
  287|      0|    }
  288|       |
  289|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didSelectItemAtIndexPath:)`.
  290|       |    ///
  291|       |    /// It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  292|       |    /// or any other data source conforming to `SectionedViewDataSourceType` protocol.
  293|       |    ///
  294|       |    /// ```
  295|       |    ///     collectionView.rx.modelDeselected(MyModel.self)
  296|       |    ///        .map { ...
  297|       |    /// ```
  298|      0|    public func modelDeselected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  299|      0|        let source: Observable<T> = itemDeselected.flatMap { [weak view = self.base as UICollectionView] indexPath -> Observable<T> in
  300|      0|            guard let view = view else {
  301|      0|                return Observable.empty()
  302|      0|            }
  303|      0|
  304|      0|            return Observable.just(try view.rx.model(at: indexPath))
  305|      0|        }
  306|      0|
  307|      0|        return ControlEvent(events: source)
  308|      0|    }
  309|       |    
  310|       |    /// Synchronous helper method for retrieving a model at indexPath through a reactive data source
  311|       |    public func model<T>(at indexPath: IndexPath) throws -> T {
  312|       |        let dataSource: SectionedViewDataSourceType = castOrFatalError(self.dataSource.forwardToDelegate(), message: "This method only works in case one of the `rx.itemsWith*` methods was used.")
  313|       |        
  314|       |        let element = try dataSource.model(at: indexPath)
  315|       |
  316|       |        return try castOrThrow(T.self, element)
  317|       |    }
  318|       |}
  319|       |
  320|       |@available(iOS 10.0, tvOS 10.0, *)
  321|       |extension Reactive where Base: UICollectionView {
  322|       |
  323|       |    /// Reactive wrapper for `prefetchDataSource`.
  324|       |    ///
  325|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
  326|      0|    public var prefetchDataSource: DelegateProxy<UICollectionView, UICollectionViewDataSourcePrefetching> {
  327|      0|        return RxCollectionViewDataSourcePrefetchingProxy.proxy(for: base)
  328|      0|    }
  329|       |
  330|       |    /**
  331|       |     Installs prefetch data source as forwarding delegate on `rx.prefetchDataSource`.
  332|       |     Prefetch data source won't be retained.
  333|       |
  334|       |     It enables using normal delegate mechanism with reactive delegate mechanism.
  335|       |
  336|       |     - parameter prefetchDataSource: Prefetch data source object.
  337|       |     - returns: Disposable object that can be used to unbind the data source.
  338|       |     */
  339|       |    public func setPrefetchDataSource(_ prefetchDataSource: UICollectionViewDataSourcePrefetching)
  340|      0|        -> Disposable {
  341|      0|            return RxCollectionViewDataSourcePrefetchingProxy.installForwardDelegate(prefetchDataSource, retainDelegate: false, onProxyForObject: self.base)
  342|      0|    }
  343|       |
  344|       |    /// Reactive wrapper for `prefetchDataSource` message `collectionView(_:prefetchItemsAt:)`.
  345|      0|    public var prefetchItems: ControlEvent<[IndexPath]> {
  346|      0|        let source = RxCollectionViewDataSourcePrefetchingProxy.proxy(for: base).prefetchItemsPublishSubject
  347|      0|        return ControlEvent(events: source)
  348|      0|    }
  349|       |
  350|       |    /// Reactive wrapper for `prefetchDataSource` message `collectionView(_:cancelPrefetchingForItemsAt:)`.
  351|      0|    public var cancelPrefetchingForItems: ControlEvent<[IndexPath]> {
  352|      0|        let source = prefetchDataSource.methodInvoked(#selector(UICollectionViewDataSourcePrefetching.collectionView(_:cancelPrefetchingForItemsAt:)))
  353|      0|            .map { a in
  354|      0|                return try castOrThrow(Array<IndexPath>.self, a[1])
  355|      0|        }
  356|      0|
  357|      0|        return ControlEvent(events: source)
  358|      0|    }
  359|       |
  360|       |}
  361|       |#endif
  362|       |
  363|       |#if os(tvOS)
  364|       |
  365|       |extension Reactive where Base: UICollectionView {
  366|       |    
  367|       |    /// Reactive wrapper for `delegate` message `collectionView(_:didUpdateFocusInContext:withAnimationCoordinator:)`.
  368|       |    public var didUpdateFocusInContextWithAnimationCoordinator: ControlEvent<(context: UICollectionViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator)> {
  369|       |
  370|       |        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didUpdateFocusIn:with:)))
  371|       |            .map { a -> (context: UICollectionViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator) in
  372|       |                let context = try castOrThrow(UICollectionViewFocusUpdateContext.self, a[1])
  373|       |                let animationCoordinator = try castOrThrow(UIFocusAnimationCoordinator.self, a[2])
  374|       |                return (context: context, animationCoordinator: animationCoordinator)
  375|       |            }
  376|       |
  377|       |        return ControlEvent(events: source)
  378|       |    }
  379|       |}
  380|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIControl+Rx.swift:
    1|       |//
    2|       |//  UIControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |#if swift(>=4.2)
   15|       |    public typealias UIControlEvents = UIControl.Event
   16|       |#endif
   17|       |
   18|       |extension Reactive where Base: UIControl {
   19|       |    
   20|       |    /// Bindable sink for `enabled` property.
   21|      0|    public var isEnabled: Binder<Bool> {
   22|      0|        return Binder(self.base) { control, value in
   23|      0|            control.isEnabled = value
   24|      0|        }
   25|      0|    }
   26|       |
   27|       |    /// Bindable sink for `selected` property.
   28|      0|    public var isSelected: Binder<Bool> {
   29|      0|        return Binder(self.base) { control, selected in
   30|      0|            control.isSelected = selected
   31|      0|        }
   32|      0|    }
   33|       |
   34|       |    /// Reactive wrapper for target action pattern.
   35|       |    ///
   36|       |    /// - parameter controlEvents: Filter for observed event types.
   37|      0|    public func controlEvent(_ controlEvents: UIControlEvents) -> ControlEvent<()> {
   38|      0|        let source: Observable<Void> = Observable.create { [weak control = self.base] observer in
   39|      0|                MainScheduler.ensureRunningOnMainThread()
   40|      0|
   41|      0|                guard let control = control else {
   42|      0|                    observer.on(.completed)
   43|      0|                    return Disposables.create()
   44|      0|                }
   45|      0|
   46|      0|                let controlTarget = ControlTarget(control: control, controlEvents: controlEvents) { _ in
   47|      0|                    observer.on(.next(()))
   48|      0|                }
   49|      0|
   50|      0|                return Disposables.create(with: controlTarget.dispose)
   51|      0|            }
   52|      0|            .takeUntil(deallocated)
   53|      0|
   54|      0|        return ControlEvent(events: source)
   55|      0|    }
   56|       |
   57|       |    /// Creates a `ControlProperty` that is triggered by target/action pattern value updates.
   58|       |    ///
   59|       |    /// - parameter controlEvents: Events that trigger value update sequence elements.
   60|       |    /// - parameter getter: Property value getter.
   61|       |    /// - parameter setter: Property value setter.
   62|       |    public func controlProperty<T>(
   63|       |        editingEvents: UIControlEvents,
   64|       |        getter: @escaping (Base) -> T,
   65|       |        setter: @escaping (Base, T) -> Void
   66|      0|    ) -> ControlProperty<T> {
   67|      0|        let source: Observable<T> = Observable.create { [weak weakControl = base] observer in
   68|      0|                guard let control = weakControl else {
   69|      0|                    observer.on(.completed)
   70|      0|                    return Disposables.create()
   71|      0|                }
   72|      0|
   73|      0|                observer.on(.next(getter(control)))
   74|      0|
   75|      0|                let controlTarget = ControlTarget(control: control, controlEvents: editingEvents) { _ in
   76|      0|                    if let control = weakControl {
   77|      0|                        observer.on(.next(getter(control)))
   78|      0|                    }
   79|      0|                }
   80|      0|                
   81|      0|                return Disposables.create(with: controlTarget.dispose)
   82|      0|            }
   83|      0|            .takeUntil(deallocated)
   84|      0|
   85|      0|        let bindingObserver = Binder(base, binding: setter)
   86|      0|
   87|      0|        return ControlProperty<T>(values: source, valueSink: bindingObserver)
   88|      0|    }
   89|       |
   90|       |    /// This is a separate method to better communicate to public consumers that
   91|       |    /// an `editingEvent` needs to fire for control property to be updated.
   92|       |    internal func controlPropertyWithDefaultEvents<T>(
   93|       |        editingEvents: UIControlEvents = [.allEditingEvents, .valueChanged],
   94|       |        getter: @escaping (Base) -> T,
   95|       |        setter: @escaping (Base, T) -> Void
   96|      0|        ) -> ControlProperty<T> {
   97|      0|        return controlProperty(
   98|      0|            editingEvents: editingEvents,
   99|      0|            getter: getter,
  100|      0|            setter: setter
  101|      0|        )
  102|      0|    }
  103|       |}
  104|       |
  105|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIDatePicker+Rx.swift:
    1|       |//
    2|       |//  UIDatePicker+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UIDatePicker {
   15|       |    /// Reactive wrapper for `date` property.
   16|      0|    public var date: ControlProperty<Date> {
   17|      0|        return value
   18|      0|    }
   19|       |
   20|       |    /// Reactive wrapper for `date` property.
   21|       |    public var value: ControlProperty<Date> {
   22|       |        return base.rx.controlPropertyWithDefaultEvents(
   23|      0|            getter: { datePicker in
   24|      0|                datePicker.date
   25|      0|            }, setter: { datePicker, value in
   26|      0|                datePicker.date = value
   27|      0|            }
   28|       |        )
   29|       |    }
   30|       |
   31|       |    /// Reactive wrapper for `countDownDuration` property.
   32|      0|    public var countDownDuration: ControlProperty<TimeInterval> {
   33|      0|        return base.rx.controlPropertyWithDefaultEvents(
   34|      0|            getter: { datePicker in
   35|      0|                datePicker.countDownDuration
   36|      0|            }, setter: { datePicker, value in
   37|      0|                datePicker.countDownDuration = value
   38|      0|            }
   39|      0|        )
   40|      0|    }
   41|       |}
   42|       |
   43|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIGestureRecognizer+Rx.swift:
    1|       |//
    2|       |//  UIGestureRecognizer+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 10/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |// This should be only used from `MainScheduler`
   15|       |final class GestureTarget<Recognizer: UIGestureRecognizer>: RxTarget {
   16|       |    typealias Callback = (Recognizer) -> Void
   17|       |    
   18|       |    let selector = #selector(ControlTarget.eventHandler(_:))
   19|       |    
   20|       |    weak var gestureRecognizer: Recognizer?
   21|       |    var callback: Callback?
   22|       |    
   23|      0|    init(_ gestureRecognizer: Recognizer, callback: @escaping Callback) {
   24|      0|        self.gestureRecognizer = gestureRecognizer
   25|      0|        self.callback = callback
   26|      0|        
   27|      0|        super.init()
   28|      0|        
   29|      0|        gestureRecognizer.addTarget(self, action: selector)
   30|      0|
   31|      0|        let method = self.method(for: selector)
   32|      0|        if method == nil {
   33|      0|            fatalError("Can't find method")
   34|      0|        }
   35|      0|    }
   36|       |    
   37|      0|    @objc func eventHandler(_ sender: UIGestureRecognizer) {
   38|      0|        if let callback = self.callback, let gestureRecognizer = self.gestureRecognizer {
   39|      0|            callback(gestureRecognizer)
   40|      0|        }
   41|      0|    }
   42|       |    
   43|      0|    override func dispose() {
   44|      0|        super.dispose()
   45|      0|        
   46|      0|        self.gestureRecognizer?.removeTarget(self, action: self.selector)
   47|      0|        self.callback = nil
   48|      0|    }
   49|       |}
   50|       |
   51|       |extension Reactive where Base: UIGestureRecognizer {
   52|       |    
   53|       |    /// Reactive wrapper for gesture recognizer events.
   54|      0|    public var event: ControlEvent<Base> {
   55|      0|        let source: Observable<Base> = Observable.create { [weak control = self.base] observer in
   56|      0|            MainScheduler.ensureRunningOnMainThread()
   57|      0|
   58|      0|            guard let control = control else {
   59|      0|                observer.on(.completed)
   60|      0|                return Disposables.create()
   61|      0|            }
   62|      0|            
   63|      0|            let observer = GestureTarget(control) { control in
   64|      0|                observer.on(.next(control))
   65|      0|            }
   66|      0|            
   67|      0|            return observer
   68|      0|        }.takeUntil(deallocated)
   69|      0|        
   70|      0|        return ControlEvent(events: source)
   71|      0|    }
   72|       |    
   73|       |}
   74|       |
   75|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIImageView+Rx.swift:
    1|       |//
    2|       |//  UIImageView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UIImageView {
   15|       |    
   16|       |    /// Bindable sink for `image` property.
   17|      0|    public var image: Binder<UIImage?> {
   18|      0|        return Binder(base) { imageView, image in
   19|      0|            imageView.image = image
   20|      0|        }
   21|      0|    }
   22|       |}
   23|       |
   24|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UILabel+Rx.swift:
    1|       |//
    2|       |//  UILabel+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UILabel {
   15|       |    
   16|       |    /// Bindable sink for `text` property.
   17|      0|    public var text: Binder<String?> {
   18|      0|        return Binder(self.base) { label, text in
   19|      0|            label.text = text
   20|      0|        }
   21|      0|    }
   22|       |
   23|       |    /// Bindable sink for `attributedText` property.
   24|      0|    public var attributedText: Binder<NSAttributedString?> {
   25|      0|        return Binder(self.base) { label, text in
   26|      0|            label.attributedText = text
   27|      0|        }
   28|      0|    }
   29|       |    
   30|       |}
   31|       |
   32|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UINavigationController+Rx.swift:
    1|       |//
    2|       |//  UINavigationController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Diogo on 13/04/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UINavigationController {
   15|       |    public typealias ShowEvent = (viewController: UIViewController, animated: Bool)
   16|       |
   17|       |    /// Reactive wrapper for `delegate`.
   18|       |    ///
   19|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   20|      0|    public var delegate: DelegateProxy<UINavigationController, UINavigationControllerDelegate> {
   21|      0|        return RxNavigationControllerDelegateProxy.proxy(for: base)
   22|      0|    }
   23|       |
   24|       |    /// Reactive wrapper for delegate method `navigationController(:willShow:animated:)`.
   25|      0|    public var willShow: ControlEvent<ShowEvent> {
   26|      0|        let source: Observable<ShowEvent> = delegate
   27|      0|            .methodInvoked(#selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:)))
   28|      0|            .map { arg in
   29|      0|                let viewController = try castOrThrow(UIViewController.self, arg[1])
   30|      0|                let animated = try castOrThrow(Bool.self, arg[2])
   31|      0|                return (viewController, animated)
   32|      0|        }
   33|      0|        return ControlEvent(events: source)
   34|      0|    }
   35|       |
   36|       |    /// Reactive wrapper for delegate method `navigationController(:didShow:animated:)`.
   37|      0|    public var didShow: ControlEvent<ShowEvent> {
   38|      0|        let source: Observable<ShowEvent> = delegate
   39|      0|            .methodInvoked(#selector(UINavigationControllerDelegate.navigationController(_:didShow:animated:)))
   40|      0|            .map { arg in
   41|      0|                let viewController = try castOrThrow(UIViewController.self, arg[1])
   42|      0|                let animated = try castOrThrow(Bool.self, arg[2])
   43|      0|                return (viewController, animated)
   44|      0|        }
   45|      0|        return ControlEvent(events: source)
   46|      0|    }
   47|       |}
   48|       |
   49|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UINavigationItem+Rx.swift:
    1|       |//
    2|       |//  UINavigationItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by kumapo on 2016/05/09.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |import UIKit
   12|       |import RxSwift
   13|       |    
   14|       |extension Reactive where Base: UINavigationItem {
   15|       |    
   16|       |    /// Bindable sink for `title` property.
   17|      0|    public var title: Binder<String?> {
   18|      0|        return Binder(self.base) { navigationItem, text in
   19|      0|            navigationItem.title = text
   20|      0|        }
   21|      0|    }
   22|       |        
   23|       |}
   24|       |    
   25|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIPageControl+Rx.swift:
    1|       |//
    2|       |//  UIPageControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Francesco Puntillo on 14/04/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |    
   14|       |extension Reactive where Base: UIPageControl {
   15|       |    
   16|       |    /// Bindable sink for `currentPage` property.
   17|      0|    public var currentPage: Binder<Int> {
   18|      0|        return Binder(self.base) { controller, page in
   19|      0|            controller.currentPage = page
   20|      0|        }
   21|      0|    }
   22|       |    
   23|       |    /// Bindable sink for `numberOfPages` property.
   24|      0|    public var numberOfPages: Binder<Int> {
   25|      0|        return Binder(self.base) { controller, page in
   26|      0|            controller.numberOfPages = page
   27|      0|        }
   28|      0|    }
   29|       |    
   30|       |}
   31|       |    
   32|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIPickerView+Rx.swift:
    1|       |//
    2|       |//  UIPickerView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |    
   11|       |    import RxSwift
   12|       |    import UIKit
   13|       |
   14|       |    extension Reactive where Base: UIPickerView {
   15|       |
   16|       |        /// Reactive wrapper for `delegate`.
   17|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   18|      0|        public var delegate: DelegateProxy<UIPickerView, UIPickerViewDelegate> {
   19|      0|            return RxPickerViewDelegateProxy.proxy(for: base)
   20|      0|        }
   21|       |        
   22|       |        /// Installs delegate as forwarding delegate on `delegate`.
   23|       |        /// Delegate won't be retained.
   24|       |        ///
   25|       |        /// It enables using normal delegate mechanism with reactive delegate mechanism.
   26|       |        ///
   27|       |        /// - parameter delegate: Delegate object.
   28|       |        /// - returns: Disposable object that can be used to unbind the delegate.
   29|       |        public func setDelegate(_ delegate: UIPickerViewDelegate)
   30|      0|            -> Disposable {
   31|      0|                return RxPickerViewDelegateProxy.installForwardDelegate(delegate, retainDelegate: false, onProxyForObject: self.base)
   32|      0|        }
   33|       |        
   34|       |        /**
   35|       |         Reactive wrapper for `dataSource`.
   36|       |         
   37|       |         For more information take a look at `DelegateProxyType` protocol documentation.
   38|       |         */
   39|      0|        public var dataSource: DelegateProxy<UIPickerView, UIPickerViewDataSource> {
   40|      0|            return RxPickerViewDataSourceProxy.proxy(for: base)
   41|      0|        }
   42|       |        
   43|       |        /**
   44|       |         Reactive wrapper for `delegate` message `pickerView:didSelectRow:inComponent:`.
   45|       |         */
   46|      0|        public var itemSelected: ControlEvent<(row: Int, component: Int)> {
   47|      0|            let source = delegate
   48|      0|                .methodInvoked(#selector(UIPickerViewDelegate.pickerView(_:didSelectRow:inComponent:)))
   49|      0|                .map {
   50|      0|                    return (row: try castOrThrow(Int.self, $0[1]), component: try castOrThrow(Int.self, $0[2]))
   51|      0|                }
   52|      0|            return ControlEvent(events: source)
   53|      0|        }
   54|       |        
   55|       |        /**
   56|       |         Reactive wrapper for `delegate` message `pickerView:didSelectRow:inComponent:`.
   57|       |         
   58|       |         It can be only used when one of the `rx.itemTitles, rx.itemAttributedTitles, items(_ source: O)` methods is used to bind observable sequence,
   59|       |         or any other data source conforming to a `ViewDataSourceType` protocol.
   60|       |         
   61|       |         ```
   62|       |         pickerView.rx.modelSelected(MyModel.self)
   63|       |         .map { ...
   64|       |         ```
   65|       |         - parameter modelType: Type of a Model which bound to the dataSource
   66|       |         */
   67|      0|        public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<[T]> {
   68|      0|            let source = itemSelected.flatMap { [weak view = self.base as UIPickerView] _, component -> Observable<[T]> in
   69|      0|                guard let view = view else {
   70|      0|                    return Observable.empty()
   71|      0|                }
   72|      0|
   73|      0|                let model: [T] = try (0 ..< view.numberOfComponents).map { component in
   74|      0|                    let row = view.selectedRow(inComponent: component)
   75|      0|                    return try view.rx.model(at: IndexPath(row: row, section: component))
   76|      0|                }
   77|      0|
   78|      0|                return Observable.just(model)
   79|      0|            }
   80|      0|            
   81|      0|            return ControlEvent(events: source)
   82|      0|        }
   83|       |        
   84|       |        /**
   85|       |         Binds sequences of elements to picker view rows.
   86|       |         
   87|       |         - parameter source: Observable sequence of items.
   88|       |         - parameter titleForRow: Transform between sequence elements and row titles.
   89|       |         - returns: Disposable object that can be used to unbind.
   90|       |         
   91|       |         Example:
   92|       |         
   93|       |            let items = Observable.just([
   94|       |                    "First Item",
   95|       |                    "Second Item",
   96|       |                    "Third Item"
   97|       |                ])
   98|       |         
   99|       |            items
  100|       |                .bind(to: pickerView.rx.itemTitles) { (row, element) in
  101|       |                    return element.title
  102|       |                }
  103|       |                .disposed(by: disposeBag)
  104|       |         
  105|       |         */
  106|       |        
  107|       |        public func itemTitles<S: Sequence, O: ObservableType>
  108|       |            (_ source: O)
  109|       |            -> (_ titleForRow: @escaping (Int, S.Iterator.Element) -> String?)
  110|      0|            -> Disposable where O.E == S  {
  111|      0|                return { titleForRow in
  112|      0|                    let adapter = RxStringPickerViewAdapter<S>(titleForRow: titleForRow)
  113|      0|                    return self.items(adapter: adapter)(source)
  114|      0|                }
  115|      0|        }
  116|       |        
  117|       |        /**
  118|       |         Binds sequences of elements to picker view rows.
  119|       |         
  120|       |         - parameter source: Observable sequence of items.
  121|       |         - parameter attributedTitleForRow: Transform between sequence elements and row attributed titles.
  122|       |         - returns: Disposable object that can be used to unbind.
  123|       |         
  124|       |         Example:
  125|       |         
  126|       |         let items = Observable.just([
  127|       |                "First Item",
  128|       |                "Second Item",
  129|       |                "Third Item"
  130|       |            ])
  131|       |         
  132|       |         items
  133|       |            .bind(to: pickerView.rx.itemAttributedTitles) { (row, element) in
  134|       |                return NSAttributedString(string: element.title)
  135|       |            }
  136|       |            .disposed(by: disposeBag)
  137|       |        
  138|       |         */
  139|       |
  140|       |        public func itemAttributedTitles<S: Sequence, O: ObservableType>
  141|       |            (_ source: O)
  142|       |            -> (_ attributedTitleForRow: @escaping (Int, S.Iterator.Element) -> NSAttributedString?)
  143|      0|            -> Disposable where O.E == S  {
  144|      0|                return { attributedTitleForRow in
  145|      0|                    let adapter = RxAttributedStringPickerViewAdapter<S>(attributedTitleForRow: attributedTitleForRow)
  146|      0|                    return self.items(adapter: adapter)(source)
  147|      0|                }
  148|      0|        }
  149|       |        
  150|       |        /**
  151|       |         Binds sequences of elements to picker view rows.
  152|       |         
  153|       |         - parameter source: Observable sequence of items.
  154|       |         - parameter viewForRow: Transform between sequence elements and row views.
  155|       |         - returns: Disposable object that can be used to unbind.
  156|       |         
  157|       |         Example:
  158|       |         
  159|       |         let items = Observable.just([
  160|       |                "First Item",
  161|       |                "Second Item",
  162|       |                "Third Item"
  163|       |            ])
  164|       |         
  165|       |         items
  166|       |            .bind(to: pickerView.rx.items) { (row, element, view) in
  167|       |                guard let myView = view as? MyView else {
  168|       |                    let view = MyView()
  169|       |                    view.configure(with: element)
  170|       |                    return view
  171|       |                }
  172|       |                myView.configure(with: element)
  173|       |                return myView
  174|       |            }
  175|       |            .disposed(by: disposeBag)
  176|       |         
  177|       |         */
  178|       |
  179|       |        public func items<S: Sequence, O: ObservableType>
  180|       |            (_ source: O)
  181|       |            -> (_ viewForRow: @escaping (Int, S.Iterator.Element, UIView?) -> UIView)
  182|      0|            -> Disposable where O.E == S  {
  183|      0|                return { viewForRow in
  184|      0|                    let adapter = RxPickerViewAdapter<S>(viewForRow: viewForRow)
  185|      0|                    return self.items(adapter: adapter)(source)
  186|      0|                }
  187|      0|        }
  188|       |        
  189|       |        /**
  190|       |         Binds sequences of elements to picker view rows using a custom reactive adapter used to perform the transformation.
  191|       |         This method will retain the adapter for as long as the subscription isn't disposed (result `Disposable`
  192|       |         being disposed).
  193|       |         In case `source` observable sequence terminates successfully, the adapter will present latest element
  194|       |         until the subscription isn't disposed.
  195|       |         
  196|       |         - parameter adapter: Adapter used to transform elements to picker components.
  197|       |         - parameter source: Observable sequence of items.
  198|       |         - returns: Disposable object that can be used to unbind.
  199|       |         */
  200|       |        public func items<O: ObservableType,
  201|       |                          Adapter: RxPickerViewDataSourceType & UIPickerViewDataSource & UIPickerViewDelegate>(adapter: Adapter)
  202|       |            -> (_ source: O)
  203|       |            -> Disposable where O.E == Adapter.Element {
  204|      0|                return { source in
  205|      0|                    let delegateSubscription = self.setDelegate(adapter)
  206|      0|                    let dataSourceSubscription = source.subscribeProxyDataSource(ofObject: self.base, dataSource: adapter, retainDataSource: true, binding: { [weak pickerView = self.base] (_: RxPickerViewDataSourceProxy, event) in
  207|      0|                        guard let pickerView = pickerView else { return }
  208|      0|                        adapter.pickerView(pickerView, observedEvent: event)
  209|      0|                    })
  210|      0|                    return Disposables.create(delegateSubscription, dataSourceSubscription)
  211|      0|                }
  212|       |        }
  213|       |        
  214|       |        /**
  215|       |         Synchronous helper method for retrieving a model at indexPath through a reactive data source.
  216|       |         */
  217|       |        public func model<T>(at indexPath: IndexPath) throws -> T {
  218|       |            let dataSource: SectionedViewDataSourceType = castOrFatalError(self.dataSource.forwardToDelegate(), message: "This method only works in case one of the `rx.itemTitles, rx.itemAttributedTitles, items(_ source: O)` methods was used.")
  219|       |            
  220|       |            return castOrFatalError(try dataSource.model(at: indexPath))
  221|       |        }
  222|       |    }
  223|       |
  224|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIProgressView+Rx.swift:
    1|       |//
    2|       |//  UIProgressView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Samuel Bae on 2/27/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UIProgressView {
   15|       |
   16|       |    /// Bindable sink for `progress` property
   17|      0|    public var progress: Binder<Float> {
   18|      0|        return Binder(self.base) { progressView, progress in
   19|      0|            progressView.progress = progress
   20|      0|        }
   21|      0|    }
   22|       |
   23|       |}
   24|       |
   25|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIRefreshControl+Rx.swift:
    1|       |//
    2|       |//  UIRefreshControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yosuke Ishikawa on 1/31/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UIRefreshControl {
   15|       |    /// Bindable sink for `beginRefreshing()`, `endRefreshing()` methods.
   16|      0|    public var isRefreshing: Binder<Bool> {
   17|      0|        return Binder(self.base) { refreshControl, refresh in
   18|      0|            if refresh {
   19|      0|                refreshControl.beginRefreshing()
   20|      0|            } else {
   21|      0|                refreshControl.endRefreshing()
   22|      0|            }
   23|      0|        }
   24|      0|    }
   25|       |
   26|       |}
   27|       |
   28|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIScrollView+Rx.swift:
    1|       |//
    2|       |//  UIScrollView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/3/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |    import RxSwift
   12|       |    import UIKit
   13|       |
   14|       |    extension Reactive where Base: UIScrollView {
   15|       |        public typealias EndZoomEvent = (view: UIView?, scale: CGFloat)
   16|       |        public typealias WillEndDraggingEvent = (velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>)
   17|       |
   18|       |        /// Reactive wrapper for `delegate`.
   19|       |        ///
   20|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   21|      0|        public var delegate: DelegateProxy<UIScrollView, UIScrollViewDelegate> {
   22|      0|            return RxScrollViewDelegateProxy.proxy(for: base)
   23|      0|        }
   24|       |        
   25|       |        /// Reactive wrapper for `contentOffset`.
   26|      0|        public var contentOffset: ControlProperty<CGPoint> {
   27|      0|            let proxy = RxScrollViewDelegateProxy.proxy(for: base)
   28|      0|
   29|      0|            let bindingObserver = Binder(self.base) { scrollView, contentOffset in
   30|      0|                scrollView.contentOffset = contentOffset
   31|      0|            }
   32|      0|
   33|      0|            return ControlProperty(values: proxy.contentOffsetBehaviorSubject, valueSink: bindingObserver)
   34|      0|        }
   35|       |
   36|       |        /// Bindable sink for `scrollEnabled` property.
   37|      0|        public var isScrollEnabled: Binder<Bool> {
   38|      0|            return Binder(self.base) { scrollView, scrollEnabled in
   39|      0|                scrollView.isScrollEnabled = scrollEnabled
   40|      0|            }
   41|      0|        }
   42|       |
   43|       |        /// Reactive wrapper for delegate method `scrollViewDidScroll`
   44|      0|        public var didScroll: ControlEvent<Void> {
   45|      0|            let source = RxScrollViewDelegateProxy.proxy(for: base).contentOffsetPublishSubject
   46|      0|            return ControlEvent(events: source)
   47|      0|        }
   48|       |        
   49|       |        /// Reactive wrapper for delegate method `scrollViewWillBeginDecelerating`
   50|      0|        public var willBeginDecelerating: ControlEvent<Void> {
   51|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewWillBeginDecelerating(_:))).map { _ in }
   52|      0|            return ControlEvent(events: source)
   53|      0|        }
   54|       |    	
   55|       |    	/// Reactive wrapper for delegate method `scrollViewDidEndDecelerating`
   56|      0|    	public var didEndDecelerating: ControlEvent<Void> {
   57|      0|    		let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))).map { _ in }
   58|      0|    		return ControlEvent(events: source)
   59|      0|    	}
   60|       |    	
   61|       |        /// Reactive wrapper for delegate method `scrollViewWillBeginDragging`
   62|      0|        public var willBeginDragging: ControlEvent<Void> {
   63|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewWillBeginDragging(_:))).map { _ in }
   64|      0|            return ControlEvent(events: source)
   65|      0|        }
   66|       |        
   67|       |        /// Reactive wrapper for delegate method `scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)`
   68|      0|        public var willEndDragging: ControlEvent<WillEndDraggingEvent> {
   69|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)))
   70|      0|                .map { value -> WillEndDraggingEvent in
   71|      0|                    let velocity = try castOrThrow(CGPoint.self, value[1])
   72|      0|                    let targetContentOffsetValue = try castOrThrow(NSValue.self, value[2])
   73|      0|
   74|      0|                    guard let rawPointer = targetContentOffsetValue.pointerValue else { throw RxCocoaError.unknown }
   75|      0|                    let typedPointer = rawPointer.bindMemory(to: CGPoint.self, capacity: MemoryLayout<CGPoint>.size)
   76|      0|
   77|      0|                    return (velocity, typedPointer)
   78|      0|            }
   79|      0|            return ControlEvent(events: source)
   80|      0|        }
   81|       |        
   82|       |    	/// Reactive wrapper for delegate method `scrollViewDidEndDragging(_:willDecelerate:)`
   83|      0|        public var didEndDragging: ControlEvent<Bool> {
   84|      0|    		let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))).map { value -> Bool in
   85|      0|    			return try castOrThrow(Bool.self, value[1])
   86|      0|    		}
   87|      0|    		return ControlEvent(events: source)
   88|      0|    	}
   89|       |
   90|       |        /// Reactive wrapper for delegate method `scrollViewDidZoom`
   91|      0|        public var didZoom: ControlEvent<Void> {
   92|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidZoom)).map { _ in }
   93|      0|            return ControlEvent(events: source)
   94|      0|        }
   95|       |
   96|       |
   97|       |        /// Reactive wrapper for delegate method `scrollViewDidScrollToTop`
   98|      0|        public var didScrollToTop: ControlEvent<Void> {
   99|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))).map { _ in }
  100|      0|            return ControlEvent(events: source)
  101|      0|        }
  102|       |        
  103|       |        /// Reactive wrapper for delegate method `scrollViewDidEndScrollingAnimation`
  104|      0|        public var didEndScrollingAnimation: ControlEvent<Void> {
  105|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:))).map { _ in }
  106|      0|            return ControlEvent(events: source)
  107|      0|        }
  108|       |        
  109|       |        /// Reactive wrapper for delegate method `scrollViewWillBeginZooming(_:with:)`
  110|      0|        public var willBeginZooming: ControlEvent<UIView?> {
  111|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewWillBeginZooming(_:with:))).map { value -> UIView? in
  112|      0|                return try castOptionalOrThrow(UIView.self, value[1] as AnyObject)
  113|      0|            }
  114|      0|            return ControlEvent(events: source)
  115|      0|        }
  116|       |        
  117|       |        /// Reactive wrapper for delegate method `scrollViewDidEndZooming(_:with:atScale:)`
  118|      0|        public var didEndZooming: ControlEvent<EndZoomEvent> {
  119|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndZooming(_:with:atScale:))).map { value -> EndZoomEvent in
  120|      0|                return (try castOptionalOrThrow(UIView.self, value[1] as AnyObject), try castOrThrow(CGFloat.self, value[2]))
  121|      0|            }
  122|      0|            return ControlEvent(events: source)
  123|      0|        }
  124|       |
  125|       |        /// Installs delegate as forwarding delegate on `delegate`.
  126|       |        /// Delegate won't be retained.
  127|       |        ///
  128|       |        /// It enables using normal delegate mechanism with reactive delegate mechanism.
  129|       |        ///
  130|       |        /// - parameter delegate: Delegate object.
  131|       |        /// - returns: Disposable object that can be used to unbind the delegate.
  132|       |        public func setDelegate(_ delegate: UIScrollViewDelegate)
  133|      0|            -> Disposable {
  134|      0|            return RxScrollViewDelegateProxy.installForwardDelegate(delegate, retainDelegate: false, onProxyForObject: self.base)
  135|      0|        }
  136|       |    }
  137|       |
  138|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UISearchBar+Rx.swift:
    1|       |//
    2|       |//  UISearchBar+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UISearchBar {
   15|       |
   16|       |    /// Reactive wrapper for `delegate`.
   17|       |    ///
   18|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   19|      0|    public var delegate: DelegateProxy<UISearchBar, UISearchBarDelegate> {
   20|      0|        return RxSearchBarDelegateProxy.proxy(for: base)
   21|      0|    }
   22|       |
   23|       |    /// Reactive wrapper for `text` property.
   24|      0|    public var text: ControlProperty<String?> {
   25|      0|        return value
   26|      0|    }
   27|       |    
   28|       |    /// Reactive wrapper for `text` property.
   29|       |    public var value: ControlProperty<String?> {
   30|      0|        let source: Observable<String?> = Observable.deferred { [weak searchBar = self.base as UISearchBar] () -> Observable<String?> in
   31|      0|            let text = searchBar?.text
   32|      0|
   33|      0|            let textDidChange = (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty())
   34|      0|            let didEndEditing = (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:))) ?? Observable.empty())
   35|      0|            
   36|      0|            return Observable.merge(textDidChange, didEndEditing)
   37|      0|                    .map { _ in searchBar?.text ?? "" }
   38|      0|                    .startWith(text)
   39|      0|        }
   40|       |
   41|      0|        let bindingObserver = Binder(self.base) { (searchBar, text: String?) in
   42|      0|            searchBar.text = text
   43|      0|        }
   44|       |        
   45|       |        return ControlProperty(values: source, valueSink: bindingObserver)
   46|       |    }
   47|       |    
   48|       |    /// Reactive wrapper for `selectedScopeButtonIndex` property.
   49|      0|    public var selectedScopeButtonIndex: ControlProperty<Int> {
   50|      0|        let source: Observable<Int> = Observable.deferred { [weak source = self.base as UISearchBar] () -> Observable<Int> in
   51|      0|            let index = source?.selectedScopeButtonIndex ?? 0
   52|      0|            
   53|      0|            return (source?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:))) ?? Observable.empty())
   54|      0|                .map { a in
   55|      0|                    return try castOrThrow(Int.self, a[1])
   56|      0|                }
   57|      0|                .startWith(index)
   58|      0|        }
   59|      0|        
   60|      0|        let bindingObserver = Binder(self.base) { (searchBar, index: Int) in
   61|      0|            searchBar.selectedScopeButtonIndex = index
   62|      0|        }
   63|      0|        
   64|      0|        return ControlProperty(values: source, valueSink: bindingObserver)
   65|      0|    }
   66|       |    
   67|       |#if os(iOS)
   68|       |    /// Reactive wrapper for delegate method `searchBarCancelButtonClicked`.
   69|      0|    public var cancelButtonClicked: ControlEvent<Void> {
   70|      0|        let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:)))
   71|      0|            .map { _ in
   72|      0|                return ()
   73|      0|            }
   74|      0|        return ControlEvent(events: source)
   75|      0|    }
   76|       |
   77|       |	/// Reactive wrapper for delegate method `searchBarBookmarkButtonClicked`.
   78|      0|	public var bookmarkButtonClicked: ControlEvent<Void> {
   79|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:)))
   80|      0|			.map { _ in
   81|      0|				return ()
   82|      0|			}
   83|      0|		return ControlEvent(events: source)
   84|      0|	}
   85|       |
   86|       |	/// Reactive wrapper for delegate method `searchBarResultsListButtonClicked`.
   87|      0|	public var resultsListButtonClicked: ControlEvent<Void> {
   88|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:)))
   89|      0|			.map { _ in
   90|      0|				return ()
   91|      0|		}
   92|      0|		return ControlEvent(events: source)
   93|      0|	}
   94|       |#endif
   95|       |	
   96|       |    /// Reactive wrapper for delegate method `searchBarSearchButtonClicked`.
   97|      0|    public var searchButtonClicked: ControlEvent<Void> {
   98|      0|        let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:)))
   99|      0|            .map { _ in
  100|      0|                return ()
  101|      0|        }
  102|      0|        return ControlEvent(events: source)
  103|      0|    }
  104|       |	
  105|       |	/// Reactive wrapper for delegate method `searchBarTextDidBeginEditing`.
  106|      0|	public var textDidBeginEditing: ControlEvent<Void> {
  107|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:)))
  108|      0|			.map { _ in
  109|      0|				return ()
  110|      0|		}
  111|      0|		return ControlEvent(events: source)
  112|      0|	}
  113|       |	
  114|       |	/// Reactive wrapper for delegate method `searchBarTextDidEndEditing`.
  115|      0|	public var textDidEndEditing: ControlEvent<Void> {
  116|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:)))
  117|      0|			.map { _ in
  118|      0|				return ()
  119|      0|		}
  120|      0|		return ControlEvent(events: source)
  121|      0|	}
  122|       |  
  123|       |    /// Installs delegate as forwarding delegate on `delegate`.
  124|       |    /// Delegate won't be retained.
  125|       |    ///
  126|       |    /// It enables using normal delegate mechanism with reactive delegate mechanism.
  127|       |    ///
  128|       |    /// - parameter delegate: Delegate object.
  129|       |    /// - returns: Disposable object that can be used to unbind the delegate.
  130|       |    public func setDelegate(_ delegate: UISearchBarDelegate)
  131|      0|        -> Disposable {
  132|      0|        return RxSearchBarDelegateProxy.installForwardDelegate(delegate, retainDelegate: false, onProxyForObject: self.base)
  133|      0|    }
  134|       |}
  135|       |
  136|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UISearchController+Rx.swift:
    1|       |//
    2|       |//  UISearchController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 3/17/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |    
   11|       |    import RxSwift
   12|       |    import UIKit
   13|       |    
   14|       |    @available(iOS 8.0, *)
   15|       |    extension Reactive where Base: UISearchController {
   16|       |        /// Reactive wrapper for `delegate`.
   17|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   18|      0|        public var delegate: DelegateProxy<UISearchController, UISearchControllerDelegate> {
   19|      0|            return RxSearchControllerDelegateProxy.proxy(for: base)
   20|      0|        }
   21|       |
   22|       |        /// Reactive wrapper for `delegate` message.
   23|      0|        public var didDismiss: Observable<Void> {
   24|      0|            return delegate
   25|      0|                .methodInvoked( #selector(UISearchControllerDelegate.didDismissSearchController(_:)))
   26|      0|                .map { _ in }
   27|      0|        }
   28|       |
   29|       |        /// Reactive wrapper for `delegate` message.
   30|      0|        public var didPresent: Observable<Void> {
   31|      0|            return delegate
   32|      0|                .methodInvoked(#selector(UISearchControllerDelegate.didPresentSearchController(_:)))
   33|      0|                .map { _ in }
   34|      0|        }
   35|       |
   36|       |        /// Reactive wrapper for `delegate` message.
   37|      0|        public var present: Observable<Void> {
   38|      0|            return delegate
   39|      0|                .methodInvoked( #selector(UISearchControllerDelegate.presentSearchController(_:)))
   40|      0|                .map { _ in }
   41|      0|        }
   42|       |
   43|       |        /// Reactive wrapper for `delegate` message.
   44|      0|        public var willDismiss: Observable<Void> {
   45|      0|            return delegate
   46|      0|                .methodInvoked(#selector(UISearchControllerDelegate.willDismissSearchController(_:)))
   47|      0|                .map { _ in }
   48|      0|        }
   49|       |        
   50|       |        /// Reactive wrapper for `delegate` message.
   51|      0|        public var willPresent: Observable<Void> {
   52|      0|            return delegate
   53|      0|                .methodInvoked( #selector(UISearchControllerDelegate.willPresentSearchController(_:)))
   54|      0|                .map { _ in }
   55|      0|        }
   56|       |        
   57|       |    }
   58|       |    
   59|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UISegmentedControl+Rx.swift:
    1|       |//
    2|       |//  UISegmentedControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 8/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UISegmentedControl {
   15|       |    /// Reactive wrapper for `selectedSegmentIndex` property.
   16|      0|    public var selectedSegmentIndex: ControlProperty<Int> {
   17|      0|        return value
   18|      0|    }
   19|       |    
   20|       |    /// Reactive wrapper for `selectedSegmentIndex` property.
   21|       |    public var value: ControlProperty<Int> {
   22|       |        return base.rx.controlPropertyWithDefaultEvents(
   23|      0|            getter: { segmentedControl in
   24|      0|                segmentedControl.selectedSegmentIndex
   25|      0|            }, setter: { segmentedControl, value in
   26|      0|                segmentedControl.selectedSegmentIndex = value
   27|      0|            }
   28|       |        )
   29|       |    }
   30|       |    
   31|       |    /// Reactive wrapper for `setEnabled(_:forSegmentAt:)`
   32|      0|    public func enabledForSegment(at index: Int) -> Binder<Bool> {
   33|      0|        return Binder(self.base) { segmentedControl, segmentEnabled -> Void in
   34|      0|            segmentedControl.setEnabled(segmentEnabled, forSegmentAt: index)
   35|      0|        }
   36|      0|    }
   37|       |    
   38|       |    /// Reactive wrapper for `setTitle(_:forSegmentAt:)`
   39|      0|    public func titleForSegment(at index: Int) -> Binder<String?> {
   40|      0|        return Binder(self.base) { segmentedControl, title -> Void in
   41|      0|            segmentedControl.setTitle(title, forSegmentAt: index)
   42|      0|        }
   43|      0|    }
   44|       |    
   45|       |    /// Reactive wrapper for `setImage(_:forSegmentAt:)`
   46|      0|    public func imageForSegment(at index: Int) -> Binder<UIImage?> {
   47|      0|        return Binder(self.base) { segmentedControl, image -> Void in
   48|      0|            segmentedControl.setImage(image, forSegmentAt: index)
   49|      0|        }
   50|      0|    }
   51|       |
   52|       |}
   53|       |
   54|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UISlider+Rx.swift:
    1|       |//
    2|       |//  UISlider+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Alexander van der Werff on 28/05/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UISlider {
   15|       |    
   16|       |    /// Reactive wrapper for `value` property.
   17|      0|    public var value: ControlProperty<Float> {
   18|      0|        return base.rx.controlPropertyWithDefaultEvents(
   19|      0|            getter: { slider in
   20|      0|                slider.value
   21|      0|            }, setter: { slider, value in
   22|      0|                slider.value = value
   23|      0|            }
   24|      0|        )
   25|      0|    }
   26|       |    
   27|       |}
   28|       |
   29|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIStepper+Rx.swift:
    1|       |//
    2|       |//  UIStepper+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 9/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UIStepper {
   15|       |    
   16|       |    /// Reactive wrapper for `value` property.
   17|      0|    public var value: ControlProperty<Double> {
   18|      0|        return base.rx.controlPropertyWithDefaultEvents(
   19|      0|            getter: { stepper in
   20|      0|                stepper.value
   21|      0|            }, setter: { stepper, value in
   22|      0|                stepper.value = value
   23|      0|            }
   24|      0|        )
   25|      0|    }
   26|       |
   27|       |    /// Reactive wrapper for `stepValue` property.
   28|      0|    public var stepValue: Binder<Double> {
   29|      0|        return Binder(self.base) { stepper, value in
   30|      0|            stepper.stepValue = value
   31|      0|        }
   32|      0|    }
   33|       |    
   34|       |}
   35|       |
   36|       |#endif
   37|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UISwitch+Rx.swift:
    1|       |//
    2|       |//  UISwitch+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 8/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UISwitch {
   15|       |
   16|       |    /// Reactive wrapper for `isOn` property.
   17|      0|    public var isOn: ControlProperty<Bool> {
   18|      0|        return value
   19|      0|    }
   20|       |
   21|       |    /// Reactive wrapper for `isOn` property.
   22|       |    ///
   23|       |    /// ⚠️ Versions prior to iOS 10.2 were leaking `UISwitch`'s, so on those versions
   24|       |    /// underlying observable sequence won't complete when nothing holds a strong reference
   25|       |    /// to `UISwitch`.
   26|       |    public var value: ControlProperty<Bool> {
   27|       |        return base.rx.controlPropertyWithDefaultEvents(
   28|      0|            getter: { uiSwitch in
   29|      0|                uiSwitch.isOn
   30|      0|            }, setter: { uiSwitch, value in
   31|      0|                uiSwitch.isOn = value
   32|      0|            }
   33|       |        )
   34|       |    }
   35|       |    
   36|       |}
   37|       |
   38|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBar+Rx.swift:
    1|       |//
    2|       |//  UITabBar+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Jesse Farless on 5/13/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |/**
   15|       | iOS only
   16|       | */
   17|       |#if os(iOS)
   18|       |extension Reactive where Base: UITabBar {
   19|       |
   20|       |    /// Reactive wrapper for `delegate` message `tabBar(_:willBeginCustomizing:)`.
   21|      0|    public var willBeginCustomizing: ControlEvent<[UITabBarItem]> {
   22|      0|        
   23|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:)))
   24|      0|            .map { a in
   25|      0|                return try castOrThrow([UITabBarItem].self, a[1])
   26|      0|            }
   27|      0|
   28|      0|        return ControlEvent(events: source)
   29|      0|    }
   30|       |
   31|       |    /// Reactive wrapper for `delegate` message `tabBar(_:didBeginCustomizing:)`.
   32|      0|    public var didBeginCustomizing: ControlEvent<[UITabBarItem]> {
   33|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:)))
   34|      0|            .map { a in
   35|      0|                return try castOrThrow([UITabBarItem].self, a[1])
   36|      0|            }
   37|      0|
   38|      0|        return ControlEvent(events: source)
   39|      0|    }
   40|       |
   41|       |    /// Reactive wrapper for `delegate` message `tabBar(_:willEndCustomizing:changed:)`.
   42|      0|    public var willEndCustomizing: ControlEvent<([UITabBarItem], Bool)> {
   43|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:)))
   44|      0|            .map { (a: [Any]) -> (([UITabBarItem], Bool)) in
   45|      0|                let items = try castOrThrow([UITabBarItem].self, a[1])
   46|      0|                let changed = try castOrThrow(Bool.self, a[2])
   47|      0|                return (items, changed)
   48|      0|            }
   49|      0|
   50|      0|        return ControlEvent(events: source)
   51|      0|    }
   52|       |
   53|       |    /// Reactive wrapper for `delegate` message `tabBar(_:didEndCustomizing:changed:)`.
   54|      0|    public var didEndCustomizing: ControlEvent<([UITabBarItem], Bool)> {
   55|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:)))
   56|      0|            .map { (a: [Any]) -> (([UITabBarItem], Bool)) in
   57|      0|                let items = try castOrThrow([UITabBarItem].self, a[1])
   58|      0|                let changed = try castOrThrow(Bool.self, a[2])
   59|      0|                return (items, changed)
   60|      0|            }
   61|      0|
   62|      0|        return ControlEvent(events: source)
   63|      0|    }
   64|       |
   65|       |}
   66|       |#endif
   67|       |
   68|       |/**
   69|       | iOS and tvOS
   70|       | */
   71|       |    
   72|       |extension Reactive where Base: UITabBar {
   73|       |    /// Reactive wrapper for `delegate`.
   74|       |    ///
   75|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   76|       |    public var delegate: DelegateProxy<UITabBar, UITabBarDelegate> {
   77|       |        return RxTabBarDelegateProxy.proxy(for: base)
   78|       |    }
   79|       |
   80|       |    /// Reactive wrapper for `delegate` message `tabBar(_:didSelect:)`.
   81|      0|    public var didSelectItem: ControlEvent<UITabBarItem> {
   82|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didSelect:)))
   83|      0|            .map { a in
   84|      0|                return try castOrThrow(UITabBarItem.self, a[1])
   85|      0|            }
   86|      0|
   87|      0|        return ControlEvent(events: source)
   88|      0|    }
   89|       |
   90|       |}
   91|       |
   92|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBarController+Rx.swift:
    1|       |//
    2|       |//  UITabBarController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yusuke Kita on 2016/12/07.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |    
   14|       |/**
   15|       | iOS only
   16|       | */
   17|       |#if os(iOS)
   18|       |extension Reactive where Base: UITabBarController {
   19|       |    
   20|       |    /// Reactive wrapper for `delegate` message `tabBarController:willBeginCustomizing:`.
   21|      0|    public var willBeginCustomizing: ControlEvent<[UIViewController]> {
   22|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:)))
   23|      0|            .map { a in
   24|      0|                return try castOrThrow([UIViewController].self, a[1])
   25|      0|        }
   26|      0|        
   27|      0|        return ControlEvent(events: source)
   28|      0|    }
   29|       |    
   30|       |    /// Reactive wrapper for `delegate` message `tabBarController:willEndCustomizing:changed:`.
   31|      0|    public var willEndCustomizing: ControlEvent<(viewControllers: [UIViewController], changed: Bool)> {
   32|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:)))
   33|      0|            .map { (a: [Any]) -> (viewControllers: [UIViewController], changed: Bool) in
   34|      0|                let viewControllers = try castOrThrow([UIViewController].self, a[1])
   35|      0|                let changed = try castOrThrow(Bool.self, a[2])
   36|      0|                return (viewControllers, changed)
   37|      0|        }
   38|      0|        
   39|      0|        return ControlEvent(events: source)
   40|      0|    }
   41|       |    
   42|       |    /// Reactive wrapper for `delegate` message `tabBarController:didEndCustomizing:changed:`.
   43|      0|    public var didEndCustomizing: ControlEvent<(viewControllers: [UIViewController], changed: Bool)> {
   44|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:)))
   45|      0|            .map { (a: [Any]) -> (viewControllers: [UIViewController], changed: Bool) in
   46|      0|                let viewControllers = try castOrThrow([UIViewController].self, a[1])
   47|      0|                let changed = try castOrThrow(Bool.self, a[2])
   48|      0|                return (viewControllers, changed)
   49|      0|        }
   50|      0|        
   51|      0|        return ControlEvent(events: source)
   52|      0|    }
   53|       |}
   54|       |#endif
   55|       |    
   56|       |/**
   57|       | iOS and tvOS
   58|       | */
   59|       |
   60|       |    extension Reactive where Base: UITabBarController {
   61|       |    /// Reactive wrapper for `delegate`.
   62|       |    ///
   63|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   64|       |    public var delegate: DelegateProxy<UITabBarController, UITabBarControllerDelegate> {
   65|       |        return RxTabBarControllerDelegateProxy.proxy(for: base)
   66|       |    }
   67|       |    
   68|       |    /// Reactive wrapper for `delegate` message `tabBarController:didSelect:`.
   69|      0|    public var didSelect: ControlEvent<UIViewController> {
   70|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didSelect:)))
   71|      0|            .map { a in
   72|      0|                return try castOrThrow(UIViewController.self, a[1])
   73|      0|        }
   74|      0|        
   75|      0|        return ControlEvent(events: source)
   76|      0|    }
   77|       |}
   78|       |
   79|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBarItem+Rx.swift:
    1|       |//
    2|       |//  UITabBarItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Mateusz Derks on 04/03/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |import UIKit
   12|       |import RxSwift
   13|       |    
   14|       |extension Reactive where Base: UITabBarItem {
   15|       |    
   16|       |    /// Bindable sink for `badgeValue` property.
   17|      0|    public var badgeValue: Binder<String?> {
   18|      0|        return Binder(self.base) { tabBarItem, badgeValue in
   19|      0|            tabBarItem.badgeValue = badgeValue
   20|      0|        }
   21|      0|    }
   22|       |    
   23|       |}
   24|       |    
   25|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITableView+Rx.swift:
    1|       |//
    2|       |//  UITableView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |#if swift(>=4.2)
   15|       |    public typealias UITableViewCellEditingStyle = UITableViewCell.EditingStyle
   16|       |#endif
   17|       |
   18|       |// Items
   19|       |
   20|       |extension Reactive where Base: UITableView {
   21|       |
   22|       |    /**
   23|       |    Binds sequences of elements to table view rows.
   24|       |    
   25|       |    - parameter source: Observable sequence of items.
   26|       |    - parameter cellFactory: Transform between sequence elements and view cells.
   27|       |    - returns: Disposable object that can be used to unbind.
   28|       |     
   29|       |     Example:
   30|       |    
   31|       |         let items = Observable.just([
   32|       |             "First Item",
   33|       |             "Second Item",
   34|       |             "Third Item"
   35|       |         ])
   36|       |
   37|       |         items
   38|       |         .bind(to: tableView.rx.items) { (tableView, row, element) in
   39|       |             let cell = tableView.dequeueReusableCell(withIdentifier: "Cell")!
   40|       |             cell.textLabel?.text = "\(element) @ row \(row)"
   41|       |             return cell
   42|       |         }
   43|       |         .disposed(by: disposeBag)
   44|       |
   45|       |     */
   46|       |    public func items<S: Sequence, O: ObservableType>
   47|       |        (_ source: O)
   48|       |        -> (_ cellFactory: @escaping (UITableView, Int, S.Iterator.Element) -> UITableViewCell)
   49|       |        -> Disposable
   50|      0|        where O.E == S {
   51|      0|            return { cellFactory in
   52|      0|                let dataSource = RxTableViewReactiveArrayDataSourceSequenceWrapper<S>(cellFactory: cellFactory)
   53|      0|                return self.items(dataSource: dataSource)(source)
   54|      0|            }
   55|      0|    }
   56|       |
   57|       |    /**
   58|       |    Binds sequences of elements to table view rows.
   59|       |    
   60|       |    - parameter cellIdentifier: Identifier used to dequeue cells.
   61|       |    - parameter source: Observable sequence of items.
   62|       |    - parameter configureCell: Transform between sequence elements and view cells.
   63|       |    - parameter cellType: Type of table view cell.
   64|       |    - returns: Disposable object that can be used to unbind.
   65|       |     
   66|       |     Example:
   67|       |
   68|       |         let items = Observable.just([
   69|       |             "First Item",
   70|       |             "Second Item",
   71|       |             "Third Item"
   72|       |         ])
   73|       |
   74|       |         items
   75|       |             .bind(to: tableView.rx.items(cellIdentifier: "Cell", cellType: UITableViewCell.self)) { (row, element, cell) in
   76|       |                cell.textLabel?.text = "\(element) @ row \(row)"
   77|       |             }
   78|       |             .disposed(by: disposeBag)
   79|       |    */
   80|       |    public func items<S: Sequence, Cell: UITableViewCell, O : ObservableType>
   81|       |        (cellIdentifier: String, cellType: Cell.Type = Cell.self)
   82|       |        -> (_ source: O)
   83|       |        -> (_ configureCell: @escaping (Int, S.Iterator.Element, Cell) -> Void)
   84|       |        -> Disposable
   85|      0|        where O.E == S {
   86|      0|        return { source in
   87|      0|            return { configureCell in
   88|      0|                let dataSource = RxTableViewReactiveArrayDataSourceSequenceWrapper<S> { tv, i, item in
   89|      0|                    let indexPath = IndexPath(item: i, section: 0)
   90|      0|                    let cell = tv.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! Cell
   91|      0|                    configureCell(i, item, cell)
   92|      0|                    return cell
   93|      0|                }
   94|      0|                return self.items(dataSource: dataSource)(source)
   95|      0|            }
   96|      0|        }
   97|      0|    }
   98|       |
   99|       |
  100|       |    /**
  101|       |    Binds sequences of elements to table view rows using a custom reactive data used to perform the transformation.
  102|       |    This method will retain the data source for as long as the subscription isn't disposed (result `Disposable` 
  103|       |    being disposed).
  104|       |    In case `source` observable sequence terminates successfully, the data source will present latest element
  105|       |    until the subscription isn't disposed.
  106|       |    
  107|       |    - parameter dataSource: Data source used to transform elements to view cells.
  108|       |    - parameter source: Observable sequence of items.
  109|       |    - returns: Disposable object that can be used to unbind.
  110|       |    */
  111|       |    public func items<
  112|       |            DataSource: RxTableViewDataSourceType & UITableViewDataSource,
  113|       |            O: ObservableType>
  114|       |        (dataSource: DataSource)
  115|       |        -> (_ source: O)
  116|       |        -> Disposable
  117|       |        where DataSource.Element == O.E {
  118|      0|        return { source in
  119|      0|            // This is called for sideeffects only, and to make sure delegate proxy is in place when
  120|      0|            // data source is being bound.
  121|      0|            // This is needed because theoretically the data source subscription itself might
  122|      0|            // call `self.rx.delegate`. If that happens, it might cause weird side effects since
  123|      0|            // setting data source will set delegate, and UITableView might get into a weird state.
  124|      0|            // Therefore it's better to set delegate proxy first, just to be sure.
  125|      0|            _ = self.delegate
  126|      0|            // Strong reference is needed because data source is in use until result subscription is disposed
  127|      0|            return source.subscribeProxyDataSource(ofObject: self.base, dataSource: dataSource as UITableViewDataSource, retainDataSource: true) { [weak tableView = self.base] (_: RxTableViewDataSourceProxy, event) -> Void in
  128|      0|                guard let tableView = tableView else {
  129|      0|                    return
  130|      0|                }
  131|      0|                dataSource.tableView(tableView, observedEvent: event)
  132|      0|            }
  133|      0|        }
  134|       |    }
  135|       |
  136|       |}
  137|       |
  138|       |extension Reactive where Base: UITableView {
  139|       |    /**
  140|       |    Reactive wrapper for `dataSource`.
  141|       |    
  142|       |    For more information take a look at `DelegateProxyType` protocol documentation.
  143|       |    */
  144|      0|    public var dataSource: DelegateProxy<UITableView, UITableViewDataSource> {
  145|      0|        return RxTableViewDataSourceProxy.proxy(for: base)
  146|      0|    }
  147|       |   
  148|       |    /**
  149|       |    Installs data source as forwarding delegate on `rx.dataSource`.
  150|       |    Data source won't be retained.
  151|       |    
  152|       |    It enables using normal delegate mechanism with reactive delegate mechanism.
  153|       |     
  154|       |    - parameter dataSource: Data source object.
  155|       |    - returns: Disposable object that can be used to unbind the data source.
  156|       |    */
  157|       |    public func setDataSource(_ dataSource: UITableViewDataSource)
  158|      0|        -> Disposable {
  159|      0|        return RxTableViewDataSourceProxy.installForwardDelegate(dataSource, retainDelegate: false, onProxyForObject: self.base)
  160|      0|    }
  161|       |    
  162|       |    // events
  163|       |    
  164|       |    /**
  165|       |    Reactive wrapper for `delegate` message `tableView:didSelectRowAtIndexPath:`.
  166|       |    */
  167|      0|    public var itemSelected: ControlEvent<IndexPath> {
  168|      0|        let source = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))
  169|      0|            .map { a in
  170|      0|                return try castOrThrow(IndexPath.self, a[1])
  171|      0|            }
  172|      0|
  173|      0|        return ControlEvent(events: source)
  174|      0|    }
  175|       |
  176|       |    /**
  177|       |     Reactive wrapper for `delegate` message `tableView:didDeselectRowAtIndexPath:`.
  178|       |     */
  179|      0|    public var itemDeselected: ControlEvent<IndexPath> {
  180|      0|        let source = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didDeselectRowAt:)))
  181|      0|            .map { a in
  182|      0|                return try castOrThrow(IndexPath.self, a[1])
  183|      0|            }
  184|      0|
  185|      0|        return ControlEvent(events: source)
  186|      0|    }
  187|       |
  188|       |    /**
  189|       |     Reactive wrapper for `delegate` message `tableView:accessoryButtonTappedForRowWithIndexPath:`.
  190|       |     */
  191|      0|    public var itemAccessoryButtonTapped: ControlEvent<IndexPath> {
  192|      0|        let source: Observable<IndexPath> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:)))
  193|      0|            .map { a in
  194|      0|                return try castOrThrow(IndexPath.self, a[1])
  195|      0|            }
  196|      0|        
  197|      0|        return ControlEvent(events: source)
  198|      0|    }
  199|       |    
  200|       |    /**
  201|       |    Reactive wrapper for `delegate` message `tableView:commitEditingStyle:forRowAtIndexPath:`.
  202|       |    */
  203|      0|    public var itemInserted: ControlEvent<IndexPath> {
  204|      0|        let source = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
  205|      0|            .filter { a in
  206|      0|                return UITableViewCellEditingStyle(rawValue: (try castOrThrow(NSNumber.self, a[1])).intValue) == .insert
  207|      0|            }
  208|      0|            .map { a in
  209|      0|                return (try castOrThrow(IndexPath.self, a[2]))
  210|      0|        }
  211|      0|        
  212|      0|        return ControlEvent(events: source)
  213|      0|    }
  214|       |    
  215|       |    /**
  216|       |    Reactive wrapper for `delegate` message `tableView:commitEditingStyle:forRowAtIndexPath:`.
  217|       |    */
  218|      0|    public var itemDeleted: ControlEvent<IndexPath> {
  219|      0|        let source = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
  220|      0|            .filter { a in
  221|      0|                return UITableViewCellEditingStyle(rawValue: (try castOrThrow(NSNumber.self, a[1])).intValue) == .delete
  222|      0|            }
  223|      0|            .map { a in
  224|      0|                return try castOrThrow(IndexPath.self, a[2])
  225|      0|            }
  226|      0|        
  227|      0|        return ControlEvent(events: source)
  228|      0|    }
  229|       |    
  230|       |    /**
  231|       |    Reactive wrapper for `delegate` message `tableView:moveRowAtIndexPath:toIndexPath:`.
  232|       |    */
  233|      0|    public var itemMoved: ControlEvent<ItemMovedEvent> {
  234|      0|        let source: Observable<ItemMovedEvent> = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:moveRowAt:to:)))
  235|      0|            .map { a in
  236|      0|                return (try castOrThrow(IndexPath.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  237|      0|            }
  238|      0|        
  239|      0|        return ControlEvent(events: source)
  240|      0|    }
  241|       |
  242|       |    /**
  243|       |    Reactive wrapper for `delegate` message `tableView:willDisplayCell:forRowAtIndexPath:`.
  244|       |    */
  245|      0|    public var willDisplayCell: ControlEvent<WillDisplayCellEvent> {
  246|      0|        let source: Observable<WillDisplayCellEvent> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:)))
  247|      0|            .map { a in
  248|      0|                return (try castOrThrow(UITableViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  249|      0|            }
  250|      0|
  251|      0|        return ControlEvent(events: source)
  252|      0|    }
  253|       |
  254|       |    /**
  255|       |    Reactive wrapper for `delegate` message `tableView:didEndDisplayingCell:forRowAtIndexPath:`.
  256|       |    */
  257|      0|    public var didEndDisplayingCell: ControlEvent<DidEndDisplayingCellEvent> {
  258|      0|        let source: Observable<DidEndDisplayingCellEvent> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:)))
  259|      0|            .map { a in
  260|      0|                return (try castOrThrow(UITableViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  261|      0|            }
  262|      0|
  263|      0|        return ControlEvent(events: source)
  264|      0|    }
  265|       |
  266|       |    /**
  267|       |    Reactive wrapper for `delegate` message `tableView:didSelectRowAtIndexPath:`.
  268|       |    
  269|       |    It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  270|       |    or any other data source conforming to `SectionedViewDataSourceType` protocol.
  271|       |    
  272|       |     ```
  273|       |        tableView.rx.modelSelected(MyModel.self)
  274|       |            .map { ...
  275|       |     ```
  276|       |    */
  277|      0|    public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  278|      0|        let source: Observable<T> = self.itemSelected.flatMap { [weak view = self.base as UITableView] indexPath -> Observable<T> in
  279|      0|            guard let view = view else {
  280|      0|                return Observable.empty()
  281|      0|            }
  282|      0|
  283|      0|            return Observable.just(try view.rx.model(at: indexPath))
  284|      0|        }
  285|      0|        
  286|      0|        return ControlEvent(events: source)
  287|      0|    }
  288|       |
  289|       |    /**
  290|       |     Reactive wrapper for `delegate` message `tableView:didDeselectRowAtIndexPath:`.
  291|       |
  292|       |     It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  293|       |     or any other data source conforming to `SectionedViewDataSourceType` protocol.
  294|       |
  295|       |     ```
  296|       |        tableView.rx.modelDeselected(MyModel.self)
  297|       |            .map { ...
  298|       |     ```
  299|       |     */
  300|      0|    public func modelDeselected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  301|      0|         let source: Observable<T> = self.itemDeselected.flatMap { [weak view = self.base as UITableView] indexPath -> Observable<T> in
  302|      0|             guard let view = view else {
  303|      0|                 return Observable.empty()
  304|      0|             }
  305|      0|
  306|      0|            return Observable.just(try view.rx.model(at: indexPath))
  307|      0|        }
  308|      0|
  309|      0|        return ControlEvent(events: source)
  310|      0|    }
  311|       |    
  312|       |    /**
  313|       |     Reactive wrapper for `delegate` message `tableView:commitEditingStyle:forRowAtIndexPath:`.
  314|       |     
  315|       |     It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  316|       |     or any other data source conforming to `SectionedViewDataSourceType` protocol.
  317|       |     
  318|       |     ```
  319|       |        tableView.rx.modelDeleted(MyModel.self)
  320|       |            .map { ...
  321|       |     ```
  322|       |     */
  323|      0|    public func modelDeleted<T>(_ modelType: T.Type) -> ControlEvent<T> {
  324|      0|        let source: Observable<T> = self.itemDeleted.flatMap { [weak view = self.base as UITableView] indexPath -> Observable<T> in
  325|      0|            guard let view = view else {
  326|      0|                return Observable.empty()
  327|      0|            }
  328|      0|            
  329|      0|            return Observable.just(try view.rx.model(at: indexPath))
  330|      0|        }
  331|      0|        
  332|      0|        return ControlEvent(events: source)
  333|      0|    }
  334|       |
  335|       |    /**
  336|       |     Synchronous helper method for retrieving a model at indexPath through a reactive data source.
  337|       |     */
  338|       |    public func model<T>(at indexPath: IndexPath) throws -> T {
  339|       |        let dataSource: SectionedViewDataSourceType = castOrFatalError(self.dataSource.forwardToDelegate(), message: "This method only works in case one of the `rx.items*` methods was used.")
  340|       |        
  341|       |        let element = try dataSource.model(at: indexPath)
  342|       |
  343|       |        return castOrFatalError(element)
  344|       |    }
  345|       |}
  346|       |
  347|       |@available(iOS 10.0, tvOS 10.0, *)
  348|       |extension Reactive where Base: UITableView {
  349|       |
  350|       |    /// Reactive wrapper for `prefetchDataSource`.
  351|       |    ///
  352|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
  353|      0|    public var prefetchDataSource: DelegateProxy<UITableView, UITableViewDataSourcePrefetching> {
  354|      0|        return RxTableViewDataSourcePrefetchingProxy.proxy(for: base)
  355|      0|    }
  356|       |
  357|       |    /**
  358|       |     Installs prefetch data source as forwarding delegate on `rx.prefetchDataSource`.
  359|       |     Prefetch data source won't be retained.
  360|       |
  361|       |     It enables using normal delegate mechanism with reactive delegate mechanism.
  362|       |
  363|       |     - parameter prefetchDataSource: Prefetch data source object.
  364|       |     - returns: Disposable object that can be used to unbind the data source.
  365|       |     */
  366|       |    public func setPrefetchDataSource(_ prefetchDataSource: UITableViewDataSourcePrefetching)
  367|      0|        -> Disposable {
  368|      0|            return RxTableViewDataSourcePrefetchingProxy.installForwardDelegate(prefetchDataSource, retainDelegate: false, onProxyForObject: self.base)
  369|      0|    }
  370|       |
  371|       |    /// Reactive wrapper for `prefetchDataSource` message `tableView(_:prefetchRowsAt:)`.
  372|      0|    public var prefetchRows: ControlEvent<[IndexPath]> {
  373|      0|        let source = RxTableViewDataSourcePrefetchingProxy.proxy(for: base).prefetchRowsPublishSubject
  374|      0|        return ControlEvent(events: source)
  375|      0|    }
  376|       |
  377|       |    /// Reactive wrapper for `prefetchDataSource` message `tableView(_:cancelPrefetchingForRowsAt:)`.
  378|      0|    public var cancelPrefetchingForRows: ControlEvent<[IndexPath]> {
  379|      0|        let source = prefetchDataSource.methodInvoked(#selector(UITableViewDataSourcePrefetching.tableView(_:cancelPrefetchingForRowsAt:)))
  380|      0|            .map { a in
  381|      0|                return try castOrThrow(Array<IndexPath>.self, a[1])
  382|      0|        }
  383|      0|
  384|      0|        return ControlEvent(events: source)
  385|      0|    }
  386|       |
  387|       |}
  388|       |#endif
  389|       |
  390|       |#if os(tvOS)
  391|       |    
  392|       |    extension Reactive where Base: UITableView {
  393|       |        
  394|       |        /**
  395|       |         Reactive wrapper for `delegate` message `tableView:didUpdateFocusInContext:withAnimationCoordinator:`.
  396|       |         */
  397|       |        public var didUpdateFocusInContextWithAnimationCoordinator: ControlEvent<(context: UITableViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator)> {
  398|       |            
  399|       |            let source = delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:)))
  400|       |                .map { a -> (context: UITableViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator) in
  401|       |                    let context = try castOrThrow(UITableViewFocusUpdateContext.self, a[1])
  402|       |                    let animationCoordinator = try castOrThrow(UIFocusAnimationCoordinator.self, a[2])
  403|       |                    return (context: context, animationCoordinator: animationCoordinator)
  404|       |            }
  405|       |            
  406|       |            return ControlEvent(events: source)
  407|       |        }
  408|       |    }
  409|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITextField+Rx.swift:
    1|       |//
    2|       |//  UITextField+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import RxSwift
   12|       |import UIKit
   13|       |
   14|       |extension Reactive where Base: UITextField {
   15|       |    /// Reactive wrapper for `text` property.
   16|      0|    public var text: ControlProperty<String?> {
   17|      0|        return value
   18|      0|    }
   19|       |    
   20|       |    /// Reactive wrapper for `text` property.
   21|       |    public var value: ControlProperty<String?> {
   22|       |        return base.rx.controlPropertyWithDefaultEvents(
   23|      0|            getter: { textField in
   24|      0|                textField.text
   25|      0|            },
   26|      0|            setter: { textField, value in
   27|      0|                // This check is important because setting text value always clears control state
   28|      0|                // including marked text selection which is imporant for proper input 
   29|      0|                // when IME input method is used.
   30|      0|                if textField.text != value {
   31|      0|                    textField.text = value
   32|      0|                }
   33|      0|            }
   34|       |        )
   35|       |    }
   36|       |    
   37|       |    /// Bindable sink for `attributedText` property.
   38|      0|    public var attributedText: ControlProperty<NSAttributedString?> {
   39|      0|        return base.rx.controlPropertyWithDefaultEvents(
   40|      0|            getter: { textField in
   41|      0|                textField.attributedText
   42|      0|            },
   43|      0|            setter: { textField, value in
   44|      0|                // This check is important because setting text value always clears control state
   45|      0|                // including marked text selection which is imporant for proper input
   46|      0|                // when IME input method is used.
   47|      0|                if textField.attributedText != value {
   48|      0|                    textField.attributedText = value
   49|      0|                }
   50|      0|            }
   51|      0|        )
   52|      0|    }
   53|       |    
   54|       |}
   55|       |
   56|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UITextView+Rx.swift:
    1|       |//
    2|       |//  UITextView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 7/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UITextView {
   15|       |    /// Reactive wrapper for `text` property
   16|      0|    public var text: ControlProperty<String?> {
   17|      0|        return value
   18|      0|    }
   19|       |    
   20|       |    /// Reactive wrapper for `text` property.
   21|       |    public var value: ControlProperty<String?> {
   22|      0|        let source: Observable<String?> = Observable.deferred { [weak textView = self.base] in
   23|      0|            let text = textView?.text
   24|      0|            
   25|      0|            let textChanged = textView?.textStorage
   26|      0|                // This project uses text storage notifications because
   27|      0|                // that's the only way to catch autocorrect changes
   28|      0|                // in all cases. Other suggestions are welcome.
   29|      0|                .rx.didProcessEditingRangeChangeInLength
   30|      0|                // This observe on is here because text storage
   31|      0|                // will emit event while process is not completely done,
   32|      0|                // so rebinding a value will cause an exception to be thrown.
   33|      0|                .observeOn(MainScheduler.asyncInstance)
   34|      0|                .map { _ in
   35|      0|                    return textView?.textStorage.string
   36|      0|                }
   37|      0|                ?? Observable.empty()
   38|      0|            
   39|      0|            return textChanged
   40|      0|                .startWith(text)
   41|      0|        }
   42|       |
   43|      0|        let bindingObserver = Binder(self.base) { (textView, text: String?) in
   44|      0|            // This check is important because setting text value always clears control state
   45|      0|            // including marked text selection which is imporant for proper input 
   46|      0|            // when IME input method is used.
   47|      0|            if textView.text != text {
   48|      0|                textView.text = text
   49|      0|            }
   50|      0|        }
   51|       |        
   52|       |        return ControlProperty(values: source, valueSink: bindingObserver)
   53|       |    }
   54|       |    
   55|       |    
   56|       |    /// Reactive wrapper for `attributedText` property.
   57|      0|    public var attributedText: ControlProperty<NSAttributedString?> {
   58|      0|        let source: Observable<NSAttributedString?> = Observable.deferred { [weak textView = self.base] in
   59|      0|            let attributedText = textView?.attributedText
   60|      0|            
   61|      0|            let textChanged: Observable<NSAttributedString?> = textView?.textStorage
   62|      0|                // This project uses text storage notifications because
   63|      0|                // that's the only way to catch autocorrect changes
   64|      0|                // in all cases. Other suggestions are welcome.
   65|      0|                .rx.didProcessEditingRangeChangeInLength
   66|      0|                // This observe on is here because attributedText storage
   67|      0|                // will emit event while process is not completely done,
   68|      0|                // so rebinding a value will cause an exception to be thrown.
   69|      0|                .observeOn(MainScheduler.asyncInstance)
   70|      0|                .map { _ in
   71|      0|                    return textView?.attributedText
   72|      0|                }
   73|      0|                ?? Observable.empty()
   74|      0|            
   75|      0|            return textChanged
   76|      0|                .startWith(attributedText)
   77|      0|        }
   78|      0|        
   79|      0|        let bindingObserver = Binder(self.base) { (textView, attributedText: NSAttributedString?) in
   80|      0|            // This check is important because setting text value always clears control state
   81|      0|            // including marked text selection which is imporant for proper input
   82|      0|            // when IME input method is used.
   83|      0|            if textView.attributedText != attributedText {
   84|      0|                textView.attributedText = attributedText
   85|      0|            }
   86|      0|        }
   87|      0|        
   88|      0|        return ControlProperty(values: source, valueSink: bindingObserver)
   89|      0|    }
   90|       |
   91|       |    /// Reactive wrapper for `delegate` message.
   92|      0|    public var didBeginEditing: ControlEvent<()> {
   93|      0|       return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidBeginEditing(_:)))
   94|      0|            .map { _ in
   95|      0|                return ()
   96|      0|            })
   97|      0|    }
   98|       |
   99|       |    /// Reactive wrapper for `delegate` message.
  100|      0|    public var didEndEditing: ControlEvent<()> {
  101|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidEndEditing(_:)))
  102|      0|            .map { _ in
  103|      0|                return ()
  104|      0|            })
  105|      0|    }
  106|       |
  107|       |    /// Reactive wrapper for `delegate` message.
  108|      0|    public var didChange: ControlEvent<()> {
  109|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidChange(_:)))
  110|      0|            .map { _ in
  111|      0|                return ()
  112|      0|            })
  113|      0|    }
  114|       |
  115|       |    /// Reactive wrapper for `delegate` message.
  116|      0|    public var didChangeSelection: ControlEvent<()> {
  117|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidChangeSelection(_:)))
  118|      0|            .map { _ in
  119|      0|                return ()
  120|      0|            })
  121|      0|    }
  122|       |
  123|       |}
  124|       |
  125|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIView+Rx.swift:
    1|       |//
    2|       |//  UIView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |import RxSwift
   13|       |
   14|       |extension Reactive where Base: UIView {
   15|       |    /// Bindable sink for `hidden` property.
   16|      0|    public var isHidden: Binder<Bool> {
   17|      0|        return Binder(self.base) { view, hidden in
   18|      0|            view.isHidden = hidden
   19|      0|        }
   20|      0|    }
   21|       |
   22|       |    /// Bindable sink for `alpha` property.
   23|      0|    public var alpha: Binder<CGFloat> {
   24|      0|        return Binder(self.base) { view, alpha in
   25|      0|            view.alpha = alpha
   26|      0|        }
   27|      0|    }
   28|       |
   29|       |    /// Bindable sink for `backgroundColor` property.
   30|      0|    public var backgroundColor: Binder<UIColor?> {
   31|      0|        return Binder(self.base) { view, color in
   32|      0|            view.backgroundColor = color
   33|      0|        }
   34|      0|    }
   35|       |
   36|       |    /// Bindable sink for `isUserInteractionEnabled` property.
   37|      0|    public var isUserInteractionEnabled: Binder<Bool> {
   38|      0|        return Binder(self.base) { view, userInteractionEnabled in
   39|      0|            view.isUserInteractionEnabled = userInteractionEnabled
   40|      0|        }
   41|      0|    }
   42|       |    
   43|       |}
   44|       |
   45|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIViewController+Rx.swift:
    1|       |//
    2|       |//  UIViewController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Kyle Fuller on 27/05/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |    import UIKit
   12|       |    import RxSwift
   13|       |
   14|       |    extension Reactive where Base: UIViewController {
   15|       |
   16|       |        /// Bindable sink for `title`.
   17|      0|        public var title: Binder<String> {
   18|      0|            return Binder(self.base) { viewController, title in
   19|      0|                viewController.title = title
   20|      0|            }
   21|      0|        }
   22|       |    
   23|       |    }
   24|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/RxCocoa/RxCocoa/iOS/UIWebView+Rx.swift:
    1|       |//
    2|       |//  UIWebView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 8/30/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |    import UIKit
   12|       |    import RxSwift
   13|       |
   14|       |    extension Reactive where Base: UIWebView {
   15|       |
   16|       |        /// Reactive wrapper for `delegate`.
   17|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   18|      0|        public var delegate: DelegateProxy<UIWebView, UIWebViewDelegate> {
   19|      0|            return RxWebViewDelegateProxy.proxy(for: base)
   20|      0|        }
   21|       |
   22|       |        /// Reactive wrapper for `delegate` message.
   23|      0|        public var didStartLoad: Observable<Void> {
   24|      0|            return delegate
   25|      0|                .methodInvoked(#selector(UIWebViewDelegate.webViewDidStartLoad(_:)))
   26|      0|                .map { _ in }
   27|      0|        }
   28|       |
   29|       |        /// Reactive wrapper for `delegate` message.
   30|      0|        public var didFinishLoad: Observable<Void> {
   31|      0|            return delegate
   32|      0|                .methodInvoked(#selector(UIWebViewDelegate.webViewDidFinishLoad(_:)))
   33|      0|                .map { _ in }
   34|      0|        }
   35|       |        
   36|       |        /// Reactive wrapper for `delegate` message.
   37|      0|        public var didFailLoad: Observable<Error> {
   38|      0|            return delegate
   39|      0|                .methodInvoked(#selector(UIWebViewDelegate.webView(_:didFailLoadWithError:)))
   40|      0|                .map { a in
   41|      0|                    return try castOrThrow(Error.self, a[1])
   42|      0|                }
   43|      0|        }
   44|       |    }
   45|       |
   46|       |#endif

