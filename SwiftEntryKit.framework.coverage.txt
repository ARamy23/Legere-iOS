/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Extensions/UIApplication+EKAppearance.swift:
    1|       |//
    2|       |//  UIApplication+EKAppearance.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/25/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |extension UIApplication {
   12|       |    
   13|      0|    func set(statusBarStyle: EKAttributes.StatusBar) {
   14|      0|        let appearance = statusBarStyle.appearance
   15|      0|        UIApplication.shared.isStatusBarHidden = !appearance.visible
   16|      0|        UIApplication.shared.statusBarStyle = appearance.style
   17|      0|    }
   18|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Extensions/UIEdgeInsets+Utils.swift:
    1|       |//
    2|       |//  UIEdgeInsets.swift
    3|       |//  FBSnapshotTestCase
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |extension UIEdgeInsets {
   11|      0|    var hasVerticalInsets: Bool {
   12|      0|        return top > 0 || bottom > 0
   13|      0|    }
   14|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Extensions/UIView+Shadow.swift:
    1|       |//
    2|       |//  UIView+Shadow.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/25/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |extension UIView {
   11|      0|    func applyDropShadow(withOffset offset: CGSize, opacity: Float, radius: CGFloat, color: UIColor) {
   12|      0|        layer.applyDropShadow(withOffset: offset, opacity: opacity, radius: radius, color: color)
   13|      0|    }
   14|       |    
   15|      0|    func removeDropShadow() {
   16|      0|        layer.removeDropShadow()
   17|      0|    }
   18|       |}
   19|       |
   20|       |extension CALayer {
   21|       |    func applyDropShadow(withOffset offset: CGSize, opacity: Float, radius: CGFloat, color: UIColor) {
   22|       |        shadowOffset = offset
   23|       |        shadowOpacity = opacity
   24|       |        shadowRadius = radius
   25|       |        shadowColor = color.cgColor
   26|       |        shouldRasterize = true
   27|       |        rasterizationScale = UIScreen.main.scale
   28|       |    }
   29|       |    
   30|       |    func removeDropShadow() {
   31|       |        shadowOffset = .zero
   32|       |        shadowOpacity = 0
   33|       |        shadowRadius = 0
   34|       |        shadowColor = UIColor.clear.cgColor
   35|       |        shouldRasterize = false
   36|       |    }
   37|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Extensions/UIView+Utils.swift:
    1|       |//
    2|       |//  UILabel+Message.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 04/14/2018.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |extension UILabel {
   13|       |    var style: EKProperty.LabelStyle {
   14|      0|        set {
   15|      0|            font = newValue.font
   16|      0|            textColor = newValue.color
   17|      0|            textAlignment = newValue.alignment
   18|      0|            numberOfLines = newValue.numberOfLines
   19|      0|        }
   20|       |        get {
   21|       |            return EKProperty.LabelStyle(font: font, color: textColor, alignment: textAlignment, numberOfLines: numberOfLines)
   22|       |        }
   23|       |    }
   24|       |    
   25|       |    var content: EKProperty.LabelContent {
   26|      0|        set {
   27|      0|            text = newValue.text
   28|      0|            style = newValue.style
   29|      0|        }
   30|       |        get {
   31|      0|            return EKProperty.LabelContent(text: text ?? "", style: style)
   32|       |        }
   33|       |    }
   34|       |}
   35|       |
   36|       |extension UIButton {
   37|       |    var buttonContent: EKProperty.ButtonContent {
   38|      0|        set {
   39|      0|            setTitle(newValue.label.text, for: .normal)
   40|      0|            setTitleColor(newValue.label.style.color, for: .normal)
   41|      0|            titleLabel?.font = newValue.label.style.font
   42|      0|            backgroundColor = newValue.backgroundColor
   43|      0|        }
   44|       |        get {
   45|      0|            fatalError("buttonContent doesn't have a getter")
   46|       |        }
   47|       |    }
   48|       |}
   49|       |
   50|       |extension UIImageView {
   51|       |    var imageContent: EKProperty.ImageContent {
   52|      0|        set {
   53|      0|            stopAnimating()
   54|      0|            animationImages = newValue.images
   55|      0|            animationDuration = newValue.imageSequenceAnimationDuration
   56|      0|            contentMode = newValue.contentMode
   57|      0|            
   58|      0|            if let size = newValue.size {
   59|      0|                set(.width, of: size.width)
   60|      0|                set(.height, of: size.height)
   61|      0|            } else {
   62|      0|                forceContentWrap()
   63|      0|            }
   64|      0|            
   65|      0|            if newValue.makesRound {
   66|      0|                clipsToBounds = true
   67|      0|                if let size = newValue.size {
   68|      0|                    layer.cornerRadius = min(size.width, size.height) * 0.5
   69|      0|                } else {
   70|      0|                    layoutIfNeeded()
   71|      0|                    layer.cornerRadius = min(bounds.width, bounds.height) * 0.5
   72|      0|                }
   73|      0|            }
   74|      0|            
   75|      0|            startAnimating()
   76|      0|            
   77|      0|            if case .animate(duration: let duration, options: let options, transform: let transform) = newValue.animation {
   78|      0|                let options: UIView.AnimationOptions = [.repeat, .autoreverse, options]
   79|      0|                // A hack that forces the animation to run on the main thread on one of the next run loops
   80|      0|                DispatchQueue.main.async {
   81|      0|                    UIView.animate(withDuration: duration, delay: 0, options: options, animations: {
   82|      0|                        self.transform = transform
   83|      0|                    }, completion: nil)
   84|      0|                }
   85|      0|            }
   86|      0|        }
   87|       |        get {
   88|      0|            fatalError("imageContent doesn't have a getter")
   89|       |        }
   90|       |    }
   91|       |}
   92|       |
   93|       |extension UITextField {
   94|       |    var textFieldContent: EKProperty.TextFieldContent {
   95|      0|        set {
   96|      0|            attributedPlaceholder = NSAttributedString(string: newValue.placeholder.text, attributes: [.font: newValue.placeholder.style.font, .foregroundColor: newValue.placeholder.style.color])
   97|      0|            keyboardType = newValue.keyboardType
   98|      0|            textColor = newValue.textStyle.color
   99|      0|            font = newValue.textStyle.font
  100|      0|            textAlignment = newValue.textStyle.alignment
  101|      0|            isSecureTextEntry = newValue.isSecure
  102|      0|            text = newValue.textContent
  103|      0|            tintColor = newValue.tintColor
  104|      0|        }
  105|       |        get {
  106|      0|            fatalError("textFieldContent doesn't have a getter")
  107|       |        }
  108|       |    }
  109|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKBackgroundView.swift:
    1|       |//
    2|       |//  EKBackgroundView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class EKBackgroundView: EKStyleView {
   12|       |
   13|       |    // MARK: Props
   14|       |    private let visualEffectView: UIVisualEffectView
   15|       |    private let imageView: UIImageView
   16|       |    private let gradientView: GradientView
   17|       |    
   18|       |    // MARK: Setup
   19|      0|    init() {
   20|      0|        imageView = UIImageView()
   21|      0|        visualEffectView = UIVisualEffectView(effect: nil)
   22|      0|        gradientView = GradientView()
   23|      0|        super.init(frame: UIScreen.main.bounds)
   24|      0|        
   25|      0|        addSubview(imageView)
   26|      0|        imageView.contentMode = .scaleAspectFill
   27|      0|        imageView.fillSuperview()
   28|      0|        
   29|      0|        addSubview(visualEffectView)
   30|      0|        visualEffectView.fillSuperview()
   31|      0|        
   32|      0|        addSubview(gradientView)
   33|      0|        gradientView.fillSuperview()
   34|      0|    }
   35|       |    
   36|      0|    required init?(coder aDecoder: NSCoder) {
   37|      0|        fatalError("init(coder:) has not been implemented")
   38|      0|    }
   39|       |    
   40|       |    // Background setter
   41|       |    var background: EKAttributes.BackgroundStyle! {
   42|      0|        didSet {
   43|      0|            guard let background = background else {
   44|      0|                return
   45|      0|            }
   46|      0|            
   47|      0|            var gradient: EKAttributes.BackgroundStyle.Gradient?
   48|      0|            var backgroundEffect: UIBlurEffect?
   49|      0|            var backgroundColor: UIColor = .clear
   50|      0|            var backgroundImage: UIImage?
   51|      0|            
   52|      0|            switch background {
   53|      0|            case .color(color: let color):
   54|      0|                backgroundColor = color
   55|      0|            case .gradient(gradient: let value):
   56|      0|                gradient = value
   57|      0|            case .image(image: let image):
   58|      0|                backgroundImage = image
   59|      0|            case .visualEffect(style: let style):
   60|      0|                backgroundEffect = UIBlurEffect(style: style)
   61|      0|            case .clear:
   62|      0|                break
   63|      0|            }
   64|      0|        
   65|      0|            gradientView.gradient = gradient
   66|      0|            visualEffectView.effect = backgroundEffect
   67|      0|            layer.backgroundColor = backgroundColor.cgColor
   68|      0|            imageView.image = backgroundImage
   69|      0|        }
   70|       |    }
   71|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKContentView.swift:
    1|       |//
    2|       |//  EKScrollView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |protocol EntryContentViewDelegate: class {
   13|       |    func changeToActive(withAttributes attributes: EKAttributes)
   14|       |    func changeToInactive(withAttributes attributes: EKAttributes, pushOut: Bool)
   15|       |    func didFinishDisplaying(entry: EKEntryView, keepWindowActive: Bool)
   16|       |}
   17|       |
   18|       |class EKContentView: UIView {
   19|       |    
   20|       |    enum OutTranslation {
   21|       |        case exit
   22|       |        case pop
   23|       |        case swipeDown
   24|       |        case swipeUp
   25|       |    }
   26|       |    
   27|       |    struct OutTranslationAnchor {
   28|       |        var messageOut: QLAttribute
   29|       |        var screenOut: QLAttribute
   30|       |        
   31|      0|        init(_ messageOut: QLAttribute, to screenOut: QLAttribute) {
   32|      0|            self.messageOut = messageOut
   33|      0|            self.screenOut = screenOut
   34|      0|        }
   35|       |    }
   36|       |    
   37|       |    // MARK: Props
   38|       |    
   39|       |    // Entry delegate
   40|       |    private weak var entryDelegate: EntryContentViewDelegate!
   41|       |    
   42|       |    // Constraints and Offsets
   43|       |    private var entranceOutConstraint: NSLayoutConstraint!
   44|       |    private var exitOutConstraint: NSLayoutConstraint!
   45|       |    private var swipeDownOutConstraint: NSLayoutConstraint!
   46|       |    private var swipeUpOutConstraint: NSLayoutConstraint!
   47|       |    private var popOutConstraint: NSLayoutConstraint!
   48|       |    private var inConstraint: NSLayoutConstraint!
   49|       |    private var resistanceConstraint: NSLayoutConstraint!
   50|       |    private var inKeyboardConstraint: NSLayoutConstraint!
   51|       |    
   52|       |    private var inOffset: CGFloat = 0
   53|       |    private var totalTranslation: CGFloat = 0
   54|       |    private var verticalLimit: CGFloat = 0
   55|       |    private let swipeMinVelocity: CGFloat = 60
   56|       |    
   57|       |    private var outDispatchWorkItem: DispatchWorkItem!
   58|       |
   59|       |    private var keyboardState = KeyboardState.hidden
   60|       |    
   61|       |    // Dismissal handler
   62|       |    var dismissHandler: SwiftEntryKit.DismissCompletionHandler?
   63|       |    
   64|       |    // Data source
   65|      0|    private var attributes: EKAttributes {
   66|      0|        return contentView.attributes
   67|      0|    }
   68|       |    
   69|       |    // Content
   70|       |    private var contentView: EKEntryView!
   71|       |    
   72|       |    // MARK: Setup
   73|      0|    required init?(coder aDecoder: NSCoder) {
   74|      0|        fatalError("init(coder:) has not been implemented")
   75|      0|    }
   76|       |    
   77|      0|    init(withEntryDelegate entryDelegate: EntryContentViewDelegate) {
   78|      0|        self.entryDelegate = entryDelegate
   79|      0|        super.init(frame: .zero)
   80|      0|    }
   81|       |    
   82|       |    // Called from outer scope with a presentable view and attributes
   83|      0|    func setup(with contentView: EKEntryView) {
   84|      0|        
   85|      0|        self.contentView = contentView
   86|      0|        
   87|      0|        // Execute willAppear lifecycle action if needed
   88|      0|        contentView.attributes.lifecycleEvents.willAppear?()
   89|      0|        
   90|      0|        // Setup attributes
   91|      0|        setupAttributes()
   92|      0|
   93|      0|        // Setup initial position
   94|      0|        setupInitialPosition()
   95|      0|        
   96|      0|        // Setup width, height and maximum width
   97|      0|        setupLayoutConstraints()
   98|      0|        
   99|      0|        // Animate in
  100|      0|        animateIn()
  101|      0|        
  102|      0|        // Setup tap gesture
  103|      0|        setupTapGestureRecognizer()
  104|      0|        
  105|      0|        // Generate haptic feedback
  106|      0|        generateHapticFeedback()
  107|      0|        
  108|      0|        setupKeyboardChangeIfNeeded()
  109|      0|    }
  110|       |    
  111|       |    // Setup the scrollView initial position
  112|      0|    private func setupInitialPosition() {
  113|      0|        
  114|      0|        // Determine the layout entrance type according to the entry type
  115|      0|        let messageInAnchor: NSLayoutConstraint.Attribute
  116|      0|        
  117|      0|        inOffset = 0
  118|      0|        
  119|      0|        var totalEntryHeight: CGFloat = 0
  120|      0|        
  121|      0|        // Define a spacer to catch top / bottom offsets
  122|      0|        var spacerView: UIView!
  123|      0|        let safeAreaInsets = EKWindowProvider.safeAreaInsets
  124|      0|        let overrideSafeArea = attributes.positionConstraints.safeArea.isOverridden
  125|      0|        
  126|      0|        if !overrideSafeArea && safeAreaInsets.hasVerticalInsets && !attributes.position.isCenter {
  127|      0|            spacerView = UIView()
  128|      0|            addSubview(spacerView)
  129|      0|            spacerView.set(.height, of: safeAreaInsets.top)
  130|      0|            spacerView.layoutToSuperview(.width, .centerX)
  131|      0|            
  132|      0|            totalEntryHeight += safeAreaInsets.top
  133|      0|        }
  134|      0|        
  135|      0|        switch attributes.position {
  136|      0|        case .top:
  137|      0|            messageInAnchor = .top
  138|      0|            inOffset = overrideSafeArea ? 0 : safeAreaInsets.top
  139|      0|            inOffset += attributes.positionConstraints.verticalOffset
  140|      0|            spacerView?.layout(.bottom, to: .top, of: self)
  141|      0|        case .bottom:
  142|      0|            messageInAnchor = .bottom
  143|      0|            inOffset = overrideSafeArea ? 0 : -safeAreaInsets.bottom
  144|      0|            inOffset -= attributes.positionConstraints.verticalOffset
  145|      0|            spacerView?.layout(.top, to: .bottom, of: self)
  146|      0|        case .center:
  147|      0|            messageInAnchor = .centerY
  148|      0|        }
  149|      0|        
  150|      0|        // Layout the content view inside the scroll view
  151|      0|        addSubview(contentView)
  152|      0|        contentView.layoutToSuperview(.left, .right, .top, .bottom)
  153|      0|        contentView.layoutToSuperview(.width, .height)
  154|      0|        
  155|      0|        inConstraint = layout(to: messageInAnchor, of: superview!, offset: inOffset, priority: .defaultLow)
  156|      0|        
  157|      0|        // Set position constraints
  158|      0|        setupOutConstraints(messageInAnchor: messageInAnchor)
  159|      0|        
  160|      0|        totalTranslation = inOffset
  161|      0|        switch attributes.position {
  162|      0|        case .top:
  163|      0|            verticalLimit = inOffset
  164|      0|        case .bottom, .center:
  165|      0|            verticalLimit = UIScreen.main.bounds.height + inOffset
  166|      0|        }
  167|      0|        
  168|      0|        // Setup keyboard constraints
  169|      0|        switch attributes.positionConstraints.keyboardRelation {
  170|      0|        case .bind(offset: let offset):
  171|      0|            if let screenEdgeResistance = offset.screenEdgeResistance {
  172|      0|                resistanceConstraint = layoutToSuperview(.top, relation: .greaterThanOrEqual, offset: screenEdgeResistance, priority: .defaultLow)
  173|      0|            }
  174|      0|            inKeyboardConstraint = layoutToSuperview(.bottom, priority: .defaultLow)
  175|      0|        default:
  176|      0|            break
  177|      0|        }
  178|      0|    }
  179|       |    
  180|      0|    private func setupOutConstraint(animation: EKAttributes.Animation?, messageInAnchor: QLAttribute, priority: QLPriority) -> NSLayoutConstraint {
  181|      0|        let constraint: NSLayoutConstraint
  182|      0|        if let translation = animation?.translate {
  183|      0|            var anchor: OutTranslationAnchor
  184|      0|            switch translation.anchorPosition {
  185|      0|            case .top:
  186|      0|                anchor = OutTranslationAnchor(.bottom, to: .top)
  187|      0|            case .bottom:
  188|      0|                anchor = OutTranslationAnchor(.top, to: .bottom)
  189|      0|            case .automatic where attributes.position.isTop:
  190|      0|                anchor = OutTranslationAnchor(.bottom, to: .top)
  191|      0|            case .automatic: // attributes.position.isBottom:
  192|      0|                anchor = OutTranslationAnchor(.top, to: .bottom)
  193|      0|            }
  194|      0|            constraint = layout(anchor.messageOut, to: anchor.screenOut, of: superview!, priority: priority)!
  195|      0|        } else {
  196|      0|            constraint = layout(to: messageInAnchor, of: superview!, offset: inOffset, priority: priority)!
  197|      0|        }
  198|      0|        return constraint
  199|      0|    }
  200|       |    
  201|       |    // Setup out constraints - taking into account the full picture and all the possible use-cases
  202|      0|    private func setupOutConstraints(messageInAnchor: QLAttribute) {
  203|      0|        
  204|      0|        // Setup entrance and exit out constraints
  205|      0|        entranceOutConstraint = setupOutConstraint(animation: attributes.entranceAnimation, messageInAnchor: messageInAnchor, priority: .must)
  206|      0|        exitOutConstraint = setupOutConstraint(animation: attributes.exitAnimation, messageInAnchor: messageInAnchor, priority: .defaultLow)
  207|      0|        swipeDownOutConstraint = layout(.top, to: .bottom, of: superview!, priority: .defaultLow)!
  208|      0|        swipeUpOutConstraint = layout(.bottom, to: .top, of: superview!, priority: .defaultLow)!
  209|      0|        
  210|      0|        // Setup pop out constraint
  211|      0|        var popAnimation: EKAttributes.Animation?
  212|      0|        if case .animated(animation: let animation) = attributes.popBehavior {
  213|      0|            popAnimation = animation
  214|      0|        }
  215|      0|        popOutConstraint = setupOutConstraint(animation: popAnimation, messageInAnchor: messageInAnchor, priority: .defaultLow)
  216|      0|    }
  217|       |    
  218|       |    
  219|      0|    private func setupSize() {
  220|      0|        
  221|      0|        // Layout the scroll view horizontally inside the screen
  222|      0|        switch attributes.positionConstraints.size.width {
  223|      0|        case .offset(value: let offset):
  224|      0|            layoutToSuperview(axis: .horizontally, offset: offset, priority: .must)
  225|      0|        case .ratio(value: let ratio):
  226|      0|            layoutToSuperview(.width, ratio: ratio, priority: .must)
  227|      0|        case .constant(value: let constant):
  228|      0|            set(.width, of: constant, priority: .must)
  229|      0|        case .intrinsic:
  230|      0|            break
  231|      0|        }
  232|      0|        
  233|      0|        // Layout the scroll view vertically inside the screen
  234|      0|        switch attributes.positionConstraints.size.height {
  235|      0|        case .offset(value: let offset):
  236|      0|            layoutToSuperview(.height, offset: -offset * 2, priority: .must)
  237|      0|        case .ratio(value: let ratio):
  238|      0|            layoutToSuperview(.height, ratio: ratio, priority: .must)
  239|      0|        case .constant(value: let constant):
  240|      0|            set(.height, of: constant, priority: .must)
  241|      0|        case .intrinsic:
  242|      0|            break
  243|      0|        }
  244|      0|    }
  245|       |    
  246|      0|    private func setupMaxSize() {
  247|      0|        
  248|      0|        // Layout the scroll view according to the maximum width (if given any)
  249|      0|        switch attributes.positionConstraints.maxSize.width {
  250|      0|        case .offset(value: let offset):
  251|      0|            layout(to: .left, of: superview!, relation: .greaterThanOrEqual, offset: offset)
  252|      0|            layout(to: .right, of: superview!, relation: .lessThanOrEqual, offset: -offset)
  253|      0|        case .ratio(value: let ratio):
  254|      0|            layoutToSuperview(.centerX)
  255|      0|            layout(to: .width, of: superview!, relation: .lessThanOrEqual, ratio: ratio)
  256|      0|        case .constant(value: let constant):
  257|      0|            set(.width, of: constant, relation: .lessThanOrEqual)
  258|      0|            break
  259|      0|        case .intrinsic:
  260|      0|            break
  261|      0|        }
  262|      0|        
  263|      0|        // Layout the scroll view according to the maximum width (if given any)
  264|      0|        switch attributes.positionConstraints.maxSize.height {
  265|      0|        case .offset(value: let offset):
  266|      0|            layout(to: .height, of: superview!, relation: .lessThanOrEqual, offset: -offset * 2)
  267|      0|        case .ratio(value: let ratio):
  268|      0|            layout(to: .height, of: superview!, relation: .lessThanOrEqual, ratio: ratio)
  269|      0|        case .constant(value: let constant):
  270|      0|            set(.height, of: constant, relation: .lessThanOrEqual)
  271|      0|            break
  272|      0|        case .intrinsic:
  273|      0|            break
  274|      0|        }
  275|      0|    }
  276|       |    
  277|       |    // Setup layout constraints according to EKAttributes.PositionConstraints
  278|      0|    private func setupLayoutConstraints() {
  279|      0|        layoutToSuperview(.centerX)
  280|      0|        setupSize()
  281|      0|        setupMaxSize()
  282|      0|    }
  283|       |
  284|       |    // Setup general attributes
  285|      0|    private func setupAttributes() {
  286|      0|        clipsToBounds = false
  287|      0|        let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(panGestureRecognized(gr:)))
  288|      0|        panGestureRecognizer.isEnabled = attributes.scroll.isEnabled
  289|      0|        addGestureRecognizer(panGestureRecognizer)
  290|      0|    }
  291|       |    
  292|       |    // Setup tap gesture
  293|      0|    private func setupTapGestureRecognizer() {
  294|      0|        switch attributes.entryInteraction.defaultAction {
  295|      0|        case .forward:
  296|      0|            return
  297|      0|        default:
  298|      0|            let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(tapGestureRecognized))
  299|      0|            tapGestureRecognizer.numberOfTapsRequired = 1
  300|      0|            tapGestureRecognizer.cancelsTouchesInView = false
  301|      0|            addGestureRecognizer(tapGestureRecognizer)
  302|      0|        }
  303|      0|    }
  304|       |    
  305|       |    // Generate a haptic feedback if needed
  306|      0|    private func generateHapticFeedback() {
  307|      0|        guard #available(iOS 10.0, *) else {
  308|      0|            return
  309|      0|        }
  310|      0|        HapticFeedbackGenerator.notification(type: attributes.hapticFeedbackType)
  311|      0|    }
  312|       |    
  313|       |    // MARK: Animations
  314|       |    
  315|       |    // Schedule out animation
  316|      0|    private func scheduleAnimateOut(withDelay delay: TimeInterval? = nil) {
  317|      0|        outDispatchWorkItem?.cancel()
  318|      0|        outDispatchWorkItem = DispatchWorkItem { [weak self] in
  319|      0|            self?.animateOut(pushOut: false)
  320|      0|        }
  321|      0|        let delay = attributes.entranceAnimation.totalDuration + (delay ?? attributes.displayDuration)
  322|      0|        DispatchQueue.main.asyncAfter(deadline: .now() + delay, execute: outDispatchWorkItem)
  323|      0|    }
  324|       |    
  325|       |    // Animate out
  326|      0|    func animateOut(pushOut: Bool) {
  327|      0|        
  328|      0|        // Execute willDisappear action if needed
  329|      0|        contentView.attributes.lifecycleEvents.willDisappear?()
  330|      0|        
  331|      0|        if attributes.positionConstraints.keyboardRelation.isBound {
  332|      0|            endEditing(true)
  333|      0|        }
  334|      0|        
  335|      0|        outDispatchWorkItem?.cancel()
  336|      0|        entryDelegate?.changeToInactive(withAttributes: attributes, pushOut: pushOut)
  337|      0|        
  338|      0|        if case .animated(animation: let animation) = attributes.popBehavior, pushOut {
  339|      0|            animateOut(with: animation, outTranslationType: .pop)
  340|      0|        } else {
  341|      0|            animateOut(with: attributes.exitAnimation, outTranslationType: .exit)
  342|      0|        }
  343|      0|    }
  344|       |    
  345|       |    // Animate out
  346|      0|    private func animateOut(with animation: EKAttributes.Animation, outTranslationType: OutTranslation) {
  347|      0|        
  348|      0|        superview?.layoutIfNeeded()
  349|      0|        
  350|      0|        if let translation = animation.translate {
  351|      0|            performAnimation(out: true, with: translation) { [weak self] in
  352|      0|                self?.translateOut(withType: outTranslationType)
  353|      0|            }
  354|      0|        }
  355|      0|        
  356|      0|        if let fade = animation.fade {
  357|      0|            performAnimation(out: true, with: fade, preAction: { self.alpha = fade.start }) {
  358|      0|                self.alpha = fade.end
  359|      0|            }
  360|      0|        }
  361|      0|        
  362|      0|        if let scale = animation.scale {
  363|      0|            performAnimation(out: true, with: scale, preAction: { self.transform = CGAffineTransform(scaleX: scale.start, y: scale.start) }) {
  364|      0|                self.transform = CGAffineTransform(scaleX: scale.end, y: scale.end)
  365|      0|            }
  366|      0|        }
  367|      0|
  368|      0|        if animation.containsAnimation {
  369|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + animation.maxDuration) {
  370|      0|                self.removeFromSuperview(keepWindow: false)
  371|      0|            }
  372|      0|        } else {
  373|      0|            translateOut(withType: outTranslationType)
  374|      0|            removeFromSuperview(keepWindow: false)
  375|      0|        }
  376|      0|    }
  377|       |    
  378|       |    // Animate in
  379|      0|    private func animateIn() {
  380|      0|                
  381|      0|        let animation = attributes.entranceAnimation
  382|      0|        
  383|      0|        superview?.layoutIfNeeded()
  384|      0|        
  385|      0|        if let translation = animation.translate {
  386|      0|            performAnimation(out: false, with: translation, action: translateIn)
  387|      0|        } else {
  388|      0|            translateIn()
  389|      0|        }
  390|      0|        
  391|      0|        if let fade = animation.fade {
  392|      0|            performAnimation(out: false, with: fade, preAction: { self.alpha = fade.start }) {
  393|      0|                self.alpha = fade.end
  394|      0|            }
  395|      0|        }
  396|      0|        
  397|      0|        if let scale = animation.scale {
  398|      0|            performAnimation(out: false, with: scale, preAction: { self.transform = CGAffineTransform(scaleX: scale.start, y: scale.start) }) {
  399|      0|                self.transform = CGAffineTransform(scaleX: scale.end, y: scale.end)
  400|      0|            }
  401|      0|        }
  402|      0|        
  403|      0|        entryDelegate?.changeToActive(withAttributes: attributes)
  404|      0|        
  405|      0|        // Execute didAppear action if needed
  406|      0|        if animation.containsAnimation {
  407|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + animation.maxDuration) {
  408|      0|                self.contentView.attributes.lifecycleEvents.didAppear?()
  409|      0|            }
  410|      0|        } else {
  411|      0|            contentView.attributes.lifecycleEvents.didAppear?()
  412|      0|        }
  413|      0|        
  414|      0|        scheduleAnimateOut()
  415|      0|    }
  416|       |    
  417|       |    // Translate in
  418|      0|    private func translateIn() {
  419|      0|        entranceOutConstraint.priority = .defaultLow
  420|      0|        exitOutConstraint.priority = .defaultLow
  421|      0|        popOutConstraint.priority = .defaultLow
  422|      0|        inConstraint.priority = .must
  423|      0|        superview?.layoutIfNeeded()
  424|      0|    }
  425|       |    
  426|       |    // Translate out
  427|      0|    private func translateOut(withType type: OutTranslation) {
  428|      0|        inConstraint.priority = .defaultLow
  429|      0|        entranceOutConstraint.priority = .defaultLow
  430|      0|        switch type {
  431|      0|        case .exit:
  432|      0|            exitOutConstraint.priority = .must
  433|      0|        case .pop:
  434|      0|            popOutConstraint.priority = .must
  435|      0|        case .swipeUp:
  436|      0|            swipeUpOutConstraint.priority = .must
  437|      0|        case .swipeDown:
  438|      0|            swipeDownOutConstraint.priority = .must
  439|      0|        }
  440|      0|        superview?.layoutIfNeeded()
  441|      0|    }
  442|       |    
  443|       |    // Perform animation - translate / scale / fade
  444|      0|    private func performAnimation(out: Bool, with animation: EKAnimation, preAction: @escaping () -> () = {}, action: @escaping () -> ()) {
  445|      0|        let curve: UIView.AnimationOptions = out ? .curveEaseIn : .curveEaseOut
  446|      0|        let options: UIView.AnimationOptions = [curve, .beginFromCurrentState]
  447|      0|        preAction()
  448|      0|        if let spring = animation.spring {
  449|      0|            UIView.animate(withDuration: animation.duration, delay: animation.delay, usingSpringWithDamping: spring.damping, initialSpringVelocity: spring.initialVelocity, options: options, animations: {
  450|      0|                action()
  451|      0|            }, completion: nil)
  452|      0|        } else {
  453|      0|            UIView.animate(withDuration: animation.duration, delay: animation.delay, options: options, animations: {
  454|      0|                action()
  455|      0|            }, completion: nil)
  456|      0|        }
  457|      0|    }
  458|       |
  459|       |    // MARK: Remvoe entry
  460|       |    
  461|       |    // Removes the view promptly - DOES NOT animate out
  462|      0|    func removePromptly(keepWindow: Bool = true) {
  463|      0|        outDispatchWorkItem?.cancel()
  464|      0|        entryDelegate?.changeToInactive(withAttributes: attributes, pushOut: false)
  465|      0|        contentView.content.attributes.lifecycleEvents.willDisappear?()
  466|      0|        removeFromSuperview(keepWindow: keepWindow)
  467|      0|    }
  468|       |    
  469|       |    // Remove self from superview
  470|      0|    func removeFromSuperview(keepWindow: Bool) {
  471|      0|        guard superview != nil else {
  472|      0|            return
  473|      0|        }
  474|      0|        
  475|      0|        // Execute didDisappear action if needed
  476|      0|        contentView.content.attributes.lifecycleEvents.didDisappear?()
  477|      0|        
  478|      0|        // Execute dismiss handler if needed
  479|      0|        dismissHandler?()
  480|      0|        
  481|      0|        // Remove the view from its superview and in a case of a view controller, from its parent controller.
  482|      0|        super.removeFromSuperview()
  483|      0|        contentView.content.viewController?.removeFromParent()
  484|      0|        
  485|      0|        entryDelegate.didFinishDisplaying(entry: contentView, keepWindowActive: keepWindow)
  486|      0|    }
  487|       |    
  488|      0|    deinit {
  489|      0|        NotificationCenter.default.removeObserver(self)
  490|      0|    }
  491|       |}
  492|       |
  493|       |
  494|       |// MARK: Keyboard Logic
  495|       |extension EKContentView {
  496|       |    
  497|       |    private enum KeyboardState {
  498|       |        case visible
  499|       |        case hidden
  500|       |        
  501|      0|        var isVisible: Bool {
  502|      0|            return self == .visible
  503|      0|        }
  504|       |        
  505|      0|        var isHidden: Bool {
  506|      0|            return self == .hidden
  507|      0|        }
  508|       |    }
  509|       |    
  510|       |    private struct KeyboardAttributes {
  511|       |        let duration: TimeInterval
  512|       |        let curve: UIView.AnimationOptions
  513|       |        let begin: CGRect
  514|       |        let end: CGRect
  515|       |        
  516|      0|        init?(withRawValue rawValue: [AnyHashable: Any]?) {
  517|      0|            guard let rawValue = rawValue else {
  518|      0|                return nil
  519|      0|            }
  520|      0|            duration = rawValue[UIResponder.keyboardAnimationDurationUserInfoKey] as! TimeInterval
  521|      0|            curve = .init(rawValue: rawValue[UIResponder.keyboardAnimationCurveUserInfoKey] as! UInt)
  522|      0|            begin = (rawValue[UIResponder.keyboardFrameBeginUserInfoKey] as! NSValue).cgRectValue
  523|      0|            end = (rawValue[UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue
  524|      0|        }
  525|       |        
  526|      0|        var height: CGFloat {
  527|      0|            return end.maxY - end.minY
  528|      0|        }
  529|       |    }
  530|       |    
  531|       |    private func setupKeyboardChangeIfNeeded() {
  532|       |        guard attributes.positionConstraints.keyboardRelation.isBound else {
  533|       |            return
  534|       |        }
  535|       |        
  536|       |        let notificationCenter = NotificationCenter.default
  537|       |        notificationCenter.addObserver(self, selector: #selector(keyboardWillShow(_:)), name: UIResponder.keyboardWillShowNotification, object: nil)
  538|       |        notificationCenter.addObserver(self, selector: #selector(keyboardWillHide(_:)), name: UIResponder.keyboardWillHideNotification, object: nil)
  539|       |        notificationCenter.addObserver(self, selector: #selector(keyboardDidHide(_:)), name: UIResponder.keyboardDidHideNotification, object: nil)
  540|       |        notificationCenter.addObserver(self, selector: #selector(keyboardWillChangeFrame(_:)), name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
  541|       |    }
  542|       |
  543|      0|    private func animate(by userInfo: [AnyHashable: Any]?, entrance: Bool) {
  544|      0|        
  545|      0|        // Guard that the entry is bound to the keyboard
  546|      0|        guard case .bind(offset: let offset) = attributes.positionConstraints.keyboardRelation else {
  547|      0|            return
  548|      0|        }
  549|      0|        
  550|      0|        // Convert the user info into keyboard attributes
  551|      0|        guard let keyboardAtts = KeyboardAttributes(withRawValue: userInfo) else {
  552|      0|            return
  553|      0|        }
  554|      0|        
  555|      0|        if entrance {
  556|      0|            inKeyboardConstraint.constant = -(keyboardAtts.height + offset.bottom)
  557|      0|            inKeyboardConstraint.priority = .must
  558|      0|            resistanceConstraint?.priority = .must
  559|      0|            inConstraint.priority = .defaultLow
  560|      0|        } else {
  561|      0|            inKeyboardConstraint.priority = .defaultLow
  562|      0|            resistanceConstraint?.priority = .defaultLow
  563|      0|            inConstraint.priority = .must
  564|      0|        }
  565|      0|        
  566|      0|        UIView.animate(withDuration: keyboardAtts.duration, delay: 0, options: keyboardAtts.curve, animations: {
  567|      0|            self.superview?.layoutIfNeeded()
  568|      0|        }, completion: nil)
  569|      0|    }
  570|       |    
  571|      0|    @objc func keyboardWillShow(_ notification: Notification) {
  572|      0|        guard containsFirstResponder else {
  573|      0|            return
  574|      0|        }
  575|      0|        keyboardState = .visible
  576|      0|        animate(by: notification.userInfo, entrance: true)
  577|      0|    }
  578|       |    
  579|      0|    @objc func keyboardWillHide(_ notification: Notification) {
  580|      0|        animate(by: notification.userInfo, entrance: false)
  581|      0|    }
  582|       |    
  583|      0|    @objc func keyboardDidHide(_ notification: Notification) {
  584|      0|        keyboardState = .hidden
  585|      0|    }
  586|       |    
  587|      0|    @objc func keyboardWillChangeFrame(_ notification: Notification) {
  588|      0|        guard containsFirstResponder else {
  589|      0|            return
  590|      0|        }
  591|      0|        animate(by: notification.userInfo, entrance: true)
  592|      0|    }
  593|       |}
  594|       |
  595|       |// MARK: Responds to user interactions (tap / pan / swipe / touches)
  596|       |extension EKContentView {
  597|       |    
  598|       |    // Tap gesture handler
  599|      0|    @objc func tapGestureRecognized() {
  600|      0|        switch attributes.entryInteraction.defaultAction {
  601|      0|        case .delayExit(by: _) where attributes.displayDuration.isFinite:
  602|      0|            scheduleAnimateOut()
  603|      0|        case .dismissEntry:
  604|      0|            animateOut(pushOut: false)
  605|      0|        default:
  606|      0|            break
  607|      0|        }
  608|      0|        attributes.entryInteraction.customTapActions.forEach { $0() }
  609|      0|    }
  610|       |    
  611|       |    // Pan gesture handler
  612|      0|    @objc func panGestureRecognized(gr: UIPanGestureRecognizer) {
  613|      0|        guard keyboardState.isHidden else {
  614|      0|            return
  615|      0|        }
  616|      0|                
  617|      0|        // Delay the exit of the entry if needed
  618|      0|        handleExitDelayIfNeeded(byPanState: gr.state)
  619|      0|        
  620|      0|        let translation = gr.translation(in: superview!).y
  621|      0|        
  622|      0|        if shouldStretch(with: translation) {
  623|      0|            if attributes.scroll.isEdgeCrossingEnabled {
  624|      0|                totalTranslation += translation
  625|      0|                calculateLogarithmicOffset(forOffset: totalTranslation, currentTranslation: translation)
  626|      0|                
  627|      0|                switch gr.state {
  628|      0|                case .ended, .failed, .cancelled:
  629|      0|                    animateRubberBandPullback()
  630|      0|                default:
  631|      0|                    break
  632|      0|                }
  633|      0|            }
  634|      0|        } else {
  635|      0|            switch gr.state {
  636|      0|            case .ended, .failed, .cancelled:
  637|      0|                let velocity = gr.velocity(in: superview!).y
  638|      0|                swipeEnded(withVelocity: velocity)
  639|      0|            case .changed:
  640|      0|                inConstraint.constant += translation
  641|      0|            default:
  642|      0|                break
  643|      0|            }
  644|      0|        }
  645|      0|        gr.setTranslation(.zero, in: superview!)
  646|      0|    }
  647|       |
  648|       |    private func swipeEnded(withVelocity velocity: CGFloat) {
  649|       |        let distance = Swift.abs(inOffset - inConstraint.constant)
  650|       |        var duration = max(0.3, TimeInterval(distance / Swift.abs(velocity)))
  651|       |        duration = min(0.7, duration)
  652|       |        
  653|       |        if attributes.scroll.isSwipeable && testSwipeVelocity(with: velocity) && testSwipeInConstraint() {
  654|       |            stretchOut(usingSwipe: velocity > 0 ? .swipeDown : .swipeUp, duration: duration)
  655|       |        } else {
  656|       |            animateRubberBandPullback()
  657|       |        }
  658|       |    }
  659|       |    
  660|       |    private func stretchOut(usingSwipe type: OutTranslation, duration: TimeInterval) {
  661|       |        outDispatchWorkItem?.cancel()
  662|       |        entryDelegate?.changeToInactive(withAttributes: attributes, pushOut: false)
  663|       |        contentView.content.attributes.lifecycleEvents.willDisappear?()
  664|      0|        UIView.animate(withDuration: duration, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 4, options: [.allowUserInteraction, .beginFromCurrentState], animations: {
  665|      0|            self.translateOut(withType: type)
  666|      0|        }, completion: { finished in
  667|      0|            self.removeFromSuperview(keepWindow: false)
  668|      0|        })
  669|       |    }
  670|       |    
  671|       |    private func calculateLogarithmicOffset(forOffset offset: CGFloat, currentTranslation: CGFloat) {
  672|       |        if attributes.position.isTop {
  673|       |            inConstraint.constant = verticalLimit * (1 + log10(offset / verticalLimit))
  674|       |        } else {
  675|       |            let offset = Swift.abs(offset) + verticalLimit
  676|       |            let addition: CGFloat = abs(currentTranslation) < 2 ? 0 : 1
  677|       |            inConstraint.constant -= (addition + log10(offset / verticalLimit))
  678|       |        }
  679|       |    }
  680|       |    
  681|       |    private func shouldStretch(with translation: CGFloat) -> Bool {
  682|       |        if attributes.position.isTop {
  683|       |            return translation > 0 && inConstraint.constant >= inOffset
  684|       |        } else {
  685|       |            return translation < 0 && inConstraint.constant <= inOffset
  686|       |        }
  687|       |    }
  688|       |    
  689|       |    private func animateRubberBandPullback() {
  690|       |        totalTranslation = verticalLimit
  691|       |    
  692|       |        let animation: EKAttributes.Scroll.PullbackAnimation
  693|       |        if case .enabled(swipeable: _, pullbackAnimation: let pullbackAnimation) = attributes.scroll {
  694|       |            animation = pullbackAnimation
  695|       |        } else {
  696|       |            animation = .easeOut
  697|       |        }
  698|       |
  699|      0|        UIView.animate(withDuration: animation.duration, delay: 0, usingSpringWithDamping: animation.damping, initialSpringVelocity: animation.initialSpringVelocity, options: [.allowUserInteraction, .beginFromCurrentState], animations: {
  700|      0|            self.inConstraint?.constant = self.inOffset
  701|      0|            self.superview?.layoutIfNeeded()
  702|      0|        }, completion: nil)
  703|       |    }
  704|       |    
  705|       |    private func testSwipeInConstraint() -> Bool {
  706|       |        if attributes.position.isTop {
  707|       |            return inConstraint.constant < inOffset
  708|       |        } else {
  709|       |            return inConstraint.constant > inOffset
  710|       |        }
  711|       |    }
  712|       |    
  713|       |    private func testSwipeVelocity(with velocity: CGFloat) -> Bool {
  714|       |        if attributes.position.isTop {
  715|       |            return velocity < -swipeMinVelocity
  716|       |        } else {
  717|       |            return velocity > swipeMinVelocity
  718|       |        }
  719|       |    }
  720|       |    
  721|       |    private func handleExitDelayIfNeeded(byPanState state: UIGestureRecognizer.State) {
  722|       |        guard attributes.entryInteraction.isDelayExit && attributes.displayDuration.isFinite else {
  723|       |            return
  724|       |        }
  725|       |        switch state {
  726|       |        case .began:
  727|       |            outDispatchWorkItem?.cancel()
  728|       |        case .ended, .failed, .cancelled:
  729|       |            scheduleAnimateOut()
  730|       |        default:
  731|       |            break
  732|       |        }
  733|       |    }
  734|       |    
  735|       |    // MARK: UIResponder
  736|       |    
  737|      0|    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
  738|      0|        if attributes.entryInteraction.isDelayExit && attributes.displayDuration.isFinite {
  739|      0|            outDispatchWorkItem?.cancel()
  740|      0|        }
  741|      0|    }
  742|       |    
  743|      0|    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
  744|      0|        if attributes.entryInteraction.isDelayExit && attributes.displayDuration.isFinite {
  745|      0|            scheduleAnimateOut()
  746|      0|        }
  747|      0|    }
  748|       |    
  749|      0|    override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
  750|      0|        touchesEnded(touches, with: event)
  751|      0|    }
  752|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKEntryView.swift:
    1|       |//
    2|       |//  EKEntryView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/15/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |class EKEntryView: EKStyleView {
   13|       |    
   14|       |    struct Content {
   15|       |        var viewController: UIViewController!
   16|       |        var view: UIView!
   17|       |        var attributes: EKAttributes
   18|       |        
   19|      0|        init(viewController: UIViewController, attributes: EKAttributes) {
   20|      0|            self.viewController = viewController
   21|      0|            self.view = viewController.view
   22|      0|            self.attributes = attributes
   23|      0|        }
   24|       |        
   25|      0|        init(view: UIView, attributes: EKAttributes) {
   26|      0|            self.view = view
   27|      0|            self.attributes = attributes
   28|      0|        }
   29|       |    }
   30|       |    
   31|       |    // MARK: Props
   32|       |    
   33|       |    /** Background view */
   34|       |    private var backgroundView: EKBackgroundView!
   35|       |    
   36|       |    /** The content - contains the view, view controller, attributes */
   37|       |    var content: Content
   38|       |    
   39|      0|    private lazy var contentView: UIView = {
   40|      0|        return UIView()
   41|      0|    }()
   42|       |    
   43|      0|    var attributes: EKAttributes {
   44|      0|        return content.attributes
   45|      0|    }
   46|       |    
   47|      0|    private lazy var contentContainerView: EKStyleView = {
   48|      0|        let contentContainerView = EKStyleView()
   49|      0|        self.addSubview(contentContainerView)
   50|      0|        contentContainerView.layoutToSuperview(axis: .vertically)
   51|      0|        contentContainerView.layoutToSuperview(axis: .horizontally)
   52|      0|        contentContainerView.clipsToBounds = true
   53|      0|        return contentContainerView
   54|      0|    }()
   55|       |
   56|       |    // MARK: Setup
   57|      0|    init(newEntry content: Content) {
   58|      0|        self.content = content
   59|      0|        super.init(frame: UIScreen.main.bounds)
   60|      0|        setupContentView()
   61|      0|        applyDropShadow()
   62|      0|        applyBackgroundToContentView()
   63|      0|        applyFrameStyle()
   64|      0|        adjustInnerContentAppearanceIfNeeded()
   65|      0|    }
   66|       |    
   67|      0|    required init?(coder aDecoder: NSCoder) {
   68|      0|        fatalError("init(coder:) has not been implemented")
   69|      0|    }
   70|       |    
   71|      0|    override func layoutSubviews() {
   72|      0|        super.layoutSubviews()
   73|      0|        applyFrameStyle()
   74|      0|    }
   75|       |    
   76|      0|    func transform(to view: UIView) {
   77|      0|        
   78|      0|        let previousView = content.view
   79|      0|        content.view = view
   80|      0|        view.layoutIfNeeded()
   81|      0|        
   82|      0|        let previousHeight = set(.height, of: frame.height, priority: .must)
   83|      0|        let nextHeight = set(.height, of: view.frame.height, priority: .defaultLow)
   84|      0|
   85|      0|        SwiftEntryKit.layoutIfNeeded()
   86|      0|        
   87|      0|        UIView.animate(withDuration: 0.4, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 0, options: [.beginFromCurrentState, .layoutSubviews], animations: {
   88|      0|            
   89|      0|            previousHeight.priority = .defaultLow
   90|      0|            nextHeight.priority = .must
   91|      0|            
   92|      0|            previousView!.alpha = 0
   93|      0|
   94|      0|            SwiftEntryKit.layoutIfNeeded()
   95|      0|            
   96|      0|        }, completion: { (finished) in
   97|      0|            
   98|      0|            view.alpha = 0
   99|      0|            
  100|      0|            previousView!.removeFromSuperview()
  101|      0|            self.removeConstraints([previousHeight, nextHeight])
  102|      0|
  103|      0|            self.setupContentView()
  104|      0|            
  105|      0|            UIView.animate(withDuration: 0.4, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 0, options: [.curveEaseOut], animations: {
  106|      0|                view.alpha = 1
  107|      0|            }, completion: nil)
  108|      0|        })
  109|      0|    }
  110|       |    
  111|      0|    private func setupContentView() {
  112|      0|        contentView.addSubview(content.view)
  113|      0|        content.view.layoutToSuperview(axis: .horizontally)
  114|      0|        content.view.layoutToSuperview(axis: .vertically)
  115|      0|        
  116|      0|        contentContainerView.addSubview(contentView)
  117|      0|        contentView.fillSuperview()
  118|      0|        contentView.layoutToSuperview(axis: .vertically)
  119|      0|        contentView.layoutToSuperview(axis: .horizontally)
  120|      0|    }
  121|       |
  122|       |    // Complementary logic for issue #117
  123|      0|    private func adjustInnerContentAppearanceIfNeeded() {
  124|      0|        guard let view = content.view as? EntryAppearanceDescriptor else {
  125|      0|            return
  126|      0|        }
  127|      0|        view.bottomCornerRadius = attributes.roundCorners.cornerValues?.radius ?? 0
  128|      0|    }
  129|       |    
  130|       |    // Apply round corners
  131|      0|    private func applyFrameStyle() {
  132|      0|        backgroundView.applyFrameStyle(roundCorners: attributes.roundCorners, border: attributes.border)
  133|      0|    }
  134|       |    
  135|       |    // Apply drop shadow
  136|      0|    private func applyDropShadow() {
  137|      0|        switch attributes.shadow {
  138|      0|        case .active(with: let value):
  139|      0|            applyDropShadow(withOffset: value.offset, opacity: value.opacity, radius: value.radius, color: value.color)
  140|      0|        case .none:
  141|      0|            removeDropShadow()
  142|      0|        }
  143|      0|    }
  144|       |    
  145|       |    // Apply background
  146|      0|    private func applyBackgroundToContentView() {
  147|      0|        
  148|      0|        let attributes = content.attributes
  149|      0|        
  150|      0|        let backgroundView = EKBackgroundView()
  151|      0|        backgroundView.background = attributes.entryBackground
  152|      0|        
  153|      0|        switch attributes.positionConstraints.safeArea {
  154|      0|        case .empty(fillSafeArea: let fillSafeArea) where fillSafeArea: // Safe area filled with color
  155|      0|            insertSubview(backgroundView, at: 0)
  156|      0|            backgroundView.layoutToSuperview(axis: .horizontally)
  157|      0|            
  158|      0|            var topInset: CGFloat = 0
  159|      0|            var bottomInset: CGFloat = 0
  160|      0|            switch attributes.position {
  161|      0|            case .top:
  162|      0|                topInset = -EKWindowProvider.safeAreaInsets.top
  163|      0|            case .bottom, .center:
  164|      0|                bottomInset = EKWindowProvider.safeAreaInsets.bottom
  165|      0|            }
  166|      0|            
  167|      0|            backgroundView.layoutToSuperview(.top, offset: topInset)
  168|      0|            backgroundView.layoutToSuperview(.bottom, offset: bottomInset)
  169|      0|        default: // Float case or a Toast with unfilled safe area
  170|      0|            contentView.insertSubview(backgroundView, at: 0)
  171|      0|            backgroundView.fillSuperview()
  172|      0|        }
  173|      0|        
  174|      0|        self.backgroundView = backgroundView
  175|      0|    }
  176|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKRootViewController.swift:
    1|       |//
    2|       |//  EntryViewController.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |protocol EntryPresenterDelegate: class {
   12|       |    var isResponsiveToTouches: Bool { set get }
   13|       |    func displayPendingEntryIfNeeded()
   14|       |}
   15|       |
   16|       |class EKRootViewController: UIViewController {
   17|       |    
   18|       |    // MARK: - Props
   19|       |    
   20|       |    private unowned let delegate: EntryPresenterDelegate
   21|       |    
   22|       |    private var lastAttributes: EKAttributes!
   23|       |    
   24|       |    private let backgroundView = EKBackgroundView()
   25|       |
   26|      0|    private lazy var wrapperView: EKWrapperView = {
   27|      0|        return EKWrapperView()
   28|      0|    }()
   29|       |    
   30|       |    /*
   31|       |     Count the total amount of currently displaying entries,
   32|       |     meaning, total subviews less one - the backgorund of the entry
   33|       |     */
   34|      0|    fileprivate var displayingEntryCount: Int {
   35|      0|        return view.subviews.count - 1
   36|      0|    }
   37|       |    
   38|      0|    fileprivate var isDisplaying: Bool {
   39|      0|        return lastEntry != nil
   40|      0|    }
   41|       |    
   42|      0|    private var lastEntry: EKContentView? {
   43|      0|        return view.subviews.last as? EKContentView
   44|      0|    }
   45|       |        
   46|       |    private var isResponsive = false {
   47|      0|        didSet {
   48|      0|            wrapperView.isAbleToReceiveTouches = isResponsive
   49|      0|            delegate.isResponsiveToTouches = isResponsive
   50|      0|        }
   51|       |    }
   52|       |
   53|       |    override var shouldAutorotate: Bool {
   54|       |        if lastAttributes == nil {
   55|       |            return true
   56|       |        }
   57|       |        return lastAttributes.positionConstraints.rotation.isEnabled
   58|       |    }
   59|       |    
   60|       |    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
   61|       |        guard let lastAttributes = lastAttributes else {
   62|       |            return super.supportedInterfaceOrientations
   63|       |        }
   64|       |        switch lastAttributes.positionConstraints.rotation.supportedInterfaceOrientations {
   65|       |        case .standard:
   66|       |            return super.supportedInterfaceOrientations
   67|       |        case .all:
   68|       |            return .all
   69|       |        }
   70|       |    }
   71|       |    
   72|       |    // Previous status bar style
   73|       |    private let previousStatusBar: EKAttributes.StatusBar
   74|       |    
   75|       |    private var statusBar: EKAttributes.StatusBar? = nil {
   76|      0|        didSet {
   77|      0|            if let statusBar = statusBar, ![statusBar, oldValue].contains(.ignored) {
   78|      0|                UIApplication.shared.set(statusBarStyle: statusBar)
   79|      0|            }
   80|      0|        }
   81|       |    }
   82|       |    
   83|       |    override var preferredStatusBarStyle: UIStatusBarStyle {
   84|       |        if [previousStatusBar, statusBar].contains(.ignored) {
   85|       |            return super.preferredStatusBarStyle
   86|       |        }
   87|      0|        return statusBar?.appearance.style ?? previousStatusBar.appearance.style
   88|       |    }
   89|       |
   90|       |    override var prefersStatusBarHidden: Bool {
   91|       |        if [previousStatusBar, statusBar].contains(.ignored) {
   92|       |            return super.prefersStatusBarHidden
   93|       |        }
   94|      0|        return !(statusBar?.appearance.visible ?? previousStatusBar.appearance.visible)
   95|       |    }
   96|       |    
   97|       |    // MARK: - Lifecycle
   98|       |    
   99|      0|    required public init?(coder aDecoder: NSCoder) {
  100|      0|        fatalError("init(coder:) has not been implemented")
  101|      0|    }
  102|       |    
  103|      0|    public init(with delegate: EntryPresenterDelegate) {
  104|      0|        self.delegate = delegate
  105|      0|        previousStatusBar = .currentStatusBar
  106|      0|        super.init(nibName: nil, bundle: nil)
  107|      0|    }
  108|       |    
  109|      0|    override public func loadView() {
  110|      0|        view = wrapperView
  111|      0|        view.insertSubview(backgroundView, at: 0)
  112|      0|        backgroundView.isUserInteractionEnabled = false
  113|      0|        backgroundView.fillSuperview()
  114|      0|    }
  115|       |    
  116|      0|    override public func viewWillDisappear(_ animated: Bool) {
  117|      0|        super.viewWillDisappear(animated)
  118|      0|        statusBar = previousStatusBar
  119|      0|    }
  120|       |    
  121|       |    // Set status bar
  122|      0|    func setStatusBarStyle(for attributes: EKAttributes) {
  123|      0|        statusBar = attributes.statusBar
  124|      0|    }
  125|       |    
  126|       |    // MARK: - Setup
  127|       |    
  128|      0|    func configure(entryView: EKEntryView) {
  129|      0|
  130|      0|        // In case the entry is a view controller, add the entry as child of root
  131|      0|        if let viewController = entryView.content.viewController {
  132|      0|            addChild(viewController)
  133|      0|        }
  134|      0|        
  135|      0|        // Extract the attributes struct
  136|      0|        let attributes = entryView.attributes
  137|      0|        
  138|      0|        // Assign attributes
  139|      0|        let previousAttributes = lastAttributes
  140|      0|        
  141|      0|        // Remove the last entry
  142|      0|        removeLastEntry(lastAttributes: previousAttributes, keepWindow: true)
  143|      0|        
  144|      0|        lastAttributes = attributes
  145|      0|        
  146|      0|        let entryContentView = EKContentView(withEntryDelegate: self)
  147|      0|        view.addSubview(entryContentView)
  148|      0|        entryContentView.setup(with: entryView)
  149|      0|        
  150|      0|        switch attributes.screenInteraction.defaultAction {
  151|      0|        case .forward:
  152|      0|            isResponsive = false
  153|      0|        default:
  154|      0|            isResponsive = true
  155|      0|        }
  156|      0|
  157|      0|        if previousAttributes?.statusBar != attributes.statusBar {
  158|      0|            setNeedsStatusBarAppearanceUpdate()
  159|      0|        }
  160|      0|        
  161|      0|        if shouldAutorotate {
  162|      0|            UIViewController.attemptRotationToDeviceOrientation()
  163|      0|        }
  164|      0|    }
  165|       |        
  166|       |    // Check priority precedence for a given entry
  167|      0|    func canDisplay(attributes: EKAttributes) -> Bool {
  168|      0|        guard let lastAttributes = lastAttributes else {
  169|      0|            return true
  170|      0|        }
  171|      0|        return attributes.precedence.priority >= lastAttributes.precedence.priority
  172|      0|    }
  173|       |
  174|       |    // Removes last entry - can keep the window 'ON' if necessary
  175|      0|    private func removeLastEntry(lastAttributes: EKAttributes?, keepWindow: Bool) {
  176|      0|        guard let attributes = lastAttributes else {
  177|      0|            return
  178|      0|        }
  179|      0|        if attributes.popBehavior.isOverriden {
  180|      0|            lastEntry?.removePromptly()
  181|      0|        } else {
  182|      0|            popLastEntry()
  183|      0|        }
  184|      0|    }
  185|       |    
  186|       |    // Make last entry exit using exitAnimation - animatedly
  187|      0|    func animateOutLastEntry(completionHandler: SwiftEntryKit.DismissCompletionHandler? = nil) {
  188|      0|        lastEntry?.dismissHandler = completionHandler
  189|      0|        lastEntry?.animateOut(pushOut: false)
  190|      0|    }
  191|       |    
  192|       |    // Pops last entry (using pop animation) - animatedly
  193|      0|    func popLastEntry() {
  194|      0|        lastEntry?.animateOut(pushOut: true)
  195|      0|    }
  196|       |}
  197|       |
  198|       |// MARK: - UIResponder
  199|       |
  200|       |extension EKRootViewController {
  201|       |    
  202|      0|    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
  203|      0|        switch lastAttributes.screenInteraction.defaultAction {
  204|      0|        case .dismissEntry:
  205|      0|            lastEntry?.animateOut(pushOut: false)
  206|      0|            fallthrough
  207|      0|        default:
  208|      0|            lastAttributes.screenInteraction.customTapActions.forEach { $0() }
  209|      0|        }
  210|      0|    }
  211|       |}
  212|       |
  213|       |// MARK: - EntryScrollViewDelegate
  214|       |
  215|       |extension EKRootViewController: EntryContentViewDelegate {
  216|       |    
  217|      0|    func didFinishDisplaying(entry: EKEntryView, keepWindowActive: Bool) {
  218|      0|        guard !isDisplaying else {
  219|      0|            return
  220|      0|        }
  221|      0|        
  222|      0|        guard !keepWindowActive else {
  223|      0|            return
  224|      0|        }
  225|      0|        
  226|      0|        delegate.displayPendingEntryIfNeeded()
  227|      0|    }
  228|       |    
  229|      0|    func changeToInactive(withAttributes attributes: EKAttributes, pushOut: Bool) {
  230|      0|        guard displayingEntryCount <= 1 else {
  231|      0|            return
  232|      0|        }
  233|      0|        
  234|      0|        let clear = {
  235|      0|            self.changeBackground(to: .clear, duration: attributes.exitAnimation.totalDuration)
  236|      0|        }
  237|      0|        
  238|      0|        guard pushOut else {
  239|      0|            clear()
  240|      0|            return
  241|      0|        }
  242|      0|        
  243|      0|        guard let lastBackroundStyle = lastAttributes?.screenBackground else {
  244|      0|            clear()
  245|      0|            return
  246|      0|        }
  247|      0|        
  248|      0|        if lastBackroundStyle != attributes.screenBackground {
  249|      0|            clear()
  250|      0|        }
  251|      0|    }
  252|       |    
  253|      0|    func changeToActive(withAttributes attributes: EKAttributes) {
  254|      0|        changeBackground(to: attributes.screenBackground, duration: attributes.entranceAnimation.totalDuration)
  255|      0|    }
  256|       |    
  257|       |    private func changeBackground(to style: EKAttributes.BackgroundStyle, duration: TimeInterval) {
  258|      0|        DispatchQueue.main.async {
  259|      0|            UIView.animate(withDuration: duration, delay: 0, options: [], animations: {
  260|      0|                self.backgroundView.background = style
  261|      0|            }, completion: nil)
  262|      0|        }
  263|       |    }
  264|       |}
  265|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKStyleView.swift:
    1|       |//
    2|       |//  EKStyleView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/28/18.
    6|       |//
    7|       |
    8|       |class EKStyleView: UIView {
    9|       |    
   10|      0|    private lazy var borderLayer: CAShapeLayer = {
   11|      0|        return CAShapeLayer()
   12|      0|    }()
   13|       |    
   14|       |    private var roundCorners: EKAttributes.RoundCorners!
   15|       |    private var border: EKAttributes.Border!
   16|       |    
   17|       |    var appliedStyle = false
   18|       |    
   19|      0|    func applyFrameStyle(roundCorners: EKAttributes.RoundCorners, border: EKAttributes.Border) {
   20|      0|        self.roundCorners = roundCorners
   21|      0|        self.border = border
   22|      0|        
   23|      0|        var cornerRadius: CGFloat = 0
   24|      0|        var corners: UIRectCorner = []
   25|      0|        (corners, cornerRadius) = roundCorners.cornerValues ?? ([], 0)
   26|      0|        
   27|      0|        let size = CGSize(width: cornerRadius, height: cornerRadius)
   28|      0|        let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: corners, cornerRadii: size)
   29|      0|        
   30|      0|        if !corners.isEmpty && cornerRadius > 0 {
   31|      0|            let maskLayer = CAShapeLayer()
   32|      0|            maskLayer.path = path.cgPath
   33|      0|            layer.mask = maskLayer
   34|      0|        }
   35|      0|        
   36|      0|        if let borderValues = border.borderValues {
   37|      0|            borderLayer.path = path.cgPath
   38|      0|            borderLayer.fillColor = UIColor.clear.cgColor
   39|      0|            borderLayer.strokeColor = borderValues.color.cgColor
   40|      0|            borderLayer.lineWidth = borderValues.width
   41|      0|            borderLayer.frame = bounds
   42|      0|            layer.addSublayer(borderLayer)
   43|      0|        }
   44|      0|        
   45|      0|        appliedStyle = true
   46|      0|    }
   47|       |    
   48|      0|    override func layoutSubviews() {
   49|      0|        super.layoutSubviews()
   50|      0|        guard let roundCorners = roundCorners, let border = border else {
   51|      0|            return
   52|      0|        }
   53|      0|        applyFrameStyle(roundCorners: roundCorners, border: border)
   54|      0|    }
   55|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKWindow.swift:
    1|       |//
    2|       |//  EKWindow.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class EKWindow: UIWindow {
   12|       |    
   13|       |    var isAbleToReceiveTouches = false
   14|       |    
   15|      0|    init(with rootVC: UIViewController) {
   16|      0|        super.init(frame: UIScreen.main.bounds)
   17|      0|        backgroundColor = .clear
   18|      0|        rootViewController = rootVC
   19|      0|    }
   20|       |    
   21|      0|    required init?(coder aDecoder: NSCoder) {
   22|      0|        fatalError("init(coder:) has not been implemented")
   23|      0|    }
   24|       |    
   25|      0|    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
   26|      0|        if isAbleToReceiveTouches {
   27|      0|            return super.hitTest(point, with: event)
   28|      0|        }
   29|      0|        if let view = super.hitTest(point, with: event), view != self {
   30|      0|            return view
   31|      0|        }
   32|      0|        return nil
   33|      0|    }
   34|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKWindowProvider.swift:
    1|       |//
    2|       |//  EKWindowProvider.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |final class EKWindowProvider: EntryPresenterDelegate {
   12|       |    
   13|       |    /** The artificial safe area insets */
   14|      0|    static var safeAreaInsets: UIEdgeInsets {
   15|      0|        if #available(iOS 11.0, *) {
   16|      0|            return EKWindowProvider.shared.entryWindow?.rootViewController?.view?.safeAreaInsets ?? UIApplication.shared.keyWindow?.rootViewController?.view.safeAreaInsets ?? .zero
   17|      0|        } else {
   18|      0|            let statusBarMaxY = UIApplication.shared.statusBarFrame.maxY
   19|      0|            return UIEdgeInsets(top: statusBarMaxY, left: 0, bottom: 10, right: 0)
   20|      0|        }
   21|      0|    }
   22|       |    
   23|       |    /** Single access point */
   24|       |    static let shared = EKWindowProvider()
   25|       |    
   26|       |    /** Current entry window */
   27|       |    var entryWindow: EKWindow!
   28|       |    
   29|       |    /** Returns the root view controller if it is instantiated */
   30|     11|    var rootVC: EKRootViewController? {
   31|     11|        return entryWindow?.rootViewController as? EKRootViewController
   32|     11|    }
   33|       |    
   34|       |    /** A window to go back to when the last entry has been dismissed */
   35|       |    private var rollbackWindow: SwiftEntryKit.RollbackWindow!
   36|       |
   37|       |    /** Entry queueing heuristic  */
   38|       |    private let entryQueue = EKAttributes.Precedence.QueueingHeuristic.value.heuristic
   39|       |    
   40|       |    private weak var entryView: EKEntryView!
   41|       |
   42|       |    /** Cannot be instantiated, customized, inherited */
   43|      1|    private init() {}
   44|       |    
   45|       |    var isResponsiveToTouches: Bool {
   46|      0|        set {
   47|      0|            entryWindow.isAbleToReceiveTouches = newValue
   48|      0|        }
   49|       |        get {
   50|       |            return entryWindow.isAbleToReceiveTouches
   51|       |        }
   52|       |    }
   53|       |    
   54|       |    // MARK: - Setup and Teardown methods
   55|       |    
   56|       |    // Prepare the window and the host view controller
   57|      0|    private func prepare(for attributes: EKAttributes, presentInsideKeyWindow: Bool) -> EKRootViewController? {
   58|      0|        let entryVC = setupWindowAndRootVC()
   59|      0|        guard entryVC.canDisplay(attributes: attributes) || attributes.precedence.isEnqueue else {
   60|      0|            return nil
   61|      0|        }
   62|      0|        entryVC.setStatusBarStyle(for: attributes)
   63|      0|
   64|      0|        entryWindow.windowLevel = attributes.windowLevel.value
   65|      0|        if presentInsideKeyWindow {
   66|      0|            entryWindow.makeKeyAndVisible()
   67|      0|        } else {
   68|      0|            entryWindow.isHidden = false
   69|      0|        }
   70|      0|
   71|      0|        return entryVC
   72|      0|    }
   73|       |    
   74|       |    /** Boilerplate generic setup for entry-window and root-view-controller  */
   75|       |    private func setupWindowAndRootVC() -> EKRootViewController {
   76|       |        let entryVC: EKRootViewController
   77|       |        if entryWindow == nil {
   78|       |            entryVC = EKRootViewController(with: self)
   79|       |            entryWindow = EKWindow(with: entryVC)
   80|       |        } else {
   81|       |            entryVC = rootVC!
   82|       |        }
   83|       |        return entryVC
   84|       |    }
   85|       |    
   86|       |    /**
   87|       |     Privately used to display an entry
   88|       |     */
   89|      0|    private func display(entryView: EKEntryView, using attributes: EKAttributes, presentInsideKeyWindow: Bool, rollbackWindow: SwiftEntryKit.RollbackWindow) {
   90|      0|        switch entryView.attributes.precedence {
   91|      0|        case .override(priority: _, dropEnqueuedEntries: let dropEnqueuedEntries):
   92|      0|            if dropEnqueuedEntries {
   93|      0|                entryQueue.removeAll()
   94|      0|            }
   95|      0|            show(entryView: entryView, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
   96|      0|        case .enqueue where isCurrentlyDisplaying():
   97|      0|            entryQueue.enqueue(entry: .init(view: entryView, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow))
   98|      0|        case .enqueue:
   99|      0|            show(entryView: entryView, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
  100|      0|        }
  101|      0|    }
  102|       |    
  103|       |    // MARK: - Exposed Actions
  104|       |    
  105|      0|    func queueContains(entryNamed name: String? = nil) -> Bool {
  106|      0|        if name == nil && !entryQueue.isEmpty {
  107|      0|            return true
  108|      0|        }
  109|      0|        if let name = name {
  110|      0|            return entryQueue.contains(entryNamed: name)
  111|      0|        } else {
  112|      0|            return false
  113|      0|        }
  114|      0|    }
  115|       |    
  116|       |    /**
  117|       |     Returns *true* if the currently displayed entry has the given name.
  118|       |     In case *name* has the value of *nil*, the result is *true* if any entry is currently displayed.
  119|       |     */
  120|       |    func isCurrentlyDisplaying(entryNamed name: String? = nil) -> Bool {
  121|       |        guard let entryView = entryView else {
  122|       |            return false
  123|       |        }
  124|       |        if let name = name { // Test for names equality
  125|       |            return entryView.content.attributes.name == name
  126|       |        } else { // Return true by default if the name is *nil*
  127|       |            return true
  128|       |        }
  129|       |    }
  130|       |    
  131|       |    /** Transform current entry to view */
  132|      0|    func transform(to view: UIView) {
  133|      0|        entryView?.transform(to: view)
  134|      0|    }
  135|       |    
  136|       |    /** Display a view using attributes */
  137|      0|    func display(view: UIView, using attributes: EKAttributes, presentInsideKeyWindow: Bool, rollbackWindow: SwiftEntryKit.RollbackWindow) {
  138|      0|        let entryView = EKEntryView(newEntry: .init(view: view, attributes: attributes))
  139|      0|        display(entryView: entryView, using: attributes, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
  140|      0|    }
  141|       |
  142|       |    /** Display a view controller using attributes */
  143|      0|    func display(viewController: UIViewController, using attributes: EKAttributes, presentInsideKeyWindow: Bool, rollbackWindow: SwiftEntryKit.RollbackWindow) {
  144|      0|        let entryView = EKEntryView(newEntry: .init(viewController: viewController, attributes: attributes))
  145|      0|        display(entryView: entryView, using: attributes, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
  146|      0|    }
  147|       |    
  148|       |    /** Clear all entries immediately and display to the rollback window */
  149|      0|    func displayRollbackWindow() {
  150|      0|        entryWindow = nil
  151|      0|        entryView = nil
  152|      0|        switch rollbackWindow! {
  153|      0|        case .main:
  154|      0|            UIApplication.shared.keyWindow?.makeKeyAndVisible()
  155|      0|        case .custom(window: let window):
  156|      0|            window.makeKeyAndVisible()
  157|      0|        }
  158|      0|    }
  159|       |    
  160|       |    /** Display a pending entry if there is any inside the queue */
  161|      0|    func displayPendingEntryIfNeeded() {
  162|      0|        if let next = entryQueue.dequeue() {
  163|      0|            show(entryView: next.view, presentInsideKeyWindow: next.presentInsideKeyWindow, rollbackWindow: next.rollbackWindow)
  164|      0|        } else {
  165|      0|            displayRollbackWindow()
  166|      0|        }
  167|      0|    }
  168|       |    
  169|       |    /** Dismiss entries according to a given descriptor */
  170|     11|    func dismiss(_ descriptor: SwiftEntryKit.EntryDismissalDescriptor, with completion: SwiftEntryKit.DismissCompletionHandler? = nil) {
  171|     11|        guard let rootVC = rootVC else {
  172|     11|            return
  173|     11|        }
  174|      0|        
  175|      0|        switch descriptor {
  176|      0|        case .displayed:
  177|      0|            rootVC.animateOutLastEntry(completionHandler: completion)
  178|      0|        case .specific(entryName: let name):
  179|      0|            entryQueue.removeEntries(by: name)
  180|      0|            if entryView?.attributes.name == name {
  181|      0|                rootVC.animateOutLastEntry(completionHandler: completion)
  182|      0|            }
  183|      0|        case .prioritizedLowerOrEqualTo(priority: let priorityThreshold):
  184|      0|            entryQueue.removeEntries(withPriorityLowerOrEqualTo: priorityThreshold)
  185|      0|            if let currentPriority = entryView?.attributes.precedence.priority, currentPriority <= priorityThreshold {
  186|      0|                rootVC.animateOutLastEntry(completionHandler: completion)
  187|      0|            }
  188|      0|        case .enqueued:
  189|      0|            entryQueue.removeAll()
  190|      0|        case .all:
  191|      0|            entryQueue.removeAll()
  192|      0|            rootVC.animateOutLastEntry(completionHandler: completion)
  193|      0|        }
  194|      0|    }
  195|       |    
  196|       |    /** Layout the view-hierarchy rooted in the window */
  197|      0|    func layoutIfNeeded() {
  198|      0|        entryWindow?.layoutIfNeeded()
  199|      0|    }
  200|       |    
  201|       |    /** Privately using to prepare the root view controller and show the entry immediately */
  202|       |    private func show(entryView: EKEntryView, presentInsideKeyWindow: Bool, rollbackWindow: SwiftEntryKit.RollbackWindow) {
  203|       |        guard let entryVC = prepare(for: entryView.attributes, presentInsideKeyWindow: presentInsideKeyWindow) else {
  204|       |            return
  205|       |        }
  206|       |        entryVC.configure(entryView: entryView)
  207|       |        self.entryView = entryView
  208|       |        self.rollbackWindow = rollbackWindow
  209|       |    }
  210|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EKWrapperView.swift:
    1|       |//
    2|       |//  EKWrapperView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class EKWrapperView: UIView {
   12|       |    var isAbleToReceiveTouches = false
   13|      0|    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
   14|      0|        if isAbleToReceiveTouches {
   15|      0|            return super.hitTest(point, with: event)
   16|      0|        }
   17|      0|        if let view = super.hitTest(point, with: event), view != self {
   18|      0|            return view
   19|      0|        }
   20|      0|        return nil
   21|      0|    }
   22|       |}
   23|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Infra/EntryCachingHeuristic.swift:
    1|       |//
    2|       |//  EKEntryCacher.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 9/1/18.
    6|       |//  Copyright  2018 CocoaPods. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |struct CachedEntry {
   12|       |    let view: EKEntryView
   13|       |    let presentInsideKeyWindow: Bool
   14|       |    let rollbackWindow: SwiftEntryKit.RollbackWindow
   15|       |}
   16|       |
   17|       |protocol EntryCachingHeuristic: class {
   18|       |    var entries: [CachedEntry] { set get }
   19|       |    var isEmpty: Bool { get }
   20|       |    
   21|       |    func dequeue() -> CachedEntry?
   22|       |    func enqueue(entry: CachedEntry)
   23|       |    
   24|       |    func removeEntries(by name: String)
   25|       |    func removeEntries(withPriorityLowerOrEqualTo priority: EKAttributes.Precedence.Priority)
   26|       |    func remove(entry: CachedEntry)
   27|       |    func removeAll()
   28|       |    
   29|       |    func contains(entryNamed name: String) -> Bool
   30|       |}
   31|       |
   32|       |extension EntryCachingHeuristic {
   33|       |    
   34|      0|    var isEmpty: Bool {
   35|      0|        return entries.isEmpty
   36|      0|    }
   37|       |    
   38|      0|    func contains(entryNamed name: String) -> Bool {
   39|      0|        return entries.contains { $0.view.attributes.name == name }
   40|      0|    }
   41|       |    
   42|      0|    func dequeue() -> CachedEntry? {
   43|      0|        guard let first = entries.first else {
   44|      0|            return nil
   45|      0|        }
   46|      0|        entries.removeFirst()
   47|      0|        return first
   48|      0|    }
   49|       |    
   50|      0|    func removeEntries(withPriorityLowerOrEqualTo priority: EKAttributes.Precedence.Priority) {
   51|      0|        while let index = (entries.firstIndex { $0.view.attributes.precedence.priority <= priority }) {
   52|      0|            entries.remove(at: index)
   53|      0|        }
   54|      0|    }
   55|       |    
   56|      0|    func removeEntries(by name: String) {
   57|      0|        while let index = (entries.firstIndex { $0.view.attributes.name == name }) {
   58|      0|            entries.remove(at: index)
   59|      0|        }
   60|      0|    }
   61|       |    
   62|      0|    func remove(entry: CachedEntry) {
   63|      0|        guard let index = (entries.firstIndex { $0.view == entry.view }) else {
   64|      0|            return
   65|      0|        }
   66|      0|        entries.remove(at: index)
   67|      0|    }
   68|       |    
   69|      0|    func removeAll() {
   70|      0|        entries.removeAll()
   71|      0|    }
   72|       |}
   73|       |
   74|       |class EKEntryChronologicalQueue: EntryCachingHeuristic {
   75|       |    
   76|       |    var entries: [CachedEntry] = []
   77|       |    
   78|      0|    func enqueue(entry: CachedEntry) {
   79|      0|        entries.append(entry)
   80|      0|    }
   81|       |}
   82|       |
   83|       |class EKEntryPriorityQueue: EntryCachingHeuristic {
   84|       |    
   85|       |    var entries: [CachedEntry] = []
   86|       |    
   87|      0|    func enqueue(entry: CachedEntry) {
   88|      0|        let entryPriority = entry.view.attributes.precedence.priority
   89|      0|        let index = entries.firstIndex {
   90|      0|            return entryPriority > $0.view.attributes.precedence.priority
   91|      0|        }
   92|      0|        if let index = index {
   93|      0|            entries.insert(entry, at: index)
   94|      0|        } else {
   95|      0|            entries.append(entry)
   96|      0|        }
   97|      0|    }
   98|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKAlertMessageView.swift:
    1|       |//
    2|       |//  EKAlertMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/5/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |public class EKAlertMessageView: EKSimpleMessageView, EntryAppearanceDescriptor {
   11|       |    
   12|       |    // MARK: Props
   13|       |    var buttonBarView: EKButtonBarView!
   14|       |    private var buttonsBarCompressedConstraint: NSLayoutConstraint!
   15|       |    private var buttonsBarExpandedConstraint: NSLayoutConstraint!
   16|       |    
   17|       |    // MARK: EntryAppearenceDescriptor
   18|       |    
   19|       |    var bottomCornerRadius: CGFloat = 0 {
   20|      0|        didSet {
   21|      0|            buttonBarView.bottomCornerRadius = bottomCornerRadius
   22|      0|        }
   23|       |    }
   24|       |    
   25|       |    // MARK: Setup
   26|      0|    public init(with message: EKAlertMessage) {
   27|      0|        super.init(with: message.simpleMessage)
   28|      0|        setupButtonBarView(with: message.buttonBarContent)
   29|      0|        layoutContent(with: message)
   30|      0|    }
   31|       |    
   32|      0|    public required init?(coder aDecoder: NSCoder) {
   33|      0|        fatalError("init(coder:) has not been implemented")
   34|      0|    }
   35|       |    
   36|      0|    private func setupButtonBarView(with content: EKProperty.ButtonBarContent) {
   37|      0|        buttonBarView = EKButtonBarView(with: content)
   38|      0|        buttonBarView.clipsToBounds = true
   39|      0|        addSubview(buttonBarView)
   40|      0|    }
   41|       |    
   42|      0|    func layoutContent(with message: EKAlertMessage) {
   43|      0|        switch message.imagePosition {
   44|      0|        case .top:
   45|      0|            messageContentView.verticalMargins = 16
   46|      0|            messageContentView.horizontalMargins = 16
   47|      0|            messageContentView.labelsOffset = 5
   48|      0|            
   49|      0|            if let thumbImageView = thumbImageView {
   50|      0|                thumbImageView.layoutToSuperview(.top, offset: 20)
   51|      0|                thumbImageView.layoutToSuperview(.centerX)
   52|      0|                messageContentView.layout(.top, to: .bottom, of: thumbImageView)
   53|      0|            } else {
   54|      0|                messageContentView.layoutToSuperview(.top)
   55|      0|            }
   56|      0|
   57|      0|            messageContentView.layoutToSuperview(axis: .horizontally)
   58|      0|            buttonBarView.layout(.top, to: .bottom, of: messageContentView)
   59|      0|        case .left:
   60|      0|            messageContentView.verticalMargins = 0
   61|      0|            messageContentView.horizontalMargins = 0
   62|      0|            messageContentView.labelsOffset = 5
   63|      0|            
   64|      0|            if let thumbImageView = thumbImageView {
   65|      0|                thumbImageView.layoutToSuperview(.top, .left, offset: 16)
   66|      0|                messageContentView.layout(.left, to: .right, of: thumbImageView, offset: 12)
   67|      0|                messageContentView.layout(to: .top, of: thumbImageView, offset: 2)
   68|      0|            } else {
   69|      0|                messageContentView.layoutToSuperview(.left, .top, offset: 16)
   70|      0|            }
   71|      0|
   72|      0|            messageContentView.layoutToSuperview(.right, offset: -16)
   73|      0|            buttonBarView.layout(.top, to: .bottom, of: messageContentView, offset: 10)
   74|      0|        }
   75|      0|        
   76|      0|        buttonBarView.layoutToSuperview(axis: .horizontally)
   77|      0|        buttonBarView.layoutToSuperview(.bottom)
   78|      0|        buttonBarView.alpha = 0
   79|      0|
   80|      0|        if !message.buttonBarContent.content.isEmpty {
   81|      0|            if message.buttonBarContent.expandAnimatedly {
   82|      0|                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
   83|      0|                    self.buttonBarView.expand()
   84|      0|                }
   85|      0|            } else {
   86|      0|                buttonBarView.expand()
   87|      0|            }
   88|      0|        }
   89|      0|    }
   90|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKFormMessageView.swift:
    1|       |//
    2|       |//  EKFormMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/15/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |public class EKFormMessageView: UIView {
   11|       |    
   12|       |    private let scrollViewVerticalOffset: CGFloat = 20
   13|       |    
   14|       |    // MARK: Props
   15|       |    
   16|       |    private let titleLabel = UILabel()
   17|       |    private let scrollView = UIScrollView()
   18|       |    private let textFieldsContent: [EKProperty.TextFieldContent]
   19|       |    private var textFieldViews: [EKTextField] = []
   20|       |    private var buttonBarView: EKButtonBarView!
   21|       |    
   22|       |    // MARK: Setup
   23|       |    
   24|      0|    public init(with title: EKProperty.LabelContent, textFieldsContent: [EKProperty.TextFieldContent], buttonContent: EKProperty.ButtonContent) {
   25|      0|        self.textFieldsContent = textFieldsContent
   26|      0|        super.init(frame: UIScreen.main.bounds)
   27|      0|        setupScrollView()
   28|      0|        setupTitleLabel(with: title)
   29|      0|        setupTextFields(with: textFieldsContent)
   30|      0|        setupButton(with: buttonContent)
   31|      0|        setupTapGestureRecognizer()
   32|      0|        scrollView.layoutIfNeeded()
   33|      0|        set(.height, of: scrollView.contentSize.height + scrollViewVerticalOffset * 2, priority: .defaultHigh)
   34|      0|    }
   35|       |    
   36|      0|    required public init?(coder aDecoder: NSCoder) {
   37|      0|        fatalError("init(coder:) has not been implemented")
   38|      0|    }
   39|       |    
   40|      0|    private func setupTextFields(with textFieldsContent: [EKProperty.TextFieldContent]) {
   41|      0|        var textFieldIndex = 0
   42|      0|        textFieldViews = textFieldsContent.map { content -> EKTextField in
   43|      0|            let textField = EKTextField(with: content)
   44|      0|            scrollView.addSubview(textField)
   45|      0|            textField.tag = textFieldIndex
   46|      0|            textFieldIndex += 1
   47|      0|            return textField
   48|      0|        }
   49|      0|        
   50|      0|        textFieldViews.first!.layout(.top, to: .bottom, of: titleLabel, offset: 20)
   51|      0|        textFieldViews.spread(.vertically, offset: 5)
   52|      0|        textFieldViews.layoutToSuperview(axis: .horizontally)
   53|      0|    }
   54|       |    
   55|       |    // Setup tap gesture
   56|      0|    private func setupTapGestureRecognizer() {
   57|      0|        let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(tapGestureRecognized))
   58|      0|        tapGestureRecognizer.numberOfTapsRequired = 1
   59|      0|        addGestureRecognizer(tapGestureRecognizer)
   60|      0|    }
   61|       |    
   62|      0|    private func setupScrollView() {
   63|      0|        addSubview(scrollView)
   64|      0|        scrollView.layoutToSuperview(axis: .horizontally, offset: 20)
   65|      0|        scrollView.layoutToSuperview(axis: .vertically, offset: scrollViewVerticalOffset)
   66|      0|        scrollView.layoutToSuperview(.width, .height, offset: -scrollViewVerticalOffset * 2)
   67|      0|    }
   68|       |    
   69|      0|    private func setupTitleLabel(with content: EKProperty.LabelContent) {
   70|      0|        scrollView.addSubview(titleLabel)
   71|      0|        titleLabel.layoutToSuperview(.top, .width)
   72|      0|        titleLabel.layoutToSuperview(axis: .horizontally)
   73|      0|        titleLabel.forceContentWrap(.vertically)
   74|      0|        titleLabel.content = content
   75|      0|    }
   76|       |    
   77|      0|    private func setupButton(with buttonContent: EKProperty.ButtonContent) {
   78|      0|        var buttonContent = buttonContent
   79|      0|        let action = buttonContent.action
   80|      0|        buttonContent.action = { [weak self] in
   81|      0|            self?.extractTextFieldsContent()
   82|      0|            action?()
   83|      0|        }
   84|      0|        let buttonsBarContent = EKProperty.ButtonBarContent(with: buttonContent, separatorColor: .clear, expandAnimatedly: true)
   85|      0|        buttonBarView = EKButtonBarView(with: buttonsBarContent)
   86|      0|        buttonBarView.clipsToBounds = true
   87|      0|        scrollView.addSubview(buttonBarView)
   88|      0|        buttonBarView.expand()
   89|      0|        buttonBarView.layout(.top, to: .bottom, of: textFieldViews.last!, offset: 20)
   90|      0|        buttonBarView.layoutToSuperview(.centerX)
   91|      0|        buttonBarView.layoutToSuperview(.width, offset: -40)
   92|      0|        buttonBarView.layoutToSuperview(.bottom)
   93|      0|        buttonBarView.layer.cornerRadius = 5
   94|      0|    }
   95|       |    
   96|      0|    private func extractTextFieldsContent() {
   97|      0|        for (content, textField) in zip(textFieldsContent, textFieldViews) {
   98|      0|            content.contentWrapper.text = textField.text
   99|      0|        }
  100|      0|    }
  101|       |    
  102|       |    /** Makes a specific text field the first responder */
  103|      0|    public func becomeFirstResponder(with textFieldIndex: Int) {
  104|      0|        textFieldViews[textFieldIndex].makeFirstResponder()
  105|      0|    }
  106|       |    
  107|       |    // Tap Gesture
  108|      0|    @objc func tapGestureRecognized() {
  109|      0|        endEditing(true)
  110|      0|    }
  111|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKMessageContentView.swift:
    1|       |//
    2|       |//  EKMessageContentView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |public class EKMessageContentView: UIView {
   13|       |    
   14|       |    private let titleLabel = UILabel()
   15|       |    private let subtitleLabel = UILabel()
   16|       |    
   17|       |    private var horizontalConstraints: QLAxisConstraints!
   18|       |    private var topConstraint: NSLayoutConstraint!
   19|       |    private var bottomConstraint: NSLayoutConstraint!
   20|       |    private var labelsOffsetConstraint: NSLayoutConstraint!
   21|       |    
   22|       |    public var titleContent: EKProperty.LabelContent! {
   23|      0|        didSet {
   24|      0|            titleLabel.content = titleContent
   25|      0|        }
   26|       |    }
   27|       |    
   28|       |    public var subtitleContent: EKProperty.LabelContent! {
   29|      0|        didSet {
   30|      0|            subtitleLabel.content = subtitleContent
   31|      0|        }
   32|       |    }
   33|       |    
   34|       |    public var titleAttributes: EKProperty.LabelStyle! {
   35|      0|        didSet {
   36|      0|            titleLabel.style = titleAttributes
   37|      0|        }
   38|       |    }
   39|       |    
   40|       |    public var subtitleAttributes: EKProperty.LabelStyle! {
   41|      0|        didSet {
   42|      0|            subtitleLabel.style = subtitleAttributes
   43|      0|        }
   44|       |    }
   45|       |    
   46|       |    public var title: String! {
   47|      0|        didSet {
   48|      0|            titleLabel.text = title
   49|      0|        }
   50|       |    }
   51|       |    
   52|       |    public var subtitle: String! {
   53|      0|        didSet {
   54|      0|            subtitleLabel.text = subtitle
   55|      0|        }
   56|       |    }
   57|       |    
   58|       |    public var verticalMargins: CGFloat = 20 {
   59|      0|        didSet {
   60|      0|            topConstraint.constant = verticalMargins
   61|      0|            bottomConstraint.constant = -verticalMargins
   62|      0|            layoutIfNeeded()
   63|      0|        }
   64|       |    }
   65|       |    
   66|       |    public var horizontalMargins: CGFloat = 20 {
   67|      0|        didSet {
   68|      0|            horizontalConstraints.first.constant = horizontalMargins
   69|      0|            horizontalConstraints.second.constant = -horizontalMargins
   70|      0|            layoutIfNeeded()
   71|      0|        }
   72|       |    }
   73|       |    
   74|       |    public var labelsOffset: CGFloat = 8 {
   75|      0|        didSet {
   76|      0|            labelsOffsetConstraint.constant = labelsOffset
   77|      0|            layoutIfNeeded()
   78|      0|        }
   79|       |    }
   80|       |    
   81|       |    // MARK: Setup
   82|       |    
   83|      0|    public init() {
   84|      0|        super.init(frame: UIScreen.main.bounds)
   85|      0|        clipsToBounds = true
   86|      0|        setupTitleLabel()
   87|      0|        setupSubtitleLabel()
   88|      0|    }
   89|       |    
   90|      0|    public required init?(coder aDecoder: NSCoder) {
   91|      0|        fatalError("init(coder:) has not been implemented")
   92|      0|    }
   93|       |    
   94|      0|    private func setupTitleLabel() {
   95|      0|        addSubview(titleLabel)
   96|      0|        topConstraint = titleLabel.layoutToSuperview(.top, offset: verticalMargins)
   97|      0|        horizontalConstraints = titleLabel.layoutToSuperview(axis: .horizontally, offset: horizontalMargins)
   98|      0|        titleLabel.forceContentWrap(.vertically)
   99|      0|    }
  100|       |    
  101|      0|    private func setupSubtitleLabel() {
  102|      0|        addSubview(subtitleLabel)
  103|      0|        labelsOffsetConstraint = subtitleLabel.layout(.top, to: .bottom, of: titleLabel, offset: labelsOffset)
  104|      0|        subtitleLabel.layout(to: .left, of: titleLabel)
  105|      0|        subtitleLabel.layout(to: .right, of: titleLabel)
  106|      0|        bottomConstraint = subtitleLabel.layoutToSuperview(.bottom, offset: -verticalMargins, priority: .must)
  107|      0|        subtitleLabel.forceContentWrap(.vertically)
  108|      0|    }
  109|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKNotificationMessageView.swift:
    1|       |//
    2|       |//  EKNotificationMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public class EKNotificationMessageView: EKSimpleMessageView {
   12|       |    
   13|       |    // MARK: Props
   14|       |    private var auxLabel: UILabel!
   15|       |    
   16|       |    // MARK: Setup
   17|      0|    public init(with message: EKNotificationMessage) {
   18|      0|        super.init(with: message.simpleMessage)
   19|      0|        setupAuxLabel(with: message.auxiliary)
   20|      0|        layoutContent(with: message.insets)
   21|      0|    }
   22|       |    
   23|      0|    public required init?(coder aDecoder: NSCoder) {
   24|      0|        fatalError("init(coder:) has not been implemented")
   25|      0|    }
   26|       |    
   27|      0|    private func setupAuxLabel(with content: EKProperty.LabelContent?) {
   28|      0|        guard let content = content else {
   29|      0|            return
   30|      0|        }
   31|      0|        auxLabel = UILabel()
   32|      0|        auxLabel.content = content
   33|      0|        addSubview(auxLabel)
   34|      0|    }
   35|       |    
   36|      0|    private func layoutContent(with insets: EKNotificationMessage.Insets) {
   37|      0|        
   38|      0|        messageContentView.verticalMargins = 0
   39|      0|        messageContentView.horizontalMargins = 0
   40|      0|        messageContentView.labelsOffset = insets.titleToDescription
   41|      0|        
   42|      0|        if let thumbImageView = thumbImageView {
   43|      0|            thumbImageView.layoutToSuperview(.left, offset: insets.contentInsets.left)
   44|      0|            thumbImageView.layoutToSuperview(.top, offset: insets.contentInsets.top)
   45|      0|            messageContentView.layout(.left, to: .right, of: thumbImageView, offset: 12)
   46|      0|            messageContentView.layout(to: .top, of: thumbImageView, offset: 4)
   47|      0|        } else {
   48|      0|            messageContentView.layoutToSuperview(.left, offset: insets.contentInsets.left)
   49|      0|            messageContentView.layoutToSuperview(.top, offset: insets.contentInsets.top)
   50|      0|        }
   51|      0|
   52|      0|        if let auxLabel = auxLabel {
   53|      0|            auxLabel.layoutToSuperview(.right, offset: -insets.contentInsets.right)
   54|      0|            auxLabel.layoutToSuperview(.top, offset: insets.contentInsets.top + 2)
   55|      0|            auxLabel.forceContentWrap()
   56|      0|            messageContentView.layout(.right, to: .left, of: auxLabel)
   57|      0|        } else {
   58|      0|            messageContentView.layoutToSuperview(.right, offset: -insets.contentInsets.right)
   59|      0|        }
   60|      0|        messageContentView.layoutToSuperview(.bottom, offset: -insets.contentInsets.bottom)
   61|      0|    }
   62|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKPopUpMessageView.swift:
    1|       |//
    2|       |//  EKPopUpMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public class EKPopUpMessageView: UIView {
   12|       |
   13|       |    // MARK: Props
   14|       |    private var imageView: UIImageView!
   15|       |    private let titleLabel = UILabel()
   16|       |    private let descriptionLabel = UILabel()
   17|       |    private let actionButton = UIButton()
   18|       |    
   19|       |    private let message: EKPopUpMessage
   20|       |    
   21|       |    // MARK: Setup
   22|      0|    public init(with message: EKPopUpMessage) {
   23|      0|        self.message = message
   24|      0|        super.init(frame: UIScreen.main.bounds)
   25|      0|        setupImageView()
   26|      0|        setupTitleLabel()
   27|      0|        setupDescriptionLabel()
   28|      0|        setupActionButton()
   29|      0|    }
   30|       |    
   31|      0|    public required init?(coder aDecoder: NSCoder) {
   32|      0|        fatalError("init(coder:) has not been implemented")
   33|      0|    }
   34|       |    
   35|      0|    private func setupImageView() {
   36|      0|        guard let themeImage = message.themeImage else {
   37|      0|            return
   38|      0|        }
   39|      0|        imageView = UIImageView()
   40|      0|        addSubview(imageView)
   41|      0|        imageView.layoutToSuperview(.centerX)
   42|      0|        switch themeImage.position {
   43|      0|        case .centerToTop(offset: let value):
   44|      0|            imageView.layout(.centerY, to: .top, of: self, offset: value)
   45|      0|        case .topToTop(offset: let value):
   46|      0|            imageView.layoutToSuperview(.top, offset: value)
   47|      0|        }
   48|      0|        imageView.imageContent = themeImage.image
   49|      0|    }
   50|       |    
   51|      0|    private func setupTitleLabel() {
   52|      0|        addSubview(titleLabel)
   53|      0|        titleLabel.content = message.title
   54|      0|        titleLabel.layoutToSuperview(axis: .horizontally, offset: 30)
   55|      0|        if let imageView = imageView {
   56|      0|            titleLabel.layout(.top, to: .bottom, of: imageView, offset: 20)
   57|      0|        } else {
   58|      0|            titleLabel.layoutToSuperview(.top, offset: 20)
   59|      0|        }
   60|      0|        titleLabel.forceContentWrap(.vertically)
   61|      0|    }
   62|       |    
   63|      0|    private func setupDescriptionLabel() {
   64|      0|        addSubview(descriptionLabel)
   65|      0|        descriptionLabel.content = message.description
   66|      0|        descriptionLabel.layoutToSuperview(axis: .horizontally, offset: 30)
   67|      0|        descriptionLabel.layout(.top, to: .bottom, of: titleLabel, offset: 16)
   68|      0|        descriptionLabel.forceContentWrap(.vertically)
   69|      0|    }
   70|       |    
   71|      0|    private func setupActionButton() {
   72|      0|        addSubview(actionButton)
   73|      0|        let height: CGFloat = 45
   74|      0|        actionButton.set(.height, of: height)
   75|      0|        actionButton.layout(.top, to: .bottom, of: descriptionLabel, offset: 30)
   76|      0|        actionButton.layoutToSuperview(.bottom, offset: -30)
   77|      0|        actionButton.layoutToSuperview(.centerX)
   78|      0|        
   79|      0|        let buttonAttributes = message.button
   80|      0|        actionButton.buttonContent = buttonAttributes
   81|      0|        actionButton.contentEdgeInsets = UIEdgeInsets(top: 0, left: 30, bottom: 0, right: 30)
   82|      0|        actionButton.layer.cornerRadius = height * 0.5
   83|      0|        actionButton.addTarget(self, action: #selector(actionButtonPressed), for: .touchUpInside)
   84|      0|        
   85|      0|        let tapColor = buttonAttributes.label.style.color.withAlphaComponent(0.8)
   86|      0|        actionButton.setTitleColor(tapColor, for: .highlighted)
   87|      0|        actionButton.setTitleColor(tapColor, for: .selected)
   88|      0|    }
   89|       |    
   90|      0|    @objc func actionButtonPressed() {
   91|      0|        message.action()
   92|      0|    }
   93|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKRatingMessageView.swift:
    1|       |//
    2|       |//  EKRatingMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |public class EKRatingMessageView: UIView, EntryAppearanceDescriptor {
   13|       |
   14|       |    // MARK: Properties
   15|       |    
   16|       |    private var message: EKRatingMessage
   17|       |
   18|       |    // MARK: EntryAppearenceDescriptor
   19|       |
   20|       |    var bottomCornerRadius: CGFloat = 0 {
   21|      0|        didSet {
   22|      0|            buttonBarView.bottomCornerRadius = bottomCornerRadius
   23|      0|        }
   24|       |    }
   25|       |    
   26|       |    private var selectedIndex: Int! {
   27|      0|        didSet {
   28|      0|            message.selectedIndex = selectedIndex
   29|      0|            let item = message.ratingItems[selectedIndex]
   30|      0|            set(title: item.title, description: item.description)
   31|      0|        }
   32|       |    }
   33|       |    
   34|       |    private let messageContentView = EKMessageContentView()
   35|       |    private let symbolsView = EKRatingSymbolsContainerView()
   36|       |    private var buttonBarView: EKButtonBarView!
   37|       |
   38|      0|    public init(with message: EKRatingMessage) {
   39|      0|        self.message = message
   40|      0|        super.init(frame: UIScreen.main.bounds)
   41|      0|        setupMessageContentView()
   42|      0|        setupSymbolsView()
   43|      0|        setupButtonBarView()
   44|      0|        set(title: message.initialTitle, description: message.initialDescription)
   45|      0|    }
   46|       |    
   47|      0|    required public init?(coder aDecoder: NSCoder) {
   48|      0|        fatalError("init(coder:) has not been implemented")
   49|      0|    }
   50|       |    
   51|      0|    private func set(title: EKProperty.LabelContent, description: EKProperty.LabelContent) {
   52|      0|        self.messageContentView.titleContent = title
   53|      0|        self.messageContentView.subtitleContent = description
   54|      0|        UIView.animate(withDuration: 0.4, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 0, options: [.transitionCrossDissolve], animations: {
   55|      0|            SwiftEntryKit.layoutIfNeeded()
   56|      0|        }, completion: nil)
   57|      0|    }
   58|       |    
   59|      0|    private func setupMessageContentView() {
   60|      0|        addSubview(messageContentView)
   61|      0|        messageContentView.verticalMargins = 20
   62|      0|        messageContentView.horizontalMargins = 30
   63|      0|        messageContentView.layoutToSuperview(axis: .horizontally, priority: .must)
   64|      0|        messageContentView.layoutToSuperview(.top, offset: 10)
   65|      0|    }
   66|       |    
   67|      0|    private func setupSymbolsView() {
   68|      0|        addSubview(symbolsView)
   69|      0|        symbolsView.setup(with: message) { [unowned self] (index: Int) in
   70|      0|            self.message.selectedIndex = index
   71|      0|            self.message.selection?(index)
   72|      0|            self.selectedIndex = index
   73|      0|            self.animateIn()
   74|      0|        }
   75|      0|        symbolsView.layoutToSuperview(.centerX)
   76|      0|        symbolsView.layout(.top, to: .bottom, of: messageContentView, offset: 10, priority: .must)
   77|      0|    }
   78|       |
   79|      0|    private func setupButtonBarView() {
   80|      0|        buttonBarView = EKButtonBarView(with: message.buttonBarContent)
   81|      0|        buttonBarView.clipsToBounds = true
   82|      0|        buttonBarView.alpha = 0
   83|      0|        addSubview(buttonBarView)
   84|      0|        buttonBarView.layout(.top, to: .bottom, of: symbolsView, offset: 30)
   85|      0|        buttonBarView.layoutToSuperview(.bottom)
   86|      0|        buttonBarView.layoutToSuperview(axis: .horizontally)
   87|      0|    }
   88|       |    
   89|       |    // MARK: Internal Animation
   90|      0|    private func animateIn() {
   91|      0|        layoutIfNeeded()
   92|      0|        buttonBarView.expand()
   93|      0|    }
   94|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/EKSimpleMessageView.swift:
    1|       |//
    2|       |//  EKMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/5/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |public class EKSimpleMessageView: UIView {
   11|       |
   12|       |    // MARK: Props
   13|       |    var thumbImageView: UIImageView!
   14|       |    let messageContentView = EKMessageContentView()
   15|       |    
   16|       |    // MARK: Setup
   17|      0|    init(with message: EKSimpleMessage) {
   18|      0|        super.init(frame: UIScreen.main.bounds)
   19|      0|        setupThumbImageView(with: message.image)
   20|      0|        setupMessageContentView(with: message.title, description: message.description)
   21|      0|    }
   22|       |    
   23|      0|    required public init?(coder aDecoder: NSCoder) {
   24|      0|        fatalError("init(coder:) has not been implemented")
   25|      0|    }
   26|       |    
   27|      0|    private func setupThumbImageView(with content: EKProperty.ImageContent?) {
   28|      0|        guard let content = content else {
   29|      0|            return
   30|      0|        }
   31|      0|        thumbImageView = UIImageView()
   32|      0|        addSubview(thumbImageView)
   33|      0|        thumbImageView.imageContent = content
   34|      0|    }
   35|       |    
   36|      0|    private func setupMessageContentView(with title: EKProperty.LabelContent, description: EKProperty.LabelContent) {
   37|      0|        messageContentView.titleContent = title
   38|      0|        messageContentView.subtitleContent = description
   39|      0|        addSubview(messageContentView)
   40|      0|    }    
   41|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/MessagesUtils/EKButtonBarView.swift:
    1|       |//
    2|       |//  ButtonsBarView.swift
    3|       |//  SwiftEntryKit_Example
    4|       |//
    5|       |//  Created by Daniel Huri on 4/28/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |/**
   13|       | Dynamic button bar view
   14|       | Buttons are set according to the received content.
   15|       | 1-2 buttons spread horizontally
   16|       | 3 or more buttons spread vertically
   17|       | */
   18|       |public class EKButtonBarView: UIView {
   19|       |    
   20|       |    // MARK: Props
   21|       |    private var buttonViews: [EKButtonView] = []
   22|       |    
   23|       |    private let buttonBarContent: EKProperty.ButtonBarContent
   24|       |    private let spreadAxis: QLAxis
   25|       |    private let oppositeAxis: QLAxis
   26|       |    private let relativeEdge: NSLayoutConstraint.Attribute
   27|       |    
   28|       |    var bottomCornerRadius: CGFloat = 0 {
   29|      0|        didSet {
   30|      0|            adjustRoundCornersIfNecessary()
   31|      0|        }
   32|       |    }
   33|       |    
   34|      0|    private lazy var buttonEdgeRatio: CGFloat = {
   35|      0|        return 1.0 / CGFloat(self.buttonBarContent.content.count)
   36|      0|    }()
   37|       |    
   38|      0|    private(set) lazy var intrinsicHeight: CGFloat = {
   39|      0|        var height: CGFloat = 0
   40|      0|        switch buttonBarContent.content.count {
   41|      0|        case 0:
   42|      0|            height += 1
   43|      0|        case 1...buttonBarContent.horizontalDistributionThreshold:
   44|      0|            height += buttonBarContent.buttonHeight
   45|      0|        default:
   46|      0|            for _ in 1...buttonBarContent.content.count {
   47|      0|                height += buttonBarContent.buttonHeight
   48|      0|            }
   49|      0|        }
   50|      0|        return height
   51|      0|    }()
   52|       |    
   53|       |    private var compressedConstraint: NSLayoutConstraint!
   54|      0|    private lazy var expandedConstraint: NSLayoutConstraint = {
   55|      0|        return set(.height, of: intrinsicHeight, priority: .defaultLow)
   56|      0|    }()
   57|       |
   58|       |    // MARK: Setup
   59|      0|    required public init?(coder aDecoder: NSCoder) {
   60|      0|        fatalError("init(coder:) has not been implemented")
   61|      0|    }
   62|       |    
   63|      0|    public init(with buttonBarContent: EKProperty.ButtonBarContent) {
   64|      0|        self.buttonBarContent = buttonBarContent
   65|      0|        if buttonBarContent.content.count <= buttonBarContent.horizontalDistributionThreshold {
   66|      0|            spreadAxis = .horizontally
   67|      0|            oppositeAxis = .vertically
   68|      0|            relativeEdge = .width
   69|      0|        } else {
   70|      0|            spreadAxis = .vertically
   71|      0|            oppositeAxis = .horizontally
   72|      0|            relativeEdge = .height
   73|      0|        }
   74|      0|        super.init(frame: .zero)
   75|      0|        setupButtonBarContent()
   76|      0|        setupSeparatorViews()
   77|      0|        
   78|      0|        compressedConstraint = set(.height, of: 1, priority: .must)
   79|      0|    }
   80|       |    
   81|      0|    public override func layoutSubviews() {
   82|      0|        super.layoutSubviews()
   83|      0|        adjustRoundCornersIfNecessary()
   84|      0|    }
   85|       |
   86|      0|    private func setupButtonBarContent() {
   87|      0|        for content in buttonBarContent.content {
   88|      0|            let buttonView = EKButtonView(content: content)
   89|      0|            addSubview(buttonView)
   90|      0|            buttonViews.append(buttonView)
   91|      0|        }
   92|      0|        layoutButtons()
   93|      0|    }
   94|       |    
   95|      0|    private func layoutButtons() {
   96|      0|        guard !buttonViews.isEmpty else {
   97|      0|            return
   98|      0|        }
   99|      0|        let suffix = Array(buttonViews.dropFirst())
  100|      0|        if !suffix.isEmpty {
  101|      0|            suffix.layout(.height, to: buttonViews.first!)
  102|      0|        }
  103|      0|        buttonViews.layoutToSuperview(axis: oppositeAxis)
  104|      0|        buttonViews.spread(spreadAxis, stretchEdgesToSuperview: true)
  105|      0|        buttonViews.layout(relativeEdge, to: self, ratio: buttonEdgeRatio, priority: .must)
  106|      0|    }
  107|       |    
  108|      0|    private func setupTopSeperatorView() {
  109|      0|        let topSeparatorView = UIView()
  110|      0|        addSubview(topSeparatorView)
  111|      0|        topSeparatorView.set(.height, of: 1)
  112|      0|        topSeparatorView.layoutToSuperview(.left, .right, .top)
  113|      0|        topSeparatorView.backgroundColor = buttonBarContent.separatorColor
  114|      0|    }
  115|       |    
  116|      0|    private func setupSeperatorView(after view: UIView) {
  117|      0|        let midSepView = UIView()
  118|      0|        addSubview(midSepView)
  119|      0|        let sepAttribute: NSLayoutConstraint.Attribute
  120|      0|        let buttonAttribute: NSLayoutConstraint.Attribute
  121|      0|        switch oppositeAxis {
  122|      0|        case .vertically:
  123|      0|            sepAttribute = .centerX
  124|      0|            buttonAttribute = .right
  125|      0|        case .horizontally:
  126|      0|            sepAttribute = .centerY
  127|      0|            buttonAttribute = .bottom
  128|      0|        }
  129|      0|        midSepView.layout(sepAttribute, to: buttonAttribute, of: view)
  130|      0|        midSepView.set(relativeEdge, of: 1)
  131|      0|        midSepView.layoutToSuperview(axis: oppositeAxis)
  132|      0|        midSepView.backgroundColor = buttonBarContent.separatorColor
  133|      0|    }
  134|       |    
  135|      0|    private func setupSeparatorViews() {
  136|      0|        setupTopSeperatorView()
  137|      0|        for button in buttonViews.dropLast() {
  138|      0|            setupSeperatorView(after: button)
  139|      0|        }
  140|      0|    }
  141|       |    
  142|       |    // Amination
  143|      0|    public func expand() {
  144|      0|        
  145|      0|        let expansion = {
  146|      0|            self.compressedConstraint.priority = .defaultLow
  147|      0|            self.expandedConstraint.priority = .must
  148|      0|            
  149|      0|            /* NOTE: Calling layoutIfNeeded for the whole view hierarchy.
  150|      0|             Sometimes it's easier to just use frames instead of AutoLayout for
  151|      0|             hierarch complexity considerations. Here the animation influences almost the
  152|      0|             entire view hierarchy. */
  153|      0|            SwiftEntryKit.layoutIfNeeded()
  154|      0|        }
  155|      0|        
  156|      0|        alpha = 1
  157|      0|        if buttonBarContent.expandAnimatedly {
  158|      0|            let damping: CGFloat = buttonBarContent.content.count <= 2 ? 0.4 : 0.8
  159|      0|            SwiftEntryKit.layoutIfNeeded()
  160|      0|            UIView.animate(withDuration: 0.8, delay: 0, usingSpringWithDamping: damping, initialSpringVelocity: 0, options: [.beginFromCurrentState, .allowUserInteraction, .layoutSubviews, .allowAnimatedContent], animations: {
  161|      0|                expansion()
  162|      0|            }, completion: nil)
  163|      0|        } else {
  164|      0|            expansion()
  165|      0|        }
  166|      0|    }
  167|       |    
  168|      0|    public func compress() {
  169|      0|        compressedConstraint.priority = .must
  170|      0|        expandedConstraint.priority = .defaultLow
  171|      0|    }
  172|       |    
  173|      0|    private func adjustRoundCornersIfNecessary() {
  174|      0|        let size = CGSize(width: bottomCornerRadius, height: bottomCornerRadius)
  175|      0|        let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: .bottom, cornerRadii: size)
  176|      0|        let maskLayer = CAShapeLayer()
  177|      0|        maskLayer.path = path.cgPath
  178|      0|        layer.mask = maskLayer
  179|      0|    }
  180|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/MessagesUtils/EKButtonView.swift:
    1|       |//
    2|       |//  EKButtonView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 12/8/18.
    6|       |//  Copyright  2018 CocoaPods. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class EKButtonView: UIView {
   12|       |
   13|       |    // MARK: - Properties
   14|       |    
   15|       |    private let button = UIButton()
   16|       |    private let titleLabel = UILabel()
   17|       |    
   18|       |    private let content: EKProperty.ButtonContent
   19|       |    
   20|       |    // MARK: - Setup
   21|       |    
   22|      0|    init(content: EKProperty.ButtonContent) {
   23|      0|        self.content = content
   24|      0|        super.init(frame: .zero)
   25|      0|        setupTitleLabel()
   26|      0|        setupButton()
   27|      0|    }
   28|       |    
   29|      0|    required init?(coder aDecoder: NSCoder) {
   30|      0|        fatalError("init(coder:) has not been implemented")
   31|      0|    }
   32|       |    
   33|      0|    private func setupButton() {
   34|      0|        addSubview(button)
   35|      0|        button.fillSuperview()
   36|      0|        button.addTarget(self, action: #selector(buttonTouchUp), for: [.touchUpInside, .touchUpOutside, .touchCancel])
   37|      0|        button.addTarget(self, action: #selector(buttonTouchDown), for: .touchDown)
   38|      0|        button.addTarget(self, action: #selector(buttonTouchUpInside), for: .touchUpInside)
   39|      0|    }
   40|       |    
   41|      0|    private func setupTitleLabel() {
   42|      0|        titleLabel.numberOfLines = content.label.style.numberOfLines
   43|      0|        titleLabel.font = content.label.style.font
   44|      0|        titleLabel.textColor = content.label.style.color
   45|      0|        titleLabel.text = content.label.text
   46|      0|        titleLabel.textAlignment = .center
   47|      0|        titleLabel.lineBreakMode = .byWordWrapping
   48|      0|        backgroundColor = content.backgroundColor
   49|      0|        addSubview(titleLabel)
   50|      0|        titleLabel.layoutToSuperview(axis: .horizontally, offset: content.contentEdgeInset)
   51|      0|        titleLabel.layoutToSuperview(axis: .vertically, offset: content.contentEdgeInset)
   52|      0|    }
   53|       |    
   54|      0|    private func setBackground(by content: EKProperty.ButtonContent, isHighlighted: Bool) {
   55|      0|        if isHighlighted {
   56|      0|            backgroundColor = content.highlightedBackgroundColor
   57|      0|        } else {
   58|      0|            backgroundColor = content.backgroundColor
   59|      0|        }
   60|      0|    }
   61|       |    
   62|       |    // MARK: - Selectors
   63|       |    
   64|      0|    @objc func buttonTouchUpInside() {
   65|      0|        content.action?()
   66|      0|    }
   67|       |    
   68|      0|    @objc func buttonTouchDown() {
   69|      0|        setBackground(by: content, isHighlighted: true)
   70|      0|    }
   71|       |    
   72|      0|    @objc func buttonTouchUp() {
   73|      0|        setBackground(by: content, isHighlighted: false)
   74|      0|    }
   75|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/MessagesUtils/EKRatingSymbolView.swift:
    1|       |//
    2|       |//  EKRatingSymbolView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public class EKRatingSymbolView: UIView {
   12|       |    
   13|       |    private let button = UIButton()
   14|       |    private let imageView = UIImageView()
   15|       |    
   16|       |    private let unselectedImage: EKProperty.ImageContent
   17|       |    private let selectedImage: EKProperty.ImageContent
   18|       |    
   19|       |    var selection: EKRatingMessage.Selection
   20|       |    
   21|       |    public var isSelected: Bool {
   22|      0|        set {
   23|      0|            imageView.imageContent = newValue ? selectedImage : unselectedImage
   24|      0|        }
   25|       |        get {
   26|       |            return imageView.animationImages == selectedImage.images
   27|       |        }
   28|       |    }
   29|       |    
   30|      0|    public init(unselectedImage: EKProperty.ImageContent, selectedImage: EKProperty.ImageContent, selection: @escaping EKRatingMessage.Selection) {
   31|      0|        self.unselectedImage = unselectedImage
   32|      0|        self.selectedImage = selectedImage
   33|      0|        self.selection = selection
   34|      0|        super.init(frame: .zero)
   35|      0|        setupImageView()
   36|      0|        setupButton()
   37|      0|    }
   38|       |    
   39|      0|    required public init?(coder aDecoder: NSCoder) {
   40|      0|        fatalError("init(coder:) has not been implemented")
   41|      0|    }
   42|       |    
   43|      0|    private func setupButton() {
   44|      0|        addSubview(button)
   45|      0|        button.fillSuperview()
   46|      0|        button.addTarget(self, action: #selector(touchUpInside), for: .touchUpInside)
   47|      0|        button.addTarget(self, action: #selector(touchDown), for: [.touchDown])
   48|      0|        button.addTarget(self, action: #selector(touchUp), for: [.touchUpInside, .touchUpOutside, .touchCancel])
   49|      0|    }
   50|       |    
   51|      0|    private func setupImageView() {
   52|      0|        addSubview(imageView)
   53|      0|        imageView.imageContent = unselectedImage
   54|      0|        imageView.centerInSuperview()
   55|      0|        imageView.sizeToSuperview(withRatio: 0.7)
   56|      0|    }
   57|       |    
   58|      0|    @objc func touchUpInside() {
   59|      0|        selection(tag)
   60|      0|    }
   61|       |    
   62|      0|    @objc func touchDown() {
   63|      0|        transform = CGAffineTransform(scaleX: 1.15, y: 1.15)
   64|      0|    }
   65|       |    
   66|      0|    @objc func touchUp() {
   67|      0|        transform = CGAffineTransform(scaleX: 1, y: 1)
   68|      0|    }
   69|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/MessagesUtils/EKRatingSymbolsContainerView.swift:
    1|       |//
    2|       |//  EKRatingSymbolsContainerView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public class EKRatingSymbolsContainerView: UIView {
   12|       |    
   13|       |    private var message: EKRatingMessage!
   14|       |    private var symbolsArray: [EKRatingSymbolView] = []
   15|       |    
   16|      0|    public func setup(with message: EKRatingMessage, externalSelection: @escaping EKRatingMessage.Selection) {
   17|      0|        self.message = message
   18|      0|        let internalSelection = { [unowned self] (index: Int) in
   19|      0|            self.select(index: index)
   20|      0|            externalSelection(index)
   21|      0|        }
   22|      0|        
   23|      0|        for (index, item) in message.ratingItems.enumerated() {
   24|      0|            let itemView = EKRatingSymbolView(unselectedImage: item.unselectedImage, selectedImage: item.selectedImage, selection: internalSelection)
   25|      0|            itemView.tag = index
   26|      0|            addSubview(itemView)
   27|      0|            itemView.set(.width, .height, of: 50)
   28|      0|            symbolsArray.append(itemView)
   29|      0|        }
   30|      0|        symbolsArray.layoutToSuperview(axis: .vertically, priority: .must)
   31|      0|        symbolsArray.spread(.horizontally, stretchEdgesToSuperview: true)
   32|      0|        
   33|      0|        select()
   34|      0|    }
   35|       |    
   36|      0|    private func select(index: Int? = nil) {
   37|      0|        var delay: TimeInterval = 0
   38|      0|        for (i, view) in symbolsArray.enumerated() {
   39|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
   40|      0|                if let index = index, i <= index {
   41|      0|                    view.isSelected = true
   42|      0|                    view.transform = CGAffineTransform(scaleX: 1.5, y: 1.5)
   43|      0|                } else if view.isSelected || index == nil {
   44|      0|                    view.isSelected = false
   45|      0|                    view.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)
   46|      0|                }
   47|      0|                UIView.animate(withDuration: 0.6, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0, options: [.allowUserInteraction], animations: {
   48|      0|                    view.transform = .identity
   49|      0|                }, completion: nil)
   50|      0|            }
   51|      0|            delay += 0.05
   52|      0|        }
   53|      0|    }
   54|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/MessagesUtils/EKTextField.swift:
    1|       |//
    2|       |//  EKTextField.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/16/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import UIKit
   10|       |
   11|       |public class EKTextField: UIView {
   12|       |    
   13|       |    static let totalHeight: CGFloat = 45
   14|       |    
   15|       |    private let content: EKProperty.TextFieldContent
   16|       |    
   17|       |    private let imageView = UIImageView()
   18|       |    private let textField = UITextField()
   19|       |    
   20|       |    public var text: String {
   21|      0|        set {
   22|      0|            textField.text = newValue
   23|      0|        }
   24|       |        get {
   25|      0|            return textField.text ?? ""
   26|       |        }
   27|       |    }
   28|       |    
   29|      0|    public init(with content: EKProperty.TextFieldContent) {
   30|      0|        self.content = content
   31|      0|        super.init(frame: UIScreen.main.bounds)
   32|      0|        setupImageView()
   33|      0|        setupTextField()
   34|      0|        setupSeparatorView()
   35|      0|    }
   36|       |    
   37|      0|    required public init?(coder aDecoder: NSCoder) {
   38|      0|        fatalError("init(coder:) has not been implemented")
   39|      0|    }
   40|       |    
   41|      0|    private func setupImageView() {
   42|      0|        addSubview(imageView)
   43|      0|        imageView.contentMode = .center
   44|      0|        imageView.set(.width, .height, of: EKTextField.totalHeight)
   45|      0|        imageView.layoutToSuperview(.leading)
   46|      0|        imageView.image = content.leadingImage
   47|      0|    }
   48|       |    
   49|      0|    private func setupTextField() {
   50|      0|        addSubview(textField)
   51|      0|        textField.textFieldContent = content
   52|      0|        textField.set(.height, of: EKTextField.totalHeight)
   53|      0|        textField.layout(.leading, to: .trailing, of: imageView)
   54|      0|        textField.layoutToSuperview(.top, .trailing)
   55|      0|        imageView.layout(to: .centerY, of: textField)
   56|      0|    }
   57|       |    
   58|      0|    private func setupSeparatorView() {
   59|      0|        let separatorView = UIView()
   60|      0|        addSubview(separatorView)
   61|      0|        separatorView.backgroundColor = content.bottomBorderColor
   62|      0|        separatorView.layout(.top, to: .bottom, of: textField)
   63|      0|        separatorView.set(.height, of: 1)
   64|      0|        separatorView.layoutToSuperview(.bottom)
   65|      0|        separatorView.layoutToSuperview(axis: .horizontally, offset: 10)
   66|      0|    }
   67|       |    
   68|      0|    public func makeFirstResponder() {
   69|      0|        textField.becomeFirstResponder()
   70|      0|    }
   71|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/Notes/EKAccessoryNoteMessageView.swift:
    1|       |//
    2|       |//  EKAccessoryNoteMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/4/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |public class EKAccessoryNoteMessageView: UIView {
   11|       |
   12|       |    // MARK: Props
   13|       |    private let contentView = UIView()
   14|       |    private var noteMessageView: EKNoteMessageView!
   15|       |    var accessoryView: UIView!
   16|       |
   17|      0|    func setup(with content: EKProperty.LabelContent) {
   18|      0|        clipsToBounds = true
   19|      0|        
   20|      0|        addSubview(contentView)
   21|      0|        contentView.layoutToSuperview(.centerX, .top, .bottom)
   22|      0|        contentView.layoutToSuperview(.left, relation: .greaterThanOrEqual, offset: 16)
   23|      0|        contentView.layoutToSuperview(.right, relation: .lessThanOrEqual, offset: -16)
   24|      0|        
   25|      0|        noteMessageView = EKNoteMessageView(with: content)
   26|      0|        noteMessageView.horizontalOffset = 8
   27|      0|        noteMessageView.verticalOffset = 7
   28|      0|        contentView.addSubview(noteMessageView)
   29|      0|        noteMessageView.layoutToSuperview(.top, .bottom, .trailing)
   30|      0|        
   31|      0|        contentView.addSubview(accessoryView)
   32|      0|        accessoryView.layoutToSuperview(.leading, .centerY)
   33|      0|        accessoryView.layout(.trailing, to: .leading, of: noteMessageView)
   34|      0|    }
   35|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/Notes/EKImageNoteMessageView.swift:
    1|       |//
    2|       |//  EKImageNoteMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/4/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class EKImageNoteMessageView: EKAccessoryNoteMessageView {
   11|       |    
   12|       |    // MARK: Setup
   13|      0|    public required init?(coder aDecoder: NSCoder) {
   14|      0|        fatalError("init(coder:) has not been implemented")
   15|      0|    }
   16|       |    
   17|      0|    public init(with content: EKProperty.LabelContent, imageContent: EKProperty.ImageContent) {
   18|      0|        super.init(frame: UIScreen.main.bounds)
   19|      0|        setup(with: content, imageContent: imageContent)
   20|      0|    }
   21|       |    
   22|      0|    private func setup(with content: EKProperty.LabelContent, imageContent: EKProperty.ImageContent) {
   23|      0|        let imageView = UIImageView()
   24|      0|        imageView.imageContent = imageContent
   25|      0|        accessoryView = imageView
   26|      0|        super.setup(with: content)
   27|      0|    }
   28|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/Notes/EKNoteMessageView.swift:
    1|       |//
    2|       |//  EKNoteMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |public class EKNoteMessageView: UIView {
   13|       |    
   14|       |    // MARK: Props
   15|       |    private let label = UILabel()
   16|       |    
   17|       |    private var horizontalConstrainsts: QLAxisConstraints!
   18|       |    private var verticalConstrainsts: QLAxisConstraints!
   19|       |    
   20|       |    public var horizontalOffset: CGFloat = 10 {
   21|      0|        didSet {
   22|      0|            horizontalConstrainsts.first.constant = horizontalOffset
   23|      0|            horizontalConstrainsts.second.constant = -horizontalOffset
   24|      0|            layoutIfNeeded()
   25|      0|        }
   26|       |    }
   27|       |    
   28|       |    public var verticalOffset: CGFloat = 5 {
   29|      0|        didSet {
   30|      0|            verticalConstrainsts.first.constant = verticalOffset
   31|      0|            verticalConstrainsts.second.constant = -verticalOffset
   32|      0|            layoutIfNeeded()
   33|      0|        }
   34|       |    }
   35|       |    
   36|       |    // MARK: Setup
   37|      0|    public init(with content: EKProperty.LabelContent) {
   38|      0|        super.init(frame: UIScreen.main.bounds)
   39|      0|        setup(with: content)
   40|      0|    }
   41|       |
   42|      0|    public required init?(coder aDecoder: NSCoder) {
   43|      0|        fatalError("init(coder:) has not been implemented")
   44|      0|    }
   45|       |    
   46|      0|    private func setup(with content: EKProperty.LabelContent) {
   47|      0|        clipsToBounds = true
   48|      0|        addSubview(label)
   49|      0|        label.content = content
   50|      0|        horizontalConstrainsts = label.layoutToSuperview(axis: .horizontally, offset: horizontalOffset, priority: .must)
   51|      0|        verticalConstrainsts = label.layoutToSuperview(axis: .vertically, offset: verticalOffset, priority: .must)
   52|      0|    }
   53|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/Notes/EKProcessingNoteMessageView.swift:
    1|       |//
    2|       |//  EKProcessingNoteMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public class EKProcessingNoteMessageView: EKAccessoryNoteMessageView {
   12|       |    
   13|       |    // MARK: Props
   14|       |    private var activityIndicatorView: UIActivityIndicatorView!
   15|       |    private var noteMessageView: EKNoteMessageView!
   16|       |    
   17|       |    /** Activity indication can be turned off / on */
   18|       |    public var isProcessing: Bool = true {
   19|      0|        didSet {
   20|      0|            if isProcessing {
   21|      0|                activityIndicatorView.startAnimating()
   22|      0|            } else {
   23|      0|                activityIndicatorView.stopAnimating()
   24|      0|            }
   25|      0|        }
   26|       |    }
   27|       |    
   28|       |    // MARK: Setup
   29|      0|    public required init?(coder aDecoder: NSCoder) {
   30|      0|        fatalError("init(coder:) has not been implemented")
   31|      0|    }
   32|       |    
   33|      0|    public init(with content: EKProperty.LabelContent, activityIndicator: UIActivityIndicatorView.Style) {
   34|      0|        super.init(frame: UIScreen.main.bounds)
   35|      0|        setup(with: content, activityIndicator: activityIndicator)
   36|      0|    }
   37|       |    
   38|      0|    private func setup(with content: EKProperty.LabelContent, activityIndicator: UIActivityIndicatorView.Style, setProcessing: Bool = true) {
   39|      0|        activityIndicatorView = UIActivityIndicatorView()
   40|      0|        activityIndicatorView.style = activityIndicator
   41|      0|        isProcessing = setProcessing
   42|      0|        accessoryView = activityIndicatorView
   43|      0|        super.setup(with: content)
   44|      0|    }
   45|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/MessageViews/Notes/EKXStatusBarMessageView.swift:
    1|       |//
    2|       |//  EKXStatusBarMessageView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import QuickLayout
   11|       |
   12|       |public class EKXStatusBarMessageView: UIView {
   13|       |    
   14|       |    // MARK: Props
   15|       |    private let leadingLabel = UILabel()
   16|       |    private let trailingLabel = UILabel()
   17|       |    
   18|       |    // MARK: Setup
   19|      0|    public init(leading: EKProperty.LabelContent, trailing: EKProperty.LabelContent) {
   20|      0|        super.init(frame: UIScreen.main.bounds)
   21|      0|        setup(leading: leading, trailing: trailing)
   22|      0|    }
   23|       |    
   24|      0|    public required init?(coder aDecoder: NSCoder) {
   25|      0|        fatalError("init(coder:) has not been implemented")
   26|      0|    }
   27|       |    
   28|      0|    private func setup(leading: EKProperty.LabelContent, trailing: EKProperty.LabelContent) {
   29|      0|        clipsToBounds = true
   30|      0|        
   31|      0|        set(.height, of: UIApplication.shared.statusBarFrame.maxY)
   32|      0|        
   33|      0|        addSubview(leadingLabel)
   34|      0|        leadingLabel.content = leading
   35|      0|        
   36|      0|        leadingLabel.layoutToSuperview(axis: .vertically)
   37|      0|        leadingLabel.layoutToSuperview(.leading)
   38|      0|        leadingLabel.layoutToSuperview(.width, ratio: 0.26)
   39|      0|        
   40|      0|        addSubview(trailingLabel)
   41|      0|        trailingLabel.content = trailing
   42|      0|        
   43|      0|        trailingLabel.layoutToSuperview(axis: .vertically)
   44|      0|        trailingLabel.layoutToSuperview(.trailing)
   45|      0|        trailingLabel.layoutToSuperview(.width, ratio: 0.26)
   46|      0|    }
   47|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKAlertMessage.swift:
    1|       |//
    2|       |//  EKAlertMessage.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |public struct EKAlertMessage {
   10|       |    
   11|       |    public enum ImagePosition {
   12|       |        case top
   13|       |        case left
   14|       |    }
   15|       |    
   16|       |    /** The position of the image inside the alert */
   17|       |    public let imagePosition: ImagePosition
   18|       |    
   19|       |    /** Image, Title, Description */
   20|       |    public let simpleMessage: EKSimpleMessage
   21|       |    
   22|       |    /** Contents of button bar */
   23|       |    public let buttonBarContent: EKProperty.ButtonBarContent
   24|       |    
   25|      0|    public init(simpleMessage: EKSimpleMessage, imagePosition: ImagePosition = .top, buttonBarContent: EKProperty.ButtonBarContent) {
   26|      0|        self.simpleMessage = simpleMessage
   27|      0|        self.imagePosition = imagePosition
   28|      0|        self.buttonBarContent = buttonBarContent
   29|      0|    }
   30|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKNotificationMessage.swift:
    1|       |//
    2|       |//  EKNotificationMessage.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public struct EKNotificationMessage {
   12|       |    
   13|       |    /** Insets of the content of the message */
   14|       |    public struct Insets {
   15|       |        
   16|       |        /** The insets of the content of the message, from the top, bottom, left, right */
   17|       |        public var contentInsets = UIEdgeInsets(top: 16, left: 16, bottom: 16, right: 16)
   18|       |        
   19|       |        /** The distance between the title and the description */
   20|       |        public var titleToDescription: CGFloat = 5
   21|       |        
   22|       |        public static var `default` = Insets()
   23|       |    }
   24|       |    
   25|       |    /** Image, Title, Description */
   26|       |    public let simpleMessage: EKSimpleMessage
   27|       |    
   28|       |    /** Optional auxiliary label descriptor (For instance, it be used to display time of message) */
   29|       |    public let auxiliary: EKProperty.LabelContent?
   30|       |    
   31|       |    /** Defines the vertical and horizontal margins */
   32|       |    public let insets: Insets
   33|       |    
   34|      0|    public init(simpleMessage: EKSimpleMessage, auxiliary: EKProperty.LabelContent? = nil, insets: Insets = .default) {
   35|      0|        self.simpleMessage = simpleMessage
   36|      0|        self.auxiliary = auxiliary
   37|      0|        self.insets = insets
   38|      0|    }
   39|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKPopUpMessage.swift:
    1|       |//
    2|       |//  EKPopUpMessage.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public struct EKPopUpMessage {
   12|       |    
   13|       |    /** Code block that is executed as the user taps the popup button */
   14|       |    public typealias EKPopUpMessageAction = () -> ()
   15|       |    
   16|       |    /** Popup theme image */
   17|       |    public struct ThemeImage {
   18|       |        
   19|       |        /** Position of the theme image */
   20|       |        public enum Position {
   21|       |            case topToTop(offset: CGFloat)
   22|       |            case centerToTop(offset: CGFloat)
   23|       |        }
   24|       |        
   25|       |        /** The content of the image */
   26|       |        public var image: EKProperty.ImageContent
   27|       |        
   28|       |        /** The psotion of the image */
   29|       |        public var position: Position
   30|       |        
   31|       |        /** Initializer */
   32|      0|        public init(image: EKProperty.ImageContent, position: Position = .topToTop(offset: 40)) {
   33|      0|            self.image = image
   34|      0|            self.position = position
   35|      0|        }
   36|       |    }
   37|       |    
   38|       |    public var themeImage: ThemeImage?
   39|       |    public var title: EKProperty.LabelContent
   40|       |    public var description: EKProperty.LabelContent
   41|       |    public var button: EKProperty.ButtonContent
   42|       |    public var action: EKPopUpMessageAction
   43|       |    
   44|      0|    var containsImage: Bool {
   45|      0|        return themeImage != nil
   46|      0|    }
   47|       |    
   48|      0|    public init(themeImage: ThemeImage? = nil, title: EKProperty.LabelContent, description: EKProperty.LabelContent, button: EKProperty.ButtonContent, action: @escaping EKPopUpMessageAction) {
   49|      0|        self.themeImage = themeImage
   50|      0|        self.title = title
   51|      0|        self.description = description
   52|      0|        self.button = button
   53|      0|        self.action = action
   54|      0|    }
   55|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKProperty.swift:
    1|       |//
    2|       |//  EKProperty.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public struct EKProperty {
   12|       |    
   13|       |    /** Button content descriptor */
   14|       |    public struct ButtonContent {
   15|       |        
   16|       |        public typealias Action = () -> ()
   17|       |        
   18|       |        /** Button title label content descriptor */
   19|       |        public var label: LabelContent
   20|       |        
   21|       |        /** Button background color */
   22|       |        public var backgroundColor: UIColor
   23|       |        public var highlightedBackgroundColor: UIColor
   24|       |
   25|       |        /** Content edge inset */
   26|       |        public var contentEdgeInset: CGFloat
   27|       |        
   28|       |        /** Action */
   29|       |        public var action: Action?
   30|       |        
   31|      0|        public init(label: LabelContent, backgroundColor: UIColor, highlightedBackgroundColor: UIColor, contentEdgeInset: CGFloat = 5, action: @escaping Action = {}) {
   32|      0|            self.label = label
   33|      0|            self.backgroundColor = backgroundColor
   34|      0|            self.highlightedBackgroundColor = highlightedBackgroundColor
   35|      0|            self.contentEdgeInset = contentEdgeInset
   36|      0|            self.action = action
   37|      0|        }
   38|       |    }
   39|       |    
   40|       |    /** Label content descriptor */
   41|       |    public struct LabelContent {
   42|       |        
   43|       |        /** The text */
   44|       |        public var text: String
   45|       |        
   46|       |        /** The label's style */
   47|       |        public var style: LabelStyle
   48|       |        
   49|      0|        public init(text: String, style: LabelStyle) {
   50|      0|            self.text = text
   51|      0|            self.style = style
   52|      0|        }
   53|       |    }
   54|       |    
   55|       |    /** Label style descriptor */
   56|       |    public struct LabelStyle {
   57|       |        
   58|       |        /** Font of the text */
   59|       |        public var font: UIFont
   60|       |        
   61|       |        /** Color of the text */
   62|       |        public var color: UIColor
   63|       |        
   64|       |        /** Text Alignment */
   65|       |        public var alignment: NSTextAlignment
   66|       |        
   67|       |        /** Number of lines */
   68|       |        public var numberOfLines: Int
   69|       |        
   70|      0|        public init(font: UIFont, color: UIColor, alignment: NSTextAlignment = .left, numberOfLines: Int = 0) {
   71|      0|            self.font = font
   72|      0|            self.color = color
   73|      0|            self.alignment = alignment
   74|      0|            self.numberOfLines = numberOfLines
   75|      0|        }
   76|       |    }
   77|       |    
   78|       |    /** Image View style descriptor */
   79|       |    public struct ImageContent {
   80|       |        
   81|       |        /** Repeated-reversed animation throughout the presentation of an image */
   82|       |        public enum TransformAnimation {
   83|       |            case animate(duration: TimeInterval, options: UIView.AnimationOptions, transform: CGAffineTransform)
   84|       |            case none
   85|       |        }
   86|       |        
   87|       |        /** The images */
   88|       |        public var images: [UIImage]
   89|       |        
   90|       |        /** Image sequence duration, if any */
   91|       |        public var imageSequenceAnimationDuration: TimeInterval
   92|       |        
   93|       |        /** Image View size - can be forced. If nil, then the image view hugs content and resists compression */
   94|       |        public var size: CGSize?
   95|       |    
   96|       |        /** Content mode */
   97|       |        public var contentMode: UIView.ContentMode
   98|       |        
   99|       |        /** Should the image be rounded */
  100|       |        public var makesRound: Bool
  101|       |        
  102|       |        /** Repeated-Reversed animation */
  103|       |        public var animation: TransformAnimation
  104|       |        
  105|      0|        public init(imageName: String, animation: TransformAnimation = .none, size: CGSize? = nil, contentMode: UIView.ContentMode = .scaleToFill, makesRound: Bool = false) {
  106|      0|            let image = UIImage(named: imageName)!
  107|      0|            self.init(image: image, size: size, contentMode: contentMode, makesRound: makesRound)
  108|      0|        }
  109|       |        
  110|      0|        public init(image: UIImage, animation: TransformAnimation = .none, size: CGSize? = nil, contentMode: UIView.ContentMode = .scaleToFill, makesRound: Bool = false) {
  111|      0|            self.images = [image]
  112|      0|            self.size = size
  113|      0|            self.contentMode = contentMode
  114|      0|            self.makesRound = makesRound
  115|      0|            self.animation = animation
  116|      0|            self.imageSequenceAnimationDuration = 0
  117|      0|        }
  118|       |        
  119|      0|        public init(images: [UIImage], imageSequenceAnimationDuration: TimeInterval = 1, animation: TransformAnimation = .none, size: CGSize? = nil, contentMode: UIView.ContentMode = .scaleToFill, makesRound: Bool = false) {
  120|      0|            self.images = images
  121|      0|            self.size = size
  122|      0|            self.contentMode = contentMode
  123|      0|            self.makesRound = makesRound
  124|      0|            self.animation = animation
  125|      0|            self.imageSequenceAnimationDuration = imageSequenceAnimationDuration
  126|      0|        }
  127|       |        
  128|      0|        public init(imagesNames: [String], imageSequenceAnimationDuration: TimeInterval = 1, animation: TransformAnimation = .none, size: CGSize? = nil, contentMode: UIView.ContentMode = .scaleToFill, makesRound: Bool = false) {
  129|      0|            let images = imagesNames.map { UIImage(named: $0)! }
  130|      0|            self.init(images: images, imageSequenceAnimationDuration: imageSequenceAnimationDuration, animation: animation, size: size, contentMode: contentMode, makesRound: makesRound)
  131|      0|        }
  132|       |        
  133|       |        /** Quick thumbail property generator */
  134|      0|        public static func thumb(with image: UIImage, edgeSize: CGFloat) -> ImageContent {
  135|      0|            return ImageContent(images: [image], size: CGSize(width: edgeSize, height: edgeSize), contentMode: .scaleAspectFill, makesRound: true)
  136|      0|        }
  137|       |        
  138|       |        /** Quick thumbail property generator */
  139|      0|        public static func thumb(with imageName: String, edgeSize: CGFloat) -> ImageContent {
  140|      0|            return ImageContent(imagesNames: [imageName], size: CGSize(width: edgeSize, height: edgeSize), contentMode: .scaleAspectFill, makesRound: true)
  141|      0|        }
  142|       |    }
  143|       |    
  144|       |    /** Text field content **/
  145|       |    public struct TextFieldContent {
  146|       |        
  147|       |        // NOTE: Intentionally a reference type
  148|       |        class ContentWrapper {
  149|       |            var text = ""
  150|       |        }
  151|       |        
  152|       |        public var keyboardType: UIKeyboardType
  153|       |        public var isSecure: Bool
  154|       |        public var leadingImage: UIImage!
  155|       |        public var placeholder: LabelContent
  156|       |        public var textStyle: LabelStyle
  157|       |        public var tintColor: UIColor!
  158|       |        public var bottomBorderColor: UIColor
  159|       |        let contentWrapper = ContentWrapper()
  160|       |        public var textContent: String {
  161|      0|            set {
  162|      0|                contentWrapper.text = newValue
  163|      0|            }
  164|       |            get {
  165|       |                return contentWrapper.text
  166|       |            }
  167|       |        }
  168|       |        
  169|      0|        public init(keyboardType: UIKeyboardType = .default, placeholder: LabelContent, tintColor: UIColor? = nil, textStyle: LabelStyle, isSecure: Bool = false, leadingImage: UIImage? = nil, bottomBorderColor: UIColor = .clear) {
  170|      0|            self.keyboardType = keyboardType
  171|      0|            self.placeholder = placeholder
  172|      0|            self.textStyle = textStyle
  173|      0|            self.tintColor = tintColor
  174|      0|            self.isSecure = isSecure
  175|      0|            self.leadingImage = leadingImage
  176|      0|            self.bottomBorderColor = bottomBorderColor
  177|      0|        }
  178|       |    }
  179|       |    
  180|       |    /** Button bar content */
  181|       |    public struct ButtonBarContent {
  182|       |        
  183|       |        /** Button content array */
  184|       |        public var content: [ButtonContent] = []
  185|       |        
  186|       |        /** The color of the separator */
  187|       |        public var separatorColor: UIColor
  188|       |        
  189|       |        /** Upper threshold for the number of buttons (*ButtonContent*) for horizontal distribution. Must be a positive value */
  190|       |        public var horizontalDistributionThreshold: Int
  191|       |        
  192|       |        /** Determines whether the buttons expands animately */
  193|       |        public var expandAnimatedly: Bool
  194|       |        
  195|       |        /** The height of each button. All are equally distributed in their axis */
  196|       |        public var buttonHeight: CGFloat
  197|       |        
  198|      0|        public init(with buttonContents: ButtonContent..., separatorColor: UIColor, horizontalDistributionThreshold: Int = 2, buttonHeight: CGFloat = 50, expandAnimatedly: Bool) {
  199|      0|            guard horizontalDistributionThreshold > 0 else {
  200|      0|                fatalError("horizontalDistributionThreshold Must have a positive value!")
  201|      0|            }
  202|      0|            self.separatorColor = separatorColor
  203|      0|            self.horizontalDistributionThreshold = horizontalDistributionThreshold
  204|      0|            self.expandAnimatedly = expandAnimatedly
  205|      0|            self.buttonHeight = buttonHeight
  206|      0|            content.append(contentsOf: buttonContents)
  207|      0|        }
  208|       |    }
  209|       |    
  210|       |    /** Rating item content */
  211|       |    public struct EKRatingItemContent {
  212|       |        public var title: EKProperty.LabelContent
  213|       |        public var description: EKProperty.LabelContent
  214|       |        public var unselectedImage: EKProperty.ImageContent
  215|       |        public var selectedImage: EKProperty.ImageContent
  216|       |        
  217|      0|        public init(title: EKProperty.LabelContent, description: EKProperty.LabelContent, unselectedImage: EKProperty.ImageContent, selectedImage: EKProperty.ImageContent) {
  218|      0|            self.title = title
  219|      0|            self.description = description
  220|      0|            self.unselectedImage = unselectedImage
  221|      0|            self.selectedImage = selectedImage
  222|      0|        }
  223|       |    }
  224|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKRatingMessage.swift:
    1|       |//
    2|       |//  EKRatingMessage.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct EKRatingMessage {
   12|       |    
   13|       |    // NOTE: Intentionally a reference type
   14|       |    class SelectedIndex {
   15|       |        var selectedIndex: Int!
   16|       |    }
   17|       |    
   18|       |    /** Selection */
   19|       |    public typealias Selection = (Int) -> Void
   20|       |
   21|       |    /** Initial title */
   22|       |    public var initialTitle: EKProperty.LabelContent
   23|       |    
   24|       |    /** Initial description */
   25|       |    public var initialDescription: EKProperty.LabelContent
   26|       |    
   27|       |    /** Rating items */
   28|       |    public var ratingItems: [EKProperty.EKRatingItemContent]
   29|       |    
   30|       |    /** Button bar content appears after selection */
   31|       |    public var buttonBarContent: EKProperty.ButtonBarContent
   32|       |    
   33|       |    /** Selection event - Each time the user interacts a rating star */
   34|       |    public var selection: Selection!
   35|       |    
   36|       |    let selectedIndexRef = SelectedIndex()
   37|       |    
   38|       |    /** Selected index (if there is one) */
   39|       |    public var selectedIndex: Int? {
   40|      0|        get {
   41|      0|            return selectedIndexRef.selectedIndex
   42|      0|        }
   43|      0|        set {
   44|      0|            selectedIndexRef.selectedIndex = newValue
   45|      0|        }
   46|       |    }
   47|       |    
   48|       |    /** Initializer */
   49|      0|    public init(initialTitle: EKProperty.LabelContent, initialDescription: EKProperty.LabelContent, ratingItems: [EKProperty.EKRatingItemContent], buttonBarContent: EKProperty.ButtonBarContent, selection: Selection? = nil) {
   50|      0|        self.initialTitle = initialTitle
   51|      0|        self.initialDescription = initialDescription
   52|      0|        self.ratingItems = ratingItems
   53|      0|        self.buttonBarContent = buttonBarContent
   54|      0|        self.selection = selection
   55|      0|    }
   56|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EKSimpleMessage.swift:
    1|       |//
    2|       |//  EKSimpleMessage.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/1/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct EKSimpleMessage {
   12|       |    
   13|       |    /** The image view descriptor */
   14|       |    public let image: EKProperty.ImageContent?
   15|       |    
   16|       |    /** The title label descriptor */
   17|       |    public let title: EKProperty.LabelContent
   18|       |    
   19|       |    /** The description label descriptor */
   20|       |    public let description: EKProperty.LabelContent
   21|       |    
   22|      0|    public init(image: EKProperty.ImageContent? = nil, title: EKProperty.LabelContent, description: EKProperty.LabelContent) {
   23|      0|        self.image = image
   24|      0|        self.title = title
   25|      0|        self.description = description
   26|      0|    }
   27|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Animation.swift:
    1|       |//
    2|       |//  EKAttributes+Animation.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |// A protocol that describes an animation
   12|       |protocol EKAnimation {
   13|       |    var delay: TimeInterval { get set }
   14|       |    var duration: TimeInterval { get set }
   15|       |    var spring: EKAttributes.Animation.Spring? { get set }
   16|       |}
   17|       |
   18|       |// A protocol that describes a range animation
   19|       |protocol EKRangeAnimation: EKAnimation {
   20|       |    var start: CGFloat { get set }
   21|       |    var end: CGFloat { get set }
   22|       |}
   23|       |
   24|       |public extension EKAttributes {
   25|       |    
   26|       |    /** Describes an animation that can be performed on the entry */
   27|       |    struct Animation {
   28|       |    
   29|       |        /** Describes properties for a spring animation that can be performed on the entry */
   30|       |        public struct Spring {
   31|       |            
   32|       |            /** The dampic of the spring animation */
   33|       |            public var damping: CGFloat
   34|       |            
   35|       |            /** The initial velocity of the spring animation */
   36|       |            public var initialVelocity: CGFloat
   37|       |            
   38|       |            /** Initializer */
   39|      0|            public init(damping: CGFloat, initialVelocity: CGFloat) {
   40|      0|                self.damping = damping
   41|      0|                self.initialVelocity = initialVelocity
   42|      0|            }
   43|       |        }
   44|       |
   45|       |        /** Describes an animation with range */
   46|       |        public struct RangeAnimation: EKRangeAnimation {
   47|       |            
   48|       |            /** The duration of the range animation */
   49|       |            public var duration: TimeInterval
   50|       |            
   51|       |            /** The delay of the range animation */
   52|       |            public var delay: TimeInterval
   53|       |            
   54|       |            /** The start value of the range animation (e.g. alpha, scale) */
   55|       |            public var start: CGFloat
   56|       |            
   57|       |            /** The end value of the range animation (e.g. alpha, scale) */
   58|       |            public var end: CGFloat
   59|       |            
   60|       |            /** The spring of the animation */
   61|       |            public var spring: Spring?
   62|       |            
   63|       |            /** Initializer */
   64|      0|            public init(from start: CGFloat, to end: CGFloat, duration: TimeInterval, delay: TimeInterval = 0, spring: Spring? = nil) {
   65|      0|                self.start = start
   66|      0|                self.end = end
   67|      0|                self.delay = delay
   68|      0|                self.duration = duration
   69|      0|                self.spring = spring
   70|      0|            }
   71|       |        }
   72|       |        
   73|       |        /** Describes translation animation */
   74|       |        public struct Translate: EKAnimation {
   75|       |            
   76|       |            /** Describes the anchor position */
   77|       |            public enum AnchorPosition {
   78|       |                
   79|       |                /** Top position - the entry shows from top or exits towards the top */
   80|       |                case top
   81|       |                
   82|       |                /** Bottom position - the entry shows from bottom or exits towards the bottom */
   83|       |                case bottom
   84|       |                
   85|       |                /** Automatic position - the entry shows and exits according to EKAttributes.Position value. If the position of the entry is top, bottom, the entry's translation anchor is top, bottom - respectively.*/
   86|       |                case automatic
   87|       |            }
   88|       |            
   89|       |            /** Animation duration */
   90|       |            public var duration: TimeInterval
   91|       |            
   92|       |            /** Animation delay */
   93|       |            public var delay: TimeInterval
   94|       |            
   95|       |            /** To where OR from the entry is animated */
   96|       |            public var anchorPosition: AnchorPosition
   97|       |            
   98|       |            /** Optional translation spring */
   99|       |            public var spring: Spring?
  100|       |
  101|       |            /** Initializer */
  102|      0|            public init(duration: TimeInterval, anchorPosition: AnchorPosition = .automatic, delay: TimeInterval = 0, spring: Spring? = nil) {
  103|      0|                self.anchorPosition = anchorPosition
  104|      0|                self.duration = duration
  105|      0|                self.delay = delay
  106|      0|                self.spring = spring
  107|      0|            }
  108|       |        }
  109|       |        
  110|       |        /** Translation animation prop */
  111|       |        public var translate: Translate?
  112|       |        
  113|       |        /** Scale animation prop */
  114|       |        public var scale: RangeAnimation?
  115|       |        
  116|       |        /** Fade animation prop */
  117|       |        public var fade: RangeAnimation?
  118|       |        
  119|       |        /** Does the animation contains translation */
  120|      0|        public var containsTranslation: Bool {
  121|      0|            return translate != nil
  122|      0|        }
  123|       |        
  124|       |        /** Does the animation contains scale */
  125|      0|        public var containsScale: Bool {
  126|      0|            return scale != nil
  127|      0|        }
  128|       |        
  129|       |        /** Does the animation contains fade */
  130|      0|        public var containsFade: Bool {
  131|      0|            return fade != nil
  132|      0|        }
  133|       |        
  134|       |        /** Does the animation contains any animation whatsoever */
  135|      0|        public var containsAnimation: Bool {
  136|      0|            return containsTranslation || containsScale || containsFade
  137|      0|        }
  138|       |        
  139|       |        /** Returns the maximum delay amongst all animations */
  140|      0|        public var maxDelay: TimeInterval {
  141|      0|            return max(translate?.delay ?? 0, max(scale?.delay ?? 0, fade?.delay ?? 0))
  142|      0|        }
  143|       |        
  144|       |        /** Returns the maximum duration amongst all animations */
  145|      0|        public var maxDuration: TimeInterval {
  146|      0|            return max(translate?.duration ?? 0, max(scale?.duration ?? 0, fade?.duration ?? 0))
  147|      0|        }
  148|       |        
  149|       |        /** Returns the maximum (duration+delay) amongst all animations */
  150|      0|        public var totalDuration: TimeInterval {
  151|      0|            return maxDelay + maxDuration
  152|      0|        }
  153|       |        
  154|       |        /** Returns the maximum (duration+delay) amongst all animations */
  155|      0|        public static var translation: Animation {
  156|      0|            return Animation(translate: .init(duration: 0.3))
  157|      0|        }
  158|       |        
  159|       |        /** No animation at all */
  160|      0|        public static var none: Animation {
  161|      0|            return Animation()
  162|      0|        }
  163|       |        
  164|       |        /** Initializer */
  165|      0|        public init(translate: Translate? = nil, scale: RangeAnimation? = nil, fade: RangeAnimation? = nil) {
  166|      0|            self.translate = translate
  167|      0|            self.scale = scale
  168|      0|            self.fade = fade
  169|      0|        }
  170|       |    }
  171|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+BackgroundStyle.swift:
    1|       |//
    2|       |//  EKAttributes+BackgroundStyle.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public extension EKAttributes {
   12|       |    
   13|       |    /** The background style property */
   14|       |    enum BackgroundStyle: Equatable {
   15|       |        
   16|       |        /** Gradient background style */
   17|       |        public struct Gradient {
   18|       |            public var colors: [UIColor]
   19|       |            public var startPoint: CGPoint
   20|       |            public var endPoint: CGPoint
   21|       |            
   22|      0|            public init(colors: [UIColor], startPoint: CGPoint, endPoint: CGPoint) {
   23|      0|                self.colors = colors
   24|      0|                self.startPoint = startPoint
   25|      0|                self.endPoint = endPoint
   26|      0|            }
   27|       |        }
   28|       |        
   29|       |        /** Visual Effect (Blurred) background style */
   30|       |        case visualEffect(style: UIBlurEffect.Style)
   31|       |        
   32|       |        /** Color background style */
   33|       |        case color(color: UIColor)
   34|       |        
   35|       |        /** Gradient background style */
   36|       |        case gradient(gradient: Gradient)
   37|       |        
   38|       |        /** Image background style */
   39|       |        case image(image: UIImage)
   40|       |        
   41|       |        /** Clear background style */
   42|       |        case clear
   43|       |        
   44|       |        /** == operator overload */
   45|      0|        public static func == (lhs: EKAttributes.BackgroundStyle, rhs: EKAttributes.BackgroundStyle) -> Bool {
   46|      0|            switch (lhs, rhs) {
   47|      0|            case (visualEffect(style: let leftStyle), visualEffect(style: let rightStyle)):
   48|      0|                return leftStyle == rightStyle
   49|      0|            case (color(color: let leftColor), color(color: let rightColor)):
   50|      0|                return leftColor == rightColor
   51|      0|            case (image(image: let leftImage), image(image: let rightImage)):
   52|      0|                return leftImage == rightImage
   53|      0|            case (gradient(gradient: let leftGradient), gradient(gradient: let rightGradient)):
   54|      0|                for (leftColor, rightColor) in zip(leftGradient.colors, rightGradient.colors) {
   55|      0|                    guard leftColor == rightColor else {
   56|      0|                        return false
   57|      0|                    }
   58|      0|                }
   59|      0|                return leftGradient.startPoint == rightGradient.startPoint && leftGradient.endPoint == rightGradient.endPoint
   60|      0|            case (clear, clear):
   61|      0|                return true
   62|      0|            default:
   63|      0|                return false
   64|      0|            }
   65|      0|        }
   66|       |    }
   67|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+FrameStyle.swift:
    1|       |//
    2|       |//  EKAttributes+FrameStyle.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/28/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public extension EKAttributes {
   11|       |    
   12|       |    /** Corner radius of the entry - Specifies the corners */
   13|       |    enum RoundCorners {
   14|       |        
   15|       |        /** *None* of the corners will be round */
   16|       |        case none
   17|       |        
   18|       |        /** *All* of the corners will be round */
   19|       |        case all(radius: CGFloat)
   20|       |        
   21|       |        /** Only the *top* left and right corners will be round */
   22|       |        case top(radius: CGFloat)
   23|       |        
   24|       |        /** Only the *bottom* left and right corners will be round */
   25|       |        case bottom(radius: CGFloat)
   26|       |        
   27|      0|        var hasRoundCorners: Bool {
   28|      0|            switch self {
   29|      0|            case .none:
   30|      0|                return false
   31|      0|            default:
   32|      0|                return true
   33|      0|            }
   34|      0|        }
   35|       |        
   36|      0|        var cornerValues: (value: UIRectCorner, radius: CGFloat)? {
   37|      0|            switch self {
   38|      0|            case .all(radius: let radius):
   39|      0|                return (value: .allCorners, radius: radius)
   40|      0|            case .top(radius: let radius):
   41|      0|                return (value: .top, radius: radius)
   42|      0|            case .bottom(radius: let radius):
   43|      0|                return (value: .bottom, radius: radius)
   44|      0|            case .none:
   45|      0|                return nil
   46|      0|            }
   47|      0|        }
   48|       |    }
   49|       |    
   50|       |    /** The border around the entry */
   51|       |    enum Border {
   52|       |        
   53|       |        /** No border */
   54|       |        case none
   55|       |        
   56|       |        /** Border wirh color and width */
   57|       |        case value(color: UIColor, width: CGFloat)
   58|       |        
   59|      0|        var hasBorder: Bool {
   60|      0|            switch self {
   61|      0|            case .none:
   62|      0|                return false
   63|      0|            default:
   64|      0|                return true
   65|      0|            }
   66|      0|        }
   67|       |        
   68|      0|        var borderValues: (color: UIColor, width: CGFloat)? {
   69|      0|            switch self {
   70|      0|            case .value(color: let color, width: let width):
   71|      0|                return(color: color, width: width)
   72|      0|            case .none:
   73|      0|                return nil
   74|      0|            }
   75|      0|        }
   76|       |    }
   77|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+HapticFeedback.swift:
    1|       |//
    2|       |//  EKAttributes+HapticFeedback.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/1/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public extension EKAttributes {
   11|       |    
   12|       |    /** Notification haptic feedback type. Adds an additional sensuous layer. Read more at UINotificationFeedbackType. Available from iOS 10, but you are not required to check the iOS version before using it. It's automatically handled by the kit.
   13|       |     */
   14|       |    enum NotificationHapticFeedback {
   15|       |        case success
   16|       |        case warning
   17|       |        case error
   18|       |        case none
   19|       |        
   20|       |        @available(iOS 10.0, *)
   21|      0|        var value: UINotificationFeedbackGenerator.FeedbackType? {
   22|      0|            switch self {
   23|      0|            case .success:
   24|      0|                return .success
   25|      0|            case .warning:
   26|      0|                return .warning
   27|      0|            case .error:
   28|      0|                return .error
   29|      0|            case .none:
   30|      0|                return nil
   31|      0|            }
   32|      0|        }
   33|       |        
   34|      0|        var isValid: Bool {
   35|      0|            return self != .none
   36|      0|        }
   37|       |    }
   38|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+LifecycleActions.swift:
    1|       |//
    2|       |//  EKAttributes+LifecycleActions.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 6/16/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public extension EKAttributes {
   12|       |
   13|       |    /** Contains optionally injected events that take place during the entry lifecycle */
   14|       |    struct LifecycleEvents {
   15|       |        
   16|       |        public typealias Event = () -> Void
   17|       |
   18|       |        /** Executed before the entry appears - before the animation starts.
   19|       |         Might not get called in case another entry with a higher display priority is displayed.
   20|       |         */
   21|       |        public var willAppear: Event?
   22|       |        
   23|       |        /** Executed after the animation ends.
   24|       |         Might not get called in case another entry with a higher display priority is displayed.
   25|       |         */
   26|       |        public var didAppear: Event?
   27|       |
   28|       |        /** Executed before the entry disappears (Before the animation starts) */
   29|       |        public var willDisappear: Event?
   30|       |        
   31|       |        /** Executed after the entry disappears (After the animation ends) */
   32|       |        public var didDisappear: Event?
   33|       |        
   34|      0|        public init(willAppear: Event? = nil, didAppear: Event? = nil, willDisappear: Event? = nil, didDisappear: Event? = nil) {
   35|      0|            self.willAppear = willAppear
   36|      0|            self.didAppear = didAppear
   37|      0|            self.willDisappear = willDisappear
   38|      0|            self.didDisappear = didDisappear
   39|      0|        }
   40|       |    }
   41|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+PopBehavior.swift:
    1|       |//
    2|       |//  EKAttributes+PopBehavior.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/26/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public extension EKAttributes {
   11|       |    
   12|       |    /** Describes the entry behavior when a new entry shows (with equal or higher display-priority) */
   13|       |    enum PopBehavior {
   14|       |                
   15|       |        /** The entry disappears promptly (Does not animates out) when a new one shows */
   16|       |        case overridden
   17|       |        
   18|       |        /** Animate the entry out - The entry rolls out when a new one shows */
   19|       |        case animated(animation: Animation)
   20|       |        
   21|      0|        public var isOverriden: Bool {
   22|      0|            switch self {
   23|      0|            case .overridden:
   24|      0|                return true
   25|      0|            default:
   26|      0|                return false
   27|      0|            }
   28|      0|        }
   29|       |    }
   30|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Position.swift:
    1|       |//
    2|       |//  EKAttributes+Position.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public extension EKAttributes {
   12|       |
   13|       |    /** The position of the entry. */
   14|       |    enum Position {
   15|       |        
   16|       |        /** The entry appears at the top of the screen. */
   17|       |        case top
   18|       |        
   19|       |        /** The entry appears at the bottom of the screen. */
   20|       |        case bottom
   21|       |        
   22|       |        /** The entry appears at the center of the screen. */
   23|       |        case center
   24|       |        
   25|      0|        public var isTop: Bool {
   26|      0|            return self == .top
   27|      0|        }
   28|       |        
   29|      0|        public var isCenter: Bool {
   30|      0|            return self == .center
   31|      0|        }
   32|       |        
   33|      0|        public var isBottom: Bool {
   34|      0|            return self == .bottom
   35|      0|        }
   36|       |    }
   37|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+PositionConstraints.swift:
    1|       |//
    2|       |//  EKAttributes+Frame.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public extension EKAttributes {
   12|       |    
   13|       |    /** Describes the frame of the entry. It's limitations, width and offset from the anchor (top / bottom of the screen) */
   14|       |    struct PositionConstraints {
   15|       |
   16|       |        /** Describes safe area relation */
   17|       |        public enum SafeArea {
   18|       |            
   19|       |            /** Entry overrides safe area */
   20|       |            case overridden
   21|       |            
   22|       |            /** The entry shows outs. But can optionally be colored */
   23|       |            case empty(fillSafeArea: Bool)
   24|       |            
   25|      0|            public var isOverridden: Bool {
   26|      0|                switch self {
   27|      0|                case .overridden:
   28|      0|                    return true
   29|      0|                default:
   30|      0|                    return false
   31|      0|                }
   32|      0|            }
   33|       |        }
   34|       |        
   35|       |        /** Describes an edge constraint of the entry */
   36|       |        public enum Edge {
   37|       |            
   38|       |            /** Ratio constraint to screen edge */
   39|       |            case ratio(value: CGFloat)
   40|       |            
   41|       |            /** Offset from each edge of the screen */
   42|       |            case offset(value: CGFloat)
   43|       |            
   44|       |            /** Constant edge length */
   45|       |            case constant(value: CGFloat)
   46|       |            
   47|       |            /** Unspecified edge length */
   48|       |            case intrinsic
   49|       |            
   50|       |            /** Edge totally filled */
   51|      0|            public static var fill: Edge {
   52|      0|                return .offset(value: 0)
   53|      0|            }
   54|       |        }
   55|       |        
   56|       |        /** Describes the size of the entry */
   57|       |        public struct Size {
   58|       |            
   59|       |            /** Describes a width constraint */
   60|       |            public var width: Edge
   61|       |            
   62|       |            /** Describes a height constraint */
   63|       |            public var height: Edge
   64|       |            
   65|       |            /** Initializer */
   66|      0|            public init(width: Edge, height: Edge) {
   67|      0|                self.width = width
   68|      0|                self.height = height
   69|      0|            }
   70|       |            
   71|       |            /** The content's size. Entry's content view must have tight constraints */
   72|      0|            public static var intrinsic: Size {
   73|      0|                return Size(width: .intrinsic, height: .intrinsic)
   74|      0|            }
   75|       |            
   76|       |            /** The content's size. Entry's content view must have tight constraints */
   77|      0|            public static var sizeToWidth: Size {
   78|      0|                return Size(width: .offset(value: 0), height: .intrinsic)
   79|      0|            }
   80|       |            
   81|       |            /** Screen size, without horizontal or vertical offset */
   82|      0|            public static var screen: Size {
   83|      0|                return Size(width: .fill, height: .fill)
   84|      0|            }
   85|       |        }
   86|       |        
   87|       |        /** The relation to the keyboard's top and the screen's top while it is opened */
   88|       |        public enum KeyboardRelation {
   89|       |            
   90|       |            /** Describes the offset when the keyboard is opened */
   91|       |            public struct Offset {
   92|       |                
   93|       |                /** Describes top keyboard offset to the entry's bottom */
   94|       |                public var bottom: CGFloat
   95|       |                
   96|       |                /** Describes top screen offset to the entry's top, useful to prevent the entry from exceeding the screen top bounds */
   97|       |                public var screenEdgeResistance: CGFloat?
   98|       |                
   99|      0|                public init(bottom: CGFloat = 0, screenEdgeResistance: CGFloat? = nil) {
  100|      0|                    self.bottom = bottom
  101|      0|                    self.screenEdgeResistance = screenEdgeResistance
  102|      0|                }
  103|       |                
  104|       |                /** None offset */
  105|      0|                public static var none: Offset {
  106|      0|                    return Offset()
  107|      0|                }
  108|       |            }
  109|       |            
  110|       |            /** Bind the entry's bottom to the keyboard's top with an offset.
  111|       |             Additionally, the top edge of the screen can have a resistance offset which the entry isn't able to cross.
  112|       |             The resistance is mostly used when the device orientation changes and the entry's frame crosses the screen bounds.
  113|       |             Current isn't supported with center entry position.*/
  114|       |            case bind(offset: Offset)
  115|       |            
  116|       |            /** Entry is unbound to the keyboard. It's location doesn't change. */
  117|       |            case unbind
  118|       |            
  119|       |            /** Returns true if the entry is bound to the keyboard */
  120|      0|            public var isBound: Bool {
  121|      0|                switch self {
  122|      0|                case .bind(offset: _):
  123|      0|                    return true
  124|      0|                case .unbind:
  125|      0|                    return false
  126|      0|                }
  127|      0|            }
  128|       |        }
  129|       |        
  130|       |        /** Rotation related position constraints */
  131|       |        public struct Rotation {
  132|       |            
  133|       |            /** Attributes of supported interface orientations */
  134|       |            public enum SupportedInterfaceOrientation {
  135|       |                
  136|       |                /** Uses standard supported interface orientation (target specification in general settings) */
  137|       |                case standard
  138|       |                
  139|       |                /** Supports all orinetations */
  140|       |                case all
  141|       |            }
  142|       |            
  143|       |            /** Autorotate the entry along with the device orientation */
  144|       |            public var isEnabled = true
  145|       |            
  146|       |            /** The screen autorotates with accordance to this option */
  147|       |            public var supportedInterfaceOrientations = SupportedInterfaceOrientation.standard
  148|       |            
  149|      0|            public init() {}
  150|       |        }
  151|       |        
  152|       |        /** The rotation attributes of the entry */
  153|       |        public var rotation = Rotation()
  154|       |        
  155|       |        /** The entry can be bound to keyboard in case of appearance */
  156|       |        public var keyboardRelation = KeyboardRelation.unbind
  157|       |        
  158|       |        /** The size of the entry */
  159|       |        public var size: Size
  160|       |        
  161|       |        /** The maximum size of the entry */
  162|       |        public var maxSize: Size
  163|       |
  164|       |        /** The vertical offset from the top or bottom anchor */
  165|       |        public var verticalOffset: CGFloat
  166|       |        
  167|       |        /** Can be used to display the content outside the safe area margins such as on the notch of the iPhone X or the status bar itself. */
  168|       |        public var safeArea = SafeArea.empty(fillSafeArea: false)
  169|       |        
  170|      0|        public var hasVerticalOffset: Bool {
  171|      0|            return verticalOffset > 0
  172|      0|        }
  173|       |        
  174|       |        /** Returns a floating entry (float-like) */
  175|      0|        public static var float: PositionConstraints {
  176|      0|            return PositionConstraints(verticalOffset: 10, size: .init(width: .offset(value: 20), height: .intrinsic))
  177|      0|        }
  178|       |        
  179|       |        /** A full width entry (toast-like) */
  180|      0|        public static var fullWidth: PositionConstraints {
  181|      0|            return PositionConstraints(verticalOffset: 0, size: .sizeToWidth)
  182|      0|        }
  183|       |        
  184|       |        /** A full screen entry - fills the entire screen, modal-like */
  185|      0|        public static var fullScreen: PositionConstraints {
  186|      0|            return PositionConstraints(verticalOffset: 0, size: .screen)
  187|      0|        }
  188|       |        
  189|       |        /** Initialize with default parameters */
  190|      0|        public init(verticalOffset: CGFloat = 0, size: Size = .sizeToWidth, maxSize: Size = .intrinsic) {
  191|      0|            self.verticalOffset = verticalOffset
  192|      0|            self.size = size
  193|      0|            self.maxSize = maxSize
  194|      0|        }
  195|       |    }
  196|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Precedence.swift:
    1|       |//
    2|       |//  EKAttributes+Precedence.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/29/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |fileprivate extension Int {
   11|      0|    var isValidDisplayPriority: Bool {
   12|      0|        return self >= EKAttributes.Precedence.Priority.minRawValue && self <= EKAttributes.Precedence.Priority.maxRawValue
   13|      0|    }
   14|       |}
   15|       |
   16|       |public extension EKAttributes {
   17|       |    
   18|       |    /**
   19|       |     Describes the manner on which the entry is pushed and displayed.
   20|       |     See the various values of more explanation.
   21|       |     */
   22|       |    enum Precedence {
   23|       |        
   24|       |        /**
   25|       |         The display priority of the entry - Determines whether is can be overriden by other entries.
   26|       |         Must be in range [0...1000]
   27|       |         */
   28|       |        public struct Priority: Hashable, Equatable, RawRepresentable, Comparable {
   29|       |            public var rawValue: Int
   30|       |            
   31|      0|            public var hashValue: Int {
   32|      0|                return rawValue
   33|      0|            }
   34|       |            
   35|      0|            public init(_ rawValue: Int) {
   36|      0|                assert(rawValue.isValidDisplayPriority, "Display Priority must be in range [\(Priority.minRawValue)...\(Priority.maxRawValue)]")
   37|      0|                self.rawValue = rawValue
   38|      0|            }
   39|       |            
   40|      0|            public init(rawValue: Int) {
   41|      0|                assert(rawValue.isValidDisplayPriority, "Display Priority must be in range [\(Priority.minRawValue)...\(Priority.maxRawValue)]")
   42|      0|                self.rawValue = rawValue
   43|      0|            }
   44|       |            
   45|      0|            public static func == (lhs: Priority, rhs: Priority) -> Bool {
   46|      0|                return lhs.rawValue == rhs.rawValue
   47|      0|            }
   48|       |            
   49|      0|            public static func < (lhs: Priority, rhs: Priority) -> Bool {
   50|      0|                return lhs.rawValue < rhs.rawValue
   51|      0|            }
   52|       |        }
   53|       |        
   54|       |        /**
   55|       |         Describes the queueing heoristic of entries.
   56|       |         */
   57|       |        public enum QueueingHeuristic {
   58|       |            
   59|       |            /** Determines the heuristic which the entry-queue is based on */
   60|       |            public static var value = QueueingHeuristic.priority
   61|       |            
   62|       |            /** Chronological - FIFO */
   63|       |            case chronological
   64|       |            
   65|       |            /** Ordered by priority */
   66|       |            case priority
   67|       |            
   68|       |            /** Returns the caching heuristics mechanism that determines the priority in queue */
   69|      1|            var heuristic: EntryCachingHeuristic {
   70|      1|                switch self {
   71|      1|                case .chronological:
   72|      0|                    return EKEntryChronologicalQueue()
   73|      1|                case .priority:
   74|      1|                    return EKEntryPriorityQueue()
   75|      1|                }
   76|      1|            }
   77|       |        }
   78|       |        
   79|       |        /**
   80|       |         Describes an *overriding* behavior for a new entry.
   81|       |         - In case no previous entry is currently presented, display the new entry.
   82|       |         - In case there is an entry that is currently presented - override it using the new entry. Also optionally drop all previously enqueued entries.
   83|       |         */
   84|       |        case override(priority: Priority, dropEnqueuedEntries: Bool)
   85|       |        
   86|       |        /**
   87|       |         Describes a FIFO behavior for an entry presentation.
   88|       |         - In case no previous entry is currently presented, display the new entry.
   89|       |         - In case there is an entry that is currently presented - enqueue the new entry, an present it just after the previous one is dismissed.
   90|       |         */
   91|       |        case enqueue(priority: Priority)
   92|       |        
   93|      0|        var isEnqueue: Bool {
   94|      0|            switch self {
   95|      0|            case .enqueue:
   96|      0|                return true
   97|      0|            default:
   98|      0|                return false
   99|      0|            }
  100|      0|        }
  101|       |        
  102|       |        /** Setter / Getter for the display priority */
  103|       |        public var priority: Priority {
  104|      0|            set {
  105|      0|                switch self {
  106|      0|                case .enqueue(priority: _):
  107|      0|                    self = .enqueue(priority: newValue)
  108|      0|                case .override(priority: _, dropEnqueuedEntries: let dropEnqueuedEntries):
  109|      0|                    self = .override(priority: newValue, dropEnqueuedEntries: dropEnqueuedEntries)
  110|      0|                }
  111|      0|            }
  112|       |            get {
  113|       |                switch self {
  114|       |                case .enqueue(priority: let priority):
  115|       |                    return priority
  116|       |                case .override(priority: let priority, dropEnqueuedEntries: _):
  117|       |                    return priority
  118|       |                }
  119|       |            }
  120|       |        }
  121|       |    }
  122|       |}
  123|       |
  124|       |/** High priority entries can be overriden by other equal or higher priority entries only.
  125|       | Entries are ignored as a higher priority entry is being displayed.
  126|       | High priority entry overrides any other entry including another equal priority one.
  127|       | You can you on of the values (.max, high, normal, low, min) and also set your own values. */
  128|       |public extension EKAttributes.Precedence.Priority {
  129|       |    static let maxRawValue = 1000
  130|       |    static let highRawValue = 750
  131|       |    static let normalRawValue = 500
  132|       |    static let lowRawValue = 250
  133|       |    static let minRawValue = 0
  134|       |
  135|       |    /** Max - the highest possible priority of an entry. Can override only entries with *max* priority */
  136|       |    static let max = EKAttributes.Precedence.Priority(rawValue: maxRawValue)
  137|       |    static let high = EKAttributes.Precedence.Priority(rawValue: highRawValue)
  138|       |    static let normal = EKAttributes.Precedence.Priority(rawValue: normalRawValue)
  139|       |    static let low = EKAttributes.Precedence.Priority(rawValue: lowRawValue)
  140|       |    static let min = EKAttributes.Precedence.Priority(rawValue: minRawValue)
  141|       |}
  142|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Presets.swift:
    1|       |//
    2|       |//  EKAttributes+Presets.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/23/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public extension EKAttributes {
   11|       |    
   12|       |    /** Default attributes - Can be mutated according to the hosting application theme */
   13|       |    static var `default` = EKAttributes()
   14|       |    
   15|       |    /** Toast preset - The frame fills margins and safe area is filled with background view */
   16|      0|    static var toast: EKAttributes {
   17|      0|        var attributes = EKAttributes()
   18|      0|        attributes.positionConstraints = .fullWidth
   19|      0|        attributes.positionConstraints.safeArea = .empty(fillSafeArea: true)
   20|      0|        attributes.windowLevel = .statusBar
   21|      0|        attributes.scroll = .edgeCrossingDisabled(swipeable: true)
   22|      0|        attributes.popBehavior = .animated(animation: .translation)
   23|      0|        return attributes
   24|      0|    }
   25|       |    
   26|       |    /** Float preset - The frame is margined and the safe area is left cleared */
   27|      0|    static var float: EKAttributes {
   28|      0|        var attributes = EKAttributes()
   29|      0|        attributes.positionConstraints = .float
   30|      0|        attributes.roundCorners = .all(radius: 10)
   31|      0|        attributes.positionConstraints.safeArea = .empty(fillSafeArea: false)
   32|      0|        attributes.windowLevel = .statusBar
   33|      0|        return attributes
   34|      0|    }
   35|       |    
   36|       |    /** Preset for top float entry */
   37|      0|    static var topFloat: EKAttributes {
   38|      0|        var attributes = float
   39|      0|        attributes.position = .top
   40|      0|        return attributes
   41|      0|    }
   42|       |    
   43|       |    /** Preset for a bottom float entry */
   44|      0|    static var bottomFloat: EKAttributes {
   45|      0|        var attributes = float
   46|      0|        attributes.position = .bottom
   47|      0|        return attributes
   48|      0|    }
   49|       |    
   50|       |    /** Preset for a center float entry */
   51|      0|    static var centerFloat: EKAttributes {
   52|      0|        var attributes = float
   53|      0|        attributes.position = .center
   54|      0|        return attributes
   55|      0|    }
   56|       |    
   57|       |    /** Preset for a bottom toast entry */
   58|      0|    static var bottomToast: EKAttributes {
   59|      0|        var attributes = toast
   60|      0|        attributes.position = .bottom
   61|      0|        return attributes
   62|      0|    }
   63|       |    
   64|       |    /** Preset for a top toast entry */
   65|      0|    static var topToast: EKAttributes {
   66|      0|        var attributes = toast
   67|      0|        attributes.position = .top
   68|      0|        return attributes
   69|      0|    }
   70|       |    
   71|       |    /** Preset for a top note entry */
   72|      0|    static var topNote: EKAttributes {
   73|      0|        var attributes = topToast
   74|      0|        attributes.scroll = .disabled
   75|      0|        attributes.windowLevel = .normal
   76|      0|        attributes.entryInteraction = .absorbTouches
   77|      0|        return attributes
   78|      0|    }
   79|       |    
   80|       |    /** Preset for a bottom note entry */
   81|      0|    static var bottomNote: EKAttributes {
   82|      0|        var attributes = bottomToast
   83|      0|        attributes.scroll = .disabled
   84|      0|        attributes.windowLevel = .normal
   85|      0|        attributes.entryInteraction = .absorbTouches
   86|      0|        return attributes
   87|      0|    }
   88|       |    
   89|       |    /** Preset for a status bar entry - appears on top of the status bar */
   90|      0|    static var statusBar: EKAttributes {
   91|      0|        var attributes = topToast
   92|      0|        attributes.windowLevel = .statusBar
   93|      0|        attributes.entryInteraction = .absorbTouches
   94|      0|        attributes.positionConstraints.safeArea = .overridden
   95|      0|        return attributes
   96|      0|    }
   97|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Scroll.swift:
    1|       |//
    2|       |//  EKAttributes+Scroll.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/30/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public extension EKAttributes {
   11|       |    
   12|       |    /** Describes the event of scroll user interaction */
   13|       |    enum Scroll {
   14|       |    
   15|       |        /** Describes the event when the user leaves the entry after rubber-banding it - How the entry behaves */
   16|       |        public struct PullbackAnimation {
   17|       |            public var duration: TimeInterval
   18|       |            public var damping: CGFloat
   19|       |            public var initialSpringVelocity: CGFloat
   20|       |            
   21|      0|            public init(duration: TimeInterval, damping: CGFloat, initialSpringVelocity: CGFloat) {
   22|      0|                self.duration = duration
   23|      0|                self.damping = damping
   24|      0|                self.initialSpringVelocity = initialSpringVelocity
   25|      0|            }
   26|       |            
   27|       |            /** The entry is jolted when it's pulled back into the original position */
   28|      0|            public static var jolt: PullbackAnimation {
   29|      0|                return PullbackAnimation(duration: 0.5, damping: 0.3, initialSpringVelocity: 10)
   30|      0|            }
   31|       |            
   32|       |            /** The view eases out when it's pulled back into the original position */
   33|      0|            public static var easeOut: PullbackAnimation {
   34|      0|                return PullbackAnimation(duration: 0.3, damping: 1, initialSpringVelocity: 10)
   35|      0|            }
   36|       |        }
   37|       |        
   38|       |        /** The scroll ability is totally disabled */
   39|       |        case disabled
   40|       |        
   41|       |        /** The scroll in the opposite direction to the edge is disabled */
   42|       |        case edgeCrossingDisabled(swipeable: Bool)
   43|       |        
   44|       |        /** The scroll abiliby is enabled */
   45|       |        case enabled(swipeable: Bool, pullbackAnimation: PullbackAnimation)
   46|       |        
   47|      0|        var isEnabled: Bool {
   48|      0|            switch self {
   49|      0|            case .disabled:
   50|      0|                return false
   51|      0|            default:
   52|      0|                return true
   53|      0|            }
   54|      0|        }
   55|       |        
   56|      0|        var isSwipeable: Bool {
   57|      0|            switch self {
   58|      0|            case .edgeCrossingDisabled(swipeable: let swipeable), .enabled(swipeable: let swipeable, pullbackAnimation: _):
   59|      0|                return swipeable
   60|      0|            default:
   61|      0|                return false
   62|      0|            }
   63|      0|        }
   64|       |        
   65|      0|        var isEdgeCrossingEnabled: Bool {
   66|      0|            switch self {
   67|      0|            case .edgeCrossingDisabled:
   68|      0|                return false
   69|      0|            default:
   70|      0|                return true
   71|      0|            }
   72|      0|        }
   73|       |    }
   74|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Shadow.swift:
    1|       |//
    2|       |//  EKAttributes+Shadow.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |public extension EKAttributes {
   13|       |
   14|       |    /** The shadow around the entry */
   15|       |    enum Shadow {
   16|       |        
   17|       |        /** No shadow */
   18|       |        case none
   19|       |        
   20|       |        /** Shadow with value */
   21|       |        case active(with: Value)
   22|       |        
   23|       |        /** The shadow properties */
   24|       |        public struct Value {
   25|       |            public let radius: CGFloat
   26|       |            public let opacity: Float
   27|       |            public let color: UIColor
   28|       |            public let offset: CGSize
   29|       |            
   30|      0|            public init(color: UIColor = .black, opacity: Float, radius: CGFloat, offset: CGSize = .zero) {
   31|      0|                self.color = color
   32|      0|                self.radius = radius
   33|      0|                self.offset = offset
   34|      0|                self.opacity = opacity
   35|      0|            }
   36|       |        }
   37|       |    }
   38|       |}
   39|       |
   40|       |

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+StatusBar.swift:
    1|       |//
    2|       |//  EKAttributes+StatusBar.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/25/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public extension EKAttributes {
   12|       |    
   13|       |    /** Status bar appearance */
   14|       |    enum StatusBar {
   15|       |        
   16|       |        /** The appearance of the status bar */
   17|       |        public typealias Appearance = (visible: Bool, style: UIStatusBarStyle)
   18|       |        
   19|       |        /** Ignored. Status bar is ignored by entries with this apperance value*/
   20|       |        case ignored
   21|       |        
   22|       |        /** Hidden. Doesn't apply to iPhone X */
   23|       |        case hidden
   24|       |        
   25|       |        /** Visible with explicit dark style */
   26|       |        case dark
   27|       |        
   28|       |        /** Visible with explicit light style */
   29|       |        case light
   30|       |        
   31|       |        /** Keep previous state of status bar.
   32|       |         In case there is an already displayed entry, keep its status bar appearance.
   33|       |         In case the app is already displaying a status bar, keep its appearance */
   34|       |        case inferred
   35|       |        
   36|       |        /** Returns the status bar appearance.
   37|       |         Note: See *Appearance* */
   38|      0|        public var appearance: Appearance {
   39|      0|            switch self {
   40|      0|            case .dark:
   41|      0|                return (true, .default)
   42|      0|            case .light:
   43|      0|                return (true, .lightContent)
   44|      0|            case .inferred:
   45|      0|                return StatusBar.currentAppearance
   46|      0|            case .hidden:
   47|      0|                return (false, StatusBar.currentStyle)
   48|      0|            case .ignored:
   49|      0|                fatalError("There is no defined appearance for an ignored status bar")
   50|      0|            }
   51|      0|        }
   52|       |        
   53|       |        /** Returns the status bar according to a given appearance */
   54|      0|        public static func statusBar(by appearance: Appearance) -> StatusBar {
   55|      0|            guard appearance.visible else {
   56|      0|                return .hidden
   57|      0|            }
   58|      0|            switch appearance.style {
   59|      0|            case .lightContent:
   60|      0|                return .light
   61|      0|            default:
   62|      0|                return .dark
   63|      0|            }
   64|      0|        }
   65|       |        
   66|       |        /** Returns the current appearance */
   67|       |        public static var currentAppearance: Appearance {
   68|       |            return (StatusBar.isCurrentVisible, StatusBar.currentStyle)
   69|       |        }
   70|       |        
   71|       |        /** Returns the current status bar */
   72|      0|        public static var currentStatusBar: StatusBar {
   73|      0|            return statusBar(by: currentAppearance)
   74|      0|        }
   75|       |        
   76|       |        // Accessors
   77|       |        private static var currentStyle: UIStatusBarStyle {
   78|       |            return UIApplication.shared.statusBarStyle
   79|       |        }
   80|       |        
   81|       |        private static var isCurrentVisible: Bool {
   82|       |            return !UIApplication.shared.isStatusBarHidden
   83|       |        }
   84|       |    }
   85|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+UserInteraction.swift:
    1|       |//
    2|       |//  EKAttributes+UserInteraction.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public extension EKAttributes {
   12|       |    
   13|       |    /** Describes the user interaction events that are triggered as the user taps the entry / screen */
   14|       |    struct UserInteraction {
   15|       |        
   16|       |        /** Code that is executed when the user taps the entry / screen */
   17|       |        public typealias Action = () -> ()
   18|       |        
   19|       |        /** The default event that happens as the user interacts */
   20|       |        public enum Default {
   21|       |            
   22|       |            /** Absorbs touches. The entry / screen does nothing (Swallows the touch) */
   23|       |            case absorbTouches
   24|       |            
   25|       |            /** Touches delay the exit of the entry */
   26|       |            case delayExit(by: TimeInterval)
   27|       |            
   28|       |            /** Taps dismiss the entry immediately */
   29|       |            case dismissEntry
   30|       |            
   31|       |            /** Touches are forwarded to the lower window (In most cases it would be the application main window that will handle it */
   32|       |            case forward
   33|       |        }
   34|       |        
   35|      0|        var isResponsive: Bool {
   36|      0|            switch defaultAction {
   37|      0|            case .forward:
   38|      0|                return false
   39|      0|            default:
   40|      0|                return true
   41|      0|            }
   42|      0|        }
   43|       |        
   44|      0|        var isDelayExit: Bool {
   45|      0|            switch defaultAction {
   46|      0|            case .delayExit:
   47|      0|                return true
   48|      0|            default:
   49|      0|                return false
   50|      0|            }
   51|      0|        }
   52|       |        
   53|       |        /** A default action that is executed when the entry or the screen are interacted by the user */
   54|       |        public var defaultAction: Default
   55|       |        
   56|       |        /** Additional actions that can be customized by the user */
   57|       |        public var customTapActions: [Action]
   58|       |        
   59|      0|        public init(defaultAction: Default = .absorbTouches, customTapActions: [Action] = []) {
   60|      0|            self.defaultAction = defaultAction
   61|      0|            self.customTapActions = customTapActions
   62|      0|        }
   63|       |        
   64|       |        /** Dismiss action */
   65|      0|        public static var dismiss: UserInteraction {
   66|      0|            return UserInteraction(defaultAction: .dismissEntry)
   67|      0|        }
   68|       |        
   69|       |        /** Forward action */
   70|      0|        public static var forward: UserInteraction {
   71|      0|            return UserInteraction(defaultAction: .forward)
   72|      0|        }
   73|       |        
   74|       |        /** Absorb touches action */
   75|      0|        public static var absorbTouches: UserInteraction {
   76|      0|            return UserInteraction(defaultAction: .absorbTouches)
   77|      0|        }
   78|       |        
   79|       |        /** Delay exit action */
   80|      0|        public static func delayExit(by delay: TimeInterval) -> UserInteraction {
   81|      0|            return UserInteraction(defaultAction: .delayExit(by: delay))
   82|      0|        }
   83|       |    }
   84|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+Validations.swift:
    1|       |//
    2|       |//  EKAttributes+Validations.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/18/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |extension EKAttributes {
   11|       |    
   12|      0|    private static var minDisplayDuration: DisplayDuration {
   13|      0|        return 0
   14|      0|    }
   15|       |    
   16|      0|    var validateDisplayDuration: Bool {
   17|      0|        guard displayDuration >= EKAttributes.minDisplayDuration else {
   18|      0|            return false
   19|      0|        }
   20|      0|        return true
   21|      0|    }
   22|       |    
   23|      0|    var validateWindowLevel: Bool {
   24|      0|        return windowLevel.value >= .normal
   25|      0|    }
   26|       |    
   27|      0|    var isValid: Bool {
   28|      0|        return validateDisplayDuration && validateWindowLevel
   29|      0|    }
   30|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes+WindowLevel.swift:
    1|       |//
    2|       |//  EKAttributes+WindowLevel.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/21/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |public extension EKAttributes {
   12|       |    
   13|       |    /** Describes the window level in which the entry would be displayed */
   14|       |    enum WindowLevel {
   15|       |        
   16|       |        /** Above the alerts */
   17|       |        case alerts
   18|       |        
   19|       |        /** Above the status bar */
   20|       |        case statusBar
   21|       |        
   22|       |        /** Above the application window */
   23|       |        case normal
   24|       |        
   25|       |        /** Custom level */
   26|       |        case custom(level: UIWindow.Level)
   27|       |        
   28|       |        /** Returns the raw value - the window level itself */
   29|      0|        public var value: UIWindow.Level {
   30|      0|            switch self {
   31|      0|            case .alerts:
   32|      0|                return .alert
   33|      0|            case .statusBar:
   34|      0|                return .statusBar
   35|      0|            case .normal:
   36|      0|                return .normal
   37|      0|            case .custom(level: let level):
   38|      0|                return level
   39|      0|            }
   40|      0|        }
   41|       |    }
   42|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Model/EntryAttributes/EKAttributes.swift:
    1|       |//
    2|       |//  EKAttributes.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/19/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |public struct EKAttributes {
   13|       |    
   14|       |    // MARK: Identification
   15|       |    
   16|       |    /**
   17|       |     A settable **optional** name that matches the entry-attributes.
   18|       |     - Nameless entries cannot be inquired using *SwiftEntryKit.isCurrentlyDisplaying(entryNamed: _) -> Bool*
   19|       |     */
   20|       |    public var name: String?
   21|       |    
   22|       |    // MARK: Display Attributes
   23|       |    
   24|       |    /** Entry presentation window level */
   25|       |    public var windowLevel = WindowLevel.statusBar
   26|       |    
   27|       |    /** The position of the entry inside the screen */
   28|       |    public var position = Position.top
   29|       |
   30|       |    /** The display manner of the entry. */
   31|       |    public var precedence = Precedence.override(priority: .normal, dropEnqueuedEntries: false)
   32|       |    
   33|       |    /** Describes how long the entry is displayed before it is dismissed */
   34|       |    public var displayDuration: DisplayDuration = 2 // Use .infinity for infinite duration
   35|       |    
   36|       |    /** The frame attributes of the entry */
   37|       |    public var positionConstraints = PositionConstraints()
   38|       |    
   39|       |    // MARK: User Interaction Attributes
   40|       |    
   41|       |    /** Describes what happens when the user interacts the screen,
   42|       |     forwards the touch to the application window by default */
   43|       |    public var screenInteraction = UserInteraction.forward
   44|       |    
   45|       |    /** Describes what happens when the user interacts the entry,
   46|       |     dismisses the content by default */
   47|       |    public var entryInteraction = UserInteraction.dismiss
   48|       |
   49|       |    /** Describes the scrolling behaviour of the entry.
   50|       |     The entry can be swiped out and in with an ability to spring back with a jolt */
   51|       |    public var scroll = Scroll.enabled(swipeable: true, pullbackAnimation: .jolt)
   52|       |    
   53|       |    /** Generate haptic feedback once the entry is displayed */
   54|       |    public var hapticFeedbackType = NotificationHapticFeedback.none
   55|       |    
   56|       |    /** Describes the actions that take place when the entry appears or is being dismissed */
   57|       |    public var lifecycleEvents = LifecycleEvents()
   58|       |    
   59|       |    // MARK: Theme & Style Attributes
   60|       |    
   61|       |    /** Describes the entry's background appearance while it shows */
   62|       |    public var entryBackground = BackgroundStyle.clear
   63|       |    
   64|       |    /** Describes the background appearance while the entry shows */
   65|       |    public var screenBackground = BackgroundStyle.clear
   66|       |    
   67|       |    /** The shadow around the entry */
   68|       |    public var shadow = Shadow.none
   69|       |    
   70|       |    /** The corner attributes */
   71|       |    public var roundCorners = RoundCorners.none
   72|       |    
   73|       |    /** The border around the entry */
   74|       |    public var border = Border.none
   75|       |    
   76|       |    /** Preferred status bar style while the entry shows */
   77|       |    public var statusBar = StatusBar.inferred
   78|       |    
   79|       |    // MARK: Animation Attributes
   80|       |    
   81|       |    /** Describes how the entry animates in */
   82|       |    public var entranceAnimation = Animation.translation
   83|       |    
   84|       |    /** Describes how the entry animates out */
   85|       |    public var exitAnimation = Animation.translation
   86|       |    
   87|       |    /** Describes the previous entry behaviour when a new entry with higher display-priority shows */
   88|       |    public var popBehavior = PopBehavior.animated(animation: .translation)
   89|       |
   90|       |    /** Init with default attributes */
   91|      0|    public init() {}
   92|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/SwiftEntryKit.swift:
    1|       |//
    2|       |//  SwiftEntryKit.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/29/18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |/**
   11|       | A stateless, threadsafe (unless described otherwise) entry point that contains the display and the dismissal logic of entries.
   12|       | */
   13|       |public final class SwiftEntryKit {
   14|       |    
   15|       |    /** Describes the a single or multiple entries for possible dismissal states */
   16|       |    public enum EntryDismissalDescriptor {
   17|       |        
   18|       |        /** Describes specific entry / entries with name */
   19|       |        case specific(entryName: String)
   20|       |        
   21|       |        /** Describes a group of entries with lower or equal display priority */
   22|       |        case prioritizedLowerOrEqualTo(priority: EKAttributes.Precedence.Priority)
   23|       |        
   24|       |        /** Describes all the entries that are currently in the queue and pending presentation */
   25|       |        case enqueued
   26|       |        
   27|       |        /** Describes all the entries */
   28|       |        case all
   29|       |        
   30|       |        /** Describes the currently displayed entry */
   31|       |        case displayed
   32|       |    }
   33|       |    
   34|       |    /** The window to rollback to after dismissal */
   35|       |    public enum RollbackWindow {
   36|       |        
   37|       |        /** The main window */
   38|       |        case main
   39|       |        
   40|       |        /** A given custom window */
   41|       |        case custom(window: UIWindow)
   42|       |    }
   43|       |    
   44|       |    /** Completion handler for the dismissal method */
   45|       |    public typealias DismissCompletionHandler = () -> Void
   46|       |    
   47|       |    /** Cannot be instantiated, customized, inherited. */
   48|      0|    private init() {}
   49|       |    
   50|       |    /**
   51|       |     Returns true if **any** entry is currently displayed.
   52|       |     - Not thread safe - should be called from the main queue only in order to receive a reliable result.
   53|       |     - Convenience computed variable. Using it is the same as invoking **isCurrentlyDisplaying() -> Bool** (witohut the name of the entry).
   54|       |     */
   55|      0|    public class var isCurrentlyDisplaying: Bool {
   56|      0|        return isCurrentlyDisplaying()
   57|      0|    }
   58|       |    
   59|       |    /**
   60|       |     Returns true if an entry with a given name is currently displayed.
   61|       |     - Not thread safe - should be called from the main queue only in order to receive a reliable result.
   62|       |     - If invoked with *name* = *nil* or without the parameter value, it will return *true* if **any** entry is currently displayed.
   63|       |     - Returns a *false* value for currently enqueued entries.
   64|       |     - parameter name: The name of the entry. Its default value is *nil*.
   65|       |     */
   66|       |    public class func isCurrentlyDisplaying(entryNamed name: String? = nil) -> Bool {
   67|       |        return EKWindowProvider.shared.isCurrentlyDisplaying(entryNamed: name)
   68|       |    }
   69|       |    
   70|       |    /**
   71|       |     Returns true if **any** entry is currently enqueued and waiting to be displayed.
   72|       |     - Not thread safe - should be called from the main queue only in order to receive a reliable result.
   73|       |     - Convenience computed variable. Using it is the same as invoking **~queueContains() -> Bool** (witohut the name of the entry)
   74|       |     */
   75|      0|    public class var isQueueEmpty: Bool {
   76|      0|        return !queueContains()
   77|      0|    }
   78|       |    
   79|       |    /**
   80|       |     Returns true if an entry with a given name is currently enqueued and waiting to be displayed.
   81|       |     - Not thread safe - should be called from the main queue only in order to receive a reliable result.
   82|       |     - If invoked with *name* = *nil* or without the parameter value, it will return *true* if **any** entry is currently displayed, meaning, the queue is not currently empty.
   83|       |     - parameter name: The name of the entry. Its default value is *nil*.
   84|       |     */
   85|       |    public class func queueContains(entryNamed name: String? = nil) -> Bool {
   86|       |        return EKWindowProvider.shared.queueContains(entryNamed: name)
   87|       |    }
   88|       |    
   89|       |    /**
   90|       |     Displays a given entry view using an attributes struct.
   91|       |     - A thread-safe method - Can be invokes from any thread
   92|       |     - A class method - Should be called on the class
   93|       |     - parameter view: Custom view that is to be displayed
   94|       |     - parameter attributes: Display properties
   95|       |     - parameter presentInsideKeyWindow: Indicates whether the entry window should become the key window.
   96|       |     - parameter rollbackWindow: After the entry has been dismissed, SwiftEntryKit rolls back to the given window. By default it is *.main* which is the app main window
   97|       |     */
   98|      0|    public class func display(entry view: UIView, using attributes: EKAttributes, presentInsideKeyWindow: Bool = false, rollbackWindow: RollbackWindow = .main) {
   99|      0|        DispatchQueue.main.async {
  100|      0|            EKWindowProvider.shared.display(view: view, using: attributes, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
  101|      0|        }
  102|      0|    }
  103|       |    
  104|       |    /**
  105|       |     Displays a given entry view controller using an attributes struct.
  106|       |     - A thread-safe method - Can be invokes from any thread
  107|       |     - A class method - Should be called on the class
  108|       |     - parameter view: Custom view that is to be displayed
  109|       |     - parameter attributes: Display properties
  110|       |     - parameter presentInsideKeyWindow: Indicates whether the entry window should become the key window.
  111|       |     - parameter rollbackWindow: After the entry has been dismissed, SwiftEntryKit rolls back to the given window. By default it is *.main* - which is the app main window
  112|       |     */
  113|      0|    public class func display(entry viewController: UIViewController, using attributes: EKAttributes, presentInsideKeyWindow: Bool = false, rollbackWindow: RollbackWindow = .main) {
  114|      0|        DispatchQueue.main.async {
  115|      0|            EKWindowProvider.shared.display(viewController: viewController, using: attributes, presentInsideKeyWindow: presentInsideKeyWindow, rollbackWindow: rollbackWindow)
  116|      0|        }
  117|      0|    }
  118|       |    
  119|       |    /**
  120|       |     ALPHA FEATURE: Transform the previous entry to the current one using the previous attributes struct.
  121|       |     - A thread-safe method - Can be invoked from any thread.
  122|       |     - A class method - Should be called on the class.
  123|       |     - This feature hasn't been fully tested. Use with caution.
  124|       |     - parameter view: Custom view that is to be displayed instead of the currently displayed entry
  125|       |     */
  126|      0|    public class func transform(to view: UIView) {
  127|      0|        DispatchQueue.main.async {
  128|      0|            EKWindowProvider.shared.transform(to: view)
  129|      0|        }
  130|      0|    }
  131|       |    
  132|       |    /**
  133|       |     Dismisses the currently presented entry and removes the presented window instance after the exit animation is concluded.
  134|       |     - A thread-safe method - Can be invoked from any thread.
  135|       |     - A class method - Should be called on the class.
  136|       |     - parameter descriptor: A descriptor for the entries that are to be dismissed. The default value is *.displayed*.
  137|       |     - parameter completion: A completion handler that is to be called right after the entry is dismissed (After the animation is concluded).
  138|       |     */
  139|     11|    public class func dismiss(_ descriptor: EntryDismissalDescriptor = .displayed, with completion: DismissCompletionHandler? = nil) {
  140|     11|        DispatchQueue.main.async {
  141|     11|            EKWindowProvider.shared.dismiss(descriptor, with: completion)
  142|     11|        }
  143|     11|    }
  144|       |    
  145|       |    /**
  146|       |     Layout the view hierarchy that is rooted in the window.
  147|       |     - In case you use complex animations, you can call it to refresh the AutoLayout mechanism on the entire view hierarchy.
  148|       |     - A thread-safe method - Can be invoked from any thread.
  149|       |     - A class method - Should be called on the class.
  150|       |     */
  151|      0|    public class func layoutIfNeeded() {
  152|      0|        if Thread.isMainThread {
  153|      0|            EKWindowProvider.shared.layoutIfNeeded()
  154|      0|        } else {
  155|      0|            DispatchQueue.main.async {
  156|      0|                EKWindowProvider.shared.layoutIfNeeded()
  157|      0|            }
  158|      0|        }
  159|      0|    }
  160|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Utils/GradientView.swift:
    1|       |//
    2|       |//  GradientView.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class GradientView: UIView {
   12|       |    
   13|       |    private let gradientLayer = CAGradientLayer()
   14|       |    
   15|       |    var gradient: EKAttributes.BackgroundStyle.Gradient? {
   16|      0|        didSet {
   17|      0|            gradientLayer.colors = gradient?.colors.map { $0.cgColor }
   18|      0|            gradientLayer.startPoint = gradient?.startPoint ?? .zero
   19|      0|            gradientLayer.endPoint = gradient?.endPoint ?? .zero
   20|      0|        }
   21|       |    }
   22|       |    
   23|      0|    init() {
   24|      0|        super.init(frame: .zero)
   25|      0|        layer.addSublayer(gradientLayer)
   26|      0|    }
   27|       |    
   28|      0|    required init?(coder aDecoder: NSCoder) {
   29|      0|        fatalError("init(coder:) has not been implemented")
   30|      0|    }
   31|       |    
   32|      0|    override func layoutSubviews() {
   33|      0|        super.layoutSubviews()
   34|      0|        gradientLayer.frame = bounds
   35|      0|    }
   36|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Utils/HapticFeedbackGenerator.swift:
    1|       |//
    2|       |//  HapticFeedbackGenerator.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 4/20/18.
    6|       |//  Copyright (c) 2018 huri000@gmail.com. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |struct HapticFeedbackGenerator {
   12|       |    @available(iOS 10.0, *)
   13|      0|    static func notification(type: EKAttributes.NotificationHapticFeedback) {
   14|      0|        guard let value = type.value else {
   15|      0|            return
   16|      0|        }
   17|      0|        let generator = UINotificationFeedbackGenerator()
   18|      0|        generator.notificationOccurred(value)
   19|      0|    }
   20|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/SwiftEntryKit/Source/Utils/UIView+Responder.swift:
    1|       |//
    2|       |//  UIView+Responder.swift
    3|       |//  SwiftEntryKit
    4|       |//
    5|       |//  Created by Daniel Huri on 5/17/18.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |extension UIView {
   11|      0|    var containsFirstResponder: Bool {
   12|      0|        var contains = false
   13|      0|        for subview in subviews.reversed() where !contains {
   14|      0|            if subview.isFirstResponder {
   15|      0|                contains = true
   16|      0|            } else {
   17|      0|                contains = subview.containsFirstResponder
   18|      0|            }
   19|      0|        }
   20|      0|        return contains
   21|      0|    }
   22|       |}

