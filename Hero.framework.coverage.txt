/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Animator/HeroAnimatorViewContext.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |internal class HeroAnimatorViewContext {
   26|       |  weak var animator: HeroAnimator?
   27|       |  let snapshot: UIView
   28|       |  let appearing: Bool
   29|       |  var targetState: HeroTargetState
   30|       |  var duration: TimeInterval = 0
   31|       |
   32|       |  // computed
   33|      0|  var currentTime: TimeInterval {
   34|      0|    return snapshot.layer.convertTime(CACurrentMediaTime(), from: nil)
   35|      0|  }
   36|      0|  var container: UIView? {
   37|      0|    return animator?.hero.context.container
   38|      0|  }
   39|       |
   40|      0|  class func canAnimate(view: UIView, state: HeroTargetState, appearing: Bool) -> Bool {
   41|      0|    return false
   42|      0|  }
   43|       |
   44|      0|  func apply(state: HeroTargetState) {
   45|      0|  }
   46|       |
   47|      0|  func changeTarget(state: HeroTargetState, isDestination: Bool) {
   48|      0|  }
   49|       |
   50|      0|  func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {
   51|      0|    return 0
   52|      0|  }
   53|       |
   54|      0|  func seek(timePassed: TimeInterval) {
   55|      0|  }
   56|       |
   57|      0|  func clean() {
   58|      0|    animator = nil
   59|      0|  }
   60|       |
   61|      0|  func startAnimations() -> TimeInterval {
   62|      0|    return 0
   63|      0|  }
   64|       |
   65|      0|  required init(animator: HeroAnimator, snapshot: UIView, targetState: HeroTargetState, appearing: Bool) {
   66|      0|    self.animator = animator
   67|      0|    self.snapshot = snapshot
   68|      0|    self.targetState = targetState
   69|      0|    self.appearing = appearing
   70|      0|  }
   71|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Animator/HeroCoreAnimationViewContext.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension CALayer {
   26|      0|  internal static var heroAddedAnimations: [(CALayer, String, CAAnimation)]? = {
   27|      0|    let swizzling: (AnyClass, Selector, Selector) -> Void = { forClass, originalSelector, swizzledSelector in
   28|      0|      if let originalMethod = class_getInstanceMethod(forClass, originalSelector), let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) {
   29|      0|        method_exchangeImplementations(originalMethod, swizzledMethod)
   30|      0|      }
   31|      0|    }
   32|      0|    let originalSelector = #selector(add(_:forKey:))
   33|      0|    let swizzledSelector = #selector(hero_add(anim:forKey:))
   34|      0|    swizzling(CALayer.self, originalSelector, swizzledSelector)
   35|      0|    return nil
   36|      0|  }()
   37|       |
   38|      0|  @objc dynamic func hero_add(anim: CAAnimation, forKey: String?) {
   39|      0|    if CALayer.heroAddedAnimations != nil {
   40|      0|      let copiedAnim = anim.copy() as! CAAnimation
   41|      0|      copiedAnim.delegate = nil // having delegate resulted some weird animation behavior
   42|      0|      CALayer.heroAddedAnimations!.append((self, forKey!, copiedAnim))
   43|      0|      hero_add(anim: anim, forKey: forKey)
   44|      0|    } else {
   45|      0|      hero_add(anim: anim, forKey: forKey)
   46|      0|    }
   47|      0|  }
   48|       |}
   49|       |
   50|       |internal class HeroCoreAnimationViewContext: HeroAnimatorViewContext {
   51|       |
   52|       |  var state = [String: (Any?, Any?)]()
   53|       |  var timingFunction: CAMediaTimingFunction = .standard
   54|       |
   55|       |  var animations: [(CALayer, String, CAAnimation)] = []
   56|       |
   57|       |  // computed
   58|      0|  var contentLayer: CALayer? {
   59|      0|    let firstLayer = snapshot.layer.sublayers?.get(0)
   60|      0|    if firstLayer?.bounds == snapshot.bounds {
   61|      0|      return firstLayer
   62|      0|    }
   63|      0|    return nil
   64|      0|  }
   65|       |  var overlayLayer: CALayer?
   66|       |
   67|      0|  override class func canAnimate(view: UIView, state: HeroTargetState, appearing: Bool) -> Bool {
   68|      0|    return state.position != nil ||
   69|      0|           state.size != nil ||
   70|      0|           state.transform != nil ||
   71|      0|           state.cornerRadius != nil ||
   72|      0|           state.opacity != nil ||
   73|      0|           state.overlay != nil ||
   74|      0|           state.backgroundColor != nil ||
   75|      0|           state.borderColor != nil ||
   76|      0|           state.borderWidth != nil ||
   77|      0|           state.shadowOpacity != nil ||
   78|      0|           state.shadowRadius != nil ||
   79|      0|           state.shadowOffset != nil ||
   80|      0|           state.shadowColor != nil ||
   81|      0|           state.shadowPath != nil ||
   82|      0|           state.contentsRect != nil ||
   83|      0|           state.forceAnimate
   84|      0|  }
   85|       |
   86|      0|  func getOverlayLayer() -> CALayer {
   87|      0|    if overlayLayer == nil {
   88|      0|      overlayLayer = CALayer()
   89|      0|      overlayLayer!.frame = snapshot.bounds
   90|      0|      overlayLayer!.opacity = 0
   91|      0|      snapshot.layer.addSublayer(overlayLayer!)
   92|      0|    }
   93|      0|    return overlayLayer!
   94|      0|  }
   95|       |
   96|      0|  func overlayKeyFor(key: String) -> String? {
   97|      0|    if key.hasPrefix("overlay.") {
   98|      0|      var key = key
   99|      0|      key.removeSubrange(key.startIndex..<key.index(key.startIndex, offsetBy: 8))
  100|      0|      return key
  101|      0|    }
  102|      0|    return nil
  103|      0|  }
  104|       |
  105|      0|  func currentValue(key: String) -> Any? {
  106|      0|    if let key = overlayKeyFor(key: key) {
  107|      0|      return (overlayLayer?.presentation() ?? overlayLayer)?.value(forKeyPath: key)
  108|      0|    }
  109|      0|    if snapshot.layer.animationKeys()?.isEmpty != false {
  110|      0|      return snapshot.layer.value(forKeyPath: key)
  111|      0|    }
  112|      0|    return (snapshot.layer.presentation() ?? snapshot.layer).value(forKeyPath: key)
  113|      0|  }
  114|       |
  115|      0|  func getAnimation(key: String, beginTime: TimeInterval, duration: TimeInterval, fromValue: Any?, toValue: Any?, ignoreArc: Bool = false) -> CAPropertyAnimation {
  116|      0|    let key = overlayKeyFor(key: key) ?? key
  117|      0|    let anim: CAPropertyAnimation
  118|      0|
  119|      0|    if !ignoreArc, key == "position", let arcIntensity = targetState.arc,
  120|      0|      let fromPos = (fromValue as? NSValue)?.cgPointValue,
  121|      0|      let toPos = (toValue as? NSValue)?.cgPointValue,
  122|      0|      abs(fromPos.x - toPos.x) >= 1, abs(fromPos.y - toPos.y) >= 1 {
  123|      0|      let kanim = CAKeyframeAnimation(keyPath: key)
  124|      0|
  125|      0|      let path = CGMutablePath()
  126|      0|      let maxControl = fromPos.y > toPos.y ? CGPoint(x: toPos.x, y: fromPos.y) : CGPoint(x: fromPos.x, y: toPos.y)
  127|      0|      let minControl = (toPos - fromPos) / 2 + fromPos
  128|      0|
  129|      0|      path.move(to: fromPos)
  130|      0|      path.addQuadCurve(to: toPos, control: minControl + (maxControl - minControl) * arcIntensity)
  131|      0|
  132|      0|      kanim.values = [fromValue!, toValue!]
  133|      0|      kanim.path = path
  134|      0|      kanim.duration = duration
  135|      0|      kanim.timingFunctions = [timingFunction]
  136|      0|      anim = kanim
  137|      0|    } else if #available(iOS 9.0, *), key != "cornerRadius", let (stiffness, damping) = targetState.spring {
  138|      0|      let sanim = CASpringAnimation(keyPath: key)
  139|      0|      sanim.stiffness = stiffness
  140|      0|      sanim.damping = damping
  141|      0|      sanim.duration = sanim.settlingDuration
  142|      0|      sanim.fromValue = fromValue
  143|      0|      sanim.toValue = toValue
  144|      0|      anim = sanim
  145|      0|    } else {
  146|      0|      let banim = CABasicAnimation(keyPath: key)
  147|      0|      banim.duration = duration
  148|      0|      banim.fromValue = fromValue
  149|      0|      banim.toValue = toValue
  150|      0|      banim.timingFunction = timingFunction
  151|      0|      anim = banim
  152|      0|    }
  153|      0|
  154|      0|    anim.fillMode = CAMediaTimingFillMode.both
  155|      0|    anim.isRemovedOnCompletion = false
  156|      0|    anim.beginTime = beginTime
  157|      0|    return anim
  158|      0|  }
  159|       |
  160|      0|  func setSize(view: UIView, newSize: CGSize) {
  161|      0|    let oldSize = view.bounds.size
  162|      0|    if targetState.snapshotType != .noSnapshot {
  163|      0|      if oldSize.width == 0 || oldSize.height == 0 || newSize.width == 0 || newSize.height == 0 {
  164|      0|        for subview in view.subviews {
  165|      0|          subview.center = newSize.center
  166|      0|          subview.bounds.size = newSize
  167|      0|          setSize(view: subview, newSize: newSize)
  168|      0|        }
  169|      0|      } else {
  170|      0|        let sizeRatio = oldSize / newSize
  171|      0|        for subview in view.subviews {
  172|      0|          let center = subview.center
  173|      0|          let size = subview.bounds.size
  174|      0|          subview.center = center / sizeRatio
  175|      0|          subview.bounds.size = size / sizeRatio
  176|      0|          setSize(view: subview, newSize: size / sizeRatio)
  177|      0|        }
  178|      0|      }
  179|      0|      view.bounds.size = newSize
  180|      0|    } else {
  181|      0|      view.bounds.size = newSize
  182|      0|      view.layoutSubviews()
  183|      0|    }
  184|      0|  }
  185|       |
  186|      0|  func uiViewBasedAnimate(duration: TimeInterval, delay: TimeInterval, _ animations: @escaping () -> Void) {
  187|      0|    CALayer.heroAddedAnimations = []
  188|      0|
  189|      0|    if let (stiffness, damping) = targetState.spring {
  190|      0|      UIView.animate(withDuration: duration, delay: delay, usingSpringWithDamping: 1, initialSpringVelocity: 0, options: [], animations: animations, completion: nil)
  191|      0|
  192|      0|      let addedAnimations = CALayer.heroAddedAnimations!
  193|      0|      CALayer.heroAddedAnimations = nil
  194|      0|
  195|      0|      for (layer, key, anim) in addedAnimations {
  196|      0|        layer.removeAnimation(forKey: key)
  197|      0|        if #available(iOS 9.0, *), let anim = anim as? CASpringAnimation {
  198|      0|          anim.stiffness = stiffness
  199|      0|          anim.damping = damping
  200|      0|          self.addAnimation(anim, for: key, to: layer)
  201|      0|        } else {
  202|      0|          self.addAnimation(anim, for: key, to: layer)
  203|      0|        }
  204|      0|      }
  205|      0|    } else {
  206|      0|      CATransaction.begin()
  207|      0|      CATransaction.setAnimationTimingFunction(timingFunction)
  208|      0|      UIView.animate(withDuration: duration, delay: delay, options: [], animations: animations, completion: nil)
  209|      0|      let addedAnimations = CALayer.heroAddedAnimations!
  210|      0|      CALayer.heroAddedAnimations = nil
  211|      0|      for (layer, key, anim) in addedAnimations {
  212|      0|        layer.removeAnimation(forKey: key)
  213|      0|        self.addAnimation(anim, for: key, to: layer)
  214|      0|      }
  215|      0|      CATransaction.commit()
  216|      0|    }
  217|      0|  }
  218|       |
  219|      0|  func addAnimation(_ animation: CAAnimation, for key: String, to layer: CALayer) {
  220|      0|    let heroAnimationKey = "hero.\(key)"
  221|      0|    animations.append((layer, heroAnimationKey, animation))
  222|      0|    layer.add(animation, forKey: heroAnimationKey)
  223|      0|  }
  224|       |
  225|       |  // return the completion duration of the animation (duration + initial delay, not counting the beginTime)
  226|      0|  func animate(key: String, beginTime: TimeInterval, duration: TimeInterval, fromValue: Any?, toValue: Any?) -> TimeInterval {
  227|      0|    let anim = getAnimation(key: key, beginTime: beginTime, duration: duration, fromValue: fromValue, toValue: toValue)
  228|      0|
  229|      0|    if let overlayKey = overlayKeyFor(key: key) {
  230|      0|      addAnimation(anim, for: overlayKey, to: getOverlayLayer())
  231|      0|    } else {
  232|      0|      switch key {
  233|      0|      case "cornerRadius", "contentsRect", "contentsScale":
  234|      0|        addAnimation(anim, for: key, to: snapshot.layer)
  235|      0|        if let contentLayer = contentLayer {
  236|      0|          addAnimation(anim.copy() as! CAAnimation, for: key, to: contentLayer)
  237|      0|        }
  238|      0|        if let overlayLayer = overlayLayer {
  239|      0|          addAnimation(anim.copy() as! CAAnimation, for: key, to: overlayLayer)
  240|      0|        }
  241|      0|      case "bounds.size":
  242|      0|        guard let fromSize = (fromValue as? NSValue)?.cgSizeValue, let toSize = (toValue as? NSValue)?.cgSizeValue else {
  243|      0|          addAnimation(anim, for: key, to: snapshot.layer)
  244|      0|          break
  245|      0|        }
  246|      0|
  247|      0|        setSize(view: snapshot, newSize: fromSize)
  248|      0|        uiViewBasedAnimate(duration: anim.duration, delay: beginTime - currentTime) {
  249|      0|          self.setSize(view: self.snapshot, newSize: toSize)
  250|      0|        }
  251|      0|      default:
  252|      0|        addAnimation(anim, for: key, to: snapshot.layer)
  253|      0|      }
  254|      0|    }
  255|      0|
  256|      0|    return anim.duration + anim.beginTime - beginTime
  257|      0|  }
  258|       |
  259|       |  /**
  260|       |   - Returns: a CALayer [keyPath:value] map for animation
  261|       |   */
  262|      0|  func viewState(targetState: HeroTargetState) -> [String: Any?] {
  263|      0|    var targetState = targetState
  264|      0|    var rtn = [String: Any?]()
  265|      0|
  266|      0|    if let size = targetState.size {
  267|      0|      if targetState.useScaleBasedSizeChange ?? self.targetState.useScaleBasedSizeChange ?? false {
  268|      0|        let currentSize = snapshot.bounds.size
  269|      0|        targetState.append(.scale(x:size.width / currentSize.width,
  270|      0|                                  y:size.height / currentSize.height))
  271|      0|      } else {
  272|      0|        rtn["bounds.size"] = NSValue(cgSize: size)
  273|      0|      }
  274|      0|    }
  275|      0|    if let position = targetState.position {
  276|      0|      rtn["position"] = NSValue(cgPoint: position)
  277|      0|    }
  278|      0|    if let opacity = targetState.opacity, !(snapshot is UIVisualEffectView) {
  279|      0|      rtn["opacity"] = NSNumber(value: opacity)
  280|      0|    }
  281|      0|    if let cornerRadius = targetState.cornerRadius {
  282|      0|      rtn["cornerRadius"] = NSNumber(value: cornerRadius.native)
  283|      0|    }
  284|      0|    if let backgroundColor = targetState.backgroundColor {
  285|      0|      rtn["backgroundColor"] = backgroundColor
  286|      0|    }
  287|      0|    if let zPosition = targetState.zPosition {
  288|      0|      rtn["zPosition"] = NSNumber(value: zPosition.native)
  289|      0|    }
  290|      0|
  291|      0|    if let borderWidth = targetState.borderWidth {
  292|      0|      rtn["borderWidth"] = NSNumber(value: borderWidth.native)
  293|      0|    }
  294|      0|    if let borderColor = targetState.borderColor {
  295|      0|      rtn["borderColor"] = borderColor
  296|      0|    }
  297|      0|    if let masksToBounds = targetState.masksToBounds {
  298|      0|      rtn["masksToBounds"] = masksToBounds
  299|      0|    }
  300|      0|
  301|      0|    if targetState.displayShadow {
  302|      0|      if let shadowColor = targetState.shadowColor {
  303|      0|        rtn["shadowColor"] = shadowColor
  304|      0|      }
  305|      0|      if let shadowRadius = targetState.shadowRadius {
  306|      0|        rtn["shadowRadius"] = NSNumber(value: shadowRadius.native)
  307|      0|      }
  308|      0|      if let shadowOpacity = targetState.shadowOpacity {
  309|      0|        rtn["shadowOpacity"] = NSNumber(value: shadowOpacity)
  310|      0|      }
  311|      0|      if let shadowPath = targetState.shadowPath {
  312|      0|        rtn["shadowPath"] = shadowPath
  313|      0|      }
  314|      0|      if let shadowOffset = targetState.shadowOffset {
  315|      0|        rtn["shadowOffset"] = NSValue(cgSize: shadowOffset)
  316|      0|      }
  317|      0|    }
  318|      0|
  319|      0|    if let contentsRect = targetState.contentsRect {
  320|      0|      rtn["contentsRect"] = NSValue(cgRect: contentsRect)
  321|      0|    }
  322|      0|
  323|      0|    if let contentsScale = targetState.contentsScale {
  324|      0|      rtn["contentsScale"] = NSNumber(value: contentsScale.native)
  325|      0|    }
  326|      0|
  327|      0|    if let transform = targetState.transform {
  328|      0|      rtn["transform"] = NSValue(caTransform3D: transform)
  329|      0|    }
  330|      0|
  331|      0|    if let (color, opacity) = targetState.overlay {
  332|      0|      rtn["overlay.backgroundColor"] = color
  333|      0|      rtn["overlay.opacity"] = NSNumber(value: opacity.native)
  334|      0|    }
  335|      0|    return rtn
  336|      0|  }
  337|       |
  338|      0|  override func apply(state: HeroTargetState) {
  339|      0|    let targetState = viewState(targetState: state)
  340|      0|    for (key, targetValue) in targetState {
  341|      0|      if self.state[key] == nil {
  342|      0|        let current = currentValue(key: key)
  343|      0|        self.state[key] = (current, current)
  344|      0|      }
  345|      0|      let oldAnimations = animations
  346|      0|      animations = []
  347|      0|      _ = animate(key: key, beginTime: 0, duration: 100, fromValue: targetValue, toValue: targetValue)
  348|      0|      animations = oldAnimations
  349|      0|    }
  350|      0|  }
  351|       |
  352|      0|  override func changeTarget(state: HeroTargetState, isDestination: Bool) {
  353|      0|    let targetState = viewState(targetState: state)
  354|      0|    for (key, targetValue) in targetState {
  355|      0|      let from: Any?, to: Any?
  356|      0|      if let data = self.state[key] {
  357|      0|        from = data.0
  358|      0|        to = data.1
  359|      0|      } else {
  360|      0|        let data = currentValue(key: key)
  361|      0|        from = data
  362|      0|        to = data
  363|      0|      }
  364|      0|      if isDestination {
  365|      0|        self.state[key] = (from, targetValue)
  366|      0|      } else {
  367|      0|        self.state[key] = (targetValue, to)
  368|      0|      }
  369|      0|    }
  370|      0|  }
  371|       |
  372|      0|  override func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {
  373|      0|    for (key, (fromValue, toValue)) in state {
  374|      0|      let realToValue = !reverse ? toValue : fromValue
  375|      0|      let realFromValue = currentValue(key: key)
  376|      0|      state[key] = (realFromValue, realToValue)
  377|      0|    }
  378|      0|
  379|      0|    if reverse {
  380|      0|      if timePassed > targetState.delay + duration {
  381|      0|        let backDelay = timePassed - (targetState.delay + duration)
  382|      0|        return animate(delay: backDelay, duration: duration)
  383|      0|      } else if timePassed > targetState.delay {
  384|      0|        return animate(delay: 0, duration: duration - (timePassed - targetState.delay))
  385|      0|      } else {
  386|      0|        return 0
  387|      0|      }
  388|      0|    } else {
  389|      0|      if timePassed <= targetState.delay {
  390|      0|        return animate(delay: targetState.delay - timePassed, duration: duration)
  391|      0|      } else if timePassed <= targetState.delay + duration {
  392|      0|        let timePassedDelay = timePassed - targetState.delay
  393|      0|        return animate(delay: 0, duration: duration - timePassedDelay)
  394|      0|      } else {
  395|      0|        return 0
  396|      0|      }
  397|      0|    }
  398|      0|  }
  399|       |
  400|      0|  func animate(delay: TimeInterval, duration: TimeInterval) -> TimeInterval {
  401|      0|    for (layer, key, _) in animations {
  402|      0|      layer.removeAnimation(forKey: key)
  403|      0|    }
  404|      0|
  405|      0|    if let tf = targetState.timingFunction {
  406|      0|      timingFunction = tf
  407|      0|    }
  408|      0|
  409|      0|    var timeUntilStop: TimeInterval = duration
  410|      0|
  411|      0|    animations = []
  412|      0|    for (key, (fromValue, toValue)) in state {
  413|      0|      let neededTime = animate(key: key, beginTime: currentTime + delay, duration: duration, fromValue: fromValue, toValue: toValue)
  414|      0|      timeUntilStop = max(timeUntilStop, neededTime)
  415|      0|    }
  416|      0|
  417|      0|    return timeUntilStop + delay
  418|      0|  }
  419|       |
  420|      0|  override func seek(timePassed: TimeInterval) {
  421|      0|    let timeOffset = timePassed - targetState.delay
  422|      0|    for (layer, key, anim) in animations {
  423|      0|      anim.speed = 0
  424|      0|      anim.timeOffset = timeOffset.clamp(0, anim.duration - 0.001)
  425|      0|      layer.removeAnimation(forKey: key)
  426|      0|      layer.add(anim, forKey: key)
  427|      0|    }
  428|      0|  }
  429|       |
  430|      0|  override func clean() {
  431|      0|    super.clean()
  432|      0|    overlayLayer = nil
  433|      0|  }
  434|       |
  435|      0|  override func startAnimations() -> TimeInterval {
  436|      0|    if let beginStateModifiers = targetState.beginState {
  437|      0|      let beginState = HeroTargetState(modifiers: beginStateModifiers)
  438|      0|      let appeared = viewState(targetState: beginState)
  439|      0|      for (key, value) in appeared {
  440|      0|        snapshot.layer.setValue(value, forKeyPath: key)
  441|      0|      }
  442|      0|      if let (color, opacity) = beginState.overlay {
  443|      0|        let overlay = getOverlayLayer()
  444|      0|        overlay.backgroundColor = color
  445|      0|        overlay.opacity = Float(opacity)
  446|      0|      }
  447|      0|    }
  448|      0|
  449|      0|    let disappeared = viewState(targetState: targetState)
  450|      0|
  451|      0|    for (key, disappearedState) in disappeared {
  452|      0|      let appearingState = currentValue(key: key)
  453|      0|      let toValue = appearing ? appearingState : disappearedState
  454|      0|      let fromValue = !appearing ? appearingState : disappearedState
  455|      0|      state[key] = (fromValue, toValue)
  456|      0|    }
  457|      0|    return animate(delay: targetState.delay, duration: duration)
  458|      0|  }
  459|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Animator/HeroDefaultAnimator.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |internal extension UIView {
   26|      0|  func optimizedDurationTo(position: CGPoint?, size: CGSize?, transform: CATransform3D?) -> TimeInterval {
   27|      0|    let fromPos = (layer.presentation() ?? layer).position
   28|      0|    let toPos = position ?? fromPos
   29|      0|    let fromSize = (layer.presentation() ?? layer).bounds.size
   30|      0|    let toSize = size ?? fromSize
   31|      0|    let fromTransform = (layer.presentation() ?? layer).transform
   32|      0|    let toTransform = transform ?? fromTransform
   33|      0|
   34|      0|    let realFromPos = CGPoint.zero.transform(fromTransform) + fromPos
   35|      0|    let realToPos = CGPoint.zero.transform(toTransform) + toPos
   36|      0|
   37|      0|    let realFromSize = fromSize.transform(fromTransform)
   38|      0|    let realToSize = toSize.transform(toTransform)
   39|      0|
   40|      0|    let movePoints = (realFromPos.distance(realToPos) + realFromSize.point.distance(realToSize.point))
   41|      0|
   42|      0|    // duration is 0.2 @ 0 to 0.375 @ 500
   43|      0|    let duration = 0.208 + Double(movePoints.clamp(0, 500)) / 3000
   44|      0|    return duration
   45|      0|  }
   46|       |}
   47|       |
   48|       |internal class HeroDefaultAnimator<ViewContext: HeroAnimatorViewContext>: HeroAnimator {
   49|       |  weak public var hero: HeroTransition!
   50|      0|  public var context: HeroContext! {
   51|      0|    return hero?.context
   52|      0|  }
   53|       |  var viewContexts: [UIView: ViewContext] = [:]
   54|       |
   55|      0|  public func seekTo(timePassed: TimeInterval) {
   56|      0|    for viewContext in viewContexts.values {
   57|      0|      viewContext.seek(timePassed: timePassed)
   58|      0|    }
   59|      0|  }
   60|       |
   61|      0|  public func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {
   62|      0|    var duration: TimeInterval = 0
   63|      0|    for (_, viewContext) in viewContexts {
   64|      0|      if viewContext.targetState.duration == nil {
   65|      0|        viewContext.duration = max(viewContext.duration,
   66|      0|                                   calculateOptimizedDuration(snapshot: viewContext.snapshot,
   67|      0|                                                              targetState: viewContext.targetState) + timePassed)
   68|      0|      }
   69|      0|      let timeUntilStopped = viewContext.resume(timePassed: timePassed, reverse: reverse)
   70|      0|      duration = max(duration, timeUntilStopped)
   71|      0|    }
   72|      0|    return duration
   73|      0|  }
   74|       |
   75|      0|  public func apply(state: HeroTargetState, to view: UIView) {
   76|      0|    if let context = viewContexts[view] {
   77|      0|      context.apply(state: state)
   78|      0|    }
   79|      0|  }
   80|       |
   81|      0|  public func changeTarget(state: HeroTargetState, isDestination: Bool, to view: UIView) {
   82|      0|    if let context = viewContexts[view] {
   83|      0|      context.changeTarget(state: state, isDestination: isDestination)
   84|      0|    }
   85|      0|  }
   86|       |
   87|      0|  public func canAnimate(view: UIView, appearing: Bool) -> Bool {
   88|      0|    guard let state = context[view] else { return false }
   89|      0|    return ViewContext.canAnimate(view: view, state: state, appearing: appearing)
   90|      0|  }
   91|       |
   92|      0|  public func animate(fromViews: [UIView], toViews: [UIView]) -> TimeInterval {
   93|      0|    var maxDuration: TimeInterval = 0
   94|      0|
   95|      0|    for v in fromViews { createViewContext(view: v, appearing: false) }
   96|      0|    for v in toViews { createViewContext(view: v, appearing: true) }
   97|      0|
   98|      0|    for viewContext in viewContexts.values {
   99|      0|      if let duration = viewContext.targetState.duration, duration != .infinity {
  100|      0|        viewContext.duration = duration
  101|      0|        maxDuration = max(maxDuration, duration)
  102|      0|      } else {
  103|      0|        let duration = calculateOptimizedDuration(snapshot: viewContext.snapshot, targetState: viewContext.targetState)
  104|      0|        if viewContext.targetState.duration == nil {
  105|      0|          viewContext.duration = duration
  106|      0|        }
  107|      0|        maxDuration = max(maxDuration, duration)
  108|      0|      }
  109|      0|    }
  110|      0|    for viewContext in viewContexts.values {
  111|      0|      if viewContext.targetState.duration == .infinity {
  112|      0|        viewContext.duration = maxDuration
  113|      0|      }
  114|      0|      let timeUntilStopped = viewContext.startAnimations()
  115|      0|      maxDuration = max(maxDuration, timeUntilStopped)
  116|      0|    }
  117|      0|
  118|      0|    return maxDuration
  119|      0|  }
  120|       |
  121|      0|  func calculateOptimizedDuration(snapshot: UIView, targetState: HeroTargetState) -> TimeInterval {
  122|      0|    return snapshot.optimizedDurationTo(position: targetState.position,
  123|      0|                                        size: targetState.size,
  124|      0|                                        transform: targetState.transform)
  125|      0|  }
  126|       |
  127|      0|  func createViewContext(view: UIView, appearing: Bool) {
  128|      0|    let snapshot = context.snapshotView(for: view)
  129|      0|    let viewContext = ViewContext(animator: self, snapshot: snapshot, targetState: context[view]!, appearing: appearing)
  130|      0|    viewContexts[view] = viewContext
  131|      0|  }
  132|       |
  133|      0|  public func clean() {
  134|      0|    for vc in viewContexts.values {
  135|      0|      vc.clean()
  136|      0|    }
  137|      0|    viewContexts.removeAll()
  138|      0|  }
  139|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Animator/HeroViewPropertyViewContext.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |@available(iOS 10, tvOS 10, *)
   26|       |internal class HeroViewPropertyViewContext: HeroAnimatorViewContext {
   27|       |
   28|       |  var viewPropertyAnimator: UIViewPropertyAnimator!
   29|       |  var endEffect: UIVisualEffect?
   30|       |  var startEffect: UIVisualEffect?
   31|       |
   32|      0|  override class func canAnimate(view: UIView, state: HeroTargetState, appearing: Bool) -> Bool {
   33|      0|    return view is UIVisualEffectView && state.opacity != nil
   34|      0|  }
   35|       |
   36|      0|  override func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {
   37|      0|    guard let visualEffectView = snapshot as? UIVisualEffectView else { return 0 }
   38|      0|    if reverse {
   39|      0|      viewPropertyAnimator?.stopAnimation(false)
   40|      0|      viewPropertyAnimator?.finishAnimation(at: .current)
   41|      0|      viewPropertyAnimator = UIViewPropertyAnimator(duration: duration, curve: .linear) {
   42|      0|        visualEffectView.effect = reverse ? self.startEffect : self.endEffect
   43|      0|      }
   44|      0|    }
   45|      0|    viewPropertyAnimator.startAnimation()
   46|      0|    return duration
   47|      0|  }
   48|       |
   49|      0|  override func seek(timePassed: TimeInterval) {
   50|      0|    viewPropertyAnimator?.pauseAnimation()
   51|      0|    viewPropertyAnimator?.fractionComplete = CGFloat(timePassed / duration)
   52|      0|  }
   53|       |
   54|      0|  override func clean() {
   55|      0|    super.clean()
   56|      0|    viewPropertyAnimator?.stopAnimation(false)
   57|      0|    viewPropertyAnimator?.finishAnimation(at: .current)
   58|      0|    viewPropertyAnimator = nil
   59|      0|  }
   60|       |
   61|      0|  override func startAnimations() -> TimeInterval {
   62|      0|    guard let visualEffectView = snapshot as? UIVisualEffectView else { return 0 }
   63|      0|    let appearedEffect = visualEffectView.effect
   64|      0|    let disappearedEffect = targetState.opacity == 0 ? nil : visualEffectView.effect
   65|      0|    startEffect = appearing ? disappearedEffect : appearedEffect
   66|      0|    endEffect = appearing ? appearedEffect : disappearedEffect
   67|      0|    visualEffectView.effect = startEffect
   68|      0|    viewPropertyAnimator = UIViewPropertyAnimator(duration: duration, curve: .linear) {
   69|      0|      visualEffectView.effect = self.endEffect
   70|      0|    }
   71|      0|    viewPropertyAnimator.startAnimation()
   72|      0|    return duration
   73|      0|  }
   74|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Debug Plugin/HeroDebugPlugin.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |#if os(iOS)
   26|       |public class HeroDebugPlugin: HeroPlugin {
   27|       |  public static var showOnTop: Bool = false
   28|       |
   29|       |  var debugView: HeroDebugView?
   30|       |  var zPositionMap = [UIView: CGFloat]()
   31|       |  var addedLayers: [CALayer] = []
   32|       |  var updating = false
   33|       |
   34|      0|  override public func animate(fromViews: [UIView], toViews: [UIView]) -> TimeInterval {
   35|      0|    if hero.forceNotInteractive { return 0 }
   36|      0|    var hasArc = false
   37|      0|    for v in context.fromViews + context.toViews where context[v]?.arc != nil && context[v]?.position != nil {
   38|      0|      hasArc = true
   39|      0|      break
   40|      0|    }
   41|      0|    let debugView = HeroDebugView(initialProcess: hero.isPresenting ? 0.0 : 1.0, showCurveButton: hasArc, showOnTop: HeroDebugPlugin.showOnTop)
   42|      0|    debugView.frame = hero.container.bounds
   43|      0|    debugView.delegate = self
   44|      0|    hero.container.window?.addSubview(debugView)
   45|      0|
   46|      0|    debugView.layoutSubviews()
   47|      0|    self.debugView = debugView
   48|      0|
   49|      0|    UIView.animate(withDuration: 0.4) {
   50|      0|      debugView.showControls = true
   51|      0|    }
   52|      0|
   53|      0|    return .infinity
   54|      0|  }
   55|       |
   56|      0|  public override func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {
   57|      0|    guard let debugView = debugView else { return 0.4 }
   58|      0|    debugView.delegate = nil
   59|      0|
   60|      0|    UIView.animate(withDuration: 0.4) {
   61|      0|      debugView.showControls = false
   62|      0|      debugView.debugSlider.setValue(roundf(debugView.progress), animated: true)
   63|      0|    }
   64|      0|
   65|      0|    on3D(wants3D: false)
   66|      0|    return 0.4
   67|      0|  }
   68|       |
   69|      0|  public override func clean() {
   70|      0|    debugView?.removeFromSuperview()
   71|      0|    debugView = nil
   72|      0|  }
   73|       |}
   74|       |
   75|       |extension HeroDebugPlugin: HeroDebugViewDelegate {
   76|      0|  public func onDone() {
   77|      0|    guard let debugView = debugView else { return }
   78|      0|    let seekValue = hero.isPresenting ? debugView.progress : 1.0 - debugView.progress
   79|      0|    if seekValue > 0.5 {
   80|      0|      hero.finish()
   81|      0|    } else {
   82|      0|      hero.cancel()
   83|      0|    }
   84|      0|  }
   85|       |
   86|      0|  public func onProcessSliderChanged(progress: Float) {
   87|      0|    let seekValue = hero.isPresenting ? progress : 1.0 - progress
   88|      0|    hero.update(CGFloat(seekValue))
   89|      0|  }
   90|       |
   91|      0|  func onPerspectiveChanged(translation: CGPoint, rotation: CGFloat, scale: CGFloat) {
   92|      0|    var t = CATransform3DIdentity
   93|      0|    t.m34 = -1 / 4000
   94|      0|    t = CATransform3DTranslate(t, translation.x, translation.y, 0)
   95|      0|    t = CATransform3DScale(t, scale, scale, 1)
   96|      0|    t = CATransform3DRotate(t, rotation, 0, 1, 0)
   97|      0|    hero.container.layer.sublayerTransform = t
   98|      0|  }
   99|       |
  100|      0|  func animateZPosition(view: UIView, to: CGFloat) {
  101|      0|    let a = CABasicAnimation(keyPath: "zPosition")
  102|      0|    a.fromValue = view.layer.value(forKeyPath: "zPosition")
  103|      0|    a.toValue = NSNumber(value: Double(to))
  104|      0|    a.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
  105|      0|    a.duration = 0.4
  106|      0|    view.layer.add(a, forKey: "zPosition")
  107|      0|    view.layer.zPosition = to
  108|      0|  }
  109|       |
  110|      0|  func onDisplayArcCurve(wantsCurve: Bool) {
  111|      0|    for layer in addedLayers {
  112|      0|      layer.removeFromSuperlayer()
  113|      0|      addedLayers.removeAll()
  114|      0|    }
  115|      0|    if wantsCurve {
  116|      0|      for layer in hero.container.layer.sublayers! {
  117|      0|        for (_, anim) in layer.animations {
  118|      0|          if let keyframeAnim = anim as? CAKeyframeAnimation, let path = keyframeAnim.path {
  119|      0|            let s = CAShapeLayer()
  120|      0|            s.zPosition = layer.zPosition + 10
  121|      0|            s.path = path
  122|      0|            s.strokeColor = UIColor.blue.cgColor
  123|      0|            s.fillColor = UIColor.clear.cgColor
  124|      0|            hero.container.layer.addSublayer(s)
  125|      0|            addedLayers.append(s)
  126|      0|          }
  127|      0|        }
  128|      0|      }
  129|      0|    }
  130|      0|  }
  131|       |
  132|       |  func on3D(wants3D: Bool) {
  133|       |    var t = CATransform3DIdentity
  134|       |    if wants3D {
  135|       |      var viewsWithZPosition = Set<UIView>()
  136|       |      for view in hero.container.subviews where view.layer.zPosition != 0 {
  137|       |        viewsWithZPosition.insert(view)
  138|       |        zPositionMap[view] = view.layer.zPosition
  139|       |      }
  140|       |
  141|      0|      let viewsWithoutZPosition = hero.container.subviews.filter { return !viewsWithZPosition.contains($0) }
  142|      0|      let viewsWithPositiveZPosition = viewsWithZPosition.filter { return $0.layer.zPosition > 0 }
  143|       |
  144|       |      for (i, v) in viewsWithoutZPosition.enumerated() {
  145|       |        animateZPosition(view: v, to: CGFloat(i * 10))
  146|       |      }
  147|       |
  148|       |      var maxZPosition: CGFloat = 0
  149|       |      for v in viewsWithPositiveZPosition {
  150|       |        maxZPosition = max(maxZPosition, v.layer.zPosition)
  151|       |        animateZPosition(view: v, to: v.layer.zPosition + CGFloat(viewsWithoutZPosition.count * 10))
  152|       |      }
  153|       |
  154|       |      t.m34 = -1 / 4000
  155|       |      t = CATransform3DTranslate(t, debugView!.translation.x, debugView!.translation.y, 0)
  156|       |      t = CATransform3DScale(t, debugView!.scale, debugView!.scale, 1)
  157|       |      t = CATransform3DRotate(t, debugView!.rotation, 0, 1, 0)
  158|       |    } else {
  159|       |      for v in hero.container.subviews {
  160|      0|        animateZPosition(view: v, to: self.zPositionMap[v] ?? 0)
  161|       |      }
  162|       |      self.zPositionMap.removeAll()
  163|       |    }
  164|       |
  165|       |    let a = CABasicAnimation(keyPath: "sublayerTransform")
  166|       |    a.fromValue = hero.container.layer.value(forKeyPath: "sublayerTransform")
  167|       |    a.toValue = NSValue(caTransform3D: t)
  168|       |    a.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
  169|       |    a.duration = 0.4
  170|       |
  171|      0|    UIView.animate(withDuration: 0.4) {
  172|      0|      self.context.container.backgroundColor = UIColor(white: 0.85, alpha: 1.0)
  173|      0|    }
  174|       |
  175|       |    hero.container.layer.add(a, forKey: "debug")
  176|       |    hero.container.layer.sublayerTransform = t
  177|       |  }
  178|       |}
  179|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Debug Plugin/HeroDebugView.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |#if os(iOS)
   26|       |protocol HeroDebugViewDelegate: class {
   27|       |  func onProcessSliderChanged(progress: Float)
   28|       |  func onPerspectiveChanged(translation: CGPoint, rotation: CGFloat, scale: CGFloat)
   29|       |  func on3D(wants3D: Bool)
   30|       |  func onDisplayArcCurve(wantsCurve: Bool)
   31|       |  func onDone()
   32|       |}
   33|       |
   34|       |class HeroDebugView: UIView {
   35|       |  var backgroundView: UIView!
   36|       |  var debugSlider: UISlider!
   37|       |  var perspectiveButton: UIButton!
   38|       |  var doneButton: UIButton!
   39|       |  var arcCurveButton: UIButton?
   40|       |
   41|       |  weak var delegate: HeroDebugViewDelegate?
   42|       |  var panGR: UIPanGestureRecognizer!
   43|       |
   44|       |  var pinchGR: UIPinchGestureRecognizer!
   45|       |
   46|       |  var showControls: Bool = false {
   47|      0|    didSet {
   48|      0|      layoutSubviews()
   49|      0|    }
   50|       |  }
   51|       |
   52|       |  var showOnTop: Bool = false
   53|       |  var rotation: CGFloat = π / 6
   54|       |  var scale: CGFloat = 0.6
   55|       |  var translation: CGPoint = .zero
   56|      0|  var progress: Float {
   57|      0|    return debugSlider.value
   58|      0|  }
   59|       |
   60|      0|  init(initialProcess: Float, showCurveButton: Bool, showOnTop: Bool) {
   61|      0|    super.init(frame: .zero)
   62|      0|    self.showOnTop = showOnTop
   63|      0|    backgroundView = UIView(frame: .zero)
   64|      0|    backgroundView.backgroundColor = UIColor(white: 1.0, alpha: 0.95)
   65|      0|    backgroundView.layer.shadowColor = UIColor.darkGray.cgColor
   66|      0|    backgroundView.layer.shadowOpacity = 0.3
   67|      0|    backgroundView.layer.shadowRadius = 5
   68|      0|    backgroundView.layer.shadowOffset = CGSize.zero
   69|      0|    addSubview(backgroundView)
   70|      0|
   71|      0|    doneButton = UIButton(type: .system)
   72|      0|    doneButton.setTitle("Done", for: .normal)
   73|      0|    doneButton.addTarget(self, action: #selector(onDone), for: .touchUpInside)
   74|      0|    backgroundView.addSubview(doneButton)
   75|      0|
   76|      0|    perspectiveButton = UIButton(type: .system)
   77|      0|    perspectiveButton.setTitle("3D View", for: .normal)
   78|      0|    perspectiveButton.addTarget(self, action: #selector(onPerspective), for: .touchUpInside)
   79|      0|    backgroundView.addSubview(perspectiveButton)
   80|      0|
   81|      0|    if showCurveButton {
   82|      0|      arcCurveButton = UIButton(type: .system)
   83|      0|      arcCurveButton!.setTitle("Show Arcs", for: .normal)
   84|      0|      arcCurveButton!.addTarget(self, action: #selector(onDisplayArcCurve), for: .touchUpInside)
   85|      0|      backgroundView.addSubview(arcCurveButton!)
   86|      0|    }
   87|      0|
   88|      0|    debugSlider = UISlider(frame: .zero)
   89|      0|    debugSlider.layer.zPosition = 1000
   90|      0|    debugSlider.minimumValue = 0
   91|      0|    debugSlider.maximumValue = 1
   92|      0|    debugSlider.addTarget(self, action: #selector(onSlide), for: .valueChanged)
   93|      0|    debugSlider.isUserInteractionEnabled = true
   94|      0|    debugSlider.value = initialProcess
   95|      0|    backgroundView.addSubview(debugSlider)
   96|      0|
   97|      0|    panGR = UIPanGestureRecognizer(target: self, action: #selector(pan))
   98|      0|    panGR.delegate = self
   99|      0|    panGR.maximumNumberOfTouches = 1
  100|      0|
  101|      0|    addGestureRecognizer(panGR)
  102|      0|
  103|      0|    pinchGR = UIPinchGestureRecognizer(target: self, action: #selector(pinch))
  104|      0|    pinchGR.delegate = self
  105|      0|    addGestureRecognizer(pinchGR)
  106|      0|  }
  107|       |
  108|      0|  required public init?(coder aDecoder: NSCoder) {
  109|      0|    fatalError("init(coder:) has not been implemented")
  110|      0|  }
  111|       |
  112|      0|  public override func layoutSubviews() {
  113|      0|    super.layoutSubviews()
  114|      0|    var backgroundFrame = bounds
  115|      0|    let safeInset: CGFloat
  116|      0|    if #available(iOS 11.0, *) {
  117|      0|      safeInset = showOnTop ? safeAreaInsets.top : safeAreaInsets.bottom
  118|      0|    } else {
  119|      0|      safeInset = 0
  120|      0|    }
  121|      0|    backgroundFrame.size.height = 72 + safeInset
  122|      0|    if showOnTop {
  123|      0|      backgroundFrame.origin.y = showControls ? 0 : -80
  124|      0|    } else {
  125|      0|      backgroundFrame.origin.y = bounds.maxY - CGFloat(showControls ? 72.0 + safeInset : -8.0)
  126|      0|    }
  127|      0|    backgroundView.frame = backgroundFrame
  128|      0|
  129|      0|    var sliderFrame = bounds.insetBy(dx: 10, dy: 0)
  130|      0|    sliderFrame.size.height = 44
  131|      0|    sliderFrame.origin.y = showOnTop ? 28 + safeInset : 28
  132|      0|    debugSlider.frame = sliderFrame
  133|      0|
  134|      0|    perspectiveButton.sizeToFit()
  135|      0|    perspectiveButton.frame.origin = CGPoint(x: bounds.maxX - perspectiveButton.bounds.width - 10, y: showOnTop ? 4 + safeInset : 4)
  136|      0|    doneButton.sizeToFit()
  137|      0|    doneButton.frame.origin = CGPoint(x: 10, y: showOnTop ? 4 + safeInset : 4)
  138|      0|    arcCurveButton?.sizeToFit()
  139|      0|    arcCurveButton?.center = CGPoint(x: center.x, y: doneButton.center.y)
  140|      0|  }
  141|       |
  142|       |  var startRotation: CGFloat = 0
  143|      0|  @objc public func pan() {
  144|      0|    if panGR.state == .began {
  145|      0|      startRotation = rotation
  146|      0|    }
  147|      0|    rotation = startRotation + panGR.translation(in: nil).x / 150
  148|      0|    if rotation > π {
  149|      0|      rotation -= 2 * π
  150|      0|    } else if rotation < -π {
  151|      0|      rotation += 2 * π
  152|      0|    }
  153|      0|    delegate?.onPerspectiveChanged(translation: translation, rotation: rotation, scale: scale)
  154|      0|  }
  155|       |
  156|       |  var startLocation: CGPoint = .zero
  157|       |  var startTranslation: CGPoint = .zero
  158|       |  var startScale: CGFloat = 1
  159|      0|  @objc public func pinch() {
  160|      0|    switch pinchGR.state {
  161|      0|    case .began:
  162|      0|      startLocation = pinchGR.location(in: nil)
  163|      0|      startTranslation = translation
  164|      0|      startScale = scale
  165|      0|      fallthrough
  166|      0|    case .changed:
  167|      0|      if pinchGR.numberOfTouches >= 2 {
  168|      0|        scale = min(1, max(0.2, startScale * pinchGR.scale))
  169|      0|        translation = startTranslation + pinchGR.location(in: nil) - startLocation
  170|      0|        delegate?.onPerspectiveChanged(translation: translation, rotation: rotation, scale: scale)
  171|      0|      }
  172|      0|    default:
  173|      0|      break
  174|      0|    }
  175|      0|  }
  176|       |
  177|      0|  @objc public func onDone() {
  178|      0|    delegate?.onDone()
  179|      0|  }
  180|      0|  @objc public func onPerspective() {
  181|      0|    perspectiveButton.isSelected = !perspectiveButton.isSelected
  182|      0|    delegate?.on3D(wants3D: perspectiveButton.isSelected)
  183|      0|  }
  184|      0|  @objc public func onDisplayArcCurve() {
  185|      0|    arcCurveButton!.isSelected = !arcCurveButton!.isSelected
  186|      0|    delegate?.onDisplayArcCurve(wantsCurve: arcCurveButton!.isSelected)
  187|      0|  }
  188|      0|  @objc public func onSlide() {
  189|      0|    delegate?.onProcessSliderChanged(progress: debugSlider.value)
  190|      0|  }
  191|       |}
  192|       |
  193|       |extension HeroDebugView: UIGestureRecognizerDelegate {
  194|      0|  public override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
  195|      0|    return perspectiveButton.isSelected
  196|      0|  }
  197|       |}
  198|       |#endif

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/Array+HeroModifier.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |internal extension Array {
   26|      0|  func get(_ index: Int) -> Element? {
   27|      0|    if index < count {
   28|      0|      return self[index]
   29|      0|    }
   30|      0|    return nil
   31|      0|  }
   32|       |}
   33|       |
   34|       |internal extension Array where Element: ExprNode {
   35|      0|  func getCGFloat(_ index: Int) -> CGFloat? {
   36|      0|    if let s = get(index) as? NumberNode {
   37|      0|      return CGFloat(s.value)
   38|      0|    }
   39|      0|    return nil
   40|      0|  }
   41|      0|  func getDouble(_ index: Int) -> Double? {
   42|      0|    if let s = get(index) as? NumberNode {
   43|      0|      return Double(s.value)
   44|      0|    }
   45|      0|    return nil
   46|      0|  }
   47|      0|  func getFloat(_ index: Int) -> Float? {
   48|      0|    if let s = get(index) as? NumberNode {
   49|      0|      return s.value
   50|      0|    }
   51|      0|    return nil
   52|      0|  }
   53|      0|  func getBool(_ index: Int) -> Bool? {
   54|      0|    if let s = get(index) as? VariableNode, let f = Bool(s.name) {
   55|      0|      return f
   56|      0|    }
   57|      0|    return nil
   58|      0|  }
   59|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/CALayer+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |internal extension CALayer {
   26|       |  // return all animations running by this layer.
   27|       |  // the returned value is mutable
   28|      0|  var animations: [(String, CAAnimation)] {
   29|      0|    if let keys = animationKeys() {
   30|      0|      return keys.map { return ($0, self.animation(forKey: $0)!.copy() as! CAAnimation) }
   31|      0|    }
   32|      0|    return []
   33|      0|  }
   34|       |
   35|      0|  func flatTransformTo(layer: CALayer) -> CATransform3D {
   36|      0|    var layer = layer
   37|      0|    var trans = layer.transform
   38|      0|    while let superlayer = layer.superlayer, superlayer != self, !(superlayer.delegate is UIWindow) {
   39|      0|      trans = CATransform3DConcat(superlayer.transform, trans)
   40|      0|      layer = superlayer
   41|      0|    }
   42|      0|    return trans
   43|      0|  }
   44|       |
   45|      0|  func removeAllHeroAnimations() {
   46|      0|    guard let keys = animationKeys() else { return }
   47|      0|    for animationKey in keys where animationKey.hasPrefix("hero.") {
   48|      0|      removeAnimation(forKey: animationKey)
   49|      0|    }
   50|      0|  }
   51|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/CAMediaTimingFunction+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public extension CAMediaTimingFunction {
   26|       |  // default
   27|       |  public static let linear = CAMediaTimingFunction(name: CAMediaTimingFunctionName.linear)
   28|       |  public static let easeIn = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeIn)
   29|       |  public static let easeOut = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeOut)
   30|       |  public static let easeInOut = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
   31|       |
   32|       |  // material
   33|       |  public static let standard = CAMediaTimingFunction(controlPoints: 0.4, 0.0, 0.2, 1.0)
   34|       |  public static let deceleration = CAMediaTimingFunction(controlPoints: 0.0, 0.0, 0.2, 1)
   35|       |  public static let acceleration = CAMediaTimingFunction(controlPoints: 0.4, 0.0, 1, 1)
   36|       |  public static let sharp = CAMediaTimingFunction(controlPoints: 0.4, 0.0, 0.6, 1)
   37|       |
   38|       |  // easing.net
   39|       |  public static let easeOutBack = CAMediaTimingFunction(controlPoints: 0.175, 0.885, 0.32, 1.275)
   40|       |
   41|      0|  static func from(name: String) -> CAMediaTimingFunction? {
   42|      0|    switch name {
   43|      0|    case "linear":
   44|      0|      return .linear
   45|      0|    case "easeIn":
   46|      0|      return .easeIn
   47|      0|    case "easeOut":
   48|      0|      return .easeOut
   49|      0|    case "easeInOut":
   50|      0|      return .easeInOut
   51|      0|    case "standard":
   52|      0|      return .standard
   53|      0|    case "deceleration":
   54|      0|      return .deceleration
   55|      0|    case "acceleration":
   56|      0|      return .acceleration
   57|      0|    case "sharp":
   58|      0|      return .sharp
   59|      0|    default:
   60|      0|      return nil
   61|      0|    }
   62|      0|  }
   63|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/CG+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import MetalKit
   24|       |
   25|       |let π = CGFloat.pi
   26|       |
   27|       |internal struct KeySet<Key: Hashable, Value: Hashable> {
   28|       |  var dict: [Key: Set<Value>] = [:]
   29|       |  internal subscript(key: Key) -> Set<Value> {
   30|      0|    mutating get {
   31|      0|      if dict[key] == nil {
   32|      0|        dict[key] = Set<Value>()
   33|      0|      }
   34|      0|      return dict[key]!
   35|      0|    }
   36|      0|    set {
   37|      0|      dict[key] = newValue
   38|      0|    }
   39|       |  }
   40|       |}
   41|       |
   42|       |internal extension CGSize {
   43|      0|  internal var center: CGPoint {
   44|      0|    return CGPoint(x: width / 2, y: height / 2)
   45|      0|  }
   46|      0|  internal var point: CGPoint {
   47|      0|    return CGPoint(x: width, y: height)
   48|      0|  }
   49|      0|  internal func transform(_ t: CGAffineTransform) -> CGSize {
   50|      0|    return self.applying(t)
   51|      0|  }
   52|      0|  internal func transform(_ t: CATransform3D) -> CGSize {
   53|      0|    return self.applying(CATransform3DGetAffineTransform(t))
   54|      0|  }
   55|       |}
   56|       |
   57|       |internal extension CGRect {
   58|      0|  internal var center: CGPoint {
   59|      0|    return CGPoint(x: origin.x + width / 2, y: origin.y + height / 2)
   60|      0|  }
   61|      0|  internal var bounds: CGRect {
   62|      0|    return CGRect(origin: CGPoint.zero, size: size)
   63|      0|  }
   64|      0|  init(center: CGPoint, size: CGSize) {
   65|      0|    self.init(x: center.x - size.width / 2, y: center.y - size.height / 2, width: size.width, height: size.height)
   66|      0|  }
   67|       |}
   68|       |
   69|       |extension CGFloat {
   70|      0|  internal func clamp(_ a: CGFloat, _ b: CGFloat) -> CGFloat {
   71|      0|    return self < a ? a : (self > b ? b : self)
   72|      0|  }
   73|       |}
   74|       |extension TimeInterval {
   75|      0|  internal func clamp(_ a: TimeInterval, _ b: TimeInterval) -> TimeInterval {
   76|      0|    return self < a ? a : (self > b ? b : self)
   77|      0|  }
   78|       |}
   79|       |extension CGPoint {
   80|      0|  internal func translate(_ dx: CGFloat, dy: CGFloat) -> CGPoint {
   81|      0|    return CGPoint(x: self.x + dx, y: self.y + dy)
   82|      0|  }
   83|       |
   84|      0|  internal func transform(_ t: CGAffineTransform) -> CGPoint {
   85|      0|    return self.applying(t)
   86|      0|  }
   87|       |
   88|      0|  internal func transform(_ t: CATransform3D) -> CGPoint {
   89|      0|    return self.applying(CATransform3DGetAffineTransform(t))
   90|      0|  }
   91|       |
   92|      0|  internal func distance(_ b: CGPoint) -> CGFloat {
   93|      0|    return sqrt(pow(self.x - b.x, 2) + pow(self.y - b.y, 2))
   94|      0|  }
   95|       |
   96|      0|  internal static func + (left: CGPoint, right: CGPoint) -> CGPoint {
   97|      0|    return CGPoint(x: left.x + right.x, y: left.y + right.y)
   98|      0|  }
   99|       |
  100|      0|  internal static func - (left: CGPoint, right: CGPoint) -> CGPoint {
  101|      0|    return CGPoint(x: left.x - right.x, y: left.y - right.y)
  102|      0|  }
  103|       |
  104|      0|  internal static func / (left: CGPoint, right: CGFloat) -> CGPoint {
  105|      0|    return CGPoint(x: left.x / right, y: left.y / right)
  106|      0|  }
  107|      0|  internal static func / (left: CGPoint, right: CGPoint) -> CGPoint {
  108|      0|    return CGPoint(x: left.x / right.x, y: left.y / right.y)
  109|      0|  }
  110|      0|  internal static func * (left: CGPoint, right: CGFloat) -> CGPoint {
  111|      0|    return CGPoint(x: left.x * right, y: left.y * right)
  112|      0|  }
  113|      0|  internal static func * (left: CGPoint, right: CGSize) -> CGPoint {
  114|      0|    return CGPoint(x: left.x * right.width, y: left.y * right.height)
  115|      0|  }
  116|      0|  internal static func * (left: CGFloat, right: CGPoint) -> CGPoint {
  117|      0|    return right * left
  118|      0|  }
  119|       |
  120|      0|  internal static func * (left: CGPoint, right: CGPoint) -> CGPoint {
  121|      0|    return CGPoint(x: left.x * right.x, y: left.y * right.y)
  122|      0|  }
  123|       |
  124|      0|  internal static prefix func - (point: CGPoint) -> CGPoint {
  125|      0|    return .zero - point
  126|      0|  }
  127|       |
  128|      0|  internal static func abs(_ p: CGPoint) -> CGPoint {
  129|      0|    return CGPoint(x: Swift.abs(p.x), y: Swift.abs(p.y))
  130|      0|  }
  131|       |}
  132|       |
  133|       |extension CGSize {
  134|      0|  internal static func * (left: CGSize, right: CGFloat) -> CGSize {
  135|      0|    return CGSize(width: left.width * right, height: left.height * right)
  136|      0|  }
  137|      0|  internal static func * (left: CGSize, right: CGSize) -> CGSize {
  138|      0|    return CGSize(width: left.width * right.width, height: left.height * right.height)
  139|      0|  }
  140|      0|  internal static func / (left: CGSize, right: CGSize) -> CGSize {
  141|      0|    return CGSize(width: left.width / right.width, height: left.height / right.height)
  142|      0|  }
  143|      0|  internal static func / (left: CGPoint, right: CGSize) -> CGPoint {
  144|      0|    return CGPoint(x: left.x / right.width, y: left.y / right.height)
  145|      0|  }
  146|       |}
  147|       |
  148|       |extension CATransform3D: Equatable {
  149|      0|  public static func == (lhs: CATransform3D, rhs: CATransform3D) -> Bool {
  150|      0|    var lhs = lhs
  151|      0|    var rhs = rhs
  152|      0|    return memcmp(&lhs, &rhs, MemoryLayout<CATransform3D>.size) == 0
  153|      0|  }
  154|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/DispatchQueue+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import Foundation
   24|       |
   25|      0|func delay(_ time: Double, execute: @escaping () -> Void) {
   26|      0|  if time > 0 {
   27|      0|    DispatchQueue.main.asyncAfter(deadline: .now() + time, execute: execute)
   28|      0|  } else {
   29|      0|    DispatchQueue.main.async(execute: execute)
   30|      0|  }
   31|      0|}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/UIKit+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |private let parameterRegex = "(?:\\-?\\d+(\\.?\\d+)?)|\\w+"
   26|       |private let modifiersRegex = "(\\w+)(?:\\(([^\\)]*)\\))?"
   27|       |
   28|       |internal extension NSObject {
   29|      0|  func copyWithArchiver() -> Any? {
   30|      0|    return NSKeyedUnarchiver.unarchiveObject(with: NSKeyedArchiver.archivedData(withRootObject: self))!
   31|      0|  }
   32|       |}
   33|       |
   34|       |internal extension UIImage {
   35|      0|  class func imageWithView(view: UIView) -> UIImage {
   36|      0|    UIGraphicsBeginImageContextWithOptions(view.bounds.size, false, 0.0)
   37|      0|    view.drawHierarchy(in: view.bounds, afterScreenUpdates: true)
   38|      0|    let img = UIGraphicsGetImageFromCurrentImageContext()
   39|      0|    UIGraphicsEndImageContext()
   40|      0|    return img!
   41|      0|  }
   42|       |}
   43|       |
   44|       |internal extension UIColor {
   45|      0|  var components:(r:CGFloat, g: CGFloat, b: CGFloat, a: CGFloat) {
   46|      0|    var r: CGFloat = 0
   47|      0|    var g: CGFloat = 0
   48|      0|    var b: CGFloat = 0
   49|      0|    var a: CGFloat = 0
   50|      0|    getRed(&r, green: &g, blue: &b, alpha: &a)
   51|      0|    return (r, g, b, a)
   52|      0|  }
   53|      0|  var alphaComponent: CGFloat {
   54|      0|    return components.a
   55|      0|  }
   56|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/UIView+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |class SnapshotWrapperView: UIView {
   26|       |  let contentView: UIView
   27|      0|  init(contentView: UIView) {
   28|      0|    self.contentView = contentView
   29|      0|    super.init(frame: contentView.frame)
   30|      0|    addSubview(contentView)
   31|      0|  }
   32|      0|  required init?(coder aDecoder: NSCoder) {
   33|      0|    fatalError("init(coder:) has not been implemented")
   34|      0|  }
   35|      0|  override func layoutSubviews() {
   36|      0|    super.layoutSubviews()
   37|      0|    contentView.bounds.size = bounds.size
   38|      0|    contentView.center = bounds.center
   39|      0|  }
   40|       |}
   41|       |
   42|       |extension UIView: HeroCompatible { }
   43|       |public extension HeroExtension where Base: UIView {
   44|       |
   45|       |  /**
   46|       |   **ID** is the identifier for the view. When doing a transition between two view controllers,
   47|       |   Hero will search through all the subviews for both view controllers and matches views with the same **heroID**.
   48|       |   
   49|       |   Whenever a pair is discovered,
   50|       |   Hero will automatically transit the views from source state to the destination state.
   51|       |   */
   52|       |   public var id: String? {
   53|      0|    get { return objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroID) as? String }
   54|      0|    set { objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroID, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
   55|       |  }
   56|       |
   57|       |  /**
   58|       |   **isEnabled** allows to specify whether a view and its subviews should be consider for animations.
   59|       |   If true, Hero will search through all the subviews for heroIds and modifiers. Defaults to true
   60|       |   */
   61|       |  public var isEnabled: Bool {
   62|      0|    get { return objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroEnabled) as? Bool ?? true }
   63|      0|    set { objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroEnabled, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
   64|       |  }
   65|       |
   66|       |  /**
   67|       |   **isEnabledForSubviews** allows to specify whether a view's subviews should be consider for animations.
   68|       |   If true, Hero will search through all the subviews for heroIds and modifiers. Defaults to true
   69|       |   */
   70|       |  public var isEnabledForSubviews: Bool {
   71|      0|    get { return objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroEnabledForSubviews) as? Bool ?? true }
   72|      0|    set { objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroEnabledForSubviews, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
   73|       |  }
   74|       |
   75|       |  /**
   76|       |   Use **modifiers** to specify animations alongside the main transition. Checkout `HeroModifier.swift` for available modifiers.
   77|       |   */
   78|       |  public var modifiers: [HeroModifier]? {
   79|      0|    get { return objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroModifiers) as? [HeroModifier] }
   80|      0|    set { objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroModifiers, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
   81|       |  }
   82|       |
   83|       |  /**
   84|       |   **modifierString** provides another way to set **modifiers**. It can be assigned through storyboard.
   85|       |   */
   86|       |  public var modifierString: String? {
   87|      0|    get { fatalError("Reverse lookup is not supported") }
   88|      0|    set { modifiers = newValue?.parse() }
   89|       |  }
   90|       |
   91|       |  /// Used for .overFullScreen presentation
   92|       |  internal var storedAlpha: CGFloat? {
   93|      0|    get {
   94|      0|      if let doubleValue = (objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroStoredAlpha) as? NSNumber)?.doubleValue {
   95|      0|        return CGFloat(doubleValue)
   96|      0|      }
   97|      0|      return nil
   98|      0|    }
   99|      0|    set {
  100|      0|      if let newValue = newValue {
  101|      0|        objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroStoredAlpha, NSNumber(value: newValue.native), .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  102|      0|      } else {
  103|      0|        objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroStoredAlpha, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  104|      0|      }
  105|      0|    }
  106|       |  }
  107|       |}
  108|       |
  109|       |public extension UIView {
  110|       |  fileprivate struct AssociatedKeys {
  111|       |    static var heroID    = "heroID"
  112|       |    static var heroModifiers = "heroModifers"
  113|       |    static var heroStoredAlpha = "heroStoredAlpha"
  114|       |    static var heroEnabled = "heroEnabled"
  115|       |    static var heroEnabledForSubviews = "heroEnabledForSubviews"
  116|       |  }
  117|       |
  118|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  119|       |  @available(*, deprecated, message: "Use hero.id instead")
  120|       |  @IBInspectable var heroID: String? {
  121|       |    get { return hero.id }
  122|       |    set { hero.id = newValue }
  123|       |  }
  124|       |
  125|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  126|       |  @available(*, deprecated, message: "Use hero.isEnabled instead")
  127|       |  @IBInspectable var isHeroEnabled: Bool {
  128|       |    get { return hero.isEnabled }
  129|       |    set { hero.isEnabled = newValue }
  130|       |  }
  131|       |
  132|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  133|       |  @available(*, deprecated, message: "Use hero.isEnabledForSubviews instead")
  134|       |  @IBInspectable var isHeroEnabledForSubviews: Bool {
  135|       |    get { return hero.isEnabledForSubviews }
  136|       |    set { hero.isEnabledForSubviews = newValue }
  137|       |  }
  138|       |
  139|       |  @available(*, deprecated, message: "Use hero.modifiers instead")
  140|       |  public var heroModifiers: [HeroModifier]? {
  141|      0|    get { return hero.modifiers }
  142|      0|    set { hero.modifiers = newValue }
  143|       |  }
  144|       |
  145|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  146|       |  @available(*, deprecated, message: "Use hero.modifierString instead")
  147|       |  @IBInspectable var heroModifierString: String? {
  148|      0|    get { fatalError("Reverse lookup is not supported") }
  149|       |    set { hero.modifiers = newValue?.parse() }
  150|       |  }
  151|       |
  152|      0|  internal func slowSnapshotView() -> UIView {
  153|      0|    UIGraphicsBeginImageContextWithOptions(bounds.size, isOpaque, 0)
  154|      0|    guard let currentContext = UIGraphicsGetCurrentContext() else {
  155|      0|      UIGraphicsEndImageContext()
  156|      0|      return UIView()
  157|      0|    }
  158|      0|    layer.render(in: currentContext)
  159|      0|
  160|      0|    let image = UIGraphicsGetImageFromCurrentImageContext()
  161|      0|    UIGraphicsEndImageContext()
  162|      0|
  163|      0|    let imageView = UIImageView(image: image)
  164|      0|    imageView.frame = bounds
  165|      0|    return SnapshotWrapperView(contentView: imageView)
  166|      0|  }
  167|       |
  168|      0|  internal func snapshotView() -> UIView? {
  169|      0|    let snapshot = snapshotView(afterScreenUpdates: true)
  170|      0|    if #available(iOS 11.0, *), let oldSnapshot = snapshot {
  171|      0|      // in iOS 11, the snapshot taken by snapshotView(afterScreenUpdates) won't contain a container view
  172|      0|      return SnapshotWrapperView(contentView: oldSnapshot)
  173|      0|    } else {
  174|      0|      return snapshot
  175|      0|    }
  176|      0|  }
  177|       |
  178|      0|  internal var flattenedViewHierarchy: [UIView] {
  179|      0|    guard hero.isEnabled else { return [] }
  180|      0|    if #available(iOS 9.0, *), isHidden && (superview is UICollectionView || superview is UIStackView || self is UITableViewCell) {
  181|      0|      return []
  182|      0|    } else if isHidden && (superview is UICollectionView || self is UITableViewCell) {
  183|      0|      return []
  184|      0|    } else if hero.isEnabledForSubviews {
  185|      0|      return [self] + subviews.flatMap { $0.flattenedViewHierarchy }
  186|      0|    } else {
  187|      0|      return [self]
  188|      0|    }
  189|      0|  }
  190|       |
  191|       |  @available(*, deprecated, message: "Use hero.storedAplha instead")
  192|       |  internal var heroStoredAlpha: CGFloat? {
  193|      0|    get { return hero.storedAlpha }
  194|      0|    set { hero.storedAlpha = newValue }
  195|       |  }
  196|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Extensions/UIViewController+Hero.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |internal class HeroViewControllerConfig: NSObject {
   26|       |  var modalAnimation: HeroDefaultAnimationType = .auto
   27|       |  var navigationAnimation: HeroDefaultAnimationType = .auto
   28|       |  var tabBarAnimation: HeroDefaultAnimationType = .auto
   29|       |
   30|       |  var storedSnapshot: UIView?
   31|       |  weak var previousNavigationDelegate: UINavigationControllerDelegate?
   32|       |  weak var previousTabBarDelegate: UITabBarControllerDelegate?
   33|       |}
   34|       |
   35|       |extension UIViewController: HeroCompatible { }
   36|       |public extension HeroExtension where Base: UIViewController {
   37|       |
   38|       |  internal var config: HeroViewControllerConfig {
   39|      0|    get {
   40|      0|      if let config = objc_getAssociatedObject(base, &type(of: base).AssociatedKeys.heroConfig) as? HeroViewControllerConfig {
   41|      0|        return config
   42|      0|      }
   43|      0|      let config = HeroViewControllerConfig()
   44|      0|      self.config = config
   45|      0|      return config
   46|      0|    }
   47|       |    set { objc_setAssociatedObject(base, &type(of: base).AssociatedKeys.heroConfig, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
   48|       |  }
   49|       |
   50|       |  /// used for .overFullScreen presentation
   51|       |  internal var storedSnapshot: UIView? {
   52|      0|    get { return config.storedSnapshot }
   53|      0|    set { config.storedSnapshot = newValue }
   54|       |  }
   55|       |
   56|       |  /// default hero animation type for presenting & dismissing modally
   57|       |  public var modalAnimationType: HeroDefaultAnimationType {
   58|      0|    get { return config.modalAnimation }
   59|      0|    set { config.modalAnimation = newValue }
   60|       |  }
   61|       |
   62|       |  // TODO: can be moved to internal later (will still be accessible via IB)
   63|       |  public var modalAnimationTypeString: String? {
   64|      0|    get { return config.modalAnimation.label }
   65|      0|    set { config.modalAnimation = newValue?.parseOne() ?? .auto }
   66|       |  }
   67|       |
   68|       |  // TODO: can be moved to internal later (will still be accessible via IB)
   69|       |  public var isEnabled: Bool {
   70|      0|    get {
   71|      0|      return base.transitioningDelegate is HeroTransition
   72|      0|    }
   73|      0|    set {
   74|      0|      guard newValue != isEnabled else { return }
   75|      0|      if newValue {
   76|      0|        base.transitioningDelegate = Hero.shared
   77|      0|        if let navi = base as? UINavigationController {
   78|      0|          base.previousNavigationDelegate = navi.delegate
   79|      0|          navi.delegate = Hero.shared
   80|      0|        }
   81|      0|        if let tab = base as? UITabBarController {
   82|      0|          base.previousTabBarDelegate = tab.delegate
   83|      0|          tab.delegate = Hero.shared
   84|      0|        }
   85|      0|      } else {
   86|      0|        base.transitioningDelegate = nil
   87|      0|        if let navi = base as? UINavigationController, navi.delegate is HeroTransition {
   88|      0|          navi.delegate = base.previousNavigationDelegate
   89|      0|        }
   90|      0|        if let tab = base as? UITabBarController, tab.delegate is HeroTransition {
   91|      0|          tab.delegate = base.previousTabBarDelegate
   92|      0|        }
   93|      0|      }
   94|      0|    }
   95|       |  }
   96|       |}
   97|       |
   98|       |public extension UIViewController {
   99|       |  fileprivate struct AssociatedKeys {
  100|       |    static var heroConfig = "heroConfig"
  101|       |  }
  102|       |
  103|       |  @available(*, deprecated, message: "Use hero.config instead")
  104|       |  internal var heroConfig: HeroViewControllerConfig {
  105|      0|    get { return hero.config }
  106|      0|    set { hero.config = newValue }
  107|       |  }
  108|       |
  109|       |  internal var previousNavigationDelegate: UINavigationControllerDelegate? {
  110|       |    get { return hero.config.previousNavigationDelegate }
  111|       |    set { hero.config.previousNavigationDelegate = newValue }
  112|       |  }
  113|       |
  114|       |  internal var previousTabBarDelegate: UITabBarControllerDelegate? {
  115|       |    get { return hero.config.previousTabBarDelegate }
  116|       |    set { hero.config.previousTabBarDelegate = newValue }
  117|       |  }
  118|       |
  119|       |  @available(*, deprecated, message: "Use hero.storedSnapshot instead")
  120|       |  internal var heroStoredSnapshot: UIView? {
  121|      0|    get { return hero.config.storedSnapshot }
  122|      0|    set { hero.config.storedSnapshot = newValue }
  123|       |  }
  124|       |
  125|       |  @available(*, deprecated, message: "Use hero.modalAnimationType instead")
  126|       |  public var heroModalAnimationType: HeroDefaultAnimationType {
  127|      0|    get { return hero.modalAnimationType }
  128|      0|    set { hero.modalAnimationType = newValue }
  129|       |  }
  130|       |
  131|       |  @available(*, deprecated, message: "Use hero.modalAnimationTypeString instead")
  132|       |  @IBInspectable public var heroModalAnimationTypeString: String? {
  133|       |    get { return hero.modalAnimationTypeString }
  134|       |    set { hero.modalAnimationTypeString = newValue }
  135|       |  }
  136|       |
  137|       |  @available(*, deprecated, message: "Use hero.isEnabled instead")
  138|       |  @IBInspectable public var isHeroEnabled: Bool {
  139|       |    get { return hero.isEnabled }
  140|       |    set { hero.isEnabled = newValue }
  141|       |  }
  142|       |}
  143|       |
  144|       |public extension HeroExtension where Base: UINavigationController {
  145|       |
  146|       |  /// default hero animation type for push and pop within the navigation controller
  147|       |  public var navigationAnimationType: HeroDefaultAnimationType {
  148|      0|    get { return config.navigationAnimation }
  149|      0|    set { config.navigationAnimation = newValue }
  150|       |  }
  151|       |
  152|       |  public var navigationAnimationTypeString: String? {
  153|      0|    get { return config.navigationAnimation.label }
  154|      0|    set { config.navigationAnimation = newValue?.parseOne() ?? .auto }
  155|       |  }
  156|       |}
  157|       |
  158|       |extension UINavigationController {
  159|       |  @available(*, deprecated, message: "Use hero.navigationAnimationType instead")
  160|       |  public var heroNavigationAnimationType: HeroDefaultAnimationType {
  161|      0|    get { return hero.navigationAnimationType }
  162|      0|    set { hero.navigationAnimationType = newValue }
  163|       |  }
  164|       |
  165|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  166|       |  @available(*, deprecated, message: "Use hero.navigationAnimationTypeString instead")
  167|       |  @IBInspectable public var heroNavigationAnimationTypeString: String? {
  168|       |    get { return hero.navigationAnimationTypeString }
  169|       |    set { hero.navigationAnimationTypeString = newValue }
  170|       |  }
  171|       |}
  172|       |
  173|       |public extension HeroExtension where Base: UITabBarController {
  174|       |
  175|       |  /// default hero animation type for switching tabs within the tab bar controller
  176|       |  public var tabBarAnimationType: HeroDefaultAnimationType {
  177|      0|    get { return config.tabBarAnimation }
  178|      0|    set { config.tabBarAnimation = newValue }
  179|       |  }
  180|       |
  181|       |  public var tabBarAnimationTypeString: String? {
  182|      0|    get { return config.tabBarAnimation.label }
  183|      0|    set { config.tabBarAnimation = newValue?.parseOne() ?? .auto }
  184|       |  }
  185|       |}
  186|       |
  187|       |extension UITabBarController {
  188|       |  @available(*, deprecated, message: "Use hero.tabBarAnimationType instead")
  189|       |  public var heroTabBarAnimationType: HeroDefaultAnimationType {
  190|      0|    get { return hero.tabBarAnimationType }
  191|      0|    set { hero.tabBarAnimationType = newValue }
  192|       |  }
  193|       |
  194|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  195|       |  @available(*, deprecated, message: "Use hero.tabBarAnimationTypeString instead")
  196|       |  @IBInspectable public var heroTabBarAnimationTypeString: String? {
  197|       |    get { return hero.tabBarAnimationTypeString }
  198|       |    set { hero.tabBarAnimationTypeString = newValue }
  199|       |  }
  200|       |}
  201|       |
  202|       |public extension HeroExtension where Base: UIViewController {
  203|       |
  204|       |  /**
  205|       |   Dismiss the current view controller with animation. Will perform a navigationController.popViewController
  206|       |   if the current view controller is contained inside a navigationController
  207|       |   */
  208|      0|  public func dismissViewController(completion: (() -> Void)? = nil) {
  209|      0|    if let navigationController = base.navigationController, navigationController.viewControllers.first != base {
  210|      0|      navigationController.popViewController(animated: true)
  211|      0|    } else {
  212|      0|      base.dismiss(animated: true, completion: completion)
  213|      0|    }
  214|      0|  }
  215|       |
  216|       |  /**
  217|       |   Unwind to the root view controller using Hero
  218|       |   */
  219|      0|  public func unwindToRootViewController() {
  220|      0|    unwindToViewController { $0.presentingViewController == nil }
  221|      0|  }
  222|       |
  223|       |  /**
  224|       |   Unwind to a specific view controller using Hero
  225|       |   */
  226|      0|  public func unwindToViewController(_ toViewController: UIViewController) {
  227|      0|    unwindToViewController { $0 == toViewController }
  228|      0|  }
  229|       |
  230|      0|  public func unwindToViewController(withSelector: Selector) {
  231|      0|    unwindToViewController { $0.responds(to: withSelector) }
  232|      0|  }
  233|       |
  234|       |  /**
  235|       |   Unwind to a view controller with given class using Hero
  236|       |   */
  237|      0|  public func unwindToViewController(withClass: AnyClass) {
  238|      0|    unwindToViewController { $0.isKind(of: withClass) }
  239|      0|  }
  240|       |
  241|       |  /**
  242|       |   Unwind to a view controller that the matchBlock returns true on.
  243|       |   */
  244|       |  public func unwindToViewController(withMatchBlock: (UIViewController) -> Bool) {
  245|       |    var target: UIViewController? = nil
  246|       |    var current: UIViewController? = base
  247|       |
  248|      0|    while target == nil && current != nil {
  249|      0|      if let childViewControllers = (current as? UINavigationController)?.children ?? current!.navigationController?.children {
  250|       |        for vc in childViewControllers.reversed() {
  251|       |          if vc != base, withMatchBlock(vc) {
  252|       |            target = vc
  253|       |            break
  254|       |          }
  255|       |        }
  256|       |      }
  257|       |      if target == nil {
  258|       |        current = current!.presentingViewController
  259|       |        if let vc = current, withMatchBlock(vc) == true {
  260|       |          target = vc
  261|       |        }
  262|       |      }
  263|       |    }
  264|       |
  265|       |    if let target = target {
  266|       |      if target.presentedViewController != nil {
  267|       |        _ = target.navigationController?.popToViewController(target, animated: false)
  268|       |
  269|      0|        let fromVC = base.navigationController ?? base
  270|      0|        let toVC = target.navigationController ?? target
  271|       |
  272|       |        if target.presentedViewController != fromVC {
  273|       |          // UIKit's UIViewController.dismiss will jump to target.presentedViewController then perform the dismiss.
  274|       |          // We overcome this behavior by inserting a snapshot into target.presentedViewController
  275|       |          // And also force Hero to use the current VC as the fromViewController
  276|       |          Hero.shared.fromViewController = fromVC
  277|       |          let snapshotView = fromVC.view.snapshotView(afterScreenUpdates: true)!
  278|       |          let targetSuperview = toVC.presentedViewController!.view!
  279|       |          if let visualEffectView = targetSuperview as? UIVisualEffectView {
  280|       |            visualEffectView.contentView.addSubview(snapshotView)
  281|       |          } else {
  282|       |            targetSuperview.addSubview(snapshotView)
  283|       |          }
  284|       |        }
  285|       |
  286|       |        toVC.dismiss(animated: true, completion: nil)
  287|       |      } else {
  288|       |        _ = target.navigationController?.popToViewController(target, animated: true)
  289|       |      }
  290|       |    } else {
  291|       |      // unwind target not found
  292|       |    }
  293|       |  }
  294|       |
  295|       |  /**
  296|       |   Replace the current view controller with another VC on the navigation/modal stack.
  297|       |   */
  298|      0|  public func replaceViewController(with next: UIViewController, completion: (() -> Void)? = nil) {
  299|      0|    let hero = next.transitioningDelegate as? HeroTransition ?? Hero.shared
  300|      0|
  301|      0|    if hero.isTransitioning {
  302|      0|      print("hero.replaceViewController cancelled because Hero was doing a transition. Use Hero.shared.cancel(animated:false) or Hero.shared.end(animated:false) to stop the transition first before calling hero.replaceViewController.")
  303|      0|      return
  304|      0|    }
  305|      0|    if let navigationController = base.navigationController {
  306|      0|      var vcs = navigationController.children
  307|      0|      if !vcs.isEmpty {
  308|      0|        vcs.removeLast()
  309|      0|        vcs.append(next)
  310|      0|      }
  311|      0|      if navigationController.hero.isEnabled {
  312|      0|        hero.forceNotInteractive = true
  313|      0|      }
  314|      0|      navigationController.setViewControllers(vcs, animated: true)
  315|      0|    } else if let container = base.view.superview {
  316|      0|      let parentVC = base.presentingViewController
  317|      0|      hero.transition(from: base, to: next, in: container) { [weak base] finished in
  318|      0|        guard let base = base else { return }
  319|      0|        guard finished else { return }
  320|      0|
  321|      0|        next.view.window?.addSubview(next.view)
  322|      0|        if let parentVC = parentVC {
  323|      0|          base.dismiss(animated: false) {
  324|      0|            parentVC.present(next, animated: false, completion: completion)
  325|      0|          }
  326|      0|        } else {
  327|      0|          UIApplication.shared.keyWindow?.rootViewController = next
  328|      0|        }
  329|      0|      }
  330|      0|    }
  331|      0|  }
  332|       |}
  333|       |
  334|       |extension UIViewController {
  335|       |  @available(*, deprecated: 0.1.4, message: "use hero.dismissViewController instead")
  336|      0|  @IBAction public func ht_dismiss(_ sender: UIView) {
  337|      0|    hero.dismissViewController()
  338|      0|  }
  339|       |
  340|       |  @available(*, deprecated: 0.1.4, message: "use hero.replaceViewController(with:) instead")
  341|      0|  public func heroReplaceViewController(with next: UIViewController) {
  342|      0|    hero.replaceViewController(with: next)
  343|      0|  }
  344|       |
  345|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  346|       |  @available(*, deprecated, message: "Use hero.dismissViewController instead")
  347|      0|  @IBAction public func hero_dismissViewController() {
  348|      0|    hero.dismissViewController()
  349|      0|  }
  350|       |
  351|       |  // TODO: can be moved to internal later (will still be accessible via IB)
  352|       |  @available(*, deprecated, message: "Use hero.unwindToRootViewController instead")
  353|      0|  @IBAction public func hero_unwindToRootViewController() {
  354|      0|    hero.unwindToRootViewController()
  355|      0|  }
  356|       |
  357|       |  @available(*, deprecated, message: "Use hero.unwindToViewController(_:) instead")
  358|      0|  public func hero_unwindToViewController(_ toViewController: UIViewController) {
  359|      0|    hero.unwindToViewController(toViewController)
  360|      0|  }
  361|       |
  362|       |  @available(*, deprecated, message: "Use hero.unwindToViewController(withSelector:) instead")
  363|      0|  public func hero_unwindToViewController(withSelector: Selector) {
  364|      0|    hero.unwindToViewController(withSelector: withSelector)
  365|      0|  }
  366|       |
  367|       |  @available(*, deprecated, message: "Use hero_unwindToViewController(withClass:) instead")
  368|      0|  public func hero_unwindToViewController(withClass: AnyClass) {
  369|      0|    hero.unwindToViewController(withClass: withClass)
  370|      0|  }
  371|       |
  372|       |  @available(*, deprecated, message: "Use hero.unwindToViewController(withMatchBlock:) instead")
  373|      0|  public func hero_unwindToViewController(withMatchBlock: (UIViewController) -> Bool) {
  374|      0|    hero.unwindToViewController(withMatchBlock: withMatchBlock)
  375|      0|  }
  376|       |
  377|       |  @available(*, deprecated, message: "Use hero.replaceViewController(with:) instead")
  378|      0|  public func hero_replaceViewController(with next: UIViewController) {
  379|      0|    hero.replaceViewController(with: next)
  380|      0|  }
  381|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroCompatible.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import Foundation
   24|       |
   25|       |public protocol HeroCompatible {
   26|       |  associatedtype CompatibleType
   27|       |
   28|       |  var hero: HeroExtension<CompatibleType> { get set }
   29|       |}
   30|       |
   31|       |public extension HeroCompatible {
   32|       |  public var hero: HeroExtension<Self> {
   33|      0|    get { return HeroExtension(self) }
   34|      0|    set { }
   35|       |  }
   36|       |}
   37|       |
   38|       |public class HeroExtension<Base> {
   39|       |  public let base: Base
   40|       |
   41|      0|  init(_ base: Base) {
   42|      0|    self.base = base
   43|      0|  }
   44|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroContext.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public class HeroContext {
   26|       |  internal var heroIDToSourceView = [String: UIView]()
   27|       |  internal var heroIDToDestinationView = [String: UIView]()
   28|       |  internal var snapshotViews = [UIView: UIView]()
   29|       |  internal var viewAlphas = [UIView: CGFloat]()
   30|       |  internal var targetStates = [UIView: HeroTargetState]()
   31|       |  internal var superviewToNoSnapshotSubviewMap: [UIView: [(Int, UIView)]] = [:]
   32|       |  internal var insertToViewFirst = false
   33|       |
   34|       |  internal var defaultCoordinateSpace: HeroCoordinateSpace = .local
   35|       |
   36|      0|  internal init(container: UIView) {
   37|      0|    self.container = container
   38|      0|  }
   39|       |
   40|      0|  internal func set(fromViews: [UIView], toViews: [UIView]) {
   41|      0|    self.fromViews = fromViews
   42|      0|    self.toViews = toViews
   43|      0|    process(views: fromViews, idMap: &heroIDToSourceView)
   44|      0|    process(views: toViews, idMap: &heroIDToDestinationView)
   45|      0|  }
   46|       |
   47|      0|  internal func process(views: [UIView], idMap: inout [String: UIView]) {
   48|      0|    for view in views {
   49|      0|      view.layer.removeAllHeroAnimations()
   50|      0|      let targetState: HeroTargetState?
   51|      0|      if let modifiers = view.hero.modifiers {
   52|      0|        targetState = HeroTargetState(modifiers: modifiers)
   53|      0|      } else {
   54|      0|        targetState = nil
   55|      0|      }
   56|      0|      if targetState?.forceAnimate == true || container.convert(view.bounds, from: view).intersects(container.bounds) {
   57|      0|        if let heroID = view.hero.id {
   58|      0|          idMap[heroID] = view
   59|      0|        }
   60|      0|        targetStates[view] = targetState
   61|      0|      }
   62|      0|    }
   63|      0|  }
   64|       |
   65|       |  /**
   66|       |   The container holding all of the animating views
   67|       |   */
   68|       |  public let container: UIView
   69|       |
   70|       |  /**
   71|       |   A flattened list of all views from source ViewController
   72|       |   */
   73|       |  public var fromViews: [UIView] = []
   74|       |
   75|       |  /**
   76|       |   A flattened list of all views from destination ViewController
   77|       |   */
   78|       |  public var toViews: [UIView] = []
   79|       |}
   80|       |
   81|       |// public
   82|       |extension HeroContext {
   83|       |
   84|       |  /**
   85|       |   - Returns: a source view matching the heroID, nil if not found
   86|       |   */
   87|      0|  public func sourceView(for heroID: String) -> UIView? {
   88|      0|    return heroIDToSourceView[heroID]
   89|      0|  }
   90|       |
   91|       |  /**
   92|       |   - Returns: a destination view matching the heroID, nil if not found
   93|       |   */
   94|      0|  public func destinationView(for heroID: String) -> UIView? {
   95|      0|    return heroIDToDestinationView[heroID]
   96|      0|  }
   97|       |
   98|       |  /**
   99|       |   - Returns: a view with the same heroID, but on different view controller, nil if not found
  100|       |   */
  101|      0|  public func pairedView(for view: UIView) -> UIView? {
  102|      0|    if let id = view.hero.id {
  103|      0|      if sourceView(for: id) == view {
  104|      0|        return destinationView(for: id)
  105|      0|      } else if destinationView(for: id) == view {
  106|      0|        return sourceView(for: id)
  107|      0|      }
  108|      0|    }
  109|      0|    return nil
  110|      0|  }
  111|       |
  112|       |  /**
  113|       |   - Returns: a snapshot view for animation
  114|       |   */
  115|      0|  public func snapshotView(for view: UIView) -> UIView {
  116|      0|    if let snapshot = snapshotViews[view] {
  117|      0|      return snapshot
  118|      0|    }
  119|      0|
  120|      0|    var containerView = container
  121|      0|    let coordinateSpace = targetStates[view]?.coordinateSpace ?? defaultCoordinateSpace
  122|      0|    switch coordinateSpace {
  123|      0|    case .local:
  124|      0|      containerView = view
  125|      0|      while containerView != container, snapshotViews[containerView] == nil, let superview = containerView.superview {
  126|      0|        containerView = superview
  127|      0|      }
  128|      0|      if let snapshot = snapshotViews[containerView] {
  129|      0|        containerView = snapshot
  130|      0|      }
  131|      0|
  132|      0|      if let visualEffectView = containerView as? UIVisualEffectView {
  133|      0|        containerView = visualEffectView.contentView
  134|      0|      }
  135|      0|    case .global:
  136|      0|      break
  137|      0|    }
  138|      0|
  139|      0|    unhide(view: view)
  140|      0|
  141|      0|    // capture a snapshot without alpha, cornerRadius, or shadows
  142|      0|    let oldCornerRadius = view.layer.cornerRadius
  143|      0|    let oldAlpha = view.alpha
  144|      0|		let oldShadowRadius = view.layer.shadowRadius
  145|      0|		let oldShadowOffset = view.layer.shadowOffset
  146|      0|		let oldShadowPath = view.layer.shadowPath
  147|      0|		let oldShadowOpacity = view.layer.shadowOpacity
  148|      0|    view.layer.cornerRadius = 0
  149|      0|    view.alpha = 1
  150|      0|		view.layer.shadowRadius = 0.0
  151|      0|		view.layer.shadowOffset = .zero
  152|      0|		view.layer.shadowPath = nil
  153|      0|		view.layer.shadowOpacity = 0.0
  154|      0|
  155|      0|    let snapshot: UIView
  156|      0|    let snapshotType: HeroSnapshotType = self[view]?.snapshotType ?? .optimized
  157|      0|
  158|      0|    switch snapshotType {
  159|      0|    case .normal:
  160|      0|      snapshot = view.snapshotView() ?? UIView()
  161|      0|    case .layerRender:
  162|      0|      snapshot = view.slowSnapshotView()
  163|      0|    case .noSnapshot:
  164|      0|      if view.superview != container {
  165|      0|        if superviewToNoSnapshotSubviewMap[view.superview!] == nil {
  166|      0|          superviewToNoSnapshotSubviewMap[view.superview!] = []
  167|      0|        }
  168|      0|        superviewToNoSnapshotSubviewMap[view.superview!]!.append((view.superview!.subviews.index(of: view)!, view))
  169|      0|      }
  170|      0|      snapshot = view
  171|      0|    case .optimized:
  172|      0|      #if os(tvOS)
  173|      0|        snapshot = view.snapshotView(afterScreenUpdates: true)!
  174|      0|      #else
  175|      0|        if #available(iOS 9.0, *), let stackView = view as? UIStackView {
  176|      0|          snapshot = stackView.slowSnapshotView()
  177|      0|        } else if let imageView = view as? UIImageView, view.subviews.isEmpty {
  178|      0|          let contentView = UIImageView(image: imageView.image)
  179|      0|          contentView.frame = imageView.bounds
  180|      0|          contentView.contentMode = imageView.contentMode
  181|      0|          contentView.tintColor = imageView.tintColor
  182|      0|          contentView.backgroundColor = imageView.backgroundColor
  183|      0|          contentView.layer.magnificationFilter = imageView.layer.magnificationFilter
  184|      0|          contentView.layer.minificationFilter = imageView.layer.minificationFilter
  185|      0|          contentView.layer.minificationFilterBias = imageView.layer.minificationFilterBias
  186|      0|          let snapShotView = UIView()
  187|      0|          snapShotView.addSubview(contentView)
  188|      0|          snapshot = snapShotView
  189|      0|        } else if let barView = view as? UINavigationBar, barView.isTranslucent {
  190|      0|          let newBarView = UINavigationBar(frame: barView.frame)
  191|      0|
  192|      0|          newBarView.barStyle = barView.barStyle
  193|      0|          newBarView.tintColor = barView.tintColor
  194|      0|          newBarView.barTintColor = barView.barTintColor
  195|      0|          newBarView.clipsToBounds = false
  196|      0|
  197|      0|          // take a snapshot without the background
  198|      0|          barView.layer.sublayers![0].opacity = 0
  199|      0|          let realSnapshot = barView.snapshotView(afterScreenUpdates: true)!
  200|      0|          barView.layer.sublayers![0].opacity = 1
  201|      0|
  202|      0|          newBarView.addSubview(realSnapshot)
  203|      0|          snapshot = newBarView
  204|      0|        } else if let effectView = view as? UIVisualEffectView {
  205|      0|          snapshot = UIVisualEffectView(effect: effectView.effect)
  206|      0|          snapshot.frame = effectView.bounds
  207|      0|        } else {
  208|      0|          snapshot = view.snapshotView() ?? UIView()
  209|      0|        }
  210|      0|      #endif
  211|      0|    }
  212|      0|
  213|      0|    #if os(tvOS)
  214|      0|      if let imageView = view as? UIImageView, imageView.adjustsImageWhenAncestorFocused {
  215|      0|        snapshot.frame = imageView.focusedFrameGuide.layoutFrame
  216|      0|      }
  217|      0|    #endif
  218|      0|
  219|      0|    view.layer.cornerRadius = oldCornerRadius
  220|      0|    view.alpha = oldAlpha
  221|      0|		view.layer.shadowRadius = oldShadowRadius
  222|      0|		view.layer.shadowOffset = oldShadowOffset
  223|      0|		view.layer.shadowPath = oldShadowPath
  224|      0|		view.layer.shadowOpacity = oldShadowOpacity
  225|      0|
  226|      0|    snapshot.layer.anchorPoint = view.layer.anchorPoint
  227|      0|    snapshot.layer.position = containerView.convert(view.layer.position, from: view.superview!)
  228|      0|    snapshot.layer.transform = containerView.layer.flatTransformTo(layer: view.layer)
  229|      0|    snapshot.layer.bounds = view.layer.bounds
  230|      0|    snapshot.hero.id = view.hero.id
  231|      0|
  232|      0|    if snapshotType != .noSnapshot {
  233|      0|      if !(view is UINavigationBar), let contentView = snapshot.subviews.get(0) {
  234|      0|        // the Snapshot's contentView must have hold the cornerRadius value,
  235|      0|        // since the snapshot might not have maskToBounds set
  236|      0|        contentView.layer.cornerRadius = view.layer.cornerRadius
  237|      0|        contentView.layer.masksToBounds = true
  238|      0|      }
  239|      0|
  240|      0|      snapshot.layer.allowsGroupOpacity = false
  241|      0|      snapshot.layer.cornerRadius = view.layer.cornerRadius
  242|      0|      snapshot.layer.zPosition = view.layer.zPosition
  243|      0|      snapshot.layer.opacity = view.layer.opacity
  244|      0|      snapshot.layer.isOpaque = view.layer.isOpaque
  245|      0|      snapshot.layer.anchorPoint = view.layer.anchorPoint
  246|      0|      snapshot.layer.masksToBounds = view.layer.masksToBounds
  247|      0|      snapshot.layer.borderColor = view.layer.borderColor
  248|      0|      snapshot.layer.borderWidth = view.layer.borderWidth
  249|      0|      snapshot.layer.contentsRect = view.layer.contentsRect
  250|      0|      snapshot.layer.contentsScale = view.layer.contentsScale
  251|      0|
  252|      0|      if self[view]?.displayShadow ?? true {
  253|      0|        snapshot.layer.shadowRadius = view.layer.shadowRadius
  254|      0|        snapshot.layer.shadowOpacity = view.layer.shadowOpacity
  255|      0|        snapshot.layer.shadowColor = view.layer.shadowColor
  256|      0|        snapshot.layer.shadowOffset = view.layer.shadowOffset
  257|      0|        snapshot.layer.shadowPath = view.layer.shadowPath
  258|      0|      }
  259|      0|
  260|      0|      hide(view: view)
  261|      0|    }
  262|      0|
  263|      0|    if let pairedView = pairedView(for: view), let pairedSnapshot = snapshotViews[pairedView] {
  264|      0|      let siblingViews = pairedView.superview!.subviews
  265|      0|      let nextSiblings = siblingViews[siblingViews.index(of: pairedView)!+1..<siblingViews.count]
  266|      0|      containerView.addSubview(pairedSnapshot)
  267|      0|      containerView.addSubview(snapshot)
  268|      0|      for subview in pairedView.subviews {
  269|      0|        insertGlobalViewTree(view: subview)
  270|      0|      }
  271|      0|      for sibling in nextSiblings {
  272|      0|        insertGlobalViewTree(view: sibling)
  273|      0|      }
  274|      0|    } else {
  275|      0|      containerView.addSubview(snapshot)
  276|      0|    }
  277|      0|    containerView.addSubview(snapshot)
  278|      0|    snapshotViews[view] = snapshot
  279|      0|    return snapshot
  280|      0|  }
  281|       |
  282|       |  func insertGlobalViewTree(view: UIView) {
  283|       |    if targetStates[view]?.coordinateSpace == .global, let snapshot = snapshotViews[view] {
  284|       |      container.addSubview(snapshot)
  285|       |    }
  286|       |    for subview in view.subviews {
  287|       |      insertGlobalViewTree(view: subview)
  288|       |    }
  289|       |  }
  290|       |
  291|       |  public subscript(view: UIView) -> HeroTargetState? {
  292|       |    get {
  293|       |      return targetStates[view]
  294|       |    }
  295|      0|    set {
  296|      0|      targetStates[view] = newValue
  297|      0|    }
  298|       |  }
  299|       |
  300|      0|  public func clean() {
  301|      0|    for (superview, subviews) in superviewToNoSnapshotSubviewMap {
  302|      0|      for (index, view) in subviews.reversed() {
  303|      0|        superview.insertSubview(view, at: index)
  304|      0|      }
  305|      0|    }
  306|      0|  }
  307|       |}
  308|       |
  309|       |// internal
  310|       |extension HeroContext {
  311|       |  public func hide(view: UIView) {
  312|       |    if viewAlphas[view] == nil {
  313|       |      if view is UIVisualEffectView {
  314|       |        view.isHidden = true
  315|       |        viewAlphas[view] = 1
  316|       |      } else {
  317|       |        viewAlphas[view] = view.alpha
  318|       |        view.alpha = 0
  319|       |      }
  320|       |    }
  321|       |  }
  322|       |  public func unhide(view: UIView) {
  323|       |    if let oldAlpha = viewAlphas[view] {
  324|       |      if view is UIVisualEffectView {
  325|       |        view.isHidden = false
  326|       |      } else {
  327|       |        view.alpha = oldAlpha
  328|       |      }
  329|       |      viewAlphas[view] = nil
  330|       |    }
  331|       |  }
  332|      0|  internal func unhideAll() {
  333|      0|    for view in viewAlphas.keys {
  334|      0|      unhide(view: view)
  335|      0|    }
  336|      0|    viewAlphas.removeAll()
  337|      0|  }
  338|      0|  internal func unhide(rootView: UIView) {
  339|      0|    unhide(view: rootView)
  340|      0|    for subview in rootView.subviews {
  341|      0|      unhide(rootView: subview)
  342|      0|    }
  343|      0|  }
  344|       |
  345|      0|  internal func removeAllSnapshots() {
  346|      0|    for (view, snapshot) in snapshotViews {
  347|      0|      if view != snapshot {
  348|      0|        snapshot.removeFromSuperview()
  349|      0|      } else {
  350|      0|        view.layer.removeAllHeroAnimations()
  351|      0|      }
  352|      0|    }
  353|      0|  }
  354|      0|  internal func removeSnapshots(rootView: UIView) {
  355|      0|    if let snapshot = snapshotViews[rootView] {
  356|      0|      if rootView != snapshot {
  357|      0|        snapshot.removeFromSuperview()
  358|      0|      } else {
  359|      0|        rootView.layer.removeAllHeroAnimations()
  360|      0|      }
  361|      0|    }
  362|      0|    for subview in rootView.subviews {
  363|      0|      removeSnapshots(rootView: subview)
  364|      0|    }
  365|      0|  }
  366|      0|  internal func snapshots(rootView: UIView) -> [UIView] {
  367|      0|    var snapshots = [UIView]()
  368|      0|    for v in rootView.flattenedViewHierarchy {
  369|      0|      if let snapshot = snapshotViews[v] {
  370|      0|        snapshots.append(snapshot)
  371|      0|      }
  372|      0|    }
  373|      0|    return snapshots
  374|      0|  }
  375|      0|  internal func loadViewAlpha(rootView: UIView) {
  376|      0|    if let storedAlpha = rootView.hero.storedAlpha {
  377|      0|      rootView.alpha = storedAlpha
  378|      0|      rootView.hero.storedAlpha = nil
  379|      0|    }
  380|      0|    for subview in rootView.subviews {
  381|      0|      loadViewAlpha(rootView: subview)
  382|      0|    }
  383|      0|  }
  384|      0|  internal func storeViewAlpha(rootView: UIView) {
  385|      0|    rootView.hero.storedAlpha = viewAlphas[rootView]
  386|      0|    for subview in rootView.subviews {
  387|      0|      storeViewAlpha(rootView: subview)
  388|      0|    }
  389|      0|  }
  390|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroModifier+Advanced.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |//
   23|       |
   24|       |// advance modifiers
   25|       |extension HeroModifier {
   26|       |  /**
   27|       |   Apply modifiers directly to the view at the start of the transition.
   28|       |   The modifiers supplied here won't be animated.
   29|       |   For source views, modifiers are set directly at the beginning of the animation.
   30|       |   For destination views, they replace the target state (final appearance).
   31|       |   */
   32|      0|  public static func beginWith(_ modifiers: [HeroModifier]) -> HeroModifier {
   33|      0|    return HeroModifier { targetState in
   34|      0|      if targetState.beginState == nil {
   35|      0|        targetState.beginState = []
   36|      0|      }
   37|      0|      targetState.beginState!.append(contentsOf: modifiers)
   38|      0|    }
   39|      0|  }
   40|       |
   41|      0|  public static func beginWith(modifiers: [HeroModifier]) -> HeroModifier {
   42|      0|    return .beginWith(modifiers)
   43|      0|  }
   44|       |
   45|      0|  public static func beginWith(_ modifiers: HeroModifier...) -> HeroModifier {
   46|      0|    return .beginWith(modifiers)
   47|      0|  }
   48|       |
   49|       |  /**
   50|       |   Use global coordinate space.
   51|       |   
   52|       |   When using global coordinate space. The view become a independent view that is not a subview of any view.
   53|       |   It won't move when its parent view moves, and won't be affected by parent view's attributes.
   54|       |   
   55|       |   When a view is matched, this is automatically enabled.
   56|       |   The `source` modifier will also enable this.
   57|       |   
   58|       |   Global coordinate space is default for all views prior to version 0.1.3
   59|       |   */
   60|      0|  public static var useGlobalCoordinateSpace: HeroModifier = HeroModifier { targetState in
   61|      0|    targetState.coordinateSpace = .global
   62|      0|  }
   63|       |
   64|       |  /**
   65|       |   ignore all heroModifiers attributes for a view's direct subviews.
   66|       |   */
   67|       |  public static var ignoreSubviewModifiers: HeroModifier = .ignoreSubviewModifiers()
   68|       |
   69|       |  /**
   70|       |   ignore all heroModifiers attributes for a view's subviews.
   71|       |   - Parameters:
   72|       |   - recursive: if false, will only ignore direct subviews' modifiers. default false.
   73|       |   */
   74|       |  public static func ignoreSubviewModifiers(recursive: Bool = false) -> HeroModifier {
   75|      0|    return HeroModifier { targetState in
   76|      0|      targetState.ignoreSubviewModifiers = recursive
   77|      0|    }
   78|       |  }
   79|       |
   80|       |  /**
   81|       |   Will create snapshot optimized for different view type.
   82|       |   For custom views or views with masking, useOptimizedSnapshot might create snapshots
   83|       |   that appear differently than the actual view.
   84|       |   In that case, use .useNormalSnapshot or .useSlowRenderSnapshot to disable the optimization.
   85|       |   
   86|       |   This modifier actually does nothing by itself since .useOptimizedSnapshot is the default.
   87|       |   */
   88|      0|  public static var useOptimizedSnapshot: HeroModifier = HeroModifier { targetState in
   89|      0|    targetState.snapshotType = .optimized
   90|      0|  }
   91|       |
   92|       |  /**
   93|       |   Create snapshot using snapshotView(afterScreenUpdates:).
   94|       |   */
   95|      0|  public static var useNormalSnapshot: HeroModifier = HeroModifier { targetState in
   96|      0|    targetState.snapshotType = .normal
   97|      0|  }
   98|       |
   99|       |  /**
  100|       |   Create snapshot using layer.render(in: currentContext).
  101|       |   This is slower than .useNormalSnapshot but gives more accurate snapshot for some views (eg. UIStackView).
  102|       |   */
  103|      0|  public static var useLayerRenderSnapshot: HeroModifier = HeroModifier { targetState in
  104|      0|    targetState.snapshotType = .layerRender
  105|      0|  }
  106|       |
  107|       |  /**
  108|       |   Force Hero to not create any snapshot when animating this view.
  109|       |   This will mess up the view hierarchy, therefore, view controllers have to rebuild
  110|       |   its view structure after the transition finishes.
  111|       |   */
  112|      0|  public static var useNoSnapshot: HeroModifier = HeroModifier { targetState in
  113|      0|    targetState.snapshotType = .noSnapshot
  114|      0|  }
  115|       |
  116|       |  /**
  117|       |   Force the view to animate.
  118|       |   
  119|       |   By default, Hero will not animate if the view is outside the screen bounds or if there is no animatable hero modifier, unless this modifier is used.
  120|       |   */
  121|      0|  public static var forceAnimate = HeroModifier { targetState in
  122|      0|    targetState.forceAnimate = true
  123|      0|  }
  124|       |
  125|       |  /**
  126|       |   Force Hero use scale based size animation. This will convert all .size modifier into .scale modifier.
  127|       |   This is to help Hero animate layers that doesn't support bounds animation. Also gives better performance.
  128|       |   */
  129|      0|  public static var useScaleBasedSizeChange: HeroModifier = HeroModifier { targetState in
  130|      0|    targetState.useScaleBasedSizeChange = true
  131|      0|  }
  132|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroModifier+HeroStringConvertible.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |/// used to construct HeroModifier from heroModifierString
   26|       |extension HeroModifier: HeroStringConvertible {
   27|      0|  public static func from(node: ExprNode) -> HeroModifier? {
   28|      0|    let name: String = node.name
   29|      0|    let parameters: [ExprNode] = (node as? CallNode)?.arguments ?? []
   30|      0|
   31|      0|    switch name {
   32|      0|    case "fade":
   33|      0|      return .fade
   34|      0|    case "opacity":
   35|      0|      return HeroModifier.opacity(CGFloat(parameters.getFloat(0) ?? 1))
   36|      0|    case "position":
   37|      0|      return .position(CGPoint(x: parameters.getCGFloat(0) ?? 0, y: parameters.getCGFloat(1) ?? 0))
   38|      0|    case "size":
   39|      0|      return .size(CGSize(width: parameters.getCGFloat(0) ?? 0, height: parameters.getCGFloat(1) ?? 0))
   40|      0|    case "scale":
   41|      0|      if parameters.count == 1 {
   42|      0|        return .scale(parameters.getCGFloat(0) ?? 1)
   43|      0|      } else {
   44|      0|        return .scale(x: parameters.getCGFloat(0) ?? 1,
   45|      0|                          y: parameters.getCGFloat(1) ?? 1,
   46|      0|                          z: parameters.getCGFloat(2) ?? 1)
   47|      0|      }
   48|      0|    case "rotate":
   49|      0|      if parameters.count == 1 {
   50|      0|        return .rotate(parameters.getCGFloat(0) ?? 0)
   51|      0|      } else {
   52|      0|        return .rotate(x: parameters.getCGFloat(0) ?? 0,
   53|      0|                           y: parameters.getCGFloat(1) ?? 0,
   54|      0|                           z: parameters.getCGFloat(2) ?? 0)
   55|      0|      }
   56|      0|    case "translate":
   57|      0|      return .translate(x: parameters.getCGFloat(0) ?? 0,
   58|      0|                            y: parameters.getCGFloat(1) ?? 0,
   59|      0|                            z: parameters.getCGFloat(2) ?? 0)
   60|      0|    case "overlay":
   61|      0|      return .overlay(color: UIColor(red: parameters.getCGFloat(0) ?? 1,
   62|      0|                                         green: parameters.getCGFloat(1) ?? 1,
   63|      0|                                         blue: parameters.getCGFloat(2) ?? 1,
   64|      0|                                         alpha: 1),
   65|      0|                          opacity: parameters.getCGFloat(3) ?? 1)
   66|      0|    case "duration":
   67|      0|      if let duration = parameters.getDouble(0) {
   68|      0|        return .duration(duration)
   69|      0|      }
   70|      0|    case "durationMatchLongest":
   71|      0|      return .durationMatchLongest
   72|      0|    case "delay":
   73|      0|      if let delay = parameters.getDouble(0) {
   74|      0|        return .delay(delay)
   75|      0|      }
   76|      0|    case "spring":
   77|      0|      if #available(iOS 9, *) {
   78|      0|        return .spring(stiffness: parameters.getCGFloat(0) ?? 250, damping: parameters.getCGFloat(1) ?? 30)
   79|      0|      }
   80|      0|    case "timingFunction":
   81|      0|      if let c1 = parameters.getFloat(0),
   82|      0|        let c2 = parameters.getFloat(1),
   83|      0|        let c3 = parameters.getFloat(2),
   84|      0|        let c4 = parameters.getFloat(3) {
   85|      0|        return .timingFunction(CAMediaTimingFunction(controlPoints: c1, c2, c3, c4))
   86|      0|      } else if let name = parameters.get(0)?.name, let timingFunction = CAMediaTimingFunction.from(name: name) {
   87|      0|        return .timingFunction(timingFunction)
   88|      0|      }
   89|      0|    case "arc":
   90|      0|      return .arc(intensity: parameters.getCGFloat(0) ?? 1)
   91|      0|    case "cascade":
   92|      0|      var cascadeDirection = CascadeDirection.topToBottom
   93|      0|      if let directionString = parameters.get(1)?.name,
   94|      0|        let direction = CascadeDirection(directionString) {
   95|      0|        cascadeDirection = direction
   96|      0|      }
   97|      0|      return .cascade(delta: parameters.getDouble(0) ?? 0.02, direction: cascadeDirection, delayMatchedViews:parameters.getBool(2) ?? false)
   98|      0|    case "source":
   99|      0|      if let heroID = parameters.get(0)?.name {
  100|      0|        return .source(heroID: heroID)
  101|      0|      }
  102|      0|    case "useGlobalCoordinateSpace":
  103|      0|      return .useGlobalCoordinateSpace
  104|      0|    case "ignoreSubviewModifiers":
  105|      0|      return .ignoreSubviewModifiers(recursive:parameters.getBool(0) ?? false)
  106|      0|    case "zPosition":
  107|      0|      if let zPosition = parameters.getCGFloat(0) {
  108|      0|        return .zPosition(zPosition)
  109|      0|      }
  110|      0|    case "useOptimizedSnapshot":
  111|      0|      return .useOptimizedSnapshot
  112|      0|    case "useNormalSnapshot":
  113|      0|      return .useNormalSnapshot
  114|      0|    case "useLayerRenderSnapshot":
  115|      0|      return .useLayerRenderSnapshot
  116|      0|    case "useNoSnapshot":
  117|      0|      return .useNoSnapshot
  118|      0|    case "forceAnimate":
  119|      0|      return .forceAnimate
  120|      0|    default: break
  121|      0|    }
  122|      0|    return nil
  123|      0|  }
  124|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroModifier.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public final class HeroModifier {
   26|       |  internal let apply:(inout HeroTargetState) -> Void
   27|      0|  public init(applyFunction:@escaping (inout HeroTargetState) -> Void) {
   28|      0|    apply = applyFunction
   29|      0|  }
   30|       |}
   31|       |
   32|       |// basic modifiers
   33|       |extension HeroModifier {
   34|       |  /**
   35|       |   Fade the view during transition
   36|       |   */
   37|      0|  public static var fade = HeroModifier { targetState in
   38|      0|    targetState.opacity = 0
   39|      0|  }
   40|       |
   41|       |  /**
   42|       |   Force don't fade view during transition
   43|       |   */
   44|      0|  public static var forceNonFade = HeroModifier { targetState in
   45|      0|    targetState.nonFade = true
   46|      0|  }
   47|       |
   48|       |  /**
   49|       |   Set the position for the view to animate from/to.
   50|       |   - Parameters:
   51|       |     - position: position for the view to animate from/to
   52|       |   */
   53|      0|  public static func position(_ position: CGPoint) -> HeroModifier {
   54|      0|    return HeroModifier { targetState in
   55|      0|      targetState.position = position
   56|      0|    }
   57|      0|  }
   58|       |
   59|       |  /**
   60|       |   Set the size for the view to animate from/to.
   61|       |   - Parameters:
   62|       |     - size: size for the view to animate from/to
   63|       |   */
   64|      0|  public static func size(_ size: CGSize) -> HeroModifier {
   65|      0|    return HeroModifier { targetState in
   66|      0|      targetState.size = size
   67|      0|    }
   68|      0|  }
   69|       |}
   70|       |
   71|       |// transform modifiers
   72|       |extension HeroModifier {
   73|       |  /**
   74|       |   Set the transform for the view to animate from/to. Will override previous perspective, scale, translate, & rotate modifiers
   75|       |   - Parameters:
   76|       |     - t: the CATransform3D object
   77|       |   */
   78|      0|  public static func transform(_ t: CATransform3D) -> HeroModifier {
   79|      0|    return HeroModifier { targetState in
   80|      0|      targetState.transform = t
   81|      0|    }
   82|      0|  }
   83|       |
   84|       |  /**
   85|       |   Set the perspective on the transform. use in combination with the rotate modifier.
   86|       |   - Parameters:
   87|       |     - perspective: set the camera distance of the transform
   88|       |   */
   89|      0|  public static func perspective(_ perspective: CGFloat) -> HeroModifier {
   90|      0|    return HeroModifier { targetState in
   91|      0|      var transform = targetState.transform ?? CATransform3DIdentity
   92|      0|      transform.m34 = 1.0 / -perspective
   93|      0|      targetState.transform = transform
   94|      0|    }
   95|      0|  }
   96|       |
   97|       |  /**
   98|       |   Scale 3d
   99|       |   - Parameters:
  100|       |     - x: scale factor on x axis, default 1
  101|       |     - y: scale factor on y axis, default 1
  102|       |     - z: scale factor on z axis, default 1
  103|       |   */
  104|      0|  public static func scale(x: CGFloat = 1, y: CGFloat = 1, z: CGFloat = 1) -> HeroModifier {
  105|      0|    return HeroModifier { targetState in
  106|      0|      targetState.transform = CATransform3DScale(targetState.transform ?? CATransform3DIdentity, x, y, z)
  107|      0|    }
  108|      0|  }
  109|       |
  110|       |  /**
  111|       |   Scale in x & y axis
  112|       |   - Parameters:
  113|       |     - xy: scale factor in both x & y axis
  114|       |   */
  115|      0|  public static func scale(_ xy: CGFloat) -> HeroModifier {
  116|      0|    return .scale(x: xy, y: xy)
  117|      0|  }
  118|       |
  119|       |  /**
  120|       |   Translate 3d
  121|       |   - Parameters:
  122|       |     - x: translation distance on x axis in display pixel, default 0
  123|       |     - y: translation distance on y axis in display pixel, default 0
  124|       |     - z: translation distance on z axis in display pixel, default 0
  125|       |   */
  126|      0|  public static func translate(x: CGFloat = 0, y: CGFloat = 0, z: CGFloat = 0) -> HeroModifier {
  127|      0|    return HeroModifier { targetState in
  128|      0|      targetState.transform = CATransform3DTranslate(targetState.transform ?? CATransform3DIdentity, x, y, z)
  129|      0|    }
  130|      0|  }
  131|       |
  132|      0|  public static func translate(_ point: CGPoint, z: CGFloat = 0) -> HeroModifier {
  133|      0|    return translate(x: point.x, y: point.y, z: z)
  134|      0|  }
  135|       |
  136|       |  /**
  137|       |   Rotate 3d
  138|       |   - Parameters:
  139|       |     - x: rotation on x axis in radian, default 0
  140|       |     - y: rotation on y axis in radian, default 0
  141|       |     - z: rotation on z axis in radian, default 0
  142|       |   */
  143|      0|  public static func rotate(x: CGFloat = 0, y: CGFloat = 0, z: CGFloat = 0) -> HeroModifier {
  144|      0|    return HeroModifier { targetState in
  145|      0|      targetState.transform = CATransform3DRotate(targetState.transform ?? CATransform3DIdentity, x, 1, 0, 0)
  146|      0|      targetState.transform = CATransform3DRotate(targetState.transform!, y, 0, 1, 0)
  147|      0|      targetState.transform = CATransform3DRotate(targetState.transform!, z, 0, 0, 1)
  148|      0|    }
  149|      0|  }
  150|       |
  151|      0|  public static func rotate(_ point: CGPoint, z: CGFloat = 0) -> HeroModifier {
  152|      0|    return rotate(x: point.x, y: point.y, z: z)
  153|      0|  }
  154|       |
  155|       |  /**
  156|       |   Rotate 2d
  157|       |   - Parameters:
  158|       |     - z: rotation in radian
  159|       |   */
  160|      0|  public static func rotate(_ z: CGFloat) -> HeroModifier {
  161|      0|    return .rotate(z: z)
  162|      0|  }
  163|       |}
  164|       |
  165|       |extension HeroModifier {
  166|       |  /**
  167|       |   Set the opacity for the view to animate from/to.
  168|       |   - Parameters:
  169|       |     - opacity: opacity for the view to animate from/to
  170|       |   */
  171|      0|  public static func opacity(_ opacity: CGFloat) -> HeroModifier {
  172|      0|    return HeroModifier { targetState in
  173|      0|      targetState.opacity = Float(opacity)
  174|      0|    }
  175|      0|  }
  176|       |
  177|       |  /**
  178|       |   Set the backgroundColor for the view to animate from/to.
  179|       |   - Parameters:
  180|       |   - backgroundColor: backgroundColor for the view to animate from/to
  181|       |   */
  182|      0|  public static func backgroundColor(_ backgroundColor: UIColor) -> HeroModifier {
  183|      0|    return HeroModifier { targetState in
  184|      0|      targetState.backgroundColor = backgroundColor.cgColor
  185|      0|    }
  186|      0|  }
  187|       |
  188|       |  /**
  189|       |   Set the cornerRadius for the view to animate from/to.
  190|       |   - Parameters:
  191|       |     - cornerRadius: cornerRadius for the view to animate from/to
  192|       |   */
  193|      0|  public static func cornerRadius(_ cornerRadius: CGFloat) -> HeroModifier {
  194|      0|    return HeroModifier { targetState in
  195|      0|      targetState.cornerRadius = cornerRadius
  196|      0|    }
  197|      0|  }
  198|       |
  199|       |  /**
  200|       |   Set the zPosition for the view to animate from/to.
  201|       |   - Parameters:
  202|       |   - zPosition: zPosition for the view to animate from/to
  203|       |   */
  204|      0|  public static func zPosition(_ zPosition: CGFloat) -> HeroModifier {
  205|      0|    return HeroModifier { targetState in
  206|      0|      targetState.zPosition = zPosition
  207|      0|    }
  208|      0|  }
  209|       |
  210|       |  /**
  211|       |   Set the contentsRect for the view to animate from/to.
  212|       |   - Parameters:
  213|       |   - contentsRect: contentsRect for the view to animate from/to
  214|       |   */
  215|      0|  public static func contentsRect(_ contentsRect: CGRect) -> HeroModifier {
  216|      0|    return HeroModifier { targetState in
  217|      0|      targetState.contentsRect = contentsRect
  218|      0|    }
  219|      0|  }
  220|       |
  221|       |  /**
  222|       |   Set the contentsScale for the view to animate from/to.
  223|       |   - Parameters:
  224|       |   - contentsScale: contentsScale for the view to animate from/to
  225|       |   */
  226|      0|  public static func contentsScale(_ contentsScale: CGFloat) -> HeroModifier {
  227|      0|    return HeroModifier { targetState in
  228|      0|      targetState.contentsScale = contentsScale
  229|      0|    }
  230|      0|  }
  231|       |
  232|       |  /**
  233|       |   Set the borderWidth for the view to animate from/to.
  234|       |   - Parameters:
  235|       |   - borderWidth: borderWidth for the view to animate from/to
  236|       |   */
  237|      0|  public static func borderWidth(_ borderWidth: CGFloat) -> HeroModifier {
  238|      0|    return HeroModifier { targetState in
  239|      0|      targetState.borderWidth = borderWidth
  240|      0|    }
  241|      0|  }
  242|       |
  243|       |  /**
  244|       |   Set the borderColor for the view to animate from/to.
  245|       |   - Parameters:
  246|       |   - borderColor: borderColor for the view to animate from/to
  247|       |   */
  248|      0|  public static func borderColor(_ borderColor: UIColor) -> HeroModifier {
  249|      0|    return HeroModifier { targetState in
  250|      0|      targetState.borderColor = borderColor.cgColor
  251|      0|    }
  252|      0|  }
  253|       |
  254|       |  /**
  255|       |   Set the shadowColor for the view to animate from/to.
  256|       |   - Parameters:
  257|       |   - shadowColor: shadowColor for the view to animate from/to
  258|       |   */
  259|      0|  public static func shadowColor(_ shadowColor: UIColor) -> HeroModifier {
  260|      0|    return HeroModifier { targetState in
  261|      0|      targetState.shadowColor = shadowColor.cgColor
  262|      0|    }
  263|      0|  }
  264|       |
  265|       |  /**
  266|       |   Set the shadowOpacity for the view to animate from/to.
  267|       |   - Parameters:
  268|       |   - shadowOpacity: shadowOpacity for the view to animate from/to
  269|       |   */
  270|      0|  public static func shadowOpacity(_ shadowOpacity: CGFloat) -> HeroModifier {
  271|      0|    return HeroModifier { targetState in
  272|      0|      targetState.shadowOpacity = Float(shadowOpacity)
  273|      0|    }
  274|      0|  }
  275|       |
  276|       |  /**
  277|       |   Set the shadowOffset for the view to animate from/to.
  278|       |   - Parameters:
  279|       |   - shadowOffset: shadowOffset for the view to animate from/to
  280|       |   */
  281|      0|  public static func shadowOffset(_ shadowOffset: CGSize) -> HeroModifier {
  282|      0|    return HeroModifier { targetState in
  283|      0|      targetState.shadowOffset = shadowOffset
  284|      0|    }
  285|      0|  }
  286|       |
  287|       |  /**
  288|       |   Set the shadowRadius for the view to animate from/to.
  289|       |   - Parameters:
  290|       |   - shadowRadius: shadowRadius for the view to animate from/to
  291|       |   */
  292|      0|  public static func shadowRadius(_ shadowRadius: CGFloat) -> HeroModifier {
  293|      0|    return HeroModifier { targetState in
  294|      0|      targetState.shadowRadius = shadowRadius
  295|      0|    }
  296|      0|  }
  297|       |
  298|       |  /**
  299|       |   Set the shadowPath for the view to animate from/to.
  300|       |   - Parameters:
  301|       |   - shadowPath: shadowPath for the view to animate from/to
  302|       |   */
  303|      0|  public static func shadowPath(_ shadowPath: CGPath) -> HeroModifier {
  304|      0|    return HeroModifier { targetState in
  305|      0|      targetState.shadowPath = shadowPath
  306|      0|    }
  307|      0|  }
  308|       |
  309|       |  /**
  310|       |   Set the masksToBounds for the view to animate from/to.
  311|       |   - Parameters:
  312|       |   - masksToBounds: masksToBounds for the view to animate from/to
  313|       |   */
  314|      0|  public static func masksToBounds(_ masksToBounds: Bool) -> HeroModifier {
  315|      0|    return HeroModifier { targetState in
  316|      0|      targetState.masksToBounds = masksToBounds
  317|      0|    }
  318|      0|  }
  319|       |
  320|       |  /**
  321|       |   Create an overlay on the animating view.
  322|       |   - Parameters:
  323|       |     - color: color of the overlay
  324|       |     - opacity: opacity of the overlay
  325|       |   */
  326|      0|  public static func overlay(color: UIColor, opacity: CGFloat) -> HeroModifier {
  327|      0|    return HeroModifier { targetState in
  328|      0|      targetState.overlay = (color.cgColor, opacity)
  329|      0|    }
  330|      0|  }
  331|       |}
  332|       |
  333|       |// timing modifiers
  334|       |extension HeroModifier {
  335|       |  /**
  336|       |   Sets the duration of the animation for a given view. If not used, Hero will use determine the duration based on the distance and size changes.
  337|       |   - Parameters:
  338|       |     - duration: duration of the animation
  339|       |   
  340|       |   Note: a duration of .infinity means matching the duration of the longest animation. same as .durationMatchLongest
  341|       |   */
  342|      0|  public static func duration(_ duration: TimeInterval) -> HeroModifier {
  343|      0|    return HeroModifier { targetState in
  344|      0|      targetState.duration = duration
  345|      0|    }
  346|      0|  }
  347|       |
  348|       |  /**
  349|       |   Sets the duration of the animation for a given view to match the longest animation of the transition.
  350|       |   */
  351|      0|  public static var durationMatchLongest: HeroModifier = HeroModifier { targetState in
  352|      0|    targetState.duration = .infinity
  353|      0|  }
  354|       |
  355|       |  /**
  356|       |   Sets the delay of the animation for a given view.
  357|       |   - Parameters:
  358|       |     - delay: delay of the animation
  359|       |   */
  360|      0|  public static func delay(_ delay: TimeInterval) -> HeroModifier {
  361|      0|    return HeroModifier { targetState in
  362|      0|      targetState.delay = delay
  363|      0|    }
  364|      0|  }
  365|       |
  366|       |  /**
  367|       |   Sets the timing function of the animation for a given view. If not used, Hero will use determine the timing function based on whether or not the view is entering or exiting the screen.
  368|       |   - Parameters:
  369|       |     - timingFunction: timing function of the animation
  370|       |   */
  371|      0|  public static func timingFunction(_ timingFunction: CAMediaTimingFunction) -> HeroModifier {
  372|      0|    return HeroModifier { targetState in
  373|      0|      targetState.timingFunction = timingFunction
  374|      0|    }
  375|      0|  }
  376|       |
  377|       |  /**
  378|       |   (iOS 9+) Use spring animation with custom stiffness & damping. The duration will be automatically calculated. Will be ignored if arc, timingFunction, or duration is set.
  379|       |   - Parameters:
  380|       |     - stiffness: stiffness of the spring
  381|       |     - damping: damping of the spring
  382|       |   */
  383|       |  @available(iOS 9, *)
  384|      0|  public static func spring(stiffness: CGFloat, damping: CGFloat) -> HeroModifier {
  385|      0|    return HeroModifier { targetState in
  386|      0|      targetState.spring = (stiffness, damping)
  387|      0|    }
  388|      0|  }
  389|       |}
  390|       |
  391|       |// other modifiers
  392|       |extension HeroModifier {
  393|       |  /**
  394|       |   Transition from/to the state of the view with matching heroID
  395|       |   Will also force the view to use global coordinate space.
  396|       |   
  397|       |   The following layer properties will be animated from the given view.
  398|       |
  399|       |       position
  400|       |       bounds.size
  401|       |       cornerRadius
  402|       |       transform
  403|       |       shadowColor
  404|       |       shadowOpacity
  405|       |       shadowOffset
  406|       |       shadowRadius
  407|       |       shadowPath
  408|       |
  409|       |   Note that the following properties **won't** be taken from the source view.
  410|       |
  411|       |       backgroundColor
  412|       |       borderWidth
  413|       |       borderColor
  414|       |
  415|       |   - Parameters:
  416|       |     - heroID: the source view's heroId.
  417|       |   */
  418|      0|  public static func source(heroID: String) -> HeroModifier {
  419|      0|    return HeroModifier { targetState in
  420|      0|      targetState.source = heroID
  421|      0|    }
  422|      0|  }
  423|       |
  424|       |  /**
  425|       |   Works in combination with position modifier to apply a natural curve when moving to the destination.
  426|       |   */
  427|       |  public static var arc: HeroModifier = .arc()
  428|       |
  429|       |  /**
  430|       |   Works in combination with position modifier to apply a natural curve when moving to the destination.
  431|       |   - Parameters:
  432|       |     - intensity: a value of 1 represent a downward natural curve ╰. a value of -1 represent a upward curve ╮.
  433|       |       default is 1.
  434|       |   */
  435|       |  public static func arc(intensity: CGFloat = 1) -> HeroModifier {
  436|      0|    return HeroModifier { targetState in
  437|      0|      targetState.arc = intensity
  438|      0|    }
  439|       |  }
  440|       |
  441|       |  /**
  442|       |   Cascade applys increasing delay modifiers to subviews
  443|       |   */
  444|       |  public static var cascade: HeroModifier = .cascade()
  445|       |
  446|       |  /**
  447|       |   Cascade applys increasing delay modifiers to subviews
  448|       |   - Parameters:
  449|       |     - delta: delay in between each animation
  450|       |     - direction: cascade direction
  451|       |     - delayMatchedViews: whether or not to delay matched subviews until all cascading animation have started
  452|       |   */
  453|       |  public static func cascade(delta: TimeInterval = 0.02,
  454|       |                             direction: CascadeDirection = .topToBottom,
  455|       |                             delayMatchedViews: Bool = false) -> HeroModifier {
  456|      0|    return HeroModifier { targetState in
  457|      0|      targetState.cascade = (delta, direction, delayMatchedViews)
  458|      0|    }
  459|       |  }
  460|       |}
  461|       |
  462|       |// conditional modifiers
  463|       |extension HeroModifier {
  464|       |  /**
  465|       |   Apply modifiers only if the condition return true.
  466|       |   */
  467|      0|  public static func when(_ condition: @escaping (HeroConditionalContext) -> Bool, _ modifiers: [HeroModifier]) -> HeroModifier {
  468|      0|    return HeroModifier { targetState in
  469|      0|      if targetState.conditionalModifiers == nil {
  470|      0|        targetState.conditionalModifiers = []
  471|      0|      }
  472|      0|      targetState.conditionalModifiers!.append((condition, modifiers))
  473|      0|    }
  474|      0|  }
  475|       |
  476|      0|  public static func when(_ condition: @escaping (HeroConditionalContext) -> Bool, _ modifiers: HeroModifier...) -> HeroModifier {
  477|      0|    return .when(condition, modifiers)
  478|      0|  }
  479|       |
  480|      0|  public static func whenMatched(_ modifiers: HeroModifier...) -> HeroModifier {
  481|      0|    return .when({ $0.isMatched }, modifiers)
  482|      0|  }
  483|       |
  484|      0|  public static func whenPresenting(_ modifiers: HeroModifier...) -> HeroModifier {
  485|      0|    return .when({ $0.isPresenting }, modifiers)
  486|      0|  }
  487|       |
  488|      0|  public static func whenDismissing(_ modifiers: HeroModifier...) -> HeroModifier {
  489|      0|    return .when({ !$0.isPresenting }, modifiers)
  490|      0|  }
  491|       |
  492|      0|  public static func whenAppearing(_ modifiers: HeroModifier...) -> HeroModifier {
  493|      0|    return .when({ $0.isAppearing }, modifiers)
  494|      0|  }
  495|       |
  496|      0|  public static func whenDisappearing(_ modifiers: HeroModifier...) -> HeroModifier {
  497|      0|    return .when({ !$0.isAppearing }, modifiers)
  498|      0|  }
  499|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroPlugin.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |open class HeroPlugin: NSObject, HeroPreprocessor, HeroAnimator {
   26|       |
   27|       |  weak public var hero: HeroTransition!
   28|       |
   29|      0|  public var context: HeroContext! {
   30|      0|    return hero.context
   31|      0|  }
   32|       |
   33|       |  /**
   34|       |    Determines whether or not to receive `seekTo` callback on every frame.
   35|       |   
   36|       |    Default is false.
   37|       |   
   38|       |    When **requirePerFrameCallback** is **false**, the plugin needs to start its own animations inside `animate` & `resume`
   39|       |    The `seekTo` method is only being called during an interactive transition.
   40|       |   
   41|       |    When **requirePerFrameCallback** is **true**, the plugin will receive `seekTo` callback on every animation frame. Hence it is possible for the plugin to do per-frame animations without implementing `animate` & `resume`
   42|       |   */
   43|       |  open var requirePerFrameCallback = false
   44|       |
   45|      0|  public override required init() {}
   46|       |
   47|       |  /**
   48|       |   Called before any animation.
   49|       |   Override this method when you want to preprocess modifiers for views
   50|       |   - Parameters:
   51|       |       - context: object holding all parsed and changed modifiers,
   52|       |       - fromViews: A flattened list of all views from source ViewController
   53|       |       - toViews: A flattened list of all views from destination ViewController
   54|       |
   55|       |   To check a view's modifiers:
   56|       |
   57|       |       context[view]
   58|       |       context[view, "modifierName"]
   59|       |
   60|       |   To set a view's modifiers:
   61|       |
   62|       |       context[view] = [("modifier1", ["parameter1"]), ("modifier2", [])]
   63|       |       context[view, "modifier1"] = ["parameter1", "parameter2"]
   64|       |
   65|       |  */
   66|      0|  open func process(fromViews: [UIView], toViews: [UIView]) {}
   67|       |
   68|       |  /**
   69|       |   - Returns: return true if the plugin can handle animating the view.
   70|       |   - Parameters:
   71|       |       - context: object holding all parsed and changed modifiers,
   72|       |       - view: the view to check whether or not the plugin can handle the animation
   73|       |       - appearing: true if the view is appearing(i.e. a view in destination ViewController)
   74|       |   If return true, Hero won't animate and won't let any other plugins animate this view.
   75|       |   The view will also be hidden automatically during the animation.
   76|       |   */
   77|      0|  open func canAnimate(view: UIView, appearing: Bool) -> Bool { return false }
   78|       |
   79|       |  /**
   80|       |   Perform the animation.
   81|       |
   82|       |   Note: views in `fromViews` & `toViews` are hidden already. Unhide then if you need to take snapshots.
   83|       |   - Parameters:
   84|       |       - context: object holding all parsed and changed modifiers,
   85|       |       - fromViews: A flattened list of all views from source ViewController (filtered by `canAnimate`)
   86|       |       - toViews: A flattened list of all views from destination ViewController (filtered by `canAnimate`)
   87|       |   - Returns: The duration needed to complete the animation
   88|       |   */
   89|       |
   90|      0|  open func animate(fromViews: [UIView], toViews: [UIView]) -> TimeInterval { return 0 }
   91|       |
   92|       |  /**
   93|       |   Called when all animations are completed.
   94|       |
   95|       |   Should perform cleanup and release any reference
   96|       |   */
   97|      0|  open func clean() {}
   98|       |
   99|       |  /**
  100|       |   For supporting interactive animation only.
  101|       |
  102|       |   This method is called when an interactive animation is in place
  103|       |   The plugin should pause the animation, and seek to the given progress
  104|       |   - Parameters:
  105|       |     - timePassed: time of the animation to seek to.
  106|       |   */
  107|      0|  open func seekTo(timePassed: TimeInterval) {}
  108|       |
  109|       |  /**
  110|       |   For supporting interactive animation only.
  111|       |
  112|       |   This method is called when an interactive animation is ended
  113|       |   The plugin should resume the animation.
  114|       |   - Parameters:
  115|       |   - timePassed: will be the same value since last `seekTo`
  116|       |   - reverse: a boolean value indicating whether or not the animation should reverse
  117|       |   */
  118|      0|  open func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval { return 0 }
  119|       |
  120|       |  /**
  121|       |   For supporting interactive animation only.
  122|       |
  123|       |   This method is called when user wants to override animation modifiers during an interactive animation
  124|       |
  125|       |   - Parameters:
  126|       |       - state: the target state to override
  127|       |       - view: the view to override
  128|       |   */
  129|      0|  open func apply(state: HeroTargetState, to view: UIView) {}
  130|      0|  open func changeTarget(state: HeroTargetState, isDestination: Bool, to view: UIView) {}
  131|       |}
  132|       |
  133|       |// methods for enable/disable the current plugin
  134|       |extension HeroPlugin {
  135|       |  public static var isEnabled: Bool {
  136|      0|    get {
  137|      0|      return HeroTransition.isEnabled(plugin: self)
  138|      0|    }
  139|      0|    set {
  140|      0|      if newValue {
  141|      0|        enable()
  142|      0|      } else {
  143|      0|        disable()
  144|      0|      }
  145|      0|    }
  146|       |  }
  147|       |  public static func enable() {
  148|       |    HeroTransition.enable(plugin: self)
  149|       |  }
  150|       |  public static func disable() {
  151|       |    HeroTransition.disable(plugin: self)
  152|       |  }
  153|       |}
  154|       |
  155|       |// MARK: Plugin Support
  156|       |internal extension HeroTransition {
  157|       |  static func isEnabled(plugin: HeroPlugin.Type) -> Bool {
  158|      0|    return enabledPlugins.index(where: { return $0 == plugin}) != nil
  159|       |  }
  160|       |
  161|       |  static func enable(plugin: HeroPlugin.Type) {
  162|       |    disable(plugin: plugin)
  163|       |    enabledPlugins.append(plugin)
  164|       |  }
  165|       |
  166|       |  static func disable(plugin: HeroPlugin.Type) {
  167|      0|    if let index = enabledPlugins.index(where: { return $0 == plugin}) {
  168|       |      enabledPlugins.remove(at: index)
  169|       |    }
  170|       |  }
  171|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroTargetState.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public enum HeroSnapshotType {
   26|       |  /// Will optimize for different type of views
   27|       |  /// For custom views or views with masking, .optimizedDefault might create snapshots 
   28|       |  /// that appear differently than the actual view.
   29|       |  /// In that case, use .normal or .slowRender to disable the optimization
   30|       |  case optimized
   31|       |
   32|       |  /// snapshotView(afterScreenUpdates:)
   33|       |  case normal
   34|       |
   35|       |  /// layer.render(in: currentContext)
   36|       |  case layerRender
   37|       |
   38|       |  /// will not create snapshot. animate the view directly.
   39|       |  /// This will mess up the view hierarchy, therefore, view controllers have to rebuild
   40|       |  /// its view structure after the transition finishes
   41|       |  case noSnapshot
   42|       |}
   43|       |
   44|       |public enum HeroCoordinateSpace {
   45|       |  case global
   46|       |  case local
   47|       |}
   48|       |
   49|       |public struct HeroTargetState {
   50|       |  public var beginState: [HeroModifier]?
   51|       |  public var conditionalModifiers: [((HeroConditionalContext) -> Bool, [HeroModifier])]?
   52|       |
   53|       |  public var position: CGPoint?
   54|       |  public var size: CGSize?
   55|       |  public var transform: CATransform3D?
   56|       |  public var opacity: Float?
   57|       |  public var cornerRadius: CGFloat?
   58|       |  public var backgroundColor: CGColor?
   59|       |  public var zPosition: CGFloat?
   60|       |
   61|       |  public var contentsRect: CGRect?
   62|       |  public var contentsScale: CGFloat?
   63|       |
   64|       |  public var borderWidth: CGFloat?
   65|       |  public var borderColor: CGColor?
   66|       |
   67|       |  public var shadowColor: CGColor?
   68|       |  public var shadowOpacity: Float?
   69|       |  public var shadowOffset: CGSize?
   70|       |  public var shadowRadius: CGFloat?
   71|       |  public var shadowPath: CGPath?
   72|       |  public var masksToBounds: Bool?
   73|       |  public var displayShadow: Bool = true
   74|       |
   75|       |  public var overlay: (color: CGColor, opacity: CGFloat)?
   76|       |
   77|       |  public var spring: (CGFloat, CGFloat)?
   78|       |  public var delay: TimeInterval = 0
   79|       |  public var duration: TimeInterval?
   80|       |  public var timingFunction: CAMediaTimingFunction?
   81|       |
   82|       |  public var arc: CGFloat?
   83|       |  public var source: String?
   84|       |  public var cascade: (TimeInterval, CascadeDirection, Bool)?
   85|       |
   86|       |  public var ignoreSubviewModifiers: Bool?
   87|       |  public var coordinateSpace: HeroCoordinateSpace?
   88|       |  public var useScaleBasedSizeChange: Bool?
   89|       |  public var snapshotType: HeroSnapshotType?
   90|       |
   91|       |  public var nonFade: Bool = false
   92|       |  public var forceAnimate: Bool = false
   93|       |  public var custom: [String: Any]?
   94|       |
   95|      0|  init(modifiers: [HeroModifier]) {
   96|      0|    append(contentsOf: modifiers)
   97|      0|  }
   98|       |
   99|      0|  public mutating func append(_ modifier: HeroModifier) {
  100|      0|    modifier.apply(&self)
  101|      0|  }
  102|       |
  103|       |  public mutating func append(contentsOf modifiers: [HeroModifier]) {
  104|       |    for modifier in modifiers {
  105|       |      modifier.apply(&self)
  106|       |    }
  107|       |  }
  108|       |
  109|       |  /**
  110|       |   - Returns: custom item for a specific key
  111|       |   */
  112|       |  public subscript(key: String) -> Any? {
  113|      0|    get {
  114|      0|      return custom?[key]
  115|      0|    }
  116|      0|    set {
  117|      0|      if custom == nil {
  118|      0|        custom = [:]
  119|      0|      }
  120|      0|      custom![key] = newValue
  121|      0|    }
  122|       |  }
  123|       |}
  124|       |
  125|       |extension HeroTargetState: ExpressibleByArrayLiteral {
  126|      0|  public init(arrayLiteral elements: HeroModifier...) {
  127|      0|    append(contentsOf: elements)
  128|      0|  }
  129|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/HeroViewControllerDelegate.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |@objc public protocol HeroViewControllerDelegate {
   26|       |  @objc optional func heroWillStartAnimatingFrom(viewController: UIViewController)
   27|       |  @objc optional func heroDidEndAnimatingFrom(viewController: UIViewController)
   28|       |  @objc optional func heroDidCancelAnimatingFrom(viewController: UIViewController)
   29|       |
   30|       |  @objc optional func heroWillStartTransition()
   31|       |  @objc optional func heroDidEndTransition()
   32|       |  @objc optional func heroDidCancelTransition()
   33|       |
   34|       |  @objc optional func heroWillStartAnimatingTo(viewController: UIViewController)
   35|       |  @objc optional func heroDidEndAnimatingTo(viewController: UIViewController)
   36|       |  @objc optional func heroDidCancelAnimatingTo(viewController: UIViewController)
   37|       |}
   38|       |
   39|       |// delegate helper
   40|       |internal extension HeroTransition {
   41|      0|  func closureProcessForHeroDelegate<T: UIViewController>(vc: T, closure: (HeroViewControllerDelegate) -> Void) {
   42|      0|    if let delegate = vc as? HeroViewControllerDelegate {
   43|      0|      closure(delegate)
   44|      0|    }
   45|      0|
   46|      0|    if let navigationController = vc as? UINavigationController,
   47|      0|      let delegate = navigationController.topViewController as? HeroViewControllerDelegate {
   48|      0|      closure(delegate)
   49|      0|    } else if let tabBarController = vc as? UITabBarController,
   50|      0|      let delegate = tabBarController.selectedViewController as? HeroViewControllerDelegate {
   51|      0|      closure(delegate)
   52|      0|    } else {
   53|      0|      for vc in vc.children where vc.isViewLoaded {
   54|      0|        self.closureProcessForHeroDelegate(vc: vc, closure: closure)
   55|      0|      }
   56|      0|    }
   57|      0|  }
   58|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Parser/HeroStringConvertible.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public protocol HeroStringConvertible {
   26|       |  static func from(node: ExprNode) -> Self?
   27|       |}
   28|       |
   29|       |extension String {
   30|      0|  func parse<T: HeroStringConvertible>() -> [T]? {
   31|      0|    let lexer = Lexer(input: self)
   32|      0|    let parser = Parser(tokens: lexer.tokenize())
   33|      0|    do {
   34|      0|      let nodes = try parser.parse()
   35|      0|      var results = [T]()
   36|      0|      for node in nodes {
   37|      0|        if let modifier = T.from(node: node) {
   38|      0|          results.append(modifier)
   39|      0|        } else {
   40|      0|          print("\(node.name) doesn't exist in \(T.self)")
   41|      0|        }
   42|      0|      }
   43|      0|      return results
   44|      0|    } catch let error {
   45|      0|      print("failed to parse \"\(self)\", error: \(error)")
   46|      0|    }
   47|      0|    return nil
   48|      0|  }
   49|       |
   50|      0|  func parseOne<T: HeroStringConvertible>() -> T? {
   51|      0|    return parse()?.last
   52|      0|  }
   53|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Parser/Lexer.swift:
    1|       |//
    2|       |//  Lexer.swift
    3|       |//  Kaleidoscope
    4|       |//
    5|       |//  Created by Matthew Cheok on 15/11/15.
    6|       |//  Copyright © 2015 Matthew Cheok. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public enum Token {
   12|       |  case identifier(String, CountableRange<Int>)
   13|       |  case number(Float, CountableRange<Int>)
   14|       |  case parensOpen(CountableRange<Int>)
   15|       |  case parensClose(CountableRange<Int>)
   16|       |  case comma(CountableRange<Int>)
   17|       |  case other(String, CountableRange<Int>)
   18|       |}
   19|       |
   20|       |typealias TokenGenerator = (String, CountableRange<Int>) -> Token?
   21|       |let tokenList: [(String, TokenGenerator)] = [
   22|      0|  ("[ \t\n]", { _, _ in nil }),
   23|      0|  ("[a-zA-Z][a-zA-Z0-9]*", { .identifier($0, $1) }),
   24|      0|  ("\\-?[0-9.]+", { .number(Float($0)!, $1) }),
   25|      0|  ("\\(", { .parensOpen($1) }),
   26|      0|  ("\\)", { .parensClose($1) }),
   27|      0|  (",", { .comma($1) })
   28|       |]
   29|       |
   30|       |public class Lexer {
   31|       |  let input: String
   32|      0|  public init(input: String) {
   33|      0|    self.input = input
   34|      0|  }
   35|      0|  public func tokenize() -> [Token] {
   36|      0|    var tokens = [Token]()
   37|      0|    var content = input
   38|      0|
   39|      0|    while !content.isEmpty {
   40|      0|      var matched = false
   41|      0|
   42|      0|      for (pattern, generator) in tokenList {
   43|      0|        if let (m, r) = content.match(regex: pattern) {
   44|      0|          if let t = generator(m, r) {
   45|      0|            tokens.append(t)
   46|      0|          }
   47|      0|
   48|      0|          content = String(content[content.index(content.startIndex, offsetBy: m.count)...])
   49|      0|          matched = true
   50|      0|          break
   51|      0|        }
   52|      0|      }
   53|      0|
   54|      0|      if !matched {
   55|      0|        let index = content.index(content.startIndex, offsetBy: 1)
   56|      0|        let intIndex = content.distance(from: content.startIndex, to: index)
   57|      0|        tokens.append(.other(String(content[..<index]), intIndex..<intIndex+1))
   58|      0|        content = String(content[index...])
   59|      0|      }
   60|      0|    }
   61|      0|    return tokens
   62|      0|  }
   63|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Parser/Nodes.swift:
    1|       |//
    2|       |//  Nodes.swift
    3|       |//  Kaleidoscope
    4|       |//
    5|       |//  Created by Matthew Cheok on 15/11/15.
    6|       |//  Copyright © 2015 Matthew Cheok. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public class ExprNode: CustomStringConvertible, Equatable {
   12|       |  public var range: CountableRange<Int> = 0..<0
   13|       |  public let name: String
   14|      0|  public var description: String {
   15|      0|    return "ExprNode(name: \"\(name)\")"
   16|      0|  }
   17|      0|  public init(name: String) {
   18|      0|    self.name = name
   19|      0|  }
   20|       |}
   21|       |
   22|       |public func == (lhs: ExprNode, rhs: ExprNode) -> Bool {
   23|       |  return lhs.description == rhs.description
   24|       |}
   25|       |
   26|       |public class NumberNode: ExprNode {
   27|       |  public let value: Float
   28|      0|  public override var description: String {
   29|      0|    return "NumberNode(value: \(value))"
   30|      0|  }
   31|      0|  public init(value: Float) {
   32|      0|    self.value = value
   33|      0|    super.init(name: "\(value)")
   34|      0|  }
   35|       |}
   36|       |
   37|       |public class VariableNode: ExprNode {
   38|      0|  public override var description: String {
   39|      0|    return "VariableNode(name: \"\(name)\")"
   40|      0|  }
   41|       |}
   42|       |
   43|       |public class BinaryOpNode: ExprNode {
   44|       |  public let lhs: ExprNode
   45|       |  public let rhs: ExprNode
   46|      0|  public override var description: String {
   47|      0|    return "BinaryOpNode(name: \"\(name)\", lhs: \(lhs), rhs: \(rhs))"
   48|      0|  }
   49|      0|  public init(name: String, lhs: ExprNode, rhs: ExprNode) {
   50|      0|    self.lhs = lhs
   51|      0|    self.rhs = rhs
   52|      0|    super.init(name: "\(name)")
   53|      0|  }
   54|       |}
   55|       |
   56|       |public class CallNode: ExprNode {
   57|       |  public let arguments: [ExprNode]
   58|      0|  public override var description: String {
   59|      0|    return "CallNode(name: \"\(name)\", arguments: \(arguments))"
   60|      0|  }
   61|      0|  public init(name: String, arguments: [ExprNode]) {
   62|      0|    self.arguments = arguments
   63|      0|    super.init(name: "\(name)")
   64|      0|  }
   65|       |}
   66|       |
   67|       |public class PrototypeNode: ExprNode {
   68|       |  public let argumentNames: [String]
   69|      0|  public override var description: String {
   70|      0|    return "PrototypeNode(name: \"\(name)\", argumentNames: \(argumentNames))"
   71|      0|  }
   72|      0|  public init(name: String, argumentNames: [String]) {
   73|      0|    self.argumentNames = argumentNames
   74|      0|    super.init(name: "\(name)")
   75|      0|  }
   76|       |}
   77|       |
   78|       |public class FunctionNode: ExprNode {
   79|       |  public let prototype: PrototypeNode
   80|       |  public let body: ExprNode
   81|      0|  public override var description: String {
   82|      0|    return "FunctionNode(prototype: \(prototype), body: \(body))"
   83|      0|  }
   84|      0|  public init(prototype: PrototypeNode, body: ExprNode) {
   85|      0|    self.prototype = prototype
   86|      0|    self.body = body
   87|      0|    super.init(name: "\(prototype.name)")
   88|      0|  }
   89|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Parser/Parser.swift:
    1|       |//
    2|       |//  Parser.swift
    3|       |//  Kaleidoscope
    4|       |//
    5|       |//  Created by Matthew Cheok on 15/11/15.
    6|       |//  Copyright © 2015 Matthew Cheok. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public enum ParseError: Error {
   12|       |  case unexpectToken
   13|       |  case undefinedOperator(String)
   14|       |
   15|       |  case expectCharacter(Character)
   16|       |  case expectExpression
   17|       |  case expectArgumentList
   18|       |  case expectFunctionName
   19|       |}
   20|       |
   21|       |public class Parser {
   22|       |  let tokens: [Token]
   23|       |  var index = 0
   24|       |
   25|      0|  public init(tokens: [Token]) {
   26|      0|    self.tokens = tokens
   27|      0|  }
   28|       |
   29|      0|  func peekCurrentToken() -> Token {
   30|      0|    if index >= tokens.count {
   31|      0|      return .other("", 0..<0)
   32|      0|    }
   33|      0|    return tokens[index]
   34|      0|  }
   35|       |
   36|      0|  @discardableResult func popCurrentToken() -> Token {
   37|      0|    defer { index += 1 }
   38|      0|    return tokens[index]
   39|      0|  }
   40|       |
   41|      0|  func parseNumber() throws -> ExprNode {
   42|      0|    guard case let .number(value, _) = popCurrentToken() else {
   43|      0|      throw ParseError.unexpectToken
   44|      0|    }
   45|      0|    return NumberNode(value: value)
   46|      0|  }
   47|       |
   48|      0|  func parseExpression() throws -> ExprNode {
   49|      0|    let node = try parsePrimary()
   50|      0|    return try parseBinaryOp(node: node)
   51|      0|  }
   52|       |
   53|      0|  func parseParens() throws -> ExprNode {
   54|      0|    guard case .parensOpen = popCurrentToken() else {
   55|      0|      throw ParseError.expectCharacter("(")
   56|      0|    }
   57|      0|
   58|      0|    let exp = try parseExpression()
   59|      0|
   60|      0|    guard case .parensClose = popCurrentToken() else {
   61|      0|      throw ParseError.expectCharacter(")")
   62|      0|    }
   63|      0|
   64|      0|    return exp
   65|      0|  }
   66|       |
   67|      0|  func parseIdentifier() throws -> ExprNode {
   68|      0|    guard case let .identifier(name, _) = popCurrentToken() else {
   69|      0|      throw ParseError.unexpectToken
   70|      0|    }
   71|      0|
   72|      0|    guard case .parensOpen = peekCurrentToken() else {
   73|      0|      return VariableNode(name: name)
   74|      0|    }
   75|      0|    popCurrentToken()
   76|      0|
   77|      0|    var arguments = [ExprNode]()
   78|      0|    if case .parensClose = peekCurrentToken() {
   79|      0|    } else {
   80|      0|      while true {
   81|      0|        let argument = try parseExpression()
   82|      0|        arguments.append(argument)
   83|      0|
   84|      0|        if case .parensClose = peekCurrentToken() {
   85|      0|          break
   86|      0|        }
   87|      0|
   88|      0|        guard case .comma = popCurrentToken() else {
   89|      0|          throw ParseError.expectArgumentList
   90|      0|        }
   91|      0|      }
   92|      0|    }
   93|      0|
   94|      0|    popCurrentToken()
   95|      0|    return CallNode(name: name, arguments: arguments)
   96|      0|  }
   97|       |
   98|      0|  func parsePrimary() throws -> ExprNode {
   99|      0|    switch peekCurrentToken() {
  100|      0|    case .identifier:
  101|      0|      return try parseIdentifier()
  102|      0|    case .number:
  103|      0|      return try parseNumber()
  104|      0|    case .parensOpen:
  105|      0|      return try parseParens()
  106|      0|    default:
  107|      0|      throw ParseError.expectExpression
  108|      0|    }
  109|      0|  }
  110|       |
  111|       |  let operatorPrecedence: [String: Int] = [
  112|       |    "+": 20,
  113|       |    "-": 20,
  114|       |    "*": 40,
  115|       |    "/": 40
  116|       |  ]
  117|       |
  118|      0|  func getCurrentTokenPrecedence() throws -> Int {
  119|      0|    guard index < tokens.count else {
  120|      0|      return -1
  121|      0|    }
  122|      0|
  123|      0|    guard case let .other(op, _) = peekCurrentToken() else {
  124|      0|      return -1
  125|      0|    }
  126|      0|
  127|      0|    guard let precedence = operatorPrecedence[op] else {
  128|      0|      throw ParseError.undefinedOperator(op)
  129|      0|    }
  130|      0|
  131|      0|    return precedence
  132|      0|  }
  133|       |
  134|      0|  func parseBinaryOp(node: ExprNode, exprPrecedence: Int = 0) throws -> ExprNode {
  135|      0|    var lhs = node
  136|      0|    while true {
  137|      0|      let tokenPrecedence = try getCurrentTokenPrecedence()
  138|      0|      if tokenPrecedence < exprPrecedence {
  139|      0|        return lhs
  140|      0|      }
  141|      0|
  142|      0|      guard case let .other(op, _) = popCurrentToken() else {
  143|      0|        throw ParseError.unexpectToken
  144|      0|      }
  145|      0|
  146|      0|      var rhs = try parsePrimary()
  147|      0|      let nextPrecedence = try getCurrentTokenPrecedence()
  148|      0|
  149|      0|      if tokenPrecedence < nextPrecedence {
  150|      0|        rhs = try parseBinaryOp(node: rhs, exprPrecedence: tokenPrecedence+1)
  151|      0|      }
  152|      0|      lhs = BinaryOpNode(name: op, lhs: lhs, rhs: rhs)
  153|      0|    }
  154|      0|  }
  155|       |
  156|      0|  public func parse() throws -> [ExprNode] {
  157|      0|    index = 0
  158|      0|
  159|      0|    var nodes = [ExprNode]()
  160|      0|    while index < tokens.count {
  161|      0|      let expr = try parsePrimary()
  162|      0|      nodes.append(expr)
  163|      0|    }
  164|      0|
  165|      0|    return nodes
  166|      0|  }
  167|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Parser/Regex.swift:
    1|       |//
    2|       |//  Regex.swift
    3|       |//  Kaleidoscope
    4|       |//
    5|       |//  Created by Matthew Cheok on 15/11/15.
    6|       |//  Copyright © 2015 Matthew Cheok. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |var expressions = [String: NSRegularExpression]()
   12|       |public extension String {
   13|      0|  public func match(regex: String) -> (String, CountableRange<Int>)? {
   14|      0|    let expression: NSRegularExpression
   15|      0|    if let exists = expressions[regex] {
   16|      0|      expression = exists
   17|      0|    } else {
   18|      0|      do {
   19|      0|        expression = try NSRegularExpression(pattern: "^\(regex)", options: [])
   20|      0|        expressions[regex] = expression
   21|      0|      } catch {
   22|      0|        return nil
   23|      0|      }
   24|      0|    }
   25|      0|
   26|      0|    let range = expression.rangeOfFirstMatch(in: self, options: [], range: NSRange(0 ..< self.utf16.count))
   27|      0|    if range.location != NSNotFound {
   28|      0|      return ((self as NSString).substring(with: range), range.location ..< range.location + range.length )
   29|      0|    }
   30|      0|    return nil
   31|      0|  }
   32|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/BasePreprocessor.swift:
    1|       |//
    2|       |//  CascadeEffect.swift
    3|       |// The MIT License (MIT)
    4|       |//
    5|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    6|       |//
    7|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       |// of this software and associated documentation files (the "Software"), to deal
    9|       |// in the Software without restriction, including without limitation the rights
   10|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       |// copies of the Software, and to permit persons to whom the Software is
   12|       |// furnished to do so, subject to the following conditions:
   13|       |//
   14|       |// The above copyright notice and this permission notice shall be included in
   15|       |// all copies or substantial portions of the Software.
   16|       |//
   17|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   20|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       |// THE SOFTWARE.
   24|       |
   25|       |import UIKit
   26|       |
   27|       |class BasePreprocessor: HeroPreprocessor {
   28|       |  weak public var hero: HeroTransition!
   29|      0|  public var context: HeroContext! {
   30|      0|    return hero?.context
   31|      0|  }
   32|       |
   33|      0|  func process(fromViews: [UIView], toViews: [UIView]) {}
   34|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/CascadePreprocessor.swift:
    1|       |//
    2|       |//  CascadeEffect.swift
    3|       |// The MIT License (MIT)
    4|       |//
    5|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    6|       |//
    7|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       |// of this software and associated documentation files (the "Software"), to deal
    9|       |// in the Software without restriction, including without limitation the rights
   10|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       |// copies of the Software, and to permit persons to whom the Software is
   12|       |// furnished to do so, subject to the following conditions:
   13|       |//
   14|       |// The above copyright notice and this permission notice shall be included in
   15|       |// all copies or substantial portions of the Software.
   16|       |//
   17|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   20|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       |// THE SOFTWARE.
   24|       |
   25|       |import UIKit
   26|       |
   27|       |public enum CascadeDirection {
   28|       |  case topToBottom
   29|       |  case bottomToTop
   30|       |  case leftToRight
   31|       |  case rightToLeft
   32|       |  case radial(center:CGPoint)
   33|       |  case inverseRadial(center:CGPoint)
   34|      0|  var comparator: (UIView, UIView) -> Bool {
   35|      0|    switch self {
   36|      0|    case .topToBottom:
   37|      0|      return topToBottomComperator
   38|      0|    case .bottomToTop:
   39|      0|      return bottomToTopComperator
   40|      0|    case .leftToRight:
   41|      0|      return leftToRightComperator
   42|      0|    case .rightToLeft:
   43|      0|      return rightToLeftComperator
   44|      0|    case .radial(let center):
   45|      0|      return { (lhs: UIView, rhs: UIView) -> Bool in
   46|      0|        return lhs.center.distance(center) < rhs.center.distance(center)
   47|      0|      }
   48|      0|    case .inverseRadial(let center):
   49|      0|      return { (lhs: UIView, rhs: UIView) -> Bool in
   50|      0|        return lhs.center.distance(center) > rhs.center.distance(center)
   51|      0|      }
   52|      0|    }
   53|      0|  }
   54|       |
   55|      0|  init?(_ string: String) {
   56|      0|    switch string {
   57|      0|    case "bottomToTop":
   58|      0|      self = .bottomToTop
   59|      0|    case "leftToRight":
   60|      0|      self = .leftToRight
   61|      0|    case "rightToLeft":
   62|      0|      self = .rightToLeft
   63|      0|    case "topToBottom":
   64|      0|      self = .topToBottom
   65|      0|    default:
   66|      0|      return nil
   67|      0|    }
   68|      0|  }
   69|       |
   70|       |  private func topToBottomComperator(lhs: UIView, rhs: UIView) -> Bool {
   71|       |    return lhs.frame.minY < rhs.frame.minY
   72|       |  }
   73|       |
   74|       |  private func bottomToTopComperator(lhs: UIView, rhs: UIView) -> Bool {
   75|       |    return lhs.frame.maxY == rhs.frame.maxY ? lhs.frame.maxX > rhs.frame.maxX : lhs.frame.maxY > rhs.frame.maxY
   76|       |  }
   77|       |
   78|       |  private func leftToRightComperator(lhs: UIView, rhs: UIView) -> Bool {
   79|       |    return lhs.frame.minX < rhs.frame.minX
   80|       |  }
   81|       |
   82|       |  private func rightToLeftComperator(lhs: UIView, rhs: UIView) -> Bool {
   83|       |    return lhs.frame.maxX > rhs.frame.maxX
   84|       |  }
   85|       |}
   86|       |
   87|       |class CascadePreprocessor: BasePreprocessor {
   88|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
   89|      0|    process(views: fromViews)
   90|      0|    process(views: toViews)
   91|      0|  }
   92|       |
   93|      0|  func process(views: [UIView]) {
   94|      0|    for view in views {
   95|      0|      guard let (deltaTime, direction, delayMatchedViews) = context[view]?.cascade else { continue }
   96|      0|
   97|      0|      var parentView = view
   98|      0|      if view is UITableView, let wrapperView = view.subviews.get(0) {
   99|      0|        parentView = wrapperView
  100|      0|      }
  101|      0|
  102|      0|      let sortedSubviews = parentView.subviews.sorted(by: direction.comparator)
  103|      0|
  104|      0|      let initialDelay = context[view]!.delay
  105|      0|      let finalDelay = TimeInterval(sortedSubviews.count) * deltaTime + initialDelay
  106|      0|
  107|      0|      for (i, subview) in sortedSubviews.enumerated() {
  108|      0|        let delay = TimeInterval(i) * deltaTime + initialDelay
  109|      0|
  110|      0|        func applyDelay(view: UIView) {
  111|      0|          if context.pairedView(for: view) == nil {
  112|      0|            context[view]?.delay = delay
  113|      0|          } else if delayMatchedViews, let paired = context.pairedView(for: view) {
  114|      0|            context[view]?.delay = finalDelay
  115|      0|            context[paired]?.delay = finalDelay
  116|      0|          }
  117|      0|          for subview in view.subviews {
  118|      0|            applyDelay(view: subview)
  119|      0|          }
  120|      0|        }
  121|      0|
  122|      0|        applyDelay(view: subview)
  123|      0|      }
  124|      0|    }
  125|      0|  }
  126|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/ConditionalPreprocessor.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public struct HeroConditionalContext {
   26|       |  internal weak var hero: HeroTransition!
   27|       |  public weak var view: UIView!
   28|       |
   29|       |  public private(set) var isAppearing: Bool
   30|       |
   31|      0|  public var isPresenting: Bool {
   32|      0|    return hero.isPresenting
   33|      0|  }
   34|      0|  public var isInTabbarController: Bool {
   35|      0|    return hero.inTabBarController
   36|      0|  }
   37|      0|  public var isInNavbarController: Bool {
   38|      0|    return hero.inNavigationController
   39|      0|  }
   40|      0|  public var isMatched: Bool {
   41|      0|    return matchedView != nil
   42|      0|  }
   43|      0|  public var isAncestorViewMatched: Bool {
   44|      0|    return matchedAncestorView != nil
   45|      0|  }
   46|       |
   47|       |  public var matchedView: UIView? {
   48|       |    return hero.context.pairedView(for: view)
   49|       |  }
   50|       |  public var matchedAncestorView: (UIView, UIView)? {
   51|       |    var current = view.superview
   52|       |    while let ancestor = current, ancestor != hero.context.container {
   53|       |      if let pairedView = hero.context.pairedView(for: ancestor) {
   54|       |        return (ancestor, pairedView)
   55|       |      }
   56|       |      current = ancestor.superview
   57|       |    }
   58|       |    return nil
   59|       |  }
   60|       |
   61|      0|  public var fromViewController: UIViewController {
   62|      0|    return hero.fromViewController!
   63|      0|  }
   64|      0|  public var toViewController: UIViewController {
   65|      0|    return hero.toViewController!
   66|      0|  }
   67|      0|  public var currentViewController: UIViewController {
   68|      0|    return isAppearing ? toViewController : fromViewController
   69|      0|  }
   70|      0|  public var otherViewController: UIViewController {
   71|      0|    return isAppearing ? fromViewController : toViewController
   72|      0|  }
   73|       |}
   74|       |
   75|       |class ConditionalPreprocessor: BasePreprocessor {
   76|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
   77|      0|    process(views: fromViews, appearing: false)
   78|      0|    process(views: toViews, appearing: true)
   79|      0|  }
   80|       |
   81|      0|  func process(views: [UIView], appearing: Bool) {
   82|      0|    for view in views {
   83|      0|      guard let conditionalModifiers = context[view]?.conditionalModifiers else { continue }
   84|      0|      for (condition, modifiers) in conditionalModifiers {
   85|      0|        if condition(HeroConditionalContext(hero: hero, view: view, isAppearing: appearing)) {
   86|      0|          context[view]!.append(contentsOf: modifiers)
   87|      0|        }
   88|      0|      }
   89|      0|    }
   90|      0|  }
   91|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/DefaultAnimationPreprocessor.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |public enum HeroDefaultAnimationType {
   26|       |  public enum Direction: HeroStringConvertible {
   27|       |    case left, right, up, down
   28|      0|    public static func from(node: ExprNode) -> Direction? {
   29|      0|      switch node.name {
   30|      0|      case "left": return .left
   31|      0|      case "right": return .right
   32|      0|      case "up": return .up
   33|      0|      case "down": return .down
   34|      0|      default: return nil
   35|      0|      }
   36|      0|    }
   37|       |  }
   38|       |  case auto
   39|       |  case push(direction: Direction)
   40|       |  case pull(direction: Direction)
   41|       |  case cover(direction: Direction)
   42|       |  case uncover(direction: Direction)
   43|       |  case slide(direction: Direction)
   44|       |  case zoomSlide(direction: Direction)
   45|       |  case pageIn(direction: Direction)
   46|       |  case pageOut(direction: Direction)
   47|       |  case fade
   48|       |  case zoom
   49|       |  case zoomOut
   50|       |
   51|       |  indirect case selectBy(presenting: HeroDefaultAnimationType, dismissing: HeroDefaultAnimationType)
   52|       |
   53|      0|  public static func autoReverse(presenting: HeroDefaultAnimationType) -> HeroDefaultAnimationType {
   54|      0|    return .selectBy(presenting: presenting, dismissing: presenting.reversed())
   55|      0|  }
   56|       |
   57|       |  case none
   58|       |
   59|       |  func reversed() -> HeroDefaultAnimationType {
   60|       |    switch self {
   61|       |    case .push(direction: .up):
   62|       |      return .pull(direction: .down)
   63|       |    case .push(direction: .right):
   64|       |      return .pull(direction: .left)
   65|       |    case .push(direction: .down):
   66|       |      return .pull(direction: .up)
   67|       |    case .push(direction: .left):
   68|       |      return .pull(direction: .right)
   69|       |    case .pull(direction: .up):
   70|       |      return .push(direction: .down)
   71|       |    case .pull(direction: .right):
   72|       |      return .push(direction: .left)
   73|       |    case .pull(direction: .down):
   74|       |      return .push(direction: .up)
   75|       |    case .pull(direction: .left):
   76|       |      return .push(direction: .right)
   77|       |    case .cover(direction: .up):
   78|       |      return .uncover(direction: .down)
   79|       |    case .cover(direction: .right):
   80|       |      return .uncover(direction: .left)
   81|       |    case .cover(direction: .down):
   82|       |      return .uncover(direction: .up)
   83|       |    case .cover(direction: .left):
   84|       |      return .uncover(direction: .right)
   85|       |    case .uncover(direction: .up):
   86|       |      return .cover(direction: .down)
   87|       |    case .uncover(direction: .right):
   88|       |      return .cover(direction: .left)
   89|       |    case .uncover(direction: .down):
   90|       |      return .cover(direction: .up)
   91|       |    case .uncover(direction: .left):
   92|       |      return .cover(direction: .right)
   93|       |    case .slide(direction: .up):
   94|       |      return .slide(direction: .down)
   95|       |    case .slide(direction: .down):
   96|       |      return .slide(direction: .up)
   97|       |    case .slide(direction: .left):
   98|       |      return .slide(direction: .right)
   99|       |    case .slide(direction: .right):
  100|       |      return .slide(direction: .left)
  101|       |    case .zoomSlide(direction: .up):
  102|       |      return .zoomSlide(direction: .down)
  103|       |    case .zoomSlide(direction: .down):
  104|       |      return .zoomSlide(direction: .up)
  105|       |    case .zoomSlide(direction: .left):
  106|       |      return .zoomSlide(direction: .right)
  107|       |    case .zoomSlide(direction: .right):
  108|       |      return .zoomSlide(direction: .left)
  109|       |    case .pageIn(direction: .up):
  110|       |      return .pageOut(direction: .down)
  111|       |    case .pageIn(direction: .right):
  112|       |      return .pageOut(direction: .left)
  113|       |    case .pageIn(direction: .down):
  114|       |      return .pageOut(direction: .up)
  115|       |    case .pageIn(direction: .left):
  116|       |      return .pageOut(direction: .right)
  117|       |    case .pageOut(direction: .up):
  118|       |      return .pageIn(direction: .down)
  119|       |    case .pageOut(direction: .right):
  120|       |      return .pageIn(direction: .left)
  121|       |    case .pageOut(direction: .down):
  122|       |      return .pageIn(direction: .up)
  123|       |    case .pageOut(direction: .left):
  124|       |      return .pageIn(direction: .right)
  125|       |    case .zoom:
  126|       |      return .zoomOut
  127|       |    case .zoomOut:
  128|       |      return .zoom
  129|       |
  130|       |    default:
  131|       |      return self
  132|       |    }
  133|       |  }
  134|       |
  135|      0|  public var label: String? {
  136|      0|    let mirror = Mirror(reflecting: self)
  137|      0|    if let associated = mirror.children.first {
  138|      0|      let valuesMirror = Mirror(reflecting: associated.value)
  139|      0|      if !valuesMirror.children.isEmpty {
  140|      0|        let parameters = valuesMirror.children.map { ".\($0.value)" }.joined(separator: ",")
  141|      0|        return ".\(associated.label ?? "")(\(parameters))"
  142|      0|      }
  143|      0|      return ".\(associated.label ?? "")(.\(associated.value))"
  144|      0|    }
  145|      0|    return ".\(self)"
  146|      0|  }
  147|       |}
  148|       |
  149|       |extension HeroDefaultAnimationType: HeroStringConvertible {
  150|      0|  public static func from(node: ExprNode) -> HeroDefaultAnimationType? {
  151|      0|    let name: String = node.name
  152|      0|    let parameters: [ExprNode] = (node as? CallNode)?.arguments ?? []
  153|      0|
  154|      0|    switch name {
  155|      0|    case "auto":
  156|      0|      return .auto
  157|      0|    case "push":
  158|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  159|      0|        return .push(direction: direction)
  160|      0|      }
  161|      0|    case "pull":
  162|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  163|      0|        return .pull(direction: direction)
  164|      0|      }
  165|      0|    case "cover":
  166|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  167|      0|        return .cover(direction: direction)
  168|      0|      }
  169|      0|    case "uncover":
  170|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  171|      0|        return .uncover(direction: direction)
  172|      0|      }
  173|      0|    case "slide":
  174|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  175|      0|        return .slide(direction: direction)
  176|      0|      }
  177|      0|    case "zoomSlide":
  178|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  179|      0|        return .zoomSlide(direction: direction)
  180|      0|      }
  181|      0|    case "pageIn":
  182|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  183|      0|        return .pageIn(direction: direction)
  184|      0|      }
  185|      0|    case "pageOut":
  186|      0|      if let node = parameters.get(0), let direction = Direction.from(node: node) {
  187|      0|        return .pageOut(direction: direction)
  188|      0|      }
  189|      0|    case "fade": return .fade
  190|      0|    case "zoom": return .zoom
  191|      0|    case "zoomOut": return .zoomOut
  192|      0|    case "selectBy":
  193|      0|      if let presentingNode = parameters.get(0),
  194|      0|        let presenting = HeroDefaultAnimationType.from(node: presentingNode),
  195|      0|        let dismissingNode = parameters.get(1),
  196|      0|        let dismissing = HeroDefaultAnimationType.from(node: dismissingNode) {
  197|      0|        return .selectBy(presenting: presenting, dismissing: dismissing)
  198|      0|      }
  199|      0|    case "none": return HeroDefaultAnimationType.none
  200|      0|    default: break
  201|      0|    }
  202|      0|    return nil
  203|      0|  }
  204|       |}
  205|       |
  206|       |class DefaultAnimationPreprocessor: BasePreprocessor {
  207|      0|  func shift(direction: HeroDefaultAnimationType.Direction, appearing: Bool, size: CGSize? = nil, transpose: Bool = false) -> CGPoint {
  208|      0|    let size = size ?? context.container.bounds.size
  209|      0|    let rtn: CGPoint
  210|      0|    switch direction {
  211|      0|    case .left, .right:
  212|      0|      rtn = CGPoint(x: (direction == .right) == appearing ? -size.width : size.width, y: 0)
  213|      0|    case .up, .down:
  214|      0|      rtn = CGPoint(x: 0, y: (direction == .down) == appearing ? -size.height : size.height)
  215|      0|    }
  216|      0|    if transpose {
  217|      0|      return CGPoint(x: rtn.y, y: rtn.x)
  218|      0|    }
  219|      0|    return rtn
  220|      0|  }
  221|       |
  222|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
  223|      0|    guard let hero = hero, let toView = hero.toView, let fromView = hero.fromView else { return }
  224|      0|    var defaultAnimation = hero.defaultAnimation
  225|      0|    let inNavigationController = hero.inNavigationController
  226|      0|    let inTabBarController = hero.inTabBarController
  227|      0|    let toViewController = hero.toViewController
  228|      0|    let fromViewController = hero.fromViewController
  229|      0|    let presenting = hero.isPresenting
  230|      0|    let fromOverFullScreen = hero.fromOverFullScreen
  231|      0|    let toOverFullScreen = hero.toOverFullScreen
  232|      0|    let animators = hero.animators
  233|      0|
  234|      0|    if case .auto = defaultAnimation {
  235|      0|      if inNavigationController, let navAnim = toViewController?.navigationController?.hero.navigationAnimationType {
  236|      0|        defaultAnimation = navAnim
  237|      0|      } else if inTabBarController, let tabAnim = toViewController?.tabBarController?.hero.tabBarAnimationType {
  238|      0|        defaultAnimation = tabAnim
  239|      0|      } else if let modalAnim = (presenting ? toViewController : fromViewController)?.hero.modalAnimationType {
  240|      0|        defaultAnimation = modalAnim
  241|      0|      }
  242|      0|    }
  243|      0|
  244|      0|    if case .selectBy(let presentAnim, let dismissAnim) = defaultAnimation {
  245|      0|      defaultAnimation = presenting ? presentAnim : dismissAnim
  246|      0|    }
  247|      0|
  248|      0|    if case .auto = defaultAnimation {
  249|      0|      if animators.contains(where: { $0.canAnimate(view: toView, appearing: true) || $0.canAnimate(view: fromView, appearing: false) }) {
  250|      0|        defaultAnimation = .none
  251|      0|      } else if inNavigationController {
  252|      0|        defaultAnimation = presenting ? .push(direction:.left) : .pull(direction:.right)
  253|      0|      } else if inTabBarController {
  254|      0|        defaultAnimation = presenting ? .slide(direction:.left) : .slide(direction:.right)
  255|      0|      } else {
  256|      0|        defaultAnimation = .fade
  257|      0|      }
  258|      0|    }
  259|      0|
  260|      0|    if case .none = defaultAnimation {
  261|      0|      return
  262|      0|    }
  263|      0|
  264|      0|    context[fromView] = [.timingFunction(.standard), .duration(0.35)]
  265|      0|    context[toView] = [.timingFunction(.standard), .duration(0.35)]
  266|      0|
  267|      0|    let shadowState: [HeroModifier] = [.shadowOpacity(0.5),
  268|      0|                                       .shadowColor(.black),
  269|      0|                                       .shadowRadius(5),
  270|      0|                                       .shadowOffset(.zero),
  271|      0|                                       .masksToBounds(false)]
  272|      0|    switch defaultAnimation {
  273|      0|    case .push(let direction):
  274|      0|      context.insertToViewFirst = false
  275|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true)),
  276|      0|                                           .shadowOpacity(0),
  277|      0|                                           .beginWith(modifiers: shadowState),
  278|      0|                                           .timingFunction(.deceleration)])
  279|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false) / 3),
  280|      0|                                             .overlay(color: .black, opacity: 0.1),
  281|      0|                                             .timingFunction(.deceleration)])
  282|      0|    case .pull(let direction):
  283|      0|      context.insertToViewFirst = true
  284|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false)),
  285|      0|                                             .shadowOpacity(0),
  286|      0|                                             .beginWith(modifiers: shadowState)])
  287|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true) / 3),
  288|      0|                                           .overlay(color: .black, opacity: 0.1)])
  289|      0|    case .slide(let direction):
  290|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false))])
  291|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true))])
  292|      0|    case .zoomSlide(let direction):
  293|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false)), .scale(0.8)])
  294|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true)), .scale(0.8)])
  295|      0|    case .cover(let direction):
  296|      0|      context.insertToViewFirst = false
  297|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true)),
  298|      0|                                           .shadowOpacity(0),
  299|      0|                                           .beginWith(modifiers: shadowState),
  300|      0|                                           .timingFunction(.deceleration)])
  301|      0|      context[fromView]!.append(contentsOf: [.overlay(color: .black, opacity: 0.1),
  302|      0|                                             .timingFunction(.deceleration)])
  303|      0|    case .uncover(let direction):
  304|      0|      context.insertToViewFirst = true
  305|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false)),
  306|      0|                                             .shadowOpacity(0),
  307|      0|                                             .beginWith(modifiers: shadowState)])
  308|      0|      context[toView]!.append(contentsOf: [.overlay(color: .black, opacity: 0.1)])
  309|      0|    case .pageIn(let direction):
  310|      0|      context.insertToViewFirst = false
  311|      0|      context[toView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: true)),
  312|      0|                                           .shadowOpacity(0),
  313|      0|                                           .beginWith(modifiers: shadowState),
  314|      0|                                           .timingFunction(.deceleration)])
  315|      0|      context[fromView]!.append(contentsOf: [.scale(0.7),
  316|      0|                                             .overlay(color: .black, opacity: 0.1),
  317|      0|                                             .timingFunction(.deceleration)])
  318|      0|    case .pageOut(let direction):
  319|      0|      context.insertToViewFirst = true
  320|      0|      context[fromView]!.append(contentsOf: [.translate(shift(direction: direction, appearing: false)),
  321|      0|                                             .shadowOpacity(0),
  322|      0|                                             .beginWith(modifiers: shadowState)])
  323|      0|      context[toView]!.append(contentsOf: [.scale(0.7),
  324|      0|                                           .overlay(color: .black, opacity: 0.1)])
  325|      0|    case .fade:
  326|      0|      // TODO: clean up this. overFullScreen logic shouldn't be here
  327|      0|      if !(fromOverFullScreen && !presenting) {
  328|      0|        context[toView] = [.fade]
  329|      0|      }
  330|      0|
  331|      0|      #if os(tvOS)
  332|      0|        context[fromView] = [.fade]
  333|      0|      #else
  334|      0|        if (!presenting && toOverFullScreen) || !fromView.isOpaque || (fromView.backgroundColor?.alphaComponent ?? 1) < 1 {
  335|      0|          context[fromView] = [.fade]
  336|      0|        }
  337|      0|      #endif
  338|      0|
  339|      0|      context[toView]!.append(.durationMatchLongest)
  340|      0|      context[fromView]!.append(.durationMatchLongest)
  341|      0|    case .zoom:
  342|      0|      context.insertToViewFirst = true
  343|      0|      context[fromView]!.append(contentsOf: [.scale(1.3), .fade])
  344|      0|      context[toView]!.append(contentsOf: [.scale(0.7)])
  345|      0|    case .zoomOut:
  346|      0|      context.insertToViewFirst = false
  347|      0|      context[toView]!.append(contentsOf: [.scale(1.3), .fade])
  348|      0|      context[fromView]!.append(contentsOf: [.scale(0.7)])
  349|      0|    default:
  350|      0|      fatalError("Not implemented")
  351|      0|    }
  352|      0|  }
  353|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/IgnoreSubviewModifiersPreprocessor.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |class IgnoreSubviewModifiersPreprocessor: BasePreprocessor {
   26|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
   27|      0|    process(views: fromViews)
   28|      0|    process(views: toViews)
   29|      0|  }
   30|       |
   31|      0|  func process(views: [UIView]) {
   32|      0|    for view in views {
   33|      0|      guard let recursive = context[view]?.ignoreSubviewModifiers else { continue }
   34|      0|      var parentView = view
   35|      0|      if view is UITableView, let wrapperView = view.subviews.get(0) {
   36|      0|        parentView = wrapperView
   37|      0|      }
   38|      0|
   39|      0|      if recursive {
   40|      0|        cleanSubviewModifiers(parentView)
   41|      0|      } else {
   42|      0|        for subview in parentView.subviews {
   43|      0|          context[subview] = nil
   44|      0|        }
   45|      0|      }
   46|      0|    }
   47|      0|  }
   48|       |
   49|      0|  private func cleanSubviewModifiers(_ parentView: UIView) {
   50|      0|    for view in parentView.subviews {
   51|      0|      context[view] = nil
   52|      0|      cleanSubviewModifiers(view)
   53|      0|    }
   54|      0|  }
   55|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/MatchPreprocessor.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |class MatchPreprocessor: BasePreprocessor {
   26|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
   27|      0|    for tv in toViews {
   28|      0|      guard let id = tv.hero.id, let fv = context.sourceView(for: id) else { continue }
   29|      0|
   30|      0|      var tvState = context[tv] ?? HeroTargetState()
   31|      0|      var fvState = context[fv] ?? HeroTargetState()
   32|      0|
   33|      0|      // match is just a two-way source effect
   34|      0|      tvState.source = id
   35|      0|      fvState.source = id
   36|      0|
   37|      0|      fvState.arc = tvState.arc
   38|      0|      fvState.duration = tvState.duration
   39|      0|      fvState.timingFunction = tvState.timingFunction
   40|      0|      fvState.delay = tvState.delay
   41|      0|      fvState.spring = tvState.spring
   42|      0|
   43|      0|      let forceNonFade = tvState.nonFade || fvState.nonFade
   44|      0|      let isNonOpaque = !fv.isOpaque || fv.alpha < 1 || !tv.isOpaque || tv.alpha < 1
   45|      0|
   46|      0|      if context.insertToViewFirst {
   47|      0|        fvState.opacity = 0
   48|      0|        if !forceNonFade && isNonOpaque {
   49|      0|          tvState.opacity = 0
   50|      0|        } else {
   51|      0|          tvState.opacity = nil
   52|      0|          if !tv.layer.masksToBounds && tvState.displayShadow {
   53|      0|            fvState.displayShadow = false
   54|      0|          }
   55|      0|        }
   56|      0|      } else {
   57|      0|        tvState.opacity = 0
   58|      0|        if !forceNonFade && isNonOpaque {
   59|      0|          // cross fade if from/toViews are not opaque
   60|      0|          fvState.opacity = 0
   61|      0|        } else {
   62|      0|          // no cross fade in this case, fromView is always displayed during the transition.
   63|      0|          fvState.opacity = nil
   64|      0|
   65|      0|          // we dont want two shadows showing up. Therefore we disable toView's shadow when fromView is able to display its shadow
   66|      0|          if !fv.layer.masksToBounds && fvState.displayShadow {
   67|      0|            tvState.displayShadow = false
   68|      0|          }
   69|      0|        }
   70|      0|      }
   71|      0|
   72|      0|      context[tv] = tvState
   73|      0|      context[fv] = fvState
   74|      0|    }
   75|      0|  }
   76|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Preprocessors/SourcePreprocessor.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |class SourcePreprocessor: BasePreprocessor {
   26|      0|  override func process(fromViews: [UIView], toViews: [UIView]) {
   27|      0|    for fv in fromViews {
   28|      0|      guard let id = context[fv]?.source,
   29|      0|            let tv = context.destinationView(for: id) else { continue }
   30|      0|      prepareFor(view: fv, targetView: tv)
   31|      0|    }
   32|      0|    for tv in toViews {
   33|      0|      guard let id = context[tv]?.source,
   34|      0|            let fv = context.sourceView(for: id) else { continue }
   35|      0|      prepareFor(view: tv, targetView: fv)
   36|      0|    }
   37|      0|  }
   38|       |
   39|      0|  func prepareFor(view: UIView, targetView: UIView) {
   40|      0|    let targetPos = context.container.convert(targetView.layer.position, from: targetView.superview!)
   41|      0|    let targetTransform = context.container.layer.flatTransformTo(layer: targetView.layer)
   42|      0|
   43|      0|    var state = context[view]!
   44|      0|
   45|      0|    // use global coordinate space since over target position is converted from the global container
   46|      0|    state.coordinateSpace = .global
   47|      0|
   48|      0|    state.position = targetPos
   49|      0|    state.transform = targetTransform
   50|      0|
   51|      0|    // remove incompatible options
   52|      0|    state.size = nil
   53|      0|
   54|      0|    if view.bounds.size != targetView.bounds.size {
   55|      0|      state.size = targetView.bounds.size
   56|      0|    }
   57|      0|    if state.cornerRadius == nil, view.layer.cornerRadius != targetView.layer.cornerRadius {
   58|      0|      state.cornerRadius = targetView.layer.cornerRadius
   59|      0|    }
   60|      0|    if view.layer.shadowColor != targetView.layer.shadowColor {
   61|      0|      state.shadowColor = targetView.layer.shadowColor
   62|      0|    }
   63|      0|    if view.layer.shadowOpacity != targetView.layer.shadowOpacity {
   64|      0|      state.shadowOpacity = targetView.layer.shadowOpacity
   65|      0|    }
   66|      0|    if view.layer.shadowOffset != targetView.layer.shadowOffset {
   67|      0|      state.shadowOffset = targetView.layer.shadowOffset
   68|      0|    }
   69|      0|    if view.layer.shadowRadius != targetView.layer.shadowRadius {
   70|      0|      state.shadowRadius = targetView.layer.shadowRadius
   71|      0|    }
   72|      0|    if view.layer.shadowPath != targetView.layer.shadowPath {
   73|      0|      state.shadowPath = targetView.layer.shadowPath
   74|      0|    }
   75|      0|    if view.layer.contentsRect != targetView.layer.contentsRect {
   76|      0|      state.contentsRect = targetView.layer.contentsRect
   77|      0|    }
   78|      0|    if view.layer.contentsScale != targetView.layer.contentsScale {
   79|      0|      state.contentsScale = targetView.layer.contentsScale
   80|      0|    }
   81|      0|
   82|      0|    context[view] = state
   83|      0|  }
   84|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroProgressRunner.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |protocol HeroProgressRunnerDelegate: class {
   26|       |  func updateProgress(progress: Double)
   27|       |  func complete(finished: Bool)
   28|       |}
   29|       |
   30|       |class HeroProgressRunner {
   31|       |  weak var delegate: HeroProgressRunnerDelegate?
   32|       |
   33|      0|  var isRunning: Bool {
   34|      0|    return displayLink != nil
   35|      0|  }
   36|       |  internal var timePassed: TimeInterval = 0.0
   37|       |  internal var duration: TimeInterval = 0.0
   38|       |  internal var displayLink: CADisplayLink?
   39|       |  internal var isReversed: Bool = false
   40|       |
   41|      0|  @objc func displayUpdate(_ link: CADisplayLink) {
   42|      0|    timePassed += isReversed ? -link.duration : link.duration
   43|      0|    if isReversed, timePassed <= 1.0 / 120 {
   44|      0|      delegate?.complete(finished: false)
   45|      0|      stop()
   46|      0|      return
   47|      0|    }
   48|      0|
   49|      0|    if !isReversed, timePassed > duration - 1.0 / 120 {
   50|      0|      delegate?.complete(finished: true)
   51|      0|      stop()
   52|      0|      return
   53|      0|    }
   54|      0|
   55|      0|    delegate?.updateProgress(progress: timePassed / duration)
   56|      0|  }
   57|       |
   58|      0|  func start(timePassed: TimeInterval, totalTime: TimeInterval, reverse: Bool) {
   59|      0|    stop()
   60|      0|    self.timePassed = timePassed
   61|      0|    self.isReversed = reverse
   62|      0|    self.duration = totalTime
   63|      0|    displayLink = CADisplayLink(target: self, selector: #selector(displayUpdate(_:)))
   64|      0|    displayLink!.add(to: .main, forMode: RunLoop.Mode.common)
   65|      0|  }
   66|       |
   67|      0|  func stop() {
   68|      0|    displayLink?.isPaused = true
   69|      0|    displayLink?.remove(from: RunLoop.main, forMode: RunLoop.Mode.common)
   70|      0|    displayLink = nil
   71|      0|  }
   72|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+Animate.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import Foundation
   24|       |
   25|       |extension HeroTransition {
   26|      0|  open func animate() {
   27|      0|    guard state == .starting else { return }
   28|      0|    state = .animating
   29|      0|
   30|      0|    if let toView = toView {
   31|      0|      context.unhide(view: toView)
   32|      0|    }
   33|      0|
   34|      0|    // auto hide all animated views
   35|      0|    for view in animatingFromViews {
   36|      0|      context.hide(view: view)
   37|      0|    }
   38|      0|    for view in animatingToViews {
   39|      0|      context.hide(view: view)
   40|      0|    }
   41|      0|
   42|      0|    var totalDuration: TimeInterval = 0
   43|      0|    var animatorWantsInteractive = false
   44|      0|
   45|      0|    if context.insertToViewFirst {
   46|      0|      for v in animatingToViews { _ = context.snapshotView(for: v) }
   47|      0|      for v in animatingFromViews { _ = context.snapshotView(for: v) }
   48|      0|    } else {
   49|      0|      for v in animatingFromViews { _ = context.snapshotView(for: v) }
   50|      0|      for v in animatingToViews { _ = context.snapshotView(for: v) }
   51|      0|    }
   52|      0|
   53|      0|    // UIKit appears to set fromView setNeedLayout to be true.
   54|      0|    // We don't want fromView to layout after our animation starts.
   55|      0|    // Therefore we kick off the layout beforehand
   56|      0|    fromView?.layoutIfNeeded()
   57|      0|
   58|      0|    for animator in animators {
   59|      0|      let duration = animator.animate(fromViews: animatingFromViews.filter({ animator.canAnimate(view: $0, appearing: false) }),
   60|      0|                                      toViews: animatingToViews.filter({ animator.canAnimate(view: $0, appearing: true) }))
   61|      0|      if duration == .infinity {
   62|      0|        animatorWantsInteractive = true
   63|      0|      } else {
   64|      0|        totalDuration = max(totalDuration, duration)
   65|      0|      }
   66|      0|    }
   67|      0|
   68|      0|    self.totalDuration = totalDuration
   69|      0|    if let forceFinishing = forceFinishing {
   70|      0|      complete(finished: forceFinishing)
   71|      0|    } else if let startingProgress = startingProgress {
   72|      0|      update(startingProgress)
   73|      0|    } else if animatorWantsInteractive {
   74|      0|      update(0)
   75|      0|    } else {
   76|      0|      complete(after: totalDuration, finishing: true)
   77|      0|    }
   78|      0|
   79|      0|    fullScreenSnapshot?.removeFromSuperview()
   80|      0|  }
   81|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+Complete.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition {
   26|      0|  open func complete(finished: Bool) {
   27|      0|    if state == .notified {
   28|      0|      forceFinishing = finished
   29|      0|    }
   30|      0|    guard state == .animating || state == .starting else { return }
   31|      0|    defer {
   32|      0|      transitionContext = nil
   33|      0|      fromViewController = nil
   34|      0|      toViewController = nil
   35|      0|      inNavigationController = false
   36|      0|      inTabBarController = false
   37|      0|      forceNotInteractive = false
   38|      0|      animatingToViews.removeAll()
   39|      0|      animatingFromViews.removeAll()
   40|      0|      progressUpdateObservers = nil
   41|      0|      transitionContainer = nil
   42|      0|      completionCallback = nil
   43|      0|      forceFinishing = nil
   44|      0|      container = nil
   45|      0|      startingProgress = nil
   46|      0|      processors.removeAll()
   47|      0|      animators.removeAll()
   48|      0|      plugins.removeAll()
   49|      0|      context = nil
   50|      0|      progress = 0
   51|      0|      totalDuration = 0
   52|      0|      state = .possible
   53|      0|    }
   54|      0|    state = .completing
   55|      0|
   56|      0|    progressRunner.stop()
   57|      0|    context.clean()
   58|      0|
   59|      0|    if let toView = toView, let fromView = fromView {
   60|      0|      if finished && isPresenting && toOverFullScreen {
   61|      0|        // finished presenting a overFullScreen VC
   62|      0|        context.unhide(rootView: toView)
   63|      0|        context.removeSnapshots(rootView: toView)
   64|      0|        context.storeViewAlpha(rootView: fromView)
   65|      0|        fromViewController?.hero.storedSnapshot = container
   66|      0|        container.superview?.addSubview(fromView)
   67|      0|        fromView.addSubview(container)
   68|      0|      } else if !finished && !isPresenting && fromOverFullScreen {
   69|      0|        // cancelled dismissing a overFullScreen VC
   70|      0|        context.unhide(rootView: fromView)
   71|      0|        context.removeSnapshots(rootView: fromView)
   72|      0|        context.storeViewAlpha(rootView: toView)
   73|      0|        toViewController?.hero.storedSnapshot = container
   74|      0|        container.superview?.addSubview(toView)
   75|      0|        toView.addSubview(container)
   76|      0|      } else {
   77|      0|        context.unhideAll()
   78|      0|        context.removeAllSnapshots()
   79|      0|      }
   80|      0|
   81|      0|      // move fromView & toView back from our container back to the one supplied by UIKit
   82|      0|      if (toOverFullScreen && finished) || (fromOverFullScreen && !finished) {
   83|      0|        transitionContainer?.addSubview(finished ? fromView : toView)
   84|      0|      }
   85|      0|      transitionContainer?.addSubview(finished ? toView : fromView)
   86|      0|
   87|      0|      if isPresenting != finished, !inContainerController, transitionContext != nil {
   88|      0|        // only happens when present a .overFullScreen VC
   89|      0|        // bug: http://openradar.appspot.com/radar?id=5320103646199808
   90|      0|        UIApplication.shared.keyWindow?.addSubview(isPresenting ? fromView : toView)
   91|      0|      }
   92|      0|    }
   93|      0|
   94|      0|    if container.superview == transitionContainer {
   95|      0|      container.removeFromSuperview()
   96|      0|    }
   97|      0|
   98|      0|    for animator in animators {
   99|      0|      animator.clean()
  100|      0|    }
  101|      0|
  102|      0|    transitionContainer?.isUserInteractionEnabled = true
  103|      0|
  104|      0|    completionCallback?(finished)
  105|      0|
  106|      0|    // https://github.com/lkzhao/Hero/issues/354
  107|      0|    // tabbar not responding after pushing a view controller with hideBottomBarWhenPushed
  108|      0|    // this is due to iOS adding a few extra animation to the tabbar but they are not removed when
  109|      0|    // the transition completes. Possibly another iOS bug. let me know if you have better work around.
  110|      0|    if finished {
  111|      0|      toViewController?.tabBarController?.tabBar.layer.removeAllAnimations()
  112|      0|    } else {
  113|      0|      fromViewController?.tabBarController?.tabBar.layer.removeAllAnimations()
  114|      0|    }
  115|      0|
  116|      0|    if finished {
  117|      0|      if let fvc = fromViewController, let tvc = toViewController {
  118|      0|        closureProcessForHeroDelegate(vc: fvc) {
  119|      0|          $0.heroDidEndAnimatingTo?(viewController: tvc)
  120|      0|          $0.heroDidEndTransition?()
  121|      0|        }
  122|      0|
  123|      0|        closureProcessForHeroDelegate(vc: tvc) {
  124|      0|          $0.heroDidEndAnimatingFrom?(viewController: fvc)
  125|      0|          $0.heroDidEndTransition?()
  126|      0|        }
  127|      0|      }
  128|      0|      transitionContext?.finishInteractiveTransition()
  129|      0|    } else {
  130|      0|      if let fvc = fromViewController, let tvc = toViewController {
  131|      0|        closureProcessForHeroDelegate(vc: fvc) {
  132|      0|          $0.heroDidCancelAnimatingTo?(viewController: tvc)
  133|      0|          $0.heroDidCancelTransition?()
  134|      0|        }
  135|      0|
  136|      0|        closureProcessForHeroDelegate(vc: tvc) {
  137|      0|          $0.heroDidCancelAnimatingFrom?(viewController: fvc)
  138|      0|          $0.heroDidCancelTransition?()
  139|      0|        }
  140|      0|      }
  141|      0|      transitionContext?.cancelInteractiveTransition()
  142|      0|    }
  143|      0|    transitionContext?.completeTransition(finished)
  144|      0|  }
  145|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+CustomTransition.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |// custom transition helper, used in hero_replaceViewController
   26|       |public extension HeroTransition {
   27|      0|  public func transition(from: UIViewController, to: UIViewController, in view: UIView, completion: ((Bool) -> Void)? = nil) {
   28|      0|    guard !isTransitioning else { return }
   29|      0|    self.state = .notified
   30|      0|    isPresenting = true
   31|      0|    transitionContainer = view
   32|      0|    fromViewController = from
   33|      0|    toViewController = to
   34|      0|    completionCallback = {
   35|      0|      completion?($0)
   36|      0|      self.state = .possible
   37|      0|    }
   38|      0|    start()
   39|      0|  }
   40|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+Interactive.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition {
   26|       |  /**
   27|       |   Update the progress for the interactive transition.
   28|       |   - Parameters:
   29|       |   - progress: the current progress, must be between 0...1
   30|       |   */
   31|      0|  public func update(_ percentageComplete: CGFloat) {
   32|      0|    guard state == .animating else {
   33|      0|      startingProgress = percentageComplete
   34|      0|      return
   35|      0|    }
   36|      0|    self.progressRunner.stop()
   37|      0|    self.progress = Double(percentageComplete.clamp(0, 1))
   38|      0|  }
   39|       |
   40|       |  /**
   41|       |   Finish the interactive transition.
   42|       |   Will stop the interactive transition and animate from the
   43|       |   current state to the **end** state
   44|       |   */
   45|      0|  public func finish(animate: Bool = true) {
   46|      0|    guard state == .animating || state == .notified || state == .starting else { return }
   47|      0|    if !animate {
   48|      0|      self.complete(finished: true)
   49|      0|      return
   50|      0|    }
   51|      0|    var maxTime: TimeInterval = 0
   52|      0|    for animator in self.animators {
   53|      0|      maxTime = max(maxTime, animator.resume(timePassed: self.progress * self.totalDuration,
   54|      0|                                             reverse: false))
   55|      0|    }
   56|      0|    self.complete(after: maxTime, finishing: true)
   57|      0|  }
   58|       |
   59|       |  /**
   60|       |   Cancel the interactive transition.
   61|       |   Will stop the interactive transition and animate from the
   62|       |   current state to the **beginning** state
   63|       |   */
   64|      0|  public func cancel(animate: Bool = true) {
   65|      0|    guard state == .animating || state == .notified || state == .starting else { return }
   66|      0|    if !animate {
   67|      0|      self.complete(finished: false)
   68|      0|      return
   69|      0|    }
   70|      0|    var maxTime: TimeInterval = 0
   71|      0|    for animator in self.animators {
   72|      0|      var adjustedProgress = self.progress
   73|      0|      if adjustedProgress < 0 {
   74|      0|        adjustedProgress = -adjustedProgress
   75|      0|      }
   76|      0|      maxTime = max(maxTime, animator.resume(timePassed: adjustedProgress * self.totalDuration,
   77|      0|                                             reverse: true))
   78|      0|    }
   79|      0|    self.complete(after: maxTime, finishing: false)
   80|      0|  }
   81|       |
   82|       |  /**
   83|       |   Override modifiers during an interactive animation.
   84|       |
   85|       |   For example:
   86|       |
   87|       |   Hero.shared.apply([.position(x:50, y:50)], to:view)
   88|       |
   89|       |   will set the view's position to 50, 50
   90|       |   - Parameters:
   91|       |   - modifiers: the modifiers to override
   92|       |   - view: the view to override to
   93|       |   */
   94|      0|  public func apply(modifiers: [HeroModifier], to view: UIView) {
   95|      0|    guard state == .animating else { return }
   96|      0|    let targetState = HeroTargetState(modifiers: modifiers)
   97|      0|    if let otherView = self.context.pairedView(for: view) {
   98|      0|      for animator in self.animators {
   99|      0|        animator.apply(state: targetState, to: otherView)
  100|      0|      }
  101|      0|    }
  102|      0|    for animator in self.animators {
  103|      0|      animator.apply(state: targetState, to: view)
  104|      0|    }
  105|      0|  }
  106|       |
  107|       |  /**
  108|       |   Override target state during an interactive animation.
  109|       |
  110|       |   For example:
  111|       |
  112|       |   Hero.shared.changeTarget([.position(x:50, y:50)], to:view)
  113|       |
  114|       |   will animate the view's position to 50, 50 once `finish(animate:)` is called
  115|       |   - Parameters:
  116|       |   - modifiers: the modifiers to override
  117|       |   - isDestination: if false, it changes the starting state
  118|       |   - view: the view to override to
  119|       |   */
  120|      0|  public func changeTarget(modifiers: [HeroModifier], isDestination: Bool = true, to view: UIView) {
  121|      0|    guard state == .animating else { return }
  122|      0|    let targetState = HeroTargetState(modifiers: modifiers)
  123|      0|    if let otherView = self.context.pairedView(for: view) {
  124|      0|      for animator in self.animators {
  125|      0|        animator.changeTarget(state: targetState, isDestination: !isDestination, to: otherView)
  126|      0|      }
  127|      0|    }
  128|      0|    for animator in self.animators {
  129|      0|      animator.changeTarget(state: targetState, isDestination: isDestination, to: view)
  130|      0|    }
  131|      0|  }
  132|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+Start.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition {
   26|      0|  open func start() {
   27|      0|    guard state == .notified else { return }
   28|      0|    state = .starting
   29|      0|
   30|      0|    if let toView = toView, let fromView = fromView {
   31|      0|      if let toViewController = toViewController, let transitionContext = transitionContext {
   32|      0|        toView.frame = transitionContext.finalFrame(for: toViewController)
   33|      0|      } else {
   34|      0|        toView.frame = fromView.frame
   35|      0|      }
   36|      0|      toView.setNeedsLayout()
   37|      0|      toView.layoutIfNeeded()
   38|      0|    }
   39|      0|
   40|      0|    if let fvc = fromViewController, let tvc = toViewController {
   41|      0|      closureProcessForHeroDelegate(vc: fvc) {
   42|      0|        $0.heroWillStartTransition?()
   43|      0|        $0.heroWillStartAnimatingTo?(viewController: tvc)
   44|      0|      }
   45|      0|
   46|      0|      closureProcessForHeroDelegate(vc: tvc) {
   47|      0|        $0.heroWillStartTransition?()
   48|      0|        $0.heroWillStartAnimatingFrom?(viewController: fvc)
   49|      0|      }
   50|      0|    }
   51|      0|
   52|      0|    // take a snapshot to hide all the flashing that might happen
   53|      0|    fullScreenSnapshot = transitionContainer?.window?.snapshotView(afterScreenUpdates: false) ?? fromView?.snapshotView(afterScreenUpdates: false)
   54|      0|    if let fullScreenSnapshot = fullScreenSnapshot {
   55|      0|      (transitionContainer?.window ?? transitionContainer)?.addSubview(fullScreenSnapshot)
   56|      0|    }
   57|      0|
   58|      0|    if let oldSnapshot = fromViewController?.hero.storedSnapshot {
   59|      0|      oldSnapshot.removeFromSuperview()
   60|      0|      fromViewController?.hero.storedSnapshot = nil
   61|      0|    }
   62|      0|    if let oldSnapshot = toViewController?.hero.storedSnapshot {
   63|      0|      oldSnapshot.removeFromSuperview()
   64|      0|      toViewController?.hero.storedSnapshot = nil
   65|      0|    }
   66|      0|
   67|      0|    plugins = HeroTransition.enabledPlugins.map({ return $0.init() })
   68|      0|    processors = [
   69|      0|      IgnoreSubviewModifiersPreprocessor(),
   70|      0|      ConditionalPreprocessor(),
   71|      0|      DefaultAnimationPreprocessor(),
   72|      0|      MatchPreprocessor(),
   73|      0|      SourcePreprocessor(),
   74|      0|      CascadePreprocessor()
   75|      0|    ]
   76|      0|    animators = [
   77|      0|      HeroDefaultAnimator<HeroCoreAnimationViewContext>()
   78|      0|    ]
   79|      0|
   80|      0|    if #available(iOS 10, tvOS 10, *) {
   81|      0|      animators.append(HeroDefaultAnimator<HeroViewPropertyViewContext>())
   82|      0|    }
   83|      0|
   84|      0|    // There is no covariant in Swift, so we need to add plugins one by one.
   85|      0|    for plugin in plugins {
   86|      0|      processors.append(plugin)
   87|      0|      animators.append(plugin)
   88|      0|    }
   89|      0|
   90|      0|    transitionContainer?.isUserInteractionEnabled = isUserInteractionEnabled
   91|      0|
   92|      0|    // a view to hold all the animating views
   93|      0|    container = UIView(frame: transitionContainer?.bounds ?? .zero)
   94|      0|    if !toOverFullScreen && !fromOverFullScreen {
   95|      0|      container.backgroundColor = containerColor
   96|      0|    }
   97|      0|    transitionContainer?.addSubview(container)
   98|      0|
   99|      0|    context = HeroContext(container: container)
  100|      0|
  101|      0|    for processor in processors {
  102|      0|      processor.hero = self
  103|      0|    }
  104|      0|    for animator in animators {
  105|      0|      animator.hero = self
  106|      0|    }
  107|      0|
  108|      0|    if let toView = toView, let fromView = fromView {
  109|      0|      context.loadViewAlpha(rootView: toView)
  110|      0|      context.loadViewAlpha(rootView: fromView)
  111|      0|      container.addSubview(toView)
  112|      0|      container.addSubview(fromView)
  113|      0|
  114|      0|      toView.updateConstraints()
  115|      0|      toView.setNeedsLayout()
  116|      0|      toView.layoutIfNeeded()
  117|      0|
  118|      0|      context.set(fromViews: fromView.flattenedViewHierarchy, toViews: toView.flattenedViewHierarchy)
  119|      0|    }
  120|      0|
  121|      0|    if (viewOrderingStrategy == .auto && !isPresenting && !inTabBarController) ||
  122|      0|       viewOrderingStrategy == .sourceViewOnTop {
  123|      0|      context.insertToViewFirst = true
  124|      0|    }
  125|      0|
  126|      0|    for processor in processors {
  127|      0|      processor.process(fromViews: context.fromViews, toViews: context.toViews)
  128|      0|    }
  129|      0|    animatingFromViews = context.fromViews.filter { (view: UIView) -> Bool in
  130|      0|      for animator in animators {
  131|      0|        if animator.canAnimate(view: view, appearing: false) {
  132|      0|          return true
  133|      0|        }
  134|      0|      }
  135|      0|      return false
  136|      0|    }
  137|      0|    animatingToViews = context.toViews.filter { (view: UIView) -> Bool in
  138|      0|      for animator in animators {
  139|      0|        if animator.canAnimate(view: view, appearing: true) {
  140|      0|          return true
  141|      0|        }
  142|      0|      }
  143|      0|      return false
  144|      0|    }
  145|      0|
  146|      0|    if let toView = toView {
  147|      0|      context.hide(view: toView)
  148|      0|    }
  149|      0|
  150|      0|    #if os(tvOS)
  151|      0|      animate()
  152|      0|    #else
  153|      0|      if inNavigationController {
  154|      0|        // When animating within navigationController, we have to dispatch later into the main queue.
  155|      0|        // otherwise snapshots will be pure white. Possibly a bug with UIKit
  156|      0|        DispatchQueue.main.async {
  157|      0|          self.animate()
  158|      0|        }
  159|      0|      } else {
  160|      0|        animate()
  161|      0|      }
  162|      0|    #endif
  163|      0|  }
  164|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+UINavigationControllerDelegate.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition: UINavigationControllerDelegate {
   26|      0|  public func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
   27|      0|    if let previousNavigationDelegate = navigationController.previousNavigationDelegate {
   28|      0|      previousNavigationDelegate.navigationController?(navigationController, willShow: viewController, animated: animated)
   29|      0|    }
   30|      0|  }
   31|       |
   32|      0|  public func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
   33|      0|    if let previousNavigationDelegate = navigationController.previousNavigationDelegate {
   34|      0|      previousNavigationDelegate.navigationController?(navigationController, didShow: viewController, animated: animated)
   35|      0|    }
   36|      0|  }
   37|       |
   38|      0|  public func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
   39|      0|    guard !isTransitioning else { return nil }
   40|      0|    self.state = .notified
   41|      0|    self.isPresenting = operation == .push
   42|      0|    self.fromViewController = fromViewController ?? fromVC
   43|      0|    self.toViewController = toViewController ?? toVC
   44|      0|    self.inNavigationController = true
   45|      0|    return self
   46|      0|  }
   47|       |
   48|      0|  public func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
   49|      0|    return interactiveTransitioning
   50|      0|  }
   51|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+UITabBarControllerDelegate.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition: UITabBarControllerDelegate {
   26|      0|  public func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
   27|      0|    guard tabBarController.selectedViewController !== viewController else {
   28|      0|      return false
   29|      0|    }
   30|      0|    if isTransitioning {
   31|      0|      cancel(animate: false)
   32|      0|    }
   33|      0|    return true
   34|      0|  }
   35|       |
   36|      0|  public func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
   37|      0|    return interactiveTransitioning
   38|      0|  }
   39|       |
   40|      0|  public func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
   41|      0|    guard !isTransitioning else { return nil }
   42|      0|    self.state = .notified
   43|      0|    let fromVCIndex = tabBarController.children.index(of: fromVC)!
   44|      0|    let toVCIndex = tabBarController.children.index(of: toVC)!
   45|      0|    self.isPresenting = toVCIndex > fromVCIndex
   46|      0|    self.fromViewController = fromViewController ?? fromVC
   47|      0|    self.toViewController = toViewController ?? toVC
   48|      0|    self.inTabBarController = true
   49|      0|    return self
   50|      0|  }
   51|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition+UIViewControllerTransitioningDelegate.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |extension HeroTransition: UIViewControllerTransitioningDelegate {
   26|      0|  var interactiveTransitioning: UIViewControllerInteractiveTransitioning? {
   27|      0|    return forceNotInteractive ? nil : self
   28|      0|  }
   29|       |
   30|      0|  public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
   31|      0|    guard !isTransitioning else { return nil }
   32|      0|    self.state = .notified
   33|      0|    self.isPresenting = true
   34|      0|    self.fromViewController = fromViewController ?? presenting
   35|      0|    self.toViewController = toViewController ?? presented
   36|      0|    return self
   37|      0|  }
   38|       |
   39|      0|  public func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
   40|      0|    guard !isTransitioning else { return nil }
   41|      0|    self.state = .notified
   42|      0|    self.isPresenting = false
   43|      0|    self.fromViewController = fromViewController ?? dismissed
   44|      0|    return self
   45|      0|  }
   46|       |
   47|      0|  public func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
   48|      0|    return interactiveTransitioning
   49|      0|  }
   50|       |
   51|      0|  public func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
   52|      0|    return interactiveTransitioning
   53|      0|  }
   54|       |}
   55|       |
   56|       |extension HeroTransition: UIViewControllerAnimatedTransitioning {
   57|      0|  public func animateTransition(using context: UIViewControllerContextTransitioning) {
   58|      0|    transitionContext = context
   59|      0|    fromViewController = fromViewController ?? context.viewController(forKey: .from)
   60|      0|    toViewController = toViewController ?? context.viewController(forKey: .to)
   61|      0|    transitionContainer = context.containerView
   62|      0|    start()
   63|      0|  }
   64|      0|  public func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
   65|      0|    return 0.375 // doesn't matter, real duration will be calculated later
   66|      0|  }
   67|       |
   68|      0|  public func animationEnded(_ transitionCompleted: Bool) {
   69|      0|    self.state = .possible
   70|      0|  }
   71|       |}
   72|       |
   73|       |extension HeroTransition: UIViewControllerInteractiveTransitioning {
   74|       |  public var wantsInteractiveStart: Bool {
   75|       |    return true
   76|       |  }
   77|      0|  public func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) {
   78|      0|    animateTransition(using: transitionContext)
   79|      0|  }
   80|       |}

/Users/ahmedramy/Desktop/Workstation/Fullstack Projects/Legere/Legere-iOS/Pods/Hero/Sources/Transition/HeroTransition.swift:
    1|       |// The MIT License (MIT)
    2|       |//
    3|       |// Copyright (c) 2016 Luke Zhao <me@lkzhao.com>
    4|       |//
    5|       |// Permission is hereby granted, free of charge, to any person obtaining a copy
    6|       |// of this software and associated documentation files (the "Software"), to deal
    7|       |// in the Software without restriction, including without limitation the rights
    8|       |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9|       |// copies of the Software, and to permit persons to whom the Software is
   10|       |// furnished to do so, subject to the following conditions:
   11|       |//
   12|       |// The above copyright notice and this permission notice shall be included in
   13|       |// all copies or substantial portions of the Software.
   14|       |//
   15|       |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16|       |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17|       |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18|       |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19|       |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20|       |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   21|       |// THE SOFTWARE.
   22|       |
   23|       |import UIKit
   24|       |
   25|       |/**
   26|       | ### The singleton class/object for controlling interactive transitions.
   27|       |
   28|       | ```swift
   29|       | Hero.shared
   30|       | ```
   31|       |
   32|       | #### Use the following methods for controlling the interactive transition:
   33|       |
   34|       | ```swift
   35|       | func update(progress:Double)
   36|       | func end()
   37|       | func cancel()
   38|       | func apply(modifiers:[HeroModifier], to view:UIView)
   39|       | ```
   40|       | */
   41|       |public class Hero: NSObject {
   42|       |  /// Shared singleton object for controlling the transition
   43|       |  public static var shared = HeroTransition()
   44|       |}
   45|       |
   46|       |public protocol HeroTransitionDelegate: class {
   47|       |  func heroTransition(_ hero: HeroTransition, didUpdate state: HeroTransitionState)
   48|       |  func heroTransition(_ hero: HeroTransition, didUpdate progress: Double)
   49|       |}
   50|       |
   51|       |open class HeroTransition: NSObject {
   52|       |  public weak var delegate: HeroTransitionDelegate?
   53|       |
   54|       |  public var defaultAnimation: HeroDefaultAnimationType = .auto
   55|       |  public var containerColor: UIColor = .black
   56|       |  public var isUserInteractionEnabled = false
   57|       |  public var viewOrderingStrategy: HeroViewOrderingStrategy = .auto
   58|       |
   59|       |  public internal(set) var state: HeroTransitionState = .possible {
   60|      0|    didSet {
   61|      0|      if state != .notified, state != .starting {
   62|      0|        beginCallback?(state == .animating)
   63|      0|        beginCallback = nil
   64|      0|      }
   65|      0|      delegate?.heroTransition(self, didUpdate: state)
   66|      0|    }
   67|       |  }
   68|       |
   69|      0|  public var isTransitioning: Bool { return state != .possible }
   70|       |  public internal(set) var isPresenting: Bool = true
   71|       |
   72|       |  @available(*, deprecated, message: "Use isTransitioning instead")
   73|      0|  public var transitioning: Bool {
   74|      0|    return isTransitioning
   75|      0|  }
   76|       |  @available(*, deprecated, message: "Use isPresenting instead")
   77|      0|  public var presenting: Bool {
   78|      0|    return isPresenting
   79|      0|  }
   80|       |
   81|       |  /// container we created to hold all animating views, will be a subview of the
   82|       |  /// transitionContainer when transitioning
   83|       |  public internal(set) var container: UIView!
   84|       |
   85|       |  /// this is the container supplied by UIKit
   86|       |  internal var transitionContainer: UIView?
   87|       |
   88|       |  internal var completionCallback: ((Bool) -> Void)?
   89|       |  internal var beginCallback: ((Bool) -> Void)?
   90|       |
   91|       |  internal var processors: [HeroPreprocessor] = []
   92|       |  internal var animators: [HeroAnimator] = []
   93|       |  internal var plugins: [HeroPlugin] = []
   94|       |  internal var animatingFromViews: [UIView] = []
   95|       |  internal var animatingToViews: [UIView] = []
   96|       |  internal static var enabledPlugins: [HeroPlugin.Type] = []
   97|       |
   98|       |  /// destination view controller
   99|       |  public internal(set) var toViewController: UIViewController?
  100|       |  /// source view controller
  101|       |  public internal(set) var fromViewController: UIViewController?
  102|       |
  103|       |  /// context object holding transition informations
  104|       |  public internal(set) var context: HeroContext!
  105|       |
  106|       |  /// whether or not we are handling transition interactively
  107|      0|  public var interactive: Bool {
  108|      0|    return !progressRunner.isRunning
  109|      0|  }
  110|       |
  111|       |  internal var progressUpdateObservers: [HeroProgressUpdateObserver]?
  112|       |
  113|       |  /// max duration needed by the animators
  114|       |  public internal(set) var totalDuration: TimeInterval = 0.0
  115|       |
  116|       |  /// progress of the current transition. 0 if no transition is happening
  117|       |  public internal(set) var progress: Double = 0 {
  118|      0|    didSet {
  119|      0|      if state == .animating {
  120|      0|        if let progressUpdateObservers = progressUpdateObservers {
  121|      0|          for observer in progressUpdateObservers {
  122|      0|            observer.heroDidUpdateProgress(progress: progress)
  123|      0|          }
  124|      0|        }
  125|      0|
  126|      0|        let timePassed = progress * totalDuration
  127|      0|        if interactive {
  128|      0|          for animator in animators {
  129|      0|            animator.seekTo(timePassed: timePassed)
  130|      0|          }
  131|      0|        } else {
  132|      0|          for plugin in plugins where plugin.requirePerFrameCallback {
  133|      0|            plugin.seekTo(timePassed: timePassed)
  134|      0|          }
  135|      0|        }
  136|      0|
  137|      0|        transitionContext?.updateInteractiveTransition(CGFloat(progress))
  138|      0|      }
  139|      0|      delegate?.heroTransition(self, didUpdate: progress)
  140|      0|    }
  141|       |  }
  142|      0|  lazy var progressRunner: HeroProgressRunner = {
  143|      0|    let runner = HeroProgressRunner()
  144|      0|    runner.delegate = self
  145|      0|    return runner
  146|      0|  }()
  147|       |
  148|       |  /// a UIViewControllerContextTransitioning object provided by UIKit,
  149|       |  /// might be nil when transitioning. This happens when calling heroReplaceViewController
  150|       |  internal weak var transitionContext: UIViewControllerContextTransitioning?
  151|       |
  152|       |  internal var fullScreenSnapshot: UIView?
  153|       |
  154|       |  // By default, Hero will always appear to be interactive to UIKit. This forces it to appear non-interactive.
  155|       |  // Used when doing a hero_replaceViewController within a UINavigationController, to fix a bug with
  156|       |  // UINavigationController.setViewControllers not able to handle interactive transition
  157|       |  internal var forceNotInteractive = false
  158|       |  internal var forceFinishing: Bool?
  159|       |  internal var startingProgress: CGFloat?
  160|       |
  161|       |  internal var inNavigationController = false
  162|       |  internal var inTabBarController = false
  163|      0|  internal var inContainerController: Bool {
  164|      0|    return inNavigationController || inTabBarController
  165|      0|  }
  166|      0|  internal var toOverFullScreen: Bool {
  167|      0|    return !inContainerController && (toViewController?.modalPresentationStyle == .overFullScreen || toViewController?.modalPresentationStyle == .overCurrentContext)
  168|      0|  }
  169|      0|  internal var fromOverFullScreen: Bool {
  170|      0|    return !inContainerController && (fromViewController?.modalPresentationStyle == .overFullScreen || fromViewController?.modalPresentationStyle == .overCurrentContext)
  171|      0|  }
  172|       |
  173|      0|  internal var toView: UIView? { return toViewController?.view }
  174|      0|  internal var fromView: UIView? { return fromViewController?.view }
  175|       |
  176|      0|  public override init() { super.init() }
  177|       |
  178|      0|  func complete(after: TimeInterval, finishing: Bool) {
  179|      0|    guard [HeroTransitionState.animating, .starting, .notified].contains(state) else { return }
  180|      0|    if after <= 1.0 / 120 {
  181|      0|      complete(finished: finishing)
  182|      0|      return
  183|      0|    }
  184|      0|    let totalTime: TimeInterval
  185|      0|    if finishing {
  186|      0|      totalTime = after / max((1 - progress), 0.01)
  187|      0|    } else {
  188|      0|      totalTime = after / max(progress, 0.01)
  189|      0|    }
  190|      0|    progressRunner.start(timePassed: progress * totalTime, totalTime: totalTime, reverse: !finishing)
  191|      0|  }
  192|       |
  193|       |  // MARK: Observe Progress
  194|       |
  195|       |  /**
  196|       |   Receive callbacks on each animation frame.
  197|       |   Observers will be cleaned when transition completes
  198|       |
  199|       |   - Parameters:
  200|       |   - observer: the observer
  201|       |   */
  202|      0|  public func observeForProgressUpdate(observer: HeroProgressUpdateObserver) {
  203|      0|    if progressUpdateObservers == nil {
  204|      0|      progressUpdateObservers = []
  205|      0|    }
  206|      0|    progressUpdateObservers!.append(observer)
  207|      0|  }
  208|       |}
  209|       |
  210|       |extension HeroTransition: HeroProgressRunnerDelegate {
  211|      0|  func updateProgress(progress: Double) {
  212|      0|    self.progress = progress
  213|      0|  }
  214|       |}

